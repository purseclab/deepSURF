# Crate Documentation

**Version:** 3.11.0

**Format Version:** 39

# Module `bumpalo`

<!-- Generated by cargo-onedoc v0.2.2. DO NOT EDIT. -->

# bumpalo

[![Crates.io Version](https://badgers.space/crates/version/bumpalo)](https://crates.io/crates/bumpalo)
[![Docs.rs Latest](https://badgers.space/badge/docs.rs/latest/blue)](https://docs.rs/bumpalo)
[![Build Status](https://badgers.space/github/checks/fitzgen/bumpalo?label=build)](https://github.com/fitzgen/bumpalo/actions/workflows/build.yaml)





## License

This project is distributed under the terms of both the MIT license and the Apache License (Version 2.0).

See [LICENSE-APACHE](LICENSE-APACHE) and [LICENSE-MIT](LICENSE-MIT) for details.

## Modules

## Module `alloc`

**Attributes:**

- `#![allow(unstable_name_collisions)]`
- `#![allow(dead_code)]`
- `#![allow(deprecated)]`

Memory allocation APIs

```rust
pub(crate) mod alloc { /* ... */ }
```

### Types

#### Struct `Excess`

Represents the combination of a starting address and
a total capacity of the returned block.

```rust
pub struct Excess(pub core::ptr::NonNull<u8>, pub usize);
```

##### Fields

| Index | Type | Documentation |
|-------|------|---------------|
| 0 | `core::ptr::NonNull<u8>` |  |
| 1 | `usize` |  |

##### Implementations

###### Trait Implementations

- **Send**
- **UnwindSafe**
- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **Sync**
- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

- **Unpin**
- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **Debug**
  - ```rust
    fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<''_>) -> $crate::fmt::Result { /* ... */ }
    ```

- **Freeze**
- **RefUnwindSafe**
- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

#### Struct `AllocErr`

The `AllocErr` error indicates an allocation failure
that may be due to resource exhaustion or to
something wrong when combining the given input arguments with this
allocator.

```rust
pub struct AllocErr;
```

##### Implementations

###### Trait Implementations

- **Freeze**
- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

- **StructuralPartialEq**
- **Display**
  - ```rust
    fn fmt(self: &Self, f: &mut fmt::Formatter<''_>) -> fmt::Result { /* ... */ }
    ```

- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

- **CloneToUninit**
  - ```rust
    unsafe fn clone_to_uninit(self: &Self, dst: *mut u8) { /* ... */ }
    ```

- **Debug**
  - ```rust
    fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<''_>) -> $crate::fmt::Result { /* ... */ }
    ```

- **Sync**
- **Unpin**
- **RefUnwindSafe**
- **ToOwned**
  - ```rust
    fn to_owned(self: &Self) -> T { /* ... */ }
    ```

  - ```rust
    fn clone_into(self: &Self, target: &mut T) { /* ... */ }
    ```

- **PartialEq**
  - ```rust
    fn eq(self: &Self, other: &AllocErr) -> bool { /* ... */ }
    ```

- **UnwindSafe**
- **Clone**
  - ```rust
    fn clone(self: &Self) -> AllocErr { /* ... */ }
    ```

- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

  - ```rust
    fn from(e: AllocErr) -> Self { /* ... */ }
    ```

- **ToString**
  - ```rust
    fn to_string(self: &Self) -> String { /* ... */ }
    ```

- **Send**
- **Eq**
#### Struct `CannotReallocInPlace`

The `CannotReallocInPlace` error is used when `grow_in_place` or
`shrink_in_place` were unable to reuse the given memory block for
a requested layout.

```rust
pub struct CannotReallocInPlace;
```

##### Implementations

###### Methods

- ```rust
  pub fn description(self: &Self) -> &str { /* ... */ }
  ```

###### Trait Implementations

- **ToString**
  - ```rust
    fn to_string(self: &Self) -> String { /* ... */ }
    ```

- **Sync**
- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

- **Clone**
  - ```rust
    fn clone(self: &Self) -> CannotReallocInPlace { /* ... */ }
    ```

- **Debug**
  - ```rust
    fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<''_>) -> $crate::fmt::Result { /* ... */ }
    ```

- **Send**
- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

- **Display**
  - ```rust
    fn fmt(self: &Self, f: &mut fmt::Formatter<''_>) -> fmt::Result { /* ... */ }
    ```

- **RefUnwindSafe**
- **StructuralPartialEq**
- **PartialEq**
  - ```rust
    fn eq(self: &Self, other: &CannotReallocInPlace) -> bool { /* ... */ }
    ```

- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **Unpin**
- **Freeze**
- **UnwindSafe**
- **CloneToUninit**
  - ```rust
    unsafe fn clone_to_uninit(self: &Self, dst: *mut u8) { /* ... */ }
    ```

- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

- **Eq**
- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

- **ToOwned**
  - ```rust
    fn to_owned(self: &Self) -> T { /* ... */ }
    ```

  - ```rust
    fn clone_into(self: &Self, target: &mut T) { /* ... */ }
    ```

### Traits

#### Trait `UnstableLayoutMethods`

```rust
pub trait UnstableLayoutMethods {
    /* Associated items */
}
```

> This trait is not object-safe and cannot be used in dynamic trait objects.

##### Required Items

###### Required Methods

- `padding_needed_for`
- `repeat`
- `array`

##### Implementations

This trait is implemented for the following types:

- `Layout`

#### Trait `Alloc`

An implementation of `Alloc` can allocate, reallocate, and
deallocate arbitrary blocks of data described via `Layout`.

Some of the methods require that a memory block be *currently
allocated* via an allocator. This means that:

* the starting address for that memory block was previously
  returned by a previous call to an allocation method (`alloc`,
  `alloc_zeroed`, `alloc_excess`, `alloc_one`, `alloc_array`) or
  reallocation method (`realloc`, `realloc_excess`, or
  `realloc_array`), and

* the memory block has not been subsequently deallocated, where
  blocks are deallocated either by being passed to a deallocation
  method (`dealloc`, `dealloc_one`, `dealloc_array`) or by being
  passed to a reallocation method (see above) that returns `Ok`.

A note regarding zero-sized types and zero-sized layouts: many
methods in the `Alloc` trait state that allocation requests
must be non-zero size, or else undefined behavior can result.

* However, some higher-level allocation methods (`alloc_one`,
  `alloc_array`) are well-defined on zero-sized types and can
  optionally support them: it is left up to the implementor
  whether to return `Err`, or to return `Ok` with some pointer.

* If an `Alloc` implementation chooses to return `Ok` in this
  case (i.e. the pointer denotes a zero-sized inaccessible block)
  then that returned pointer must be considered "currently
  allocated". On such an allocator, *all* methods that take
  currently-allocated pointers as inputs must accept these
  zero-sized pointers, *without* causing undefined behavior.

* In other words, if a zero-sized pointer can flow out of an
  allocator, then that allocator must likewise accept that pointer
  flowing back into its deallocation and reallocation methods.

Some of the methods require that a layout *fit* a memory block.
What it means for a layout to "fit" a memory block means (or
equivalently, for a memory block to "fit" a layout) is that the
following two conditions must hold:

1. The block's starting address must be aligned to `layout.align()`.

2. The block's size must fall in the range `[use_min, use_max]`, where:

   * `use_min` is `self.usable_size(layout).0`, and

   * `use_max` is the capacity that was (or would have been)
     returned when (if) the block was allocated via a call to
     `alloc_excess` or `realloc_excess`.

Note that:

 * the size of the layout most recently used to allocate the block
   is guaranteed to be in the range `[use_min, use_max]`, and

 * a lower-bound on `use_max` can be safely approximated by a call to
   `usable_size`.

 * if a layout `k` fits a memory block (denoted by `ptr`)
   currently allocated via an allocator `a`, then it is legal to
   use that layout to deallocate it, i.e. `a.dealloc(ptr, k);`.

# Unsafety

The `Alloc` trait is an `unsafe` trait for a number of reasons, and
implementors must ensure that they adhere to these contracts:

* Pointers returned from allocation functions must point to valid memory and
  retain their validity until at least the instance of `Alloc` is dropped
  itself.

* `Layout` queries and calculations in general must be correct. Callers of
  this trait are allowed to rely on the contracts defined on each method,
  and implementors must ensure such contracts remain true.

Note that this list may get tweaked over time as clarifications are made in
the future.

```rust
pub unsafe trait Alloc {
    /* Associated items */
}
```

> This trait is unsafe to implement.

##### Required Items

###### Required Methods

- `alloc`: Returns a pointer meeting the size and alignment guarantees of
- `dealloc`: Deallocate the memory referenced by `ptr`.

##### Provided Methods

- ```rust
  fn usable_size(self: &Self, layout: &Layout) -> (usize, usize) { /* ... */ }
  ```
  Returns bounds on the guaranteed usable size of a successful

- ```rust
  unsafe fn realloc(self: &mut Self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<NonNull<u8>, AllocErr> { /* ... */ }
  ```
  Returns a pointer suitable for holding data described by

- ```rust
  unsafe fn alloc_zeroed(self: &mut Self, layout: Layout) -> Result<NonNull<u8>, AllocErr> { /* ... */ }
  ```
  Behaves like `alloc`, but also ensures that the contents

- ```rust
  unsafe fn alloc_excess(self: &mut Self, layout: Layout) -> Result<Excess, AllocErr> { /* ... */ }
  ```
  Behaves like `alloc`, but also returns the whole size of

- ```rust
  unsafe fn realloc_excess(self: &mut Self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<Excess, AllocErr> { /* ... */ }
  ```
  Behaves like `realloc`, but also returns the whole size of

- ```rust
  unsafe fn grow_in_place(self: &mut Self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<(), CannotReallocInPlace> { /* ... */ }
  ```
  Attempts to extend the allocation referenced by `ptr` to fit `new_size`.

- ```rust
  unsafe fn shrink_in_place(self: &mut Self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<(), CannotReallocInPlace> { /* ... */ }
  ```
  Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.

- ```rust
  fn alloc_one<T>(self: &mut Self) -> Result<NonNull<T>, AllocErr>
where
    Self: Sized { /* ... */ }
  ```
  Allocates a block suitable for holding an instance of `T`.

- ```rust
  unsafe fn dealloc_one<T>(self: &mut Self, ptr: NonNull<T>)
where
    Self: Sized { /* ... */ }
  ```
  Deallocates a block suitable for holding an instance of `T`.

- ```rust
  fn alloc_array<T>(self: &mut Self, n: usize) -> Result<NonNull<T>, AllocErr>
where
    Self: Sized { /* ... */ }
  ```
  Allocates a block suitable for holding `n` instances of `T`.

- ```rust
  unsafe fn realloc_array<T>(self: &mut Self, ptr: NonNull<T>, n_old: usize, n_new: usize) -> Result<NonNull<T>, AllocErr>
where
    Self: Sized { /* ... */ }
  ```
  Reallocates a block previously suitable for holding `n_old`

- ```rust
  unsafe fn dealloc_array<T>(self: &mut Self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>
where
    Self: Sized { /* ... */ }
  ```
  Deallocates a block suitable for holding `n` instances of `T`.

##### Implementations

This trait is implemented for the following types:

- `&''a Bump` with <''a>

### Functions

#### Function `new_layout_err`

```rust
pub(in ::alloc) fn new_layout_err() -> LayoutErr { /* ... */ }
```

#### Function `handle_alloc_error`

```rust
pub fn handle_alloc_error(layout: Layout) -> never { /* ... */ }
```

#### Function `size_align`

```rust
pub(in ::alloc) fn size_align<T>() -> (usize, usize) { /* ... */ }
```

### Re-exports

#### Re-export `Layout`

```rust
pub use core::alloc::Layout;
```

#### Re-export `LayoutErr`

```rust
pub use core::alloc::LayoutErr;
```

## Types

### Enum `AllocOrInitError`

An error returned from [`Bump::try_alloc_try_with`].

```rust
pub enum AllocOrInitError<E> {
    Alloc(AllocErr),
    Init(E),
}
```

#### Variants

##### `Alloc`

Indicates that the initial allocation failed.

Fields:

| Index | Type | Documentation |
|-------|------|---------------|
| 0 | `AllocErr` |  |

##### `Init`

Indicates that the initializer failed with the contained error after
allocation.

It is possible but not guaranteed that the allocated memory has been
released back to the allocator at this point.

Fields:

| Index | Type | Documentation |
|-------|------|---------------|
| 0 | `E` |  |

#### Implementations

##### Trait Implementations

- **Freeze**
- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

  - ```rust
    fn from(e: AllocErr) -> Self { /* ... */ }
    ```

- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **Sync**
- **CloneToUninit**
  - ```rust
    unsafe fn clone_to_uninit(self: &Self, dst: *mut u8) { /* ... */ }
    ```

- **ToOwned**
  - ```rust
    fn to_owned(self: &Self) -> T { /* ... */ }
    ```

  - ```rust
    fn clone_into(self: &Self, target: &mut T) { /* ... */ }
    ```

- **Display**
  - ```rust
    fn fmt(self: &Self, f: &mut core::fmt::Formatter<''_>) -> core::fmt::Result { /* ... */ }
    ```

- **ToString**
  - ```rust
    fn to_string(self: &Self) -> String { /* ... */ }
    ```

- **StructuralPartialEq**
- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

- **Eq**
- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

- **Clone**
  - ```rust
    fn clone(self: &Self) -> AllocOrInitError<E> { /* ... */ }
    ```

- **Debug**
  - ```rust
    fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<''_>) -> $crate::fmt::Result { /* ... */ }
    ```

- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

- **Send**
- **UnwindSafe**
- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

- **PartialEq**
  - ```rust
    fn eq(self: &Self, other: &AllocOrInitError<E>) -> bool { /* ... */ }
    ```

- **RefUnwindSafe**
- **Unpin**
### Struct `Bump`

 An arena to bump allocate into.

 ## No `Drop`s

 Objects that are bump-allocated will never have their [`Drop`] implementation
 called &mdash; unless you do it manually yourself. This makes it relatively
 easy to leak memory or other resources.

 If you have a type which internally manages

 * an allocation from the global heap (e.g. [`Vec<T>`]),
 * open file descriptors (e.g. [`std::fs::File`]), or
 * any other resource that must be cleaned up (e.g. an `mmap`)

 and relies on its `Drop` implementation to clean up the internal resource,
 then if you allocate that type with a `Bump`, you need to find a new way to
 clean up after it yourself.

 Potential solutions are:

 * Using [`bumpalo::boxed::Box::new_in`] instead of [`Bump::alloc`], that
   will drop wrapped values similarly to [`std::boxed::Box`]. Note that this
   requires enabling the `"boxed"` Cargo feature for this crate. **This is
   often the easiest solution.**

 * Calling [`drop_in_place`][drop_in_place] or using
   [`std::mem::ManuallyDrop`][manuallydrop] to manually drop these types.

 * Using [`bumpalo::collections::Vec`] instead of [`std::vec::Vec`].

 * Avoiding allocating these problematic types within a `Bump`.

 Note that not calling `Drop` is memory safe! Destructors are never
 guaranteed to run in Rust, you can't rely on them for enforcing memory
 safety.

 [`Drop`]: https://doc.rust-lang.org/std/ops/trait.Drop.html
 [`Vec<T>`]: https://doc.rust-lang.org/std/vec/struct.Vec.html
 [`std::fs::File`]: https://doc.rust-lang.org/std/fs/struct.File.html
 [drop_in_place]: https://doc.rust-lang.org/std/ptr/fn.drop_in_place.html
 [manuallydrop]: https://doc.rust-lang.org/std/mem/struct.ManuallyDrop.html
 [`bumpalo::collections::Vec`]: collections/vec/struct.Vec.html
 [`std::vec::Vec`]: https://doc.rust-lang.org/std/vec/struct.Vec.html
 [`bumpalo::boxed::Box::new_in`]: boxed/struct.Box.html#method.new_in
 [`std::boxed::Box`]: https://doc.rust-lang.org/std/boxed/struct.Box.html

 ## Example

 ```
 use bumpalo::Bump;

 // Create a new bump arena.
 let bump = Bump::new();

 // Allocate values into the arena.
 let forty_two = bump.alloc(42);
 assert_eq!(*forty_two, 42);

 // Mutable references are returned from allocation.
 let mut s = bump.alloc("bumpalo");
 *s = "the bump allocator; and also is a buffalo";
 ```

 ## Allocation Methods Come in Many Flavors

 There are various allocation methods on `Bump`, the simplest being
 [`alloc`][Bump::alloc]. The others exist to satisfy some combination of
 fallible allocation and initialization. The allocation methods are
 summarized in the following table:

 <table>
   <thead>
     <tr>
       <th></th>
       <th>Infallible Allocation</th>
       <th>Fallible Allocation</th>
     </tr>
   </thead>
     <tr>
       <th>By Value</th>
       <td><a href="#method.alloc"><code>alloc</code></a></td>
       <td><a href="#method.try_alloc"><code>try_alloc</code></a></td>
     </tr>
     <tr>
       <th>Infallible Initializer Function</th>
       <td><a href="#method.alloc_with"><code>alloc_with</code></a></td>
       <td><a href="#method.try_alloc_with"><code>try_alloc_with</code></a></td>
     </tr>
     <tr>
       <th>Fallible Initializer Function</th>
       <td><a href="#method.alloc_try_with"><code>alloc_try_with</code></a></td>
       <td><a href="#method.try_alloc_try_with"><code>try_alloc_try_with</code></a></td>
     </tr>
   <tbody>
   </tbody>
 </table>

 ### Fallible Allocation: The `try_alloc_` Method Prefix

 These allocation methods let you recover from out-of-memory (OOM)
 scenarioes, rather than raising a panic on OOM.

 ```
 use bumpalo::Bump;

 let bump = Bump::new();

 match bump.try_alloc(MyStruct {
     // ...
 }) {
     Ok(my_struct) => {
         // Allocation succeeded.
     }
     Err(e) => {
         // Out of memory.
     }
 }

 struct MyStruct {
     // ...
 }
 ```

 ### Initializer Functions: The `_with` Method Suffix

 Calling one of the generic `…alloc(x)` methods is essentially equivalent to
 the matching [`…alloc_with(|| x)`](?search=alloc_with). However if you use
 `…alloc_with`, then the closure will not be invoked until after allocating
 space for storing `x` on the heap.

 This can be useful in certain edge-cases related to compiler optimizations.
 When evaluating for example `bump.alloc(x)`, semantically `x` is first put
 on the stack and then moved onto the heap. In some cases, the compiler is
 able to optimize this into constructing `x` directly on the heap, however
 in many cases it does not.

 The `…alloc_with` functions try to help the compiler be smarter. In most
 cases doing for example `bump.try_alloc_with(|| x)` on release mode will be
 enough to help the compiler realize that this optimization is valid and
 to construct `x` directly onto the heap.

 #### Warning

 These functions critically depend on compiler optimizations to achieve their
 desired effect. This means that it is not an effective tool when compiling
 without optimizations on.

 Even when optimizations are on, these functions do not **guarantee** that
 the value is constructed on the heap. To the best of our knowledge no such
 guarantee can be made in stable Rust as of 1.54.

 ### Fallible Initialization: The `_try_with` Method Suffix

 The generic [`…alloc_try_with(|| x)`](?search=_try_with) methods behave
 like the purely `_with` suffixed methods explained above. However, they
 allow for fallible initialization by accepting a closure that returns a
 [`Result`] and will attempt to undo the initial allocation if this closure
 returns [`Err`].

 #### Warning

 If the inner closure returns [`Ok`], space for the entire [`Result`] remains
 allocated inside `self`. This can be a problem especially if the [`Err`]
 variant is larger, but even otherwise there may be overhead for the
 [`Result`]'s discriminant.

 <p><details><summary>Undoing the allocation in the <code>Err</code> case
 always fails if <code>f</code> successfully made any additional allocations
 in <code>self</code>.</summary>

 For example, the following will always leak also space for the [`Result`]
 into this `Bump`, even though the inner reference isn't kept and the [`Err`]
 payload is returned semantically by value:

 ```rust
 let bump = bumpalo::Bump::new();

 let r: Result<&mut [u8; 1000], ()> = bump.alloc_try_with(|| {
     let _ = bump.alloc(0_u8);
     Err(())
 });

 assert!(r.is_err());
 ```

</details></p>

 Since [`Err`] payloads are first placed on the heap and then moved to the
 stack, `bump.…alloc_try_with(|| x)?` is likely to execute more slowly than
 the matching `bump.…alloc(x?)` in case of initialization failure. If this
 happens frequently, using the plain un-suffixed method may perform better.

 [`Result`]: https://doc.rust-lang.org/std/result/enum.Result.html
 [`Ok`]: https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok
 [`Err`]: https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err

 ### `Bump` Allocation Limits

 `bumpalo` supports setting a limit on the maximum bytes of memory that can
 be allocated for use in a particular `Bump` arena. This limit can be set and removed with
 [`set_allocation_limit`][Bump::set_allocation_limit].
 The allocation limit is only enforced when allocating new backing chunks for
 a `Bump`. Updating the allocation limit will not affect existing allocations
 or any future allocations within the `Bump`'s current chunk.

 #### Example

 ```
 let bump = bumpalo::Bump::new();

 assert_eq!(bump.allocation_limit(), None);
 bump.set_allocation_limit(Some(0));

 assert!(bump.try_alloc(5).is_err());

 bump.set_allocation_limit(Some(6));

 assert_eq!(bump.allocation_limit(), Some(6));

 bump.set_allocation_limit(None);

 assert_eq!(bump.allocation_limit(), None);
 ```

 #### Warning

 Because of backwards compatibility, allocations that fail
 due to allocation limits will not present differently than
 errors due to resource exhaustion.

```rust
pub struct Bump {
    pub(crate) current_chunk_footer: core::cell::Cell<core::ptr::NonNull<ChunkFooter>>,
    pub(crate) allocation_limit: core::cell::Cell<Option<usize>>,
}
```

#### Fields

| Name | Type | Documentation |
|------|------|---------------|
| `current_chunk_footer` | `core::cell::Cell<core::ptr::NonNull<ChunkFooter>>` |  |
| `allocation_limit` | `core::cell::Cell<Option<usize>>` |  |

#### Implementations

##### Methods

- ```rust
  pub fn new() -> Bump { /* ... */ }
  ```
  Construct a new arena to bump allocate into.

- ```rust
  pub fn try_new() -> Result<Bump, AllocErr> { /* ... */ }
  ```
  Attempt to construct a new arena to bump allocate into.

- ```rust
  pub fn with_capacity(capacity: usize) -> Bump { /* ... */ }
  ```
  Construct a new arena with the specified byte capacity to bump allocate into.

- ```rust
  pub fn try_with_capacity(capacity: usize) -> Result<Self, AllocErr> { /* ... */ }
  ```
  Attempt to construct a new arena with the specified byte capacity to bump allocate into.

- ```rust
  pub fn allocation_limit(self: &Self) -> Option<usize> { /* ... */ }
  ```
  The allocation limit for this arena in bytes.

- ```rust
  pub fn set_allocation_limit(self: &Self, limit: Option<usize>) { /* ... */ }
  ```
  Set the allocation limit in bytes for this arena.

- ```rust
  pub(crate) fn allocation_limit_remaining(self: &Self) -> Option<usize> { /* ... */ }
  ```
  How much headroom an arena has before it hits its allocation

- ```rust
  pub(crate) fn chunk_fits_under_limit(allocation_limit_remaining: Option<usize>, new_chunk_memory_details: NewChunkMemoryDetails) -> bool { /* ... */ }
  ```
  Whether a request to allocate a new chunk with a given size for a given

- ```rust
  pub(crate) fn new_chunk_memory_details(new_size_without_footer: Option<usize>, requested_layout: Layout) -> Option<NewChunkMemoryDetails> { /* ... */ }
  ```
  Determine the memory details including final size, alignment and

- ```rust
  pub(crate) unsafe fn new_chunk(new_chunk_memory_details: NewChunkMemoryDetails, requested_layout: Layout, prev: NonNull<ChunkFooter>) -> Option<NonNull<ChunkFooter>> { /* ... */ }
  ```
  Allocate a new chunk and return its initialized footer.

- ```rust
  pub fn reset(self: &mut Self) { /* ... */ }
  ```
   Reset this bump allocator.

- ```rust
  pub fn alloc<T>(self: &Self, val: T) -> &mut T { /* ... */ }
  ```
  Allocate an object in this `Bump` and return an exclusive reference to

- ```rust
  pub fn try_alloc<T>(self: &Self, val: T) -> Result<&mut T, AllocErr> { /* ... */ }
  ```
  Try to allocate an object in this `Bump` and return an exclusive

- ```rust
  pub fn alloc_with<F, T>(self: &Self, f: F) -> &mut T
where
    F: FnOnce() -> T { /* ... */ }
  ```
  Pre-allocate space for an object in this `Bump`, initializes it using

- ```rust
  pub fn try_alloc_with<F, T>(self: &Self, f: F) -> Result<&mut T, AllocErr>
where
    F: FnOnce() -> T { /* ... */ }
  ```
  Tries to pre-allocate space for an object in this `Bump`, initializes

- ```rust
  pub fn alloc_try_with<F, T, E>(self: &Self, f: F) -> Result<&mut T, E>
where
    F: FnOnce() -> Result<T, E> { /* ... */ }
  ```
  Pre-allocates space for a [`Result`] in this `Bump`, initializes it using

- ```rust
  pub fn try_alloc_try_with<F, T, E>(self: &Self, f: F) -> Result<&mut T, AllocOrInitError<E>>
where
    F: FnOnce() -> Result<T, E> { /* ... */ }
  ```
  Tries to pre-allocates space for a [`Result`] in this `Bump`,

- ```rust
  pub fn alloc_slice_copy<T>(self: &Self, src: &[T]) -> &mut [T]
where
    T: Copy { /* ... */ }
  ```
  `Copy` a slice into this `Bump` and return an exclusive reference to

- ```rust
  pub fn alloc_slice_clone<T>(self: &Self, src: &[T]) -> &mut [T]
where
    T: Clone { /* ... */ }
  ```
  `Clone` a slice into this `Bump` and return an exclusive reference to

- ```rust
  pub fn alloc_str(self: &Self, src: &str) -> &mut str { /* ... */ }
  ```
  `Copy` a string slice into this `Bump` and return an exclusive reference to it.

- ```rust
  pub fn alloc_slice_fill_with<T, F>(self: &Self, len: usize, f: F) -> &mut [T]
where
    F: FnMut(usize) -> T { /* ... */ }
  ```
  Allocates a new slice of size `len` into this `Bump` and returns an

- ```rust
  pub fn alloc_slice_fill_copy<T: Copy>(self: &Self, len: usize, value: T) -> &mut [T] { /* ... */ }
  ```
  Allocates a new slice of size `len` into this `Bump` and returns an

- ```rust
  pub fn alloc_slice_fill_clone<T: Clone>(self: &Self, len: usize, value: &T) -> &mut [T] { /* ... */ }
  ```
  Allocates a new slice of size `len` slice into this `Bump` and return an

- ```rust
  pub fn alloc_slice_fill_iter<T, I>(self: &Self, iter: I) -> &mut [T]
where
    I: IntoIterator<Item = T>,
    <I as >::IntoIter: ExactSizeIterator { /* ... */ }
  ```
  Allocates a new slice of size `len` slice into this `Bump` and return an

- ```rust
  pub fn alloc_slice_fill_default<T: Default>(self: &Self, len: usize) -> &mut [T] { /* ... */ }
  ```
  Allocates a new slice of size `len` slice into this `Bump` and return an

- ```rust
  pub fn alloc_layout(self: &Self, layout: Layout) -> NonNull<u8> { /* ... */ }
  ```
  Allocate space for an object with the given `Layout`.

- ```rust
  pub fn try_alloc_layout(self: &Self, layout: Layout) -> Result<NonNull<u8>, AllocErr> { /* ... */ }
  ```
  Attempts to allocate space for an object with the given `Layout` or else returns

- ```rust
  pub(crate) fn try_alloc_layout_fast(self: &Self, layout: Layout) -> Option<NonNull<u8>> { /* ... */ }
  ```

- ```rust
  pub fn chunk_capacity(self: &Self) -> usize { /* ... */ }
  ```
  Gets the remaining capacity in the current chunk (in bytes).

- ```rust
  pub(crate) fn alloc_layout_slow(self: &Self, layout: Layout) -> Option<NonNull<u8>> { /* ... */ }
  ```
  Slow path allocation for when we need to allocate a new chunk from the

- ```rust
  pub fn iter_allocated_chunks(self: &mut Self) -> ChunkIter<''_> { /* ... */ }
  ```
  Returns an iterator over each chunk of allocated memory that

- ```rust
  pub unsafe fn iter_allocated_chunks_raw(self: &Self) -> ChunkRawIter<''_> { /* ... */ }
  ```
  Returns an iterator over raw pointers to chunks of allocated memory that

- ```rust
  pub fn allocated_bytes(self: &Self) -> usize { /* ... */ }
  ```
  Calculates the number of bytes currently allocated across all chunks in

- ```rust
  pub(crate) unsafe fn is_last_allocation(self: &Self, ptr: NonNull<u8>) -> bool { /* ... */ }
  ```

- ```rust
  pub(crate) unsafe fn dealloc(self: &Self, ptr: NonNull<u8>, layout: Layout) { /* ... */ }
  ```

- ```rust
  pub(crate) unsafe fn shrink(self: &Self, ptr: NonNull<u8>, old_layout: Layout, new_layout: Layout) -> Result<NonNull<u8>, AllocErr> { /* ... */ }
  ```

- ```rust
  pub(crate) unsafe fn grow(self: &Self, ptr: NonNull<u8>, old_layout: Layout, new_layout: Layout) -> Result<NonNull<u8>, AllocErr> { /* ... */ }
  ```

##### Trait Implementations

- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

- **Freeze**
- **Drop**
  - ```rust
    fn drop(self: &mut Self) { /* ... */ }
    ```

- **Default**
  - ```rust
    fn default() -> Bump { /* ... */ }
    ```

- **Debug**
  - ```rust
    fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<''_>) -> $crate::fmt::Result { /* ... */ }
    ```

- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

- **Sync**
- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

- **Alloc**
  - ```rust
    unsafe fn alloc(self: &mut Self, layout: Layout) -> Result<NonNull<u8>, AllocErr> { /* ... */ }
    ```

  - ```rust
    unsafe fn dealloc(self: &mut Self, ptr: NonNull<u8>, layout: Layout) { /* ... */ }
    ```

  - ```rust
    unsafe fn realloc(self: &mut Self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<NonNull<u8>, AllocErr> { /* ... */ }
    ```

- **Send**
- **UnwindSafe**
- **RefUnwindSafe**
- **Unpin**
### Struct `ChunkFooter`

**Attributes:**

- `#[repr(C)]`

```rust
pub(crate) struct ChunkFooter {
    pub(crate) data: core::ptr::NonNull<u8>,
    pub(crate) layout: core_alloc::alloc::Layout,
    pub(crate) prev: core::cell::Cell<core::ptr::NonNull<ChunkFooter>>,
    pub(crate) ptr: core::cell::Cell<core::ptr::NonNull<u8>>,
    pub(crate) allocated_bytes: usize,
}
```

#### Fields

| Name | Type | Documentation |
|------|------|---------------|
| `data` | `core::ptr::NonNull<u8>` |  |
| `layout` | `core_alloc::alloc::Layout` |  |
| `prev` | `core::cell::Cell<core::ptr::NonNull<ChunkFooter>>` |  |
| `ptr` | `core::cell::Cell<core::ptr::NonNull<u8>>` |  |
| `allocated_bytes` | `usize` |  |

#### Implementations

##### Methods

- ```rust
  pub(crate) fn as_raw_parts(self: &Self) -> (*const u8, usize) { /* ... */ }
  ```

- ```rust
  pub(crate) fn is_empty(self: &Self) -> bool { /* ... */ }
  ```
  Is this chunk the last empty chunk?

##### Trait Implementations

- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

- **Freeze**
- **RefUnwindSafe**
- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

- **Send**
- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **Debug**
  - ```rust
    fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<''_>) -> $crate::fmt::Result { /* ... */ }
    ```

- **Sync**
- **UnwindSafe**
- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **Unpin**
### Struct `EmptyChunkFooter`

**Attributes:**

- `#[repr(transparent)]`

A wrapper type for the canonical, statically allocated empty chunk.

For the canonical empty chunk to be `static`, its type must be `Sync`, which
is the purpose of this wrapper type. This is safe because the empty chunk is
immutable and never actually modified.

```rust
pub(crate) struct EmptyChunkFooter(pub(crate) ChunkFooter);
```

#### Fields

| Index | Type | Documentation |
|-------|------|---------------|
| 0 | `ChunkFooter` |  |

#### Implementations

##### Methods

- ```rust
  pub(crate) fn get(self: &''static Self) -> NonNull<ChunkFooter> { /* ... */ }
  ```

##### Trait Implementations

- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

- **Sync**
- **Unpin**
- **Freeze**
- **UnwindSafe**
- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

- **Send**
- **RefUnwindSafe**
### Struct `NewChunkMemoryDetails`

The memory size and alignment details for a potential new chunk
allocation.

```rust
pub(crate) struct NewChunkMemoryDetails {
    pub(crate) new_size_without_footer: usize,
    pub(crate) align: usize,
    pub(crate) size: usize,
}
```

#### Fields

| Name | Type | Documentation |
|------|------|---------------|
| `new_size_without_footer` | `usize` |  |
| `align` | `usize` |  |
| `size` | `usize` |  |

#### Implementations

##### Trait Implementations

- **Freeze**
- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

- **Debug**
  - ```rust
    fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<''_>) -> $crate::fmt::Result { /* ... */ }
    ```

- **UnwindSafe**
- **RefUnwindSafe**
- **Unpin**
- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

- **Send**
- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

- **Sync**
- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

- **Copy**
- **ToOwned**
  - ```rust
    fn to_owned(self: &Self) -> T { /* ... */ }
    ```

  - ```rust
    fn clone_into(self: &Self, target: &mut T) { /* ... */ }
    ```

- **CloneToUninit**
  - ```rust
    unsafe fn clone_to_uninit(self: &Self, dst: *mut u8) { /* ... */ }
    ```

- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

- **Clone**
  - ```rust
    fn clone(self: &Self) -> NewChunkMemoryDetails { /* ... */ }
    ```

### Struct `ChunkIter`

An iterator over each chunk of allocated memory that
an arena has bump allocated into.

The chunks are returned ordered by allocation time, with the most recently
allocated chunk being returned first.

The values inside each chunk are also ordered by allocation time, with the most
recent allocation being earlier in the slice.

This struct is created by the [`iter_allocated_chunks`] method on
[`Bump`]. See that function for a safety description regarding reading from the returned items.

[`Bump`]: struct.Bump.html
[`iter_allocated_chunks`]: struct.Bump.html#method.iter_allocated_chunks

```rust
pub struct ChunkIter<''a> {
    pub(crate) raw: ChunkRawIter<''a>,
    pub(crate) bump: core::marker::PhantomData<&''a mut Bump>,
}
```

#### Fields

| Name | Type | Documentation |
|------|------|---------------|
| `raw` | `ChunkRawIter<''a>` |  |
| `bump` | `core::marker::PhantomData<&''a mut Bump>` |  |

#### Implementations

##### Trait Implementations

- **Freeze**
- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

- **Debug**
  - ```rust
    fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<''_>) -> $crate::fmt::Result { /* ... */ }
    ```

- **Iterator**
  - ```rust
    fn next(self: &mut Self) -> Option<&''a [mem::MaybeUninit<u8>]> { /* ... */ }
    ```

- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

- **UnwindSafe**
- **Unpin**
- **Send**
- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **FusedIterator**
- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

- **Sync**
- **IntoIterator**
  - ```rust
    fn into_iter(self: Self) -> I { /* ... */ }
    ```

- **RefUnwindSafe**
- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

### Struct `ChunkRawIter`

An iterator over raw pointers to chunks of allocated memory that this
arena has bump allocated into.

See [`ChunkIter`] for details regarding the returned chunks.

This struct is created by the [`iter_allocated_chunks_raw`] method on
[`Bump`]. See that function for a safety description regarding reading from
the returned items.

[`Bump`]: struct.Bump.html
[`iter_allocated_chunks_raw`]: struct.Bump.html#method.iter_allocated_chunks_raw

```rust
pub struct ChunkRawIter<''a> {
    pub(crate) footer: core::ptr::NonNull<ChunkFooter>,
    pub(crate) bump: core::marker::PhantomData<&''a Bump>,
}
```

#### Fields

| Name | Type | Documentation |
|------|------|---------------|
| `footer` | `core::ptr::NonNull<ChunkFooter>` |  |
| `bump` | `core::marker::PhantomData<&''a Bump>` |  |

#### Implementations

##### Trait Implementations

- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

- **Freeze**
- **Iterator**
  - ```rust
    fn next(self: &mut Self) -> Option<(*mut u8, usize)> { /* ... */ }
    ```

- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

- **RefUnwindSafe**
- **Unpin**
- **UnwindSafe**
- **Debug**
  - ```rust
    fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<''_>) -> $crate::fmt::Result { /* ... */ }
    ```

- **IntoIterator**
  - ```rust
    fn into_iter(self: Self) -> I { /* ... */ }
    ```

- **Send**
- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **FusedIterator**
- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

- **Sync**
- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

## Functions

### Function `dealloc_chunk_list`

**Attributes:**

- `#[inline]`

```rust
pub(crate) unsafe fn dealloc_chunk_list(footer: core::ptr::NonNull<ChunkFooter>) { /* ... */ }
```

### Function `round_up_to`

**Attributes:**

- `#[inline]`

```rust
pub(crate) fn round_up_to(n: usize, divisor: usize) -> Option<usize> { /* ... */ }
```

### Function `round_down_to`

**Attributes:**

- `#[inline]`

```rust
pub(crate) fn round_down_to(n: usize, divisor: usize) -> usize { /* ... */ }
```

### Function `layout_from_size_align`

**Attributes:**

- `#[inline]`

Wrapper around `Layout::from_size_align` that adds debug assertions.

```rust
pub(crate) unsafe fn layout_from_size_align(size: usize, align: usize) -> core_alloc::alloc::Layout { /* ... */ }
```

### Function `allocation_size_overflow`

**Attributes:**

- `#[inline(never)]`

```rust
pub(crate) fn allocation_size_overflow<T>() -> T { /* ... */ }
```

### Function `abs_diff`

```rust
pub(crate) fn abs_diff(a: usize, b: usize) -> usize { /* ... */ }
```

### Function `oom`

**Attributes:**

- `#[inline(never)]`
- `#[cold]`

```rust
pub(crate) fn oom() -> never { /* ... */ }
```

## Constants and Statics

### Static `EMPTY_CHUNK`

```rust
pub(crate) static EMPTY_CHUNK: EmptyChunkFooter = _;
```

### Constant `PAGE_STRATEGY_CUTOFF`

```rust
pub(crate) const PAGE_STRATEGY_CUTOFF: usize = 0x1000;
```

### Constant `SUPPORTED_ITER_ALIGNMENT`

```rust
pub(crate) const SUPPORTED_ITER_ALIGNMENT: usize = 16;
```

### Constant `CHUNK_ALIGN`

```rust
pub(crate) const CHUNK_ALIGN: usize = SUPPORTED_ITER_ALIGNMENT;
```

### Constant `FOOTER_SIZE`

```rust
pub(crate) const FOOTER_SIZE: usize = _;
```

### Constant `_FOOTER_ALIGN_ASSERTION`

```rust
pub(crate) const _FOOTER_ALIGN_ASSERTION: bool = _;
```

### Constant `MALLOC_OVERHEAD`

```rust
pub(crate) const MALLOC_OVERHEAD: usize = 16;
```

### Constant `OVERHEAD`

```rust
pub(crate) const OVERHEAD: usize = _;
```

### Constant `FIRST_ALLOCATION_GOAL`

```rust
pub(crate) const FIRST_ALLOCATION_GOAL: usize = _;
```

### Constant `DEFAULT_CHUNK_SIZE_WITHOUT_FOOTER`

```rust
pub(crate) const DEFAULT_CHUNK_SIZE_WITHOUT_FOOTER: usize = _;
```

## Re-exports

### Re-export `AllocErr`

```rust
pub use alloc::AllocErr;
```

