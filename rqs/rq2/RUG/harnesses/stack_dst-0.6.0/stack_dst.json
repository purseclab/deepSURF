{"dependencies":{"<stack::StackA<T, D> as std::default::Default>::default":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"<stack::StackA<T, D> as std::ops::Drop>::drop":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"<value::ValueA<T, D> as std::ops::Deref>::deref":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","value::ValueA"],"<value::ValueA<T, D> as std::ops::DerefMut>::deref_mut":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","value::ValueA"],"<value::ValueA<T, D> as std::ops::Drop>::drop":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","value::ValueA"],"make_fat_ptr":[],"ptr_as_slice":["std::marker::Sized"],"round_to_words":[],"stack::StackA":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"stack::StackA::<T, D>::is_empty":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"stack::StackA::<T, D>::meta_words":[],"stack::StackA::<T, D>::new":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"stack::StackA::<T, D>::pop":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"stack::StackA::<T, D>::push_inner":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"stack::StackA::<T, D>::push_stable":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::result::Result"],"stack::StackA::<T, D>::top":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"stack::StackA::<T, D>::top_mut":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"stack::StackA::<T, D>::top_raw":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"stack::StackA::<[T], D>::push_cloned":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"stack::StackA::<str, D>::push_str":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"value::ValueA":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","value::ValueA"],"value::ValueA::<T, D>::as_ptr":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","value::ValueA"],"value::ValueA::<T, D>::new_raw":["std::marker::Sized","std::option::Option"],"value::ValueA::<T, D>::new_stable":["std::marker::Sized","std::ops::FnOnce","std::result::Result"],"value::trait_impls::<impl std::fmt::Debug for value::ValueA<T, D>>::fmt":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::fmt::Formatter","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::result::Result","value::ValueA"],"value::trait_impls::<impl std::fmt::Display for value::ValueA<T, D>>::fmt":["<T as DataBuf>::T","DataBuf","stack::StackA","std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::fmt::Formatter","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::result::Result","value::ValueA"],"value::trait_impls::<impl std::future::Future for value::ValueA<T, D>>::poll":["std::marker::Sized","std::pin::Pin","std::task::Context","std::task::Poll"]},"glob_path_import":{},"self_to_fn":{"<T as DataBuf>::T":["impl<T: Copy+Default+AsMut<[usize]>+AsRef<[usize]>> DataBuf for T {\n}"],"stack::StackA":["impl<D: ::DataBuf, T: Clone> StackA<[T],D>\n{\n\t/// Pushes a set of items (cloning out of the input slice)\n\tpub fn push_cloned(&mut self, v: &[T]) -> Result<(),()>\n\t{\n\t\tmatch self.push_inner(&v)\n\t\t{\n\t\tOk(d) => {\n\t\t\tunsafe\n\t\t\t{\n\t\t\t\tlet mut ptr = d.as_mut_ptr() as *mut T;\n\t\t\t\tfor val in v\n\t\t\t\t{\n\t\t\t\t\tptr::write(ptr, val.clone());\n\t\t\t\t\tptr = ptr.offset(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk( () )\n\t\t\t},\n\t\tErr(_) => Err( () ),\n\t\t}\n\t}\n}","impl<D: ::DataBuf> StackA<str,D>\n{\n\t/// Push the contents of a string slice as an item onto the stack\n\tpub fn push_str(&mut self, v: &str) -> Result<(),()>\n\t{\n\t\tmatch self.push_inner(v)\n\t\t{\n\t\tOk(d) => {\n\t\t\tunsafe { \n\t\t\t\tptr::copy( v.as_bytes().as_ptr(), d.as_mut_ptr() as *mut u8, v.len() );\n\t\t\t}\n\t\t\tOk( () )\n\t\t\t},\n\t\tErr(_) => Err( () ),\n\t\t}\n\t}\n}","impl<T: ?Sized, D: ::DataBuf> Default for StackA<T,D> {\n\tfn default() -> Self {\n\t\tStackA::new()\n\t}\n}","impl<T: ?Sized, D: ::DataBuf> StackA<T,D>\n{\n\t/// Construct a new (empty) stack\n\tpub fn new() -> StackA<T, D>\n\t{\n\t\tStackA {\n\t\t\t_pd: marker::PhantomData,\n\t\t\tnext_ofs: 0,\n\t\t\tdata: Default::default(),\n\t\t\t}\n\t}\n\n\t/// Tests if the stack is empty\n\tpub fn is_empty(&self) -> bool\n\t{\n\t\tself.next_ofs == 0\n\t}\n\n\tfn meta_words() -> usize\n\t{\n\t\tmem::size_of::<&T>() / mem::size_of::<usize>() - 1\n\t}\n\tfn push_inner(&mut self, fat_ptr: &T) -> Result<&mut [usize], ()>\n\t{\n\t\tlet bytes = mem::size_of_val(fat_ptr);\n\t\tlet words = super::round_to_words(bytes) + Self::meta_words();\n\t\t// Check if there is sufficient space for the new item\n\t\tif self.next_ofs + words <= self.data.as_ref().len()\n\t\t{\n\t\t\t// Get the base pointer for the new item\n\t\t\tself.next_ofs += words;\n\t\t\tlet len = self.data.as_ref().len();\n\t\t\tlet slot = &mut self.data.as_mut()[len - self.next_ofs..][..words];\n\t\t\tlet (meta, rv) = slot.split_at_mut(Self::meta_words());\n\n\t\t\t// Populate the metadata\n\t\t\tlet mut ptr_raw: *const T = fat_ptr;\n\t\t\tlet ptr_words = ::ptr_as_slice(&mut ptr_raw);\n\t\t\tassert_eq!(ptr_words.len(), 1 + Self::meta_words());\n\t\t\tmeta.clone_from_slice( &ptr_words[1..] );\n\n\t\t\t// Increment offset and return\n\t\t\tOk( rv )\n\t\t}\n\t\telse\n\t\t{\n\t\t\tErr( () )\n\t\t}\n\t}\n\n\t/// Push a value at the top of the stack\n\t#[cfg(feature=\"unsize\")]\n\tpub fn push<U: marker::Unsize<T>>(&mut self, v: U) -> Result<(), U>\n\t{\n\t\tself.push_stable(v, |p| p)\n\t}\n\n\t/// Push a value at the top of the stack (without using `Unsize`)\n\tpub fn push_stable<U, F: FnOnce(&U) -> &T>(&mut self, v: U, f: F) -> Result<(), U>\n\t{\n\t\t// - Ensure that Self is aligned same as data requires\n\t\tassert!(mem::align_of::<U>() <= mem::align_of::<Self>(), \"TODO: Enforce alignment >{} (requires {})\",\n\t\t\tmem::align_of::<Self>(), mem::align_of::<U>());\n\n\t\tmatch self.push_inner( f(&v) )\n\t\t{\n\t\tOk(d) => {\n\t\t\t// SAFE: Destination address is valid\n\t\t\tunsafe { ptr::write( d.as_mut_ptr() as *mut U, v ); }\n\t\t\tOk( () )\n\t\t\t},\n\t\tErr(_) => Err(v),\n\t\t}\n\t}\n\n\t// Get a raw pointer to the top of the stack\n\tfn top_raw(&self) -> Option<*mut T>\n\t{\n\t\tif self.next_ofs == 0\n\t\t{\n\t\t\tNone\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet len = self.data.as_ref().len();\n\t\t\tlet meta = &self.data.as_ref()[len - self.next_ofs..];\n\t\t\t// SAFE: Internal consistency maintains the metadata validity\n\t\t\tSome( unsafe { super::make_fat_ptr( \n\t\t\t\tmeta[Self::meta_words()..].as_ptr() as usize,\n\t\t\t\t&meta[..Self::meta_words()]\n\t\t\t\t) } )\n\t\t}\n\t}\n\t/// Returns a pointer to the top item on the stack\n\tpub fn top(&self) -> Option<&T>\n\t{\n\t\tself.top_raw().map(|x| unsafe { &*x })\n\t}\n\t/// Returns a pointer to the top item on the stack (unique/mutable)\n\tpub fn top_mut(&mut self) -> Option<&mut T>\n\t{\n\t\tself.top_raw().map(|x| unsafe { &mut *x })\n\t}\n\t/// Pop the top item off the stack\n\tpub fn pop(&mut self)\n\t{\n\t\tif let Some(ptr) = self.top_raw()\n\t\t{\n\t\t\tassert!(self.next_ofs > 0);\n\t\t\t// SAFE: Pointer is valid, and will never be accessed after this point\n\t\t\tlet words = unsafe {\n\t\t\t\tlet size = mem::size_of_val(&*ptr);\n\t\t\t\tptr::drop_in_place(ptr);\n\t\t\t\tsuper::round_to_words(size)\n\t\t\t\t};\n\t\t\tself.next_ofs -= words+1;\n\t\t}\n\t}\n}","impl<T: ?Sized, D: ::DataBuf> ops::Drop for StackA<T,D>\n{\n\tfn drop(&mut self)\n\t{\n\t\twhile ! self.is_empty()\n\t\t{\n\t\t\tself.pop();\n\t\t}\n\t}\n}"],"value::ValueA":["impl<D: ::DataBuf,T: ?Sized> fmt::Debug for super::ValueA<T, D>\nwhere\n\tT: fmt::Debug\n{\n\tfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n\t\t(**self).fmt(f)\n\t}\n}","impl<D: ::DataBuf,T: ?Sized> fmt::Display for super::ValueA<T, D>\nwhere\n\tT: fmt::Display\n{\n\tfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n\t\t(**self).fmt(f)\n\t}\n}","impl<D: ::DataBuf,T: ?Sized> future::Future for super::ValueA<T, D>\nwhere\n\tT: future::Future\n{\n\ttype Output = T::Output;\n\tfn poll(self: pin::Pin<&mut Self>, cx: &mut task::Context) -> task::Poll<Self::Output> {\n\t\tunsafe {\n\t\t\tpin::Pin::new_unchecked(&mut **self.get_unchecked_mut()).poll(cx)\n\t\t}\n\t}\n}","impl<T: ?Sized, D: ::DataBuf> ValueA<T, D>\n{\n\t/// Construct a stack-based DST\n\t/// \n\t/// Returns Ok(dst) if the allocation was successful, or Err(val) if it failed\n\t#[cfg(feature=\"unsize\")]\n\tpub fn new<U: marker::Unsize<T>>(val: U) -> Result<ValueA<T,D>,U> {\n\t\tSelf::new_stable(val, |p| p)\n\t}\n\n\t/// Construct a stack-based DST (without needing `Unsize`)\n\t/// \n\t/// Returns Ok(dst) if the allocation was successful, or Err(val) if it failed\n\tpub fn new_stable<U, F: FnOnce(&U)->&T>(val: U, get_ref: F) -> Result<ValueA<T,D>, U>\n\t{\n\t\tlet rv = unsafe {\n\t\t\tlet mut ptr: *const T = get_ref(&val);\n\t\t\tlet words = super::ptr_as_slice(&mut ptr);\n\t\t\tassert!(words[0] == &val as *const _ as usize, \"BUG: Pointer layout is not (data_ptr, info...)\");\n\t\t\t// - Ensure that Self is aligned same as data requires\n\t\t\tassert!(mem::align_of::<U>() <= mem::align_of::<Self>(), \"TODO: Enforce alignment >{} (requires {})\",\n\t\t\t\tmem::align_of::<Self>(), mem::align_of::<U>());\n\t\t\t\n\t\t\tValueA::new_raw(&words[1..], words[0] as *mut (), mem::size_of::<U>())\n\t\t\t};\n\t\tmatch rv\n\t\t{\n\t\tSome(r) => {\n\t\t\t// Prevent the destructor from running, now that we've copied it away\n\t\t\tmem::forget(val);\n\t\t\tOk(r)\n\t\t\t},\n\t\tNone => {\n\t\t\tErr(val)\n\t\t\t},\n\t\t}\n\t}\n\n\t#[cfg(all(feature=\"alloc\", feature=\"unsize\"))]\n\t/// Construct a stack-based DST, falling back on boxing if the value doesn't fit\n\t/// \n\t/// ```\n\t/// # extern crate core;\n\t/// use stack_dst::ValueA;\n\t/// use core::fmt::Debug;\n\t/// let val = [1usize, 2, 3, 4];\n\t/// assert!( ValueA::<dyn Debug, [usize; 2]>::new(val).is_err() );\n\t/// let v = ValueA::<dyn Debug, [usize; 2]>::new_or_boxed(val);\n\t/// println!(\"v = {:?}\", v);\n\t/// ```\n\tpub fn new_or_boxed<U>(val: U) -> ValueA<T, D>\n\twhere\n\t\tU: marker::Unsize<T>,\n\t\t::alloc::boxed::Box<U>: marker::Unsize<T>\n\t{\n\t\tmatch Self::new(val)\n\t\t{\n\t\tOk(v) => v,\n\t\tErr(val) => Self::new(Box::new(val)).ok().expect(\"Insufficient space for Box<T>\"),\n\t\t}\n\t}\n\n\t/// UNSAFE: `data` must point to `size` bytes, which shouldn't be freed if `Some` is returned\n\tpub unsafe fn new_raw(info: &[usize], data: *mut (), size: usize) -> Option<ValueA<T,D>>\n\t{\n\t\tif info.len()*mem::size_of::<usize>() + size > mem::size_of::<D>() {\n\t\t\tNone\n\t\t}\n\t\telse {\n\t\t\tlet mut rv = ValueA {\n\t\t\t\t\t_align: [],\n\t\t\t\t\t_pd: marker::PhantomData,\n\t\t\t\t\tdata: D::default(),\n\t\t\t\t};\n\t\t\tassert!(info.len() + super::round_to_words(size) <= rv.data.as_ref().len());\n\n\t\t\t// Place pointer information at the end of the region\n\t\t\t// - Allows the data to be at the start for alignment purposes\n\t\t\t{\n\t\t\t\tlet info_ofs = rv.data.as_ref().len() - info.len();\n\t\t\t\tlet info_dst = &mut rv.data.as_mut()[info_ofs..];\n\t\t\t\tfor (d,v) in Iterator::zip( info_dst.iter_mut(), info.iter() ) {\n\t\t\t\t\t*d = *v;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlet src_ptr = data as *const u8;\n\t\t\tlet dataptr = rv.data.as_mut()[..].as_mut_ptr() as *mut u8;\n\t\t\tfor i in 0 .. size {\n\t\t\t\t*dataptr.offset(i as isize) = *src_ptr.offset(i as isize);\n\t\t\t}\n\t\t\tSome(rv)\n\t\t}\n\t}\n\n\t/// Obtain raw pointer to the contained data\n\tunsafe fn as_ptr(&self) -> *mut T\n\t{\n\t\tlet data = self.data.as_ref();\n\t\tlet info_size = mem::size_of::<*mut T>() / mem::size_of::<usize>() - 1;\n\t\tlet info_ofs = data.len() - info_size;\n\t\tsuper::make_fat_ptr( data[..].as_ptr() as usize, &data[info_ofs..] )\n\t}\n}","impl<T: ?Sized, D: ::DataBuf> ops::Deref for ValueA<T, D> {\n\ttype Target = T;\n\tfn deref(&self) -> &T {\n\t\tunsafe {\n\t\t\t&*self.as_ptr()\n\t\t}\n\t}\n}","impl<T: ?Sized, D: ::DataBuf> ops::DerefMut for ValueA<T, D> {\n\tfn deref_mut(&mut self) -> &mut T {\n\t\tunsafe {\n\t\t\t&mut *self.as_ptr()\n\t\t}\n\t}\n}","impl<T: ?Sized, D: ::DataBuf> ops::Drop for ValueA<T, D> {\n\tfn drop(&mut self) {\n\t\tunsafe {\n\t\t\tptr::drop_in_place(&mut **self)\n\t\t}\n\t}\n}"]},"single_path_import":{"stack::StackA":"StackA","value::Value":"Value","value::ValueA":"ValueA"},"srcs":{"<stack::StackA<T, D> as std::default::Default>::default":["fn default() -> Self{\n\t\tStackA::new()\n\t}","Real(LocalPath(\"src/stack.rs\"))"],"<stack::StackA<T, D> as std::ops::Drop>::drop":["fn drop(&mut self){\n\t\twhile ! self.is_empty()\n\t\t{\n\t\t\tself.pop();\n\t\t}\n\t}","Real(LocalPath(\"src/stack.rs\"))"],"<value::ValueA<T, D> as std::ops::Deref>::deref":["fn deref(&self) -> &T{\n\t\tunsafe {\n\t\t\t&*self.as_ptr()\n\t\t}\n\t}","Real(LocalPath(\"src/value.rs\"))"],"<value::ValueA<T, D> as std::ops::DerefMut>::deref_mut":["fn deref_mut(&mut self) -> &mut T{\n\t\tunsafe {\n\t\t\t&mut *self.as_ptr()\n\t\t}\n\t}","Real(LocalPath(\"src/value.rs\"))"],"<value::ValueA<T, D> as std::ops::Drop>::drop":["fn drop(&mut self){\n\t\tunsafe {\n\t\t\tptr::drop_in_place(&mut **self)\n\t\t}\n\t}","Real(LocalPath(\"src/value.rs\"))"],"DataBuf":["/// Trait used to represent a data buffer, typically you'll passs a `[usize; N]` array.\npub trait DataBuf: Copy+Default+AsMut<[usize]>+AsRef<[usize]> {\n}","Real(LocalPath(\"src/lib.rs\"))"],"make_fat_ptr":["/// Re-construct a fat pointer\nunsafe fn make_fat_ptr<T: ?Sized>(data_ptr: usize, meta_vals: &[usize]) -> *mut T{\n\tlet mut rv = mem::MaybeUninit::<*mut T>::uninit();\n\t{\n\t\tlet s = ptr_as_slice(&mut rv);\n\t\ts[0] = data_ptr;\n\t\ts[1..].copy_from_slice(meta_vals);\n\t}\n\tlet rv = rv.assume_init();\n\tassert_eq!(rv as *const (), data_ptr as *const ());\n\trv\n}","Real(LocalPath(\"src/lib.rs\"))"],"ptr_as_slice":["/// Obtain mutable access to a pointer's words\nfn ptr_as_slice<T>(ptr: &mut T) -> &mut [usize]{\n\tassert!( mem::size_of::<T>() % mem::size_of::<usize>() == 0 );\n\tlet words = mem::size_of::<T>() / mem::size_of::<usize>();\n\t// SAFE: Points to valid memory (a raw pointer)\n\tunsafe {\n\t\tslice::from_raw_parts_mut(ptr as *mut _ as *mut usize, words)\n\t}\n}","Real(LocalPath(\"src/lib.rs\"))"],"round_to_words":["fn round_to_words(len: usize) -> usize{\n\t(len + mem::size_of::<usize>()-1) / mem::size_of::<usize>()\n}","Real(LocalPath(\"src/lib.rs\"))"],"stack::StackA":["/// A fixed-capacity stack that can contain dynamically-sized types\n///\n/// Uses an array of usize as a backing store for a First-In, Last-Out stack\n/// of items that can unsize to `T`.\n///\n/// Note: Each item in the stack takes at least one `usize` (to store the metadata)\npub struct StackA<T: ?Sized, D: ::DataBuf>\n{\n\t_pd: marker::PhantomData<*const T>,\n\t// Offset from the _back_ of `data` to the next free position.\n\t// I.e. data[data.len() - cur_ofs] is the first metadata word\n\tnext_ofs: usize,\n\tdata: D,\n}","Real(LocalPath(\"src/stack.rs\"))"],"stack::StackA::<T, D>::is_empty":["/// Tests if the stack is empty\npub fn is_empty(&self) -> bool{\n\t\tself.next_ofs == 0\n\t}","Real(LocalPath(\"src/stack.rs\"))"],"stack::StackA::<T, D>::meta_words":["fn meta_words() -> usize{\n\t\tmem::size_of::<&T>() / mem::size_of::<usize>() - 1\n\t}","Real(LocalPath(\"src/stack.rs\"))"],"stack::StackA::<T, D>::new":["/// Construct a new (empty) stack\npub fn new() -> StackA<T, D>{\n\t\tStackA {\n\t\t\t_pd: marker::PhantomData,\n\t\t\tnext_ofs: 0,\n\t\t\tdata: Default::default(),\n\t\t\t}\n\t}","Real(LocalPath(\"src/stack.rs\"))"],"stack::StackA::<T, D>::pop":["/// Pop the top item off the stack\npub fn pop(&mut self){\n\t\tif let Some(ptr) = self.top_raw()\n\t\t{\n\t\t\tassert!(self.next_ofs > 0);\n\t\t\t// SAFE: Pointer is valid, and will never be accessed after this point\n\t\t\tlet words = unsafe {\n\t\t\t\tlet size = mem::size_of_val(&*ptr);\n\t\t\t\tptr::drop_in_place(ptr);\n\t\t\t\tsuper::round_to_words(size)\n\t\t\t\t};\n\t\t\tself.next_ofs -= words+1;\n\t\t}\n\t}","Real(LocalPath(\"src/stack.rs\"))"],"stack::StackA::<T, D>::push_inner":["fn push_inner(&mut self, fat_ptr: &T) -> Result<&mut [usize], ()>{\n\t\tlet bytes = mem::size_of_val(fat_ptr);\n\t\tlet words = super::round_to_words(bytes) + Self::meta_words();\n\t\t// Check if there is sufficient space for the new item\n\t\tif self.next_ofs + words <= self.data.as_ref().len()\n\t\t{\n\t\t\t// Get the base pointer for the new item\n\t\t\tself.next_ofs += words;\n\t\t\tlet len = self.data.as_ref().len();\n\t\t\tlet slot = &mut self.data.as_mut()[len - self.next_ofs..][..words];\n\t\t\tlet (meta, rv) = slot.split_at_mut(Self::meta_words());\n\n\t\t\t// Populate the metadata\n\t\t\tlet mut ptr_raw: *const T = fat_ptr;\n\t\t\tlet ptr_words = ::ptr_as_slice(&mut ptr_raw);\n\t\t\tassert_eq!(ptr_words.len(), 1 + Self::meta_words());\n\t\t\tmeta.clone_from_slice( &ptr_words[1..] );\n\n\t\t\t// Increment offset and return\n\t\t\tOk( rv )\n\t\t}\n\t\telse\n\t\t{\n\t\t\tErr( () )\n\t\t}\n\t}","Real(LocalPath(\"src/stack.rs\"))"],"stack::StackA::<T, D>::push_stable":["/// Push a value at the top of the stack (without using `Unsize`)\npub fn push_stable<U, F: FnOnce(&U) -> &T>(&mut self, v: U, f: F) -> Result<(), U>{\n\t\t// - Ensure that Self is aligned same as data requires\n\t\tassert!(mem::align_of::<U>() <= mem::align_of::<Self>(), \"TODO: Enforce alignment >{} (requires {})\",\n\t\t\tmem::align_of::<Self>(), mem::align_of::<U>());\n\n\t\tmatch self.push_inner( f(&v) )\n\t\t{\n\t\tOk(d) => {\n\t\t\t// SAFE: Destination address is valid\n\t\t\tunsafe { ptr::write( d.as_mut_ptr() as *mut U, v ); }\n\t\t\tOk( () )\n\t\t\t},\n\t\tErr(_) => Err(v),\n\t\t}\n\t}","Real(LocalPath(\"src/stack.rs\"))"],"stack::StackA::<T, D>::top":["/// Returns a pointer to the top item on the stack\npub fn top(&self) -> Option<&T>{\n\t\tself.top_raw().map(|x| unsafe { &*x })\n\t}","Real(LocalPath(\"src/stack.rs\"))"],"stack::StackA::<T, D>::top_mut":["/// Returns a pointer to the top item on the stack (unique/mutable)\npub fn top_mut(&mut self) -> Option<&mut T>{\n\t\tself.top_raw().map(|x| unsafe { &mut *x })\n\t}","Real(LocalPath(\"src/stack.rs\"))"],"stack::StackA::<T, D>::top_raw":["fn top_raw(&self) -> Option<*mut T>{\n\t\tif self.next_ofs == 0\n\t\t{\n\t\t\tNone\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet len = self.data.as_ref().len();\n\t\t\tlet meta = &self.data.as_ref()[len - self.next_ofs..];\n\t\t\t// SAFE: Internal consistency maintains the metadata validity\n\t\t\tSome( unsafe { super::make_fat_ptr( \n\t\t\t\tmeta[Self::meta_words()..].as_ptr() as usize,\n\t\t\t\t&meta[..Self::meta_words()]\n\t\t\t\t) } )\n\t\t}\n\t}","Real(LocalPath(\"src/stack.rs\"))"],"stack::StackA::<[T], D>::push_cloned":["/// Pushes a set of items (cloning out of the input slice)\npub fn push_cloned(&mut self, v: &[T]) -> Result<(),()>{\n\t\tmatch self.push_inner(&v)\n\t\t{\n\t\tOk(d) => {\n\t\t\tunsafe\n\t\t\t{\n\t\t\t\tlet mut ptr = d.as_mut_ptr() as *mut T;\n\t\t\t\tfor val in v\n\t\t\t\t{\n\t\t\t\t\tptr::write(ptr, val.clone());\n\t\t\t\t\tptr = ptr.offset(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk( () )\n\t\t\t},\n\t\tErr(_) => Err( () ),\n\t\t}\n\t}","Real(LocalPath(\"src/stack.rs\"))"],"stack::StackA::<str, D>::push_str":["/// Push the contents of a string slice as an item onto the stack\npub fn push_str(&mut self, v: &str) -> Result<(),()>{\n\t\tmatch self.push_inner(v)\n\t\t{\n\t\tOk(d) => {\n\t\t\tunsafe { \n\t\t\t\tptr::copy( v.as_bytes().as_ptr(), d.as_mut_ptr() as *mut u8, v.len() );\n\t\t\t}\n\t\t\tOk( () )\n\t\t\t},\n\t\tErr(_) => Err( () ),\n\t\t}\n\t}","Real(LocalPath(\"src/stack.rs\"))"],"value::ValueA":["/// Stack-allocated dynamically sized type\n///\n/// `T` is the unsized type contaned.\n/// `D` is the buffer used to hold the unsized type (both data and metadata).\npub struct ValueA<T: ?Sized, D: ::DataBuf>\n{\n\t// Force alignment to be 8 bytes (for types that contain u64s)\n\t_align: [u64; 0],\n\t_pd: marker::PhantomData<T>,\n\t// Data contains the object data first, then padding, then the pointer information\n\tdata: D,\n}","Real(LocalPath(\"src/value.rs\"))"],"value::ValueA::<T, D>::as_ptr":["/// Obtain raw pointer to the contained data\nunsafe fn as_ptr(&self) -> *mut T{\n\t\tlet data = self.data.as_ref();\n\t\tlet info_size = mem::size_of::<*mut T>() / mem::size_of::<usize>() - 1;\n\t\tlet info_ofs = data.len() - info_size;\n\t\tsuper::make_fat_ptr( data[..].as_ptr() as usize, &data[info_ofs..] )\n\t}","Real(LocalPath(\"src/value.rs\"))"],"value::ValueA::<T, D>::new_raw":["/// UNSAFE: `data` must point to `size` bytes, which shouldn't be freed if `Some` is returned\npub unsafe fn new_raw(info: &[usize], data: *mut (), size: usize) -> Option<ValueA<T,D>>{\n\t\tif info.len()*mem::size_of::<usize>() + size > mem::size_of::<D>() {\n\t\t\tNone\n\t\t}\n\t\telse {\n\t\t\tlet mut rv = ValueA {\n\t\t\t\t\t_align: [],\n\t\t\t\t\t_pd: marker::PhantomData,\n\t\t\t\t\tdata: D::default(),\n\t\t\t\t};\n\t\t\tassert!(info.len() + super::round_to_words(size) <= rv.data.as_ref().len());\n\n\t\t\t// Place pointer information at the end of the region\n\t\t\t// - Allows the data to be at the start for alignment purposes\n\t\t\t{\n\t\t\t\tlet info_ofs = rv.data.as_ref().len() - info.len();\n\t\t\t\tlet info_dst = &mut rv.data.as_mut()[info_ofs..];\n\t\t\t\tfor (d,v) in Iterator::zip( info_dst.iter_mut(), info.iter() ) {\n\t\t\t\t\t*d = *v;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlet src_ptr = data as *const u8;\n\t\t\tlet dataptr = rv.data.as_mut()[..].as_mut_ptr() as *mut u8;\n\t\t\tfor i in 0 .. size {\n\t\t\t\t*dataptr.offset(i as isize) = *src_ptr.offset(i as isize);\n\t\t\t}\n\t\t\tSome(rv)\n\t\t}\n\t}","Real(LocalPath(\"src/value.rs\"))"],"value::ValueA::<T, D>::new_stable":["/// Construct a stack-based DST (without needing `Unsize`)\n/// \n/// Returns Ok(dst) if the allocation was successful, or Err(val) if it failed\npub fn new_stable<U, F: FnOnce(&U)->&T>(val: U, get_ref: F) -> Result<ValueA<T,D>, U>{\n\t\tlet rv = unsafe {\n\t\t\tlet mut ptr: *const T = get_ref(&val);\n\t\t\tlet words = super::ptr_as_slice(&mut ptr);\n\t\t\tassert!(words[0] == &val as *const _ as usize, \"BUG: Pointer layout is not (data_ptr, info...)\");\n\t\t\t// - Ensure that Self is aligned same as data requires\n\t\t\tassert!(mem::align_of::<U>() <= mem::align_of::<Self>(), \"TODO: Enforce alignment >{} (requires {})\",\n\t\t\t\tmem::align_of::<Self>(), mem::align_of::<U>());\n\t\t\t\n\t\t\tValueA::new_raw(&words[1..], words[0] as *mut (), mem::size_of::<U>())\n\t\t\t};\n\t\tmatch rv\n\t\t{\n\t\tSome(r) => {\n\t\t\t// Prevent the destructor from running, now that we've copied it away\n\t\t\tmem::forget(val);\n\t\t\tOk(r)\n\t\t\t},\n\t\tNone => {\n\t\t\tErr(val)\n\t\t\t},\n\t\t}\n\t}","Real(LocalPath(\"src/value.rs\"))"],"value::trait_impls::<impl std::fmt::Debug for value::ValueA<T, D>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n\t\t(**self).fmt(f)\n\t}","Real(LocalPath(\"src/value/trait_impls.rs\"))"],"value::trait_impls::<impl std::fmt::Display for value::ValueA<T, D>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n\t\t(**self).fmt(f)\n\t}","Real(LocalPath(\"src/value/trait_impls.rs\"))"],"value::trait_impls::<impl std::future::Future for value::ValueA<T, D>>::poll":["fn poll(self: pin::Pin<&mut Self>, cx: &mut task::Context) -> task::Poll<Self::Output>{\n\t\tunsafe {\n\t\t\tpin::Pin::new_unchecked(&mut **self.get_unchecked_mut()).poll(cx)\n\t\t}\n\t}","Real(LocalPath(\"src/value/trait_impls.rs\"))"]},"struct_constructor":{"&mut [usize]":["ptr_as_slice","push_inner"],"bool":["is_empty"],"stack::StackA":["default","new"],"std::task::Poll":["poll"],"usize":["meta_words"],"value::ValueA":["new_raw","new_stable"]},"struct_to_trait":{"<T as DataBuf>::T":["DataBuf"],"stack::StackA":["std::default::Default","std::ops::Drop"],"value::ValueA":["std::fmt::Debug","std::fmt::Display","std::future::Future","std::ops::Deref","std::ops::DerefMut","std::ops::Drop"]},"targets":{"<stack::StackA<T, D> as std::default::Default>::default":["default","Real(LocalPath(\"src/stack.rs\"))","std::default::Default"],"<stack::StackA<T, D> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/stack.rs\"))","std::ops::Drop"],"<value::ValueA<T, D> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/value.rs\"))","std::ops::Deref"],"<value::ValueA<T, D> as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/value.rs\"))","std::ops::DerefMut"],"<value::ValueA<T, D> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/value.rs\"))","std::ops::Drop"],"make_fat_ptr":["make_fat_ptr","Real(LocalPath(\"src/lib.rs\"))",""],"ptr_as_slice":["ptr_as_slice","Real(LocalPath(\"src/lib.rs\"))",""],"round_to_words":["round_to_words","Real(LocalPath(\"src/lib.rs\"))",""],"stack::StackA::<T, D>::is_empty":["is_empty","Real(LocalPath(\"src/stack.rs\"))",""],"stack::StackA::<T, D>::meta_words":["meta_words","Real(LocalPath(\"src/stack.rs\"))",""],"stack::StackA::<T, D>::new":["new","Real(LocalPath(\"src/stack.rs\"))",""],"stack::StackA::<T, D>::pop":["pop","Real(LocalPath(\"src/stack.rs\"))",""],"stack::StackA::<T, D>::push_inner":["push_inner","Real(LocalPath(\"src/stack.rs\"))",""],"stack::StackA::<T, D>::push_stable":["push_stable","Real(LocalPath(\"src/stack.rs\"))",""],"stack::StackA::<T, D>::top":["top","Real(LocalPath(\"src/stack.rs\"))",""],"stack::StackA::<T, D>::top_mut":["top_mut","Real(LocalPath(\"src/stack.rs\"))",""],"stack::StackA::<T, D>::top_raw":["top_raw","Real(LocalPath(\"src/stack.rs\"))",""],"stack::StackA::<[T], D>::push_cloned":["push_cloned","Real(LocalPath(\"src/stack.rs\"))",""],"stack::StackA::<str, D>::push_str":["push_str","Real(LocalPath(\"src/stack.rs\"))",""],"value::ValueA::<T, D>::as_ptr":["as_ptr","Real(LocalPath(\"src/value.rs\"))",""],"value::ValueA::<T, D>::new_raw":["new_raw","Real(LocalPath(\"src/value.rs\"))",""],"value::ValueA::<T, D>::new_stable":["new_stable","Real(LocalPath(\"src/value.rs\"))",""],"value::trait_impls::<impl std::fmt::Debug for value::ValueA<T, D>>::fmt":["fmt","Real(LocalPath(\"src/value/trait_impls.rs\"))","std::fmt::Debug"],"value::trait_impls::<impl std::fmt::Display for value::ValueA<T, D>>::fmt":["fmt","Real(LocalPath(\"src/value/trait_impls.rs\"))","std::fmt::Display"],"value::trait_impls::<impl std::future::Future for value::ValueA<T, D>>::poll":["poll","Real(LocalPath(\"src/value/trait_impls.rs\"))","std::future::Future"]},"trait_to_struct":{"DataBuf":["<T as DataBuf>::T"],"std::default::Default":["stack::StackA"],"std::fmt::Debug":["value::ValueA"],"std::fmt::Display":["value::ValueA"],"std::future::Future":["value::ValueA"],"std::ops::Deref":["value::ValueA"],"std::ops::DerefMut":["value::ValueA"],"std::ops::Drop":["stack::StackA","value::ValueA"]},"type_to_def_path":{"stack::StackA<T, D>":"stack::StackA","value::ValueA<T, D>":"value::ValueA"}}