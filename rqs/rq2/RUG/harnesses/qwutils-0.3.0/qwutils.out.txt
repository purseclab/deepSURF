-----------------
src/imp/result.rs imp::result::unwrap_failed
deps:{"imp::result::unwrap_failed":{"E":["std::marker::Sized"]}}
candidates:{"imp::result::unwrap_failed":{"E":["RUG_ANY"]}}
let mut p0 = "sample"; // None+&str
+imp::result::unwrap_failed(&p0);
+crate::imp::result::unwrap_failed(&p0);
+crate::imp::result::unwrap_failed(&p0);
-----------------
src/imp/option.rs imp::option::flatten
deps:{"imp::option::flatten":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::flatten":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<std::option::Option<T>>
+imp::option::flatten(p0);
+crate::imp::option::flatten(p0);
+crate::imp::option::flatten(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::slice_slice
deps:{"arc_slice::imp::slice_slice":{"S":["std::marker::Sized","std::ops::RangeBounds"]}}
candidates:{"arc_slice::imp::slice_slice":{"S":["(std::collections::Bound<&'a T>, std::collections::Bound<&'a T>)","std::ops::RangeToInclusive<T>","std::ops::Range<&T>","std::ops::RangeInclusive<&T>","std::ops::RangeInclusive<T>","std::ops::RangeFrom<T>","std::ops::RangeTo<T>","std::ops::RangeFrom<&T>","std::ops::RangeToInclusive<&T>","std::ops::Range<T>","std::ops::RangeTo<&T>","std::ops::RangeFull","(std::collections::Bound<T>, std::collections::Bound<T>)"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+arc_slice::imp::slice_slice(p0, p1);
+crate::arc_slice::imp::slice_slice(p0, p1);
+crate::arc_slice::imp::slice_slice(p0, p1);
-----------------
src/if_type.rs if_type::if_type
deps:{"if_type::if_type":{"Specific":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce() -> Specific":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"if_type::if_type":{"Specific":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce() -> Specific":["std::panic::AssertUnwindSafe<F>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl FnOnce() -> Specific
+if_type::if_type(p0);
+crate::if_type::if_type(p0);
+crate::if_type::if_type(p0);
-----------------
src/imp/vec.rs imp::vec::VecExt::push_option
deps:{"<&A as std::alloc::Allocator>":{},"imp::vec::VecExt::push_option":{"Self":["imp::vec::VecExt"],"T":["std::marker::Sized"]},"std::vec::Vec":{"A":["std::alloc::Allocator","std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"<&A as std::alloc::Allocator>":{},"imp::vec::VecExt::push_option":{"Self":["std::vec::Vec"],"T":["RUG_ANY"]},"std::vec::Vec":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<T>
+p0.push_option(p1);
+imp::vec::VecExt::push_option(p0, p1);
+crate::imp::vec::VecExt::push_option(p0, p1);
+crate::imp::vec::VecExt::push_option(p0, p1);
-----------------
src/imp/vec.rs imp::vec::VecExt::grow_to_with
deps:{"<&A as std::alloc::Allocator>":{},"imp::vec::VecExt::grow_to_with":{"F":["std::ops::FnMut","std::marker::Sized"],"Self":["imp::vec::VecExt"],"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::marker::Sized","std::alloc::Allocator"],"T":["std::marker::Sized"]}}
candidates:{"<&A as std::alloc::Allocator>":{},"imp::vec::VecExt::grow_to_with":{"F":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"],"Self":["std::vec::Vec"],"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+p0.grow_to_with(p1, p2);
+imp::vec::VecExt::grow_to_with(p0, p1, p2);
+crate::imp::vec::VecExt::grow_to_with(p0, p1, p2);
+crate::imp::vec::VecExt::grow_to_with(p0, p1, p2);
-----------------
src/imp/vec.rs imp::vec::VecExt::grow_to
deps:{"<&A as std::alloc::Allocator>":{},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Ord","std::cmp::Eq","std::cmp::PartialOrd","std::clone::Clone","std::hash::Hash"]},"imp::vec::VecExt::grow_to":{"Self":["imp::vec::VecExt"],"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"std::vec::Vec":{"A":["std::marker::Sized","std::alloc::Allocator"],"T":["std::marker::Sized"]}}
candidates:{"<&A as std::alloc::Allocator>":{},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"imp::vec::VecExt::grow_to":{"Self":["std::vec::Vec"],"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2","macros::Test"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"std::vec::Vec":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.grow_to(p1, p2);
+imp::vec::VecExt::grow_to(p0, p1, p2);
+crate::imp::vec::VecExt::grow_to(p0, p1, p2);
+crate::imp::vec::VecExt::grow_to(p0, p1, p2);
-----------------
src/imp/vec.rs imp::vec::VecExt::grow_to_default
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialOrd","std::marker::Sized","std::hash::Hash","std::cmp::PartialEq","std::cmp::Ord"]},"imp::vec::VecExt::grow_to_default":{"Self":["imp::vec::VecExt"],"T":["std::default::Default","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::vec::Vec":{"A":["std::marker::Sized","std::alloc::Allocator"],"T":["std::marker::Sized"]}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["<*mut T as std::fmt::Debug>","arc_slice::ArcSlice"]},"imp::vec::VecExt::grow_to_default":{"Self":["std::vec::Vec"],"T":["arc_slice::ArcSlice"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::vec::Vec":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.grow_to_default(p1);
+imp::vec::VecExt::grow_to_default(p0, p1);
+crate::imp::vec::VecExt::grow_to_default(p0, p1);
+crate::imp::vec::VecExt::grow_to_default(p0, p1);
-----------------
src/imp/vec.rs imp::vec::VecExt::insert_slice_copy
deps:{"<&A as std::alloc::Allocator>":{},"imp::vec::VecExt::insert_slice_copy":{"Self":["imp::vec::VecExt"],"T":["std::marker::Copy","std::marker::Sized"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::vec::Vec":{"A":["std::marker::Sized","std::alloc::Allocator"],"T":["std::marker::Sized"]}}
candidates:{"<&A as std::alloc::Allocator>":{},"imp::vec::VecExt::insert_slice_copy":{"Self":["std::vec::Vec"],"T":["i64","usize","std::marker::copy_impls::<impl std::marker::Copy for *const T>","i32","std::marker::copy_impls::<impl std::marker::Copy for *mut T>","u64","char","i8","u8","bool","i16","u32","u16"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::vec::Vec":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
let mut p2 = & MaybeUninit::uninit().assume_init(); // [T]
+p0.insert_slice_copy(p1, p2);
+imp::vec::VecExt::insert_slice_copy(p0, p1, p2);
+crate::imp::vec::VecExt::insert_slice_copy(p0, p1, p2);
+crate::imp::vec::VecExt::insert_slice_copy(p0, p1, p2);
-----------------
src/imp/vec.rs imp::vec::VecExt::insert_slice_clone
deps:{"<&A as std::alloc::Allocator>":{},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::marker::Sized","std::cmp::PartialEq","std::cmp::Ord","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialOrd","std::clone::Clone"]},"imp::vec::VecExt::insert_slice_clone":{"Self":["imp::vec::VecExt"],"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::vec::Vec":{"A":["std::alloc::Allocator","std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"<&A as std::alloc::Allocator>":{},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","arc_slice::ArcSlice"]},"imp::vec::VecExt::insert_slice_clone":{"Self":["std::vec::Vec"],"T":["macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::vec::Vec":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
let mut p2 = & MaybeUninit::uninit().assume_init(); // [T]
+p0.insert_slice_clone(p1, p2);
+imp::vec::VecExt::insert_slice_clone(p0, p1, p2);
+crate::imp::vec::VecExt::insert_slice_clone(p0, p1, p2);
+crate::imp::vec::VecExt::insert_slice_clone(p0, p1, p2);
-----------------
src/imp/vec.rs imp::vec::VecExt::extend_from_slice_copy
deps:{"<&A as std::alloc::Allocator>":{},"imp::vec::VecExt::extend_from_slice_copy":{"Self":["imp::vec::VecExt"],"T":["std::marker::Copy","std::marker::Sized"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::vec::Vec":{"A":["std::marker::Sized","std::alloc::Allocator"],"T":["std::marker::Sized"]}}
candidates:{"<&A as std::alloc::Allocator>":{},"imp::vec::VecExt::extend_from_slice_copy":{"Self":["std::vec::Vec"],"T":["std::marker::copy_impls::<impl std::marker::Copy for *const T>","u16","i64","i16","u64","u32","char","std::marker::copy_impls::<impl std::marker::Copy for &T>","usize","u8","i8","i32","bool"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::vec::Vec":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // [T]
+p0.extend_from_slice_copy(p1);
+imp::vec::VecExt::extend_from_slice_copy(p0, p1);
+crate::imp::vec::VecExt::extend_from_slice_copy(p0, p1);
+crate::imp::vec::VecExt::extend_from_slice_copy(p0, p1);
-----------------
src/imp/result.rs imp::result::ResultNonDebugUnwrap::expect_nodebug
deps:{"imp::result::ResultNonDebugUnwrap::expect_nodebug":{"E":["std::marker::Sized"],"Self":["imp::result::ResultNonDebugUnwrap"],"T":["std::marker::Sized"]},"std::result::Result":{"E":["std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"imp::result::ResultNonDebugUnwrap::expect_nodebug":{"E":["RUG_ANY"],"Self":["std::result::Result"],"T":["RUG_ANY"]},"std::result::Result":{"E":["RUG_ANY"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.expect_nodebug(&p1);
+imp::result::ResultNonDebugUnwrap::expect_nodebug(p0, &p1);
+crate::imp::result::ResultNonDebugUnwrap::expect_nodebug(p0, &p1);
+crate::imp::result::ResultNonDebugUnwrap::expect_nodebug(p0, &p1);
-----------------
src/imp/result.rs imp::result::ResultNonDebugUnwrap::expect_err_nodebug
deps:{"imp::result::ResultNonDebugUnwrap::expect_err_nodebug":{"E":["std::marker::Sized"],"Self":["imp::result::ResultNonDebugUnwrap"],"T":["std::marker::Sized"]},"std::result::Result":{"E":["std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"imp::result::ResultNonDebugUnwrap::expect_err_nodebug":{"E":["RUG_ANY"],"Self":["std::result::Result"],"T":["RUG_ANY"]},"std::result::Result":{"E":["RUG_ANY"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.expect_err_nodebug(&p1);
+imp::result::ResultNonDebugUnwrap::expect_err_nodebug(p0, &p1);
+crate::imp::result::ResultNonDebugUnwrap::expect_err_nodebug(p0, &p1);
+crate::imp::result::ResultNonDebugUnwrap::expect_err_nodebug(p0, &p1);
-----------------
src/imp/result.rs imp::result::ResultNonDebugUnwrap::unwrap_nodebug
deps:{"imp::result::ResultNonDebugUnwrap::unwrap_nodebug":{"E":["std::marker::Sized"],"Self":["imp::result::ResultNonDebugUnwrap"],"T":["std::marker::Sized"]},"std::result::Result":{"E":["std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"imp::result::ResultNonDebugUnwrap::unwrap_nodebug":{"E":["RUG_ANY"],"Self":["std::result::Result"],"T":["RUG_ANY"]},"std::result::Result":{"E":["RUG_ANY"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.unwrap_nodebug();
+imp::result::ResultNonDebugUnwrap::unwrap_nodebug(p0);
+crate::imp::result::ResultNonDebugUnwrap::unwrap_nodebug(p0);
+crate::imp::result::ResultNonDebugUnwrap::unwrap_nodebug(p0);
-----------------
src/imp/result.rs imp::result::ResultNonDebugUnwrap::unwrap_err_nodebug
deps:{"imp::result::ResultNonDebugUnwrap::unwrap_err_nodebug":{"E":["std::marker::Sized"],"Self":["imp::result::ResultNonDebugUnwrap"],"T":["std::marker::Sized"]},"std::result::Result":{"E":["std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"imp::result::ResultNonDebugUnwrap::unwrap_err_nodebug":{"E":["RUG_ANY"],"Self":["std::result::Result"],"T":["RUG_ANY"]},"std::result::Result":{"E":["RUG_ANY"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.unwrap_err_nodebug();
+imp::result::ResultNonDebugUnwrap::unwrap_err_nodebug(p0);
+crate::imp::result::ResultNonDebugUnwrap::unwrap_err_nodebug(p0);
+crate::imp::result::ResultNonDebugUnwrap::unwrap_err_nodebug(p0);
-----------------
src/imp/boolext.rs imp::boolext::BoolExtOption::option
deps:{"imp::boolext::BoolExtOption::option":{"Self":["imp::boolext::BoolExtOption"]}}
candidates:{"imp::boolext::BoolExtOption::option":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.option();
+imp::boolext::BoolExtOption::option(p0);
+crate::imp::boolext::BoolExtOption::option(p0);
+crate::imp::boolext::BoolExtOption::option(p0);
-----------------
src/imp/boolext.rs imp::boolext::BoolExtOption::result
deps:{"imp::boolext::BoolExtOption::result":{"Self":["imp::boolext::BoolExtOption"]}}
candidates:{"imp::boolext::BoolExtOption::result":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.result();
+imp::boolext::BoolExtOption::result(p0);
+crate::imp::boolext::BoolExtOption::result(p0);
+crate::imp::boolext::BoolExtOption::result(p0);
-----------------
src/imp/boolext.rs imp::boolext::BoolExtOption::map
deps:{"imp::boolext::BoolExtOption::map":{"Self":["imp::boolext::BoolExtOption"],"U":["std::marker::Sized"],"impl FnOnce() -> U":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"imp::boolext::BoolExtOption::map":{"Self":[],"U":["RUG_ANY"],"impl FnOnce() -> U":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::panic::AssertUnwindSafe<F>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce() -> U
+p0.map(p1);
+imp::boolext::BoolExtOption::map(p0, p1);
+crate::imp::boolext::BoolExtOption::map(p0, p1);
+crate::imp::boolext::BoolExtOption::map(p0, p1);
-----------------
src/imp/boolext.rs imp::boolext::BoolExtOption::map_or
deps:{"imp::boolext::BoolExtOption::map_or":{"Self":["imp::boolext::BoolExtOption"],"U":["std::marker::Sized"],"impl FnOnce() -> U":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"imp::boolext::BoolExtOption::map_or":{"Self":[],"U":["RUG_ANY"],"impl FnOnce() -> U":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::IsWhitespace","std::panic::AssertUnwindSafe<F>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // U
let mut p2 = MaybeUninit::uninit().assume_init(); // impl FnOnce() -> U
+p0.map_or(p1, p2);
+imp::boolext::BoolExtOption::map_or(p0, p1, p2);
+crate::imp::boolext::BoolExtOption::map_or(p0, p1, p2);
+crate::imp::boolext::BoolExtOption::map_or(p0, p1, p2);
-----------------
src/imp/boolext.rs imp::boolext::BoolExtOption::map_or_else
deps:{"imp::boolext::BoolExtOption::map_or_else":{"Self":["imp::boolext::BoolExtOption"],"U":["std::marker::Sized"],"impl FnOnce() -> U":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"imp::boolext::BoolExtOption::map_or_else":{"Self":[],"U":["RUG_ANY"],"impl FnOnce() -> U":["core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce() -> U
let mut p2 = MaybeUninit::uninit().assume_init(); // impl FnOnce() -> U
+p0.map_or_else(p1, p2);
+imp::boolext::BoolExtOption::map_or_else(p0, p1, p2);
+crate::imp::boolext::BoolExtOption::map_or_else(p0, p1, p2);
+crate::imp::boolext::BoolExtOption::map_or_else(p0, p1, p2);
-----------------
src/imp/boolext.rs imp::boolext::BoolExtOption::map_or_err
deps:{"imp::boolext::BoolExtOption::map_or_err":{"E":["std::marker::Sized"],"Self":["imp::boolext::BoolExtOption"],"T":["std::marker::Sized"],"impl FnOnce() -> E":["std::marker::Sized","std::ops::FnOnce"],"impl FnOnce() -> T":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"imp::boolext::BoolExtOption::map_or_err":{"E":["RUG_ANY"],"Self":[],"T":["RUG_ANY"],"impl FnOnce() -> E":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::panic::AssertUnwindSafe<F>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"],"impl FnOnce() -> T":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","std::panic::AssertUnwindSafe<F>","core::str::IsNotEmpty"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce() -> T
let mut p2 = MaybeUninit::uninit().assume_init(); // impl FnOnce() -> E
+p0.map_or_err(p1, p2);
+imp::boolext::BoolExtOption::map_or_err(p0, p1, p2);
+crate::imp::boolext::BoolExtOption::map_or_err(p0, p1, p2);
+crate::imp::boolext::BoolExtOption::map_or_err(p0, p1, p2);
-----------------
src/imp/option.rs imp::option::OptionExt::with
deps:{"imp::option::OptionExt::with":{"R":["std::marker::Sized"],"Self":["imp::option::OptionExt"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::with":{"R":["RUG_ANY"],"Self":["std::option::Option"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::panic::AssertUnwindSafe<F>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.with(p1);
+imp::option::OptionExt::with(p0, p1);
+crate::imp::option::OptionExt::with(p0, p1);
+crate::imp::option::OptionExt::with(p0, p1);
-----------------
src/imp/option.rs imp::option::OptionExt::with_mut
deps:{"imp::option::OptionExt::with_mut":{"R":["std::marker::Sized"],"Self":["imp::option::OptionExt"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::with_mut":{"R":["RUG_ANY"],"Self":["std::option::Option"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.with_mut(p1);
+imp::option::OptionExt::with_mut(p0, p1);
+crate::imp::option::OptionExt::with_mut(p0, p1);
+crate::imp::option::OptionExt::with_mut(p0, p1);
-----------------
src/imp/option.rs imp::option::OptionExt::with_if
deps:{"imp::option::OptionExt::with_if":{"R":["std::marker::Sized"],"Self":["imp::option::OptionExt"],"T":["std::marker::Sized"],"U":["std::marker::Sized"],"impl FnOnce(&T, &U) -> R":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::with_if":{"R":["RUG_ANY"],"Self":["std::option::Option"],"T":["RUG_ANY"],"U":["RUG_ANY"],"impl FnOnce(&T, &U) -> R":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::panic::AssertUnwindSafe<F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::option::Option<U>
let mut p2 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T, &U) -> R
+p0.with_if(p1, p2);
+imp::option::OptionExt::with_if(p0, p1, p2);
+crate::imp::option::OptionExt::with_if(p0, p1, p2);
+crate::imp::option::OptionExt::with_if(p0, p1, p2);
-----------------
src/imp/option.rs imp::option::OptionExt::with_mut_if
deps:{"imp::option::OptionExt::with_mut_if":{"R":["std::marker::Sized"],"Self":["imp::option::OptionExt"],"T":["std::marker::Sized"],"U":["std::marker::Sized"],"impl FnOnce(&mut T, &U) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::with_mut_if":{"R":["RUG_ANY"],"Self":["std::option::Option"],"T":["RUG_ANY"],"U":["RUG_ANY"],"impl FnOnce(&mut T, &U) -> R":["core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","std::panic::AssertUnwindSafe<F>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::option::Option<U>
let mut p2 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T, &U) -> R
+p0.with_mut_if(p1, p2);
+imp::option::OptionExt::with_mut_if(p0, p1, p2);
+crate::imp::option::OptionExt::with_mut_if(p0, p1, p2);
+crate::imp::option::OptionExt::with_mut_if(p0, p1, p2);
-----------------
src/imp/option.rs imp::option::OptionExt::with_mut_if_saturating
deps:{"imp::option::OptionExt::with_mut_if_saturating":{"R":["std::marker::Sized"],"Self":["imp::option::OptionExt"],"T":["std::marker::Sized"],"impl FnOnce(&mut T, &T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::with_mut_if_saturating":{"R":["RUG_ANY"],"Self":["std::option::Option"],"T":["RUG_ANY"],"impl FnOnce(&mut T, &T) -> R":["std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","std::panic::AssertUnwindSafe<F>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p2 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T, &T) -> R
+p0.with_mut_if_saturating(p1, p2);
+imp::option::OptionExt::with_mut_if_saturating(p0, p1, p2);
+crate::imp::option::OptionExt::with_mut_if_saturating(p0, p1, p2);
+crate::imp::option::OptionExt::with_mut_if_saturating(p0, p1, p2);
-----------------
src/imp/option.rs imp::option::OptionExt::add_to
deps:{"imp::option::OptionExt::add_to":{"Self":["imp::option::OptionExt"],"T":["std::marker::Sized","std::ops::AddAssign"],"V":["std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::add_to":{"Self":["std::option::Option"],"T":["std::simd::Simd<T, LANES>","std::time::Duration","std::time::Instant","std::time::SystemTime","std::string::String"],"V":["RUG_ANY"]},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.add_to(p1);
+imp::option::OptionExt::add_to(p0, p1);
+crate::imp::option::OptionExt::add_to(p0, p1);
+crate::imp::option::OptionExt::add_to(p0, p1);
-----------------
src/imp/option.rs imp::option::OptionExt::sub_to
deps:{"imp::option::OptionExt::sub_to":{"Self":["imp::option::OptionExt"],"T":["std::marker::Sized","std::ops::SubAssign"],"V":["std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::sub_to":{"Self":["std::option::Option"],"T":["std::simd::Simd<T, LANES>","std::time::Duration","std::time::Instant","std::time::SystemTime"],"V":["RUG_ANY"]},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.sub_to(p1);
+imp::option::OptionExt::sub_to(p0, p1);
+crate::imp::option::OptionExt::sub_to(p0, p1);
+crate::imp::option::OptionExt::sub_to(p0, p1);
-----------------
src/imp/option.rs imp::option::OptionExt::mul_to
deps:{"imp::option::OptionExt::mul_to":{"Self":["imp::option::OptionExt"],"T":["std::ops::MulAssign","std::marker::Sized"],"V":["std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::mul_to":{"Self":["std::option::Option"],"T":["std::time::Duration","std::simd::Simd<T, LANES>"],"V":["RUG_ANY"]},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.mul_to(p1);
+imp::option::OptionExt::mul_to(p0, p1);
+crate::imp::option::OptionExt::mul_to(p0, p1);
+crate::imp::option::OptionExt::mul_to(p0, p1);
-----------------
src/imp/option.rs imp::option::OptionExt::div_to
deps:{"imp::option::OptionExt::div_to":{"Self":["imp::option::OptionExt"],"T":["std::marker::Sized","std::ops::DivAssign"],"V":["std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::div_to":{"Self":["std::option::Option"],"T":["std::time::Duration","std::simd::Simd<T, LANES>"],"V":["RUG_ANY"]},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.div_to(p1);
+imp::option::OptionExt::div_to(p0, p1);
+crate::imp::option::OptionExt::div_to(p0, p1);
+crate::imp::option::OptionExt::div_to(p0, p1);
-----------------
src/imp/option.rs imp::option::OptionExt::add_to_lossy
deps:{"imp::option::OptionExt::add_to_lossy":{"Self":["imp::option::OptionExt"],"T":["std::ops::AddAssign","std::marker::Sized"],"V":["std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::add_to_lossy":{"Self":["std::option::Option"],"T":["std::simd::Simd<T, LANES>","std::string::String","std::time::Instant","std::time::SystemTime","std::time::Duration"],"V":["RUG_ANY"]},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.add_to_lossy(p1);
+imp::option::OptionExt::add_to_lossy(p0, p1);
+crate::imp::option::OptionExt::add_to_lossy(p0, p1);
+crate::imp::option::OptionExt::add_to_lossy(p0, p1);
-----------------
src/imp/option.rs imp::option::OptionExt::sub_to_lossy
deps:{"imp::option::OptionExt::sub_to_lossy":{"Self":["imp::option::OptionExt"],"T":["std::ops::SubAssign","std::marker::Sized"],"V":["std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::sub_to_lossy":{"Self":["std::option::Option"],"T":["std::time::Instant","std::simd::Simd<T, LANES>","std::time::Duration","std::time::SystemTime"],"V":["RUG_ANY"]},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.sub_to_lossy(p1);
+imp::option::OptionExt::sub_to_lossy(p0, p1);
+crate::imp::option::OptionExt::sub_to_lossy(p0, p1);
+crate::imp::option::OptionExt::sub_to_lossy(p0, p1);
-----------------
src/imp/option.rs imp::option::OptionExt::mul_to_lossy
deps:{"imp::option::OptionExt::mul_to_lossy":{"Self":["imp::option::OptionExt"],"T":["std::ops::MulAssign","std::marker::Sized"],"V":["std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::mul_to_lossy":{"Self":["std::option::Option"],"T":["std::time::Duration","std::simd::Simd<T, LANES>"],"V":["RUG_ANY"]},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.mul_to_lossy(p1);
+imp::option::OptionExt::mul_to_lossy(p0, p1);
+crate::imp::option::OptionExt::mul_to_lossy(p0, p1);
+crate::imp::option::OptionExt::mul_to_lossy(p0, p1);
-----------------
src/imp/option.rs imp::option::OptionExt::div_to_lossy
deps:{"imp::option::OptionExt::div_to_lossy":{"Self":["imp::option::OptionExt"],"T":["std::ops::DivAssign","std::marker::Sized"],"V":["std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::div_to_lossy":{"Self":["std::option::Option"],"T":["std::simd::Simd<T, LANES>","std::time::Duration"],"V":["RUG_ANY"]},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.div_to_lossy(p1);
+imp::option::OptionExt::div_to_lossy(p0, p1);
+crate::imp::option::OptionExt::div_to_lossy(p0, p1);
+crate::imp::option::OptionExt::div_to_lossy(p0, p1);
-----------------
src/imp/option.rs imp::option::OptionExt::add_to_if
deps:{"imp::option::OptionExt::add_to_if":{"Self":["imp::option::OptionExt"],"T":["std::marker::Sized","std::ops::AddAssign"],"V":["std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::add_to_if":{"Self":["std::option::Option"],"T":["std::time::SystemTime","std::time::Duration","std::time::Instant","std::string::String","std::simd::Simd<T, LANES>"],"V":["RUG_ANY"]},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.add_to_if(p1);
+imp::option::OptionExt::add_to_if(p0, p1);
+crate::imp::option::OptionExt::add_to_if(p0, p1);
+crate::imp::option::OptionExt::add_to_if(p0, p1);
-----------------
src/imp/option.rs imp::option::OptionExt::sub_to_if
deps:{"imp::option::OptionExt::sub_to_if":{"Self":["imp::option::OptionExt"],"T":["std::ops::SubAssign","std::marker::Sized"],"V":["std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::sub_to_if":{"Self":["std::option::Option"],"T":["std::time::SystemTime","std::time::Duration","std::simd::Simd<T, LANES>","std::time::Instant"],"V":["RUG_ANY"]},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.sub_to_if(p1);
+imp::option::OptionExt::sub_to_if(p0, p1);
+crate::imp::option::OptionExt::sub_to_if(p0, p1);
+crate::imp::option::OptionExt::sub_to_if(p0, p1);
-----------------
src/imp/option.rs imp::option::OptionExt::mul_to_if
deps:{"imp::option::OptionExt::mul_to_if":{"Self":["imp::option::OptionExt"],"T":["std::ops::MulAssign","std::marker::Sized"],"V":["std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::mul_to_if":{"Self":["std::option::Option"],"T":["std::time::Duration","std::simd::Simd<T, LANES>"],"V":["RUG_ANY"]},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.mul_to_if(p1);
+imp::option::OptionExt::mul_to_if(p0, p1);
+crate::imp::option::OptionExt::mul_to_if(p0, p1);
+crate::imp::option::OptionExt::mul_to_if(p0, p1);
-----------------
src/imp/option.rs imp::option::OptionExt::div_to_if
deps:{"imp::option::OptionExt::div_to_if":{"Self":["imp::option::OptionExt"],"T":["std::marker::Sized","std::ops::DivAssign"],"V":["std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized"]}}
candidates:{"imp::option::OptionExt::div_to_if":{"Self":["std::option::Option"],"T":["std::simd::Simd<T, LANES>","std::time::Duration"],"V":["RUG_ANY"]},"std::option::Option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.div_to_if(p1);
+imp::option::OptionExt::div_to_if(p0, p1);
+crate::imp::option::OptionExt::div_to_if(p0, p1);
+crate::imp::option::OptionExt::div_to_if(p0, p1);
-----------------
src/imp/tuple.rs imp::tuple::AsTuple::as_tuple
deps:{"imp::tuple::AsTuple::as_tuple":{"Self":["imp::tuple::AsTuple"]}}
candidates:{"imp::tuple::AsTuple::as_tuple":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.as_tuple();
+imp::tuple::AsTuple::as_tuple(p0);
+crate::imp::tuple::AsTuple::as_tuple(p0);
+crate::imp::tuple::AsTuple::as_tuple(p0);
-----------------
src/imp/tuple.rs imp::tuple::AsArray::as_array
deps:{"imp::tuple::AsArray::as_array":{"Self":["imp::tuple::AsArray"]}}
candidates:{"imp::tuple::AsArray::as_array":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.as_array();
+imp::tuple::AsArray::as_array(p0);
+crate::imp::tuple::AsArray::as_array(p0);
+crate::imp::tuple::AsArray::as_array(p0);
-----------------
src/imp/tuple.rs imp::tuple::TupleFns::avg
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialOrd","std::cmp::Ord","std::cmp::PartialEq","std::hash::Hash","std::fmt::Debug"]},"imp::tuple::TupleFns::avg":{"Self":["imp::tuple::TupleFns"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::convert::From","std::marker::Sized","std::ops::DivAssign","std::iter::Sum"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["<*mut T as std::fmt::Debug>","arc_slice::ArcSlice"]},"imp::tuple::TupleFns::avg":{"Self":[],"T":["arc_slice::ArcSlice","macros::Test2","macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for &mut T>"],"U":["macros::Test2","arc_slice::ArcSlice","macros::Test"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.avg();
+imp::tuple::TupleFns::avg(p0);
+crate::imp::tuple::TupleFns::avg(p0);
+crate::imp::tuple::TupleFns::avg(p0);
-----------------
src/imp/numext.rs imp::numext::DivOrNop::div_or_nop
deps:{"imp::numext::DivOrNop::div_or_nop":{"Self":["std::marker::Copy","imp::numext::DivOrNop","std::marker::Sized"]}}
candidates:{"imp::numext::DivOrNop::div_or_nop":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.div_or_nop(p1);
+imp::numext::DivOrNop::div_or_nop(p0, p1);
+crate::imp::numext::DivOrNop::div_or_nop(p0, p1);
+crate::imp::numext::DivOrNop::div_or_nop(p0, p1);
-----------------
src/refc/mod.rs refc::RefClonable::refc
deps:{"<&A as std::alloc::Allocator>":{},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::PartialOrd","std::hash::Hash","std::clone::Clone","std::cmp::Ord","std::cmp::Eq"]},"refc::RefClonable::refc":{"Self":["refc::RefClonable"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"refc::RefClonable::refc":{"Self":["arc_slice::ArcSlice","std::rc::Rc","std::sync::Arc","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.refc();
+refc::RefClonable::refc(p0);
+crate::refc::RefClonable::refc(p0);
+crate::refc::RefClonable::refc(p0);
-----------------
src/scoped/mod.rs scoped::ScopedMut::access
deps:{"<&A as std::alloc::Allocator>":{},"<T as std::borrow::ToOwned>":{"T":["std::clone::Clone","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialOrd","std::cmp::Eq","std::clone::Clone","std::cmp::Ord","std::cmp::PartialEq","std::hash::Hash"]},"scoped::ScopedMut::access":{"R":["std::marker::Sized"],"Self":["scoped::ScopedMut"],"impl FnOnce(&Self::T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<T as std::borrow::ToOwned>":{"T":["macros::Test","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","arc_slice::ArcSlice"]},"scoped::ScopedMut::access":{"R":["RUG_ANY"],"Self":["std::boxed::Box","std::borrow::Cow","scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>","std::cell::RefCell","std::sync::RwLock","std::rc::Rc","std::sync::Arc"],"impl FnOnce(&Self::T) -> R":["std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","std::panic::AssertUnwindSafe<F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::path::Path","<T as std::borrow::ToOwned>","std::ffi::OsStr","std::ffi::CStr"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&Self::T) -> R
+p0.access(p1);
+scoped::ScopedMut::access(p0, p1);
+crate::scoped::ScopedMut::access(p0, p1);
+crate::scoped::ScopedMut::access(p0, p1);
-----------------
src/scoped/mod.rs scoped::ScopedMut::access_mut
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"arc_slice::ArcSlice":{"T":["std::cmp::Ord","std::hash::Hash","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::PartialEq"]},"scoped::ScopedMut::access_mut":{"R":["std::marker::Sized"],"Self":["scoped::ScopedMut"],"impl FnOnce(&mut Self::T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<T as std::borrow::ToOwned>":{"T":["macros::Test2","macros::Test","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>"]},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","arc_slice::ArcSlice"]},"scoped::ScopedMut::access_mut":{"R":["RUG_ANY"],"Self":["std::sync::RwLock","scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>","std::borrow::Cow","std::boxed::Box","std::cell::RefCell","std::sync::Arc","std::rc::Rc"],"impl FnOnce(&mut Self::T) -> R":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","std::panic::AssertUnwindSafe<F>","core::str::LinesAnyMap"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["<T as std::borrow::ToOwned>","std::path::Path","std::ffi::CStr","std::ffi::OsStr"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut Self::T) -> R
+p0.access_mut(p1);
+scoped::ScopedMut::access_mut(p0, p1);
+crate::scoped::ScopedMut::access_mut(p0, p1);
+crate::scoped::ScopedMut::access_mut(p0, p1);
-----------------
src/scoped/mod.rs scoped::Interior::interior_access
deps:{"<&A as std::alloc::Allocator>":{},"scoped::Interior::interior_access":{"R":["std::marker::Sized"],"Self":["scoped::Interior"],"impl FnOnce(&Self::T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::Interior::interior_access":{"R":["RUG_ANY"],"Self":["std::rc::Rc","std::cell::RefCell","scoped::imp::interior::<impl scoped::Interior for &'a C>","std::sync::Arc","std::sync::RwLock","std::boxed::Box"],"impl FnOnce(&Self::T) -> R":["core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::panic::AssertUnwindSafe<F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace"]},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&Self::T) -> R
+p0.interior_access(p1);
+scoped::Interior::interior_access(p0, p1);
+crate::scoped::Interior::interior_access(p0, p1);
+crate::scoped::Interior::interior_access(p0, p1);
-----------------
src/scoped/mod.rs scoped::Interior::interior_access_mut
deps:{"<&A as std::alloc::Allocator>":{},"scoped::Interior::interior_access_mut":{"R":["std::marker::Sized"],"Self":["scoped::Interior"],"impl FnOnce(&mut Self::T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::Interior::interior_access_mut":{"R":["RUG_ANY"],"Self":["scoped::imp::interior::<impl scoped::Interior for &'a C>","std::rc::Rc","std::cell::RefCell","std::sync::RwLock","std::boxed::Box","std::sync::Arc"],"impl FnOnce(&mut Self::T) -> R":["core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::panic::AssertUnwindSafe<F>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::IsWhitespace","core::str::BytesIsNotEmpty"]},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut Self::T) -> R
+p0.interior_access_mut(p1);
+scoped::Interior::interior_access_mut(p0, p1);
+crate::scoped::Interior::interior_access_mut(p0, p1);
+crate::scoped::Interior::interior_access_mut(p0, p1);
-----------------
src/not_empty.rs not_empty::NotEmpty::_is_empty
deps:{"<&A as std::alloc::Allocator>":{},"<&mut std::collections::HashMap<K, V> as not_empty::NotEmpty>":{},"<&mut std::collections::HashSet<T> as not_empty::NotEmpty>":{},"<&mut std::vec::Vec<T> as not_empty::NotEmpty>":{},"<&std::collections::HashMap<K, V> as not_empty::NotEmpty>":{},"<&std::collections::HashSet<T> as not_empty::NotEmpty>":{},"<&std::vec::Vec<T> as not_empty::NotEmpty>":{},"not_empty::NotEmpty::_is_empty":{"Self":["not_empty::NotEmpty","std::marker::Sized"]},"std::collections::HashMap":{"K":["std::marker::Sized"],"S":["std::marker::Sized"],"V":["std::marker::Sized"]},"std::collections::HashSet":{"S":["std::marker::Sized"],"T":["std::marker::Sized"]},"std::vec::Vec":{"A":["std::alloc::Allocator","std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"<&A as std::alloc::Allocator>":{},"<&mut std::collections::HashMap<K, V> as not_empty::NotEmpty>":{},"<&mut std::collections::HashSet<T> as not_empty::NotEmpty>":{},"<&mut std::vec::Vec<T> as not_empty::NotEmpty>":{},"<&std::collections::HashMap<K, V> as not_empty::NotEmpty>":{},"<&std::collections::HashSet<T> as not_empty::NotEmpty>":{},"<&std::vec::Vec<T> as not_empty::NotEmpty>":{},"not_empty::NotEmpty::_is_empty":{"Self":["std::collections::HashMap","std::vec::Vec","std::string::String","<&mut std::vec::Vec<T> as not_empty::NotEmpty>","<&std::collections::HashMap<K, V> as not_empty::NotEmpty>","std::collections::HashSet"]},"std::collections::HashMap":{"K":["RUG_ANY"],"S":["std::collections::hash_map::RandomState","RUG_ANY"],"V":["RUG_ANY"]},"std::collections::HashSet":{"S":["std::collections::hash_map::RandomState","RUG_ANY"],"T":["RUG_ANY"]},"std::vec::Vec":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0._is_empty();
+not_empty::NotEmpty::_is_empty(p0);
+crate::not_empty::NotEmpty::_is_empty(p0);
+crate::not_empty::NotEmpty::_is_empty(p0);
-----------------
src/not_empty.rs not_empty::NotEmpty::not_empty
deps:{"<&A as std::alloc::Allocator>":{},"<&mut std::collections::HashMap<K, V> as not_empty::NotEmpty>":{},"<&mut std::collections::HashSet<T> as not_empty::NotEmpty>":{},"<&mut std::vec::Vec<T> as not_empty::NotEmpty>":{},"<&std::collections::HashMap<K, V> as not_empty::NotEmpty>":{},"<&std::collections::HashSet<T> as not_empty::NotEmpty>":{},"<&std::vec::Vec<T> as not_empty::NotEmpty>":{},"not_empty::NotEmpty::not_empty":{"Self":["not_empty::NotEmpty","std::marker::Sized"]},"std::collections::HashMap":{"K":["std::marker::Sized"],"S":["std::marker::Sized"],"V":["std::marker::Sized"]},"std::collections::HashSet":{"S":["std::marker::Sized"],"T":["std::marker::Sized"]},"std::vec::Vec":{"A":["std::marker::Sized","std::alloc::Allocator"],"T":["std::marker::Sized"]}}
candidates:{"<&A as std::alloc::Allocator>":{},"<&mut std::collections::HashMap<K, V> as not_empty::NotEmpty>":{},"<&mut std::collections::HashSet<T> as not_empty::NotEmpty>":{},"<&mut std::vec::Vec<T> as not_empty::NotEmpty>":{},"<&std::collections::HashMap<K, V> as not_empty::NotEmpty>":{},"<&std::collections::HashSet<T> as not_empty::NotEmpty>":{},"<&std::vec::Vec<T> as not_empty::NotEmpty>":{},"not_empty::NotEmpty::not_empty":{"Self":["std::string::String","std::collections::HashSet","std::collections::HashMap","<&std::collections::HashSet<T> as not_empty::NotEmpty>","std::vec::Vec"]},"std::collections::HashMap":{"K":["RUG_ANY"],"S":["std::collections::hash_map::RandomState","RUG_ANY"],"V":["RUG_ANY"]},"std::collections::HashSet":{"S":["std::collections::hash_map::RandomState","RUG_ANY"],"T":["RUG_ANY"]},"std::vec::Vec":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.not_empty();
+not_empty::NotEmpty::not_empty(p0);
+crate::not_empty::NotEmpty::not_empty(p0);
+crate::not_empty::NotEmpty::not_empty(p0);
-----------------
src/from_into.rs from_into::FromInto::qfrom
deps:{"<T as from_into::FromInto<U>>":{"T":["std::convert::Into","std::convert::From","std::marker::Sized"]},"from_into::FromInto::qfrom":{"Self":["from_into::FromInto"],"T":["std::marker::Sized"]}}
candidates:{"<T as from_into::FromInto<U>>":{"T":["i8","u8"]},"from_into::FromInto::qfrom":{"Self":["<T as from_into::FromInto<U>>"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+from_into::FromInto::qfrom(p0);
+crate::from_into::FromInto::qfrom(p0);
+crate::from_into::FromInto::qfrom(p0);
-----------------
src/from_into.rs from_into::FromInto::qinto
deps:{"<T as from_into::FromInto<U>>":{"T":["std::convert::Into","std::marker::Sized","std::convert::From"]},"from_into::FromInto::qinto":{"Self":["from_into::FromInto"],"T":["std::marker::Sized"]}}
candidates:{"<T as from_into::FromInto<U>>":{"T":["u8","i8"]},"from_into::FromInto::qinto":{"Self":["<T as from_into::FromInto<U>>"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.qinto();
+from_into::FromInto::qinto(p0);
+crate::from_into::FromInto::qinto(p0);
+crate::from_into::FromInto::qinto(p0);
-----------------
src/imp/vec.rs <std::vec::Vec<T> as imp::vec::VecExt<T>>::push_option
deps:{"<std::vec::Vec<T> as imp::vec::VecExt<T>>::push_option":{"T":["std::marker::Sized"]}}
candidates:{"<std::vec::Vec<T> as imp::vec::VecExt<T>>::push_option":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<T>
+p0.push_option(p1);
+<std::vec::Vec<T> as imp::vec::VecExt<T>>::push_option(p0, p1);
+crate::<std::vec::Vec<T> as imp::vec::VecExt<T>>::push_option(p0, p1);
+<std::vec::Vec<T>>::push_option(p0, p1);
-----------------
src/imp/vec.rs <std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to_with
deps:{"<std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to_with":{"F":["std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to_with":{"F":["core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr"],"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<T>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+p0.grow_to_with(p1, p2);
+<std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to_with(p0, p1, p2);
+crate::<std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to_with(p0, p1, p2);
+<std::vec::Vec<T>>::grow_to_with(p0, p1, p2);
-----------------
src/imp/vec.rs <std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to
deps:{"<std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to":{"T":["std::clone::Clone","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::clone::Clone","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::Ord","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test2","macros::Test","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["std::hash::impls::<impl std::hash::Hash for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<T>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.grow_to(p1, p2);
+<std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to(p0, p1, p2);
+crate::<std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to(p0, p1, p2);
+<std::vec::Vec<T>>::grow_to(p0, p1, p2);
-----------------
src/imp/vec.rs <std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to_default
deps:{"<*const T as std::fmt::Debug>":{},"<std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to_default":{"T":["std::default::Default","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::hash::Hash","std::cmp::PartialOrd","std::cmp::Ord","std::clone::Clone","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to_default":{"T":["arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","<*const T as std::fmt::Debug>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<T>
let mut p1 = 0usize; // None+usize
+p0.grow_to_default(p1);
+<std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to_default(p0, p1);
+crate::<std::vec::Vec<T> as imp::vec::VecExt<T>>::grow_to_default(p0, p1);
+<std::vec::Vec<T>>::grow_to_default(p0, p1);
-----------------
src/imp/vec.rs <std::vec::Vec<T> as imp::vec::VecExt<T>>::insert_slice_copy
deps:{"<std::vec::Vec<T> as imp::vec::VecExt<T>>::insert_slice_copy":{"T":["std::marker::Copy","std::marker::Sized"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
candidates:{"<std::vec::Vec<T> as imp::vec::VecExt<T>>::insert_slice_copy":{"T":["i8","bool","u8","char","std::marker::copy_impls::<impl std::marker::Copy for *const T>","i64","std::marker::copy_impls::<impl std::marker::Copy for &T>","u32","i32","u16","u64","i16","usize"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<T>
let mut p1 = 0usize; // None+usize
let mut p2 = & MaybeUninit::uninit().assume_init(); // [T]
+p0.insert_slice_copy(p1, p2);
+<std::vec::Vec<T> as imp::vec::VecExt<T>>::insert_slice_copy(p0, p1, p2);
+crate::<std::vec::Vec<T> as imp::vec::VecExt<T>>::insert_slice_copy(p0, p1, p2);
+<std::vec::Vec<T>>::insert_slice_copy(p0, p1, p2);
-----------------
src/imp/vec.rs <std::vec::Vec<T> as imp::vec::VecExt<T>>::insert_slice_clone
deps:{"<*mut T as std::fmt::Debug>":{},"<std::vec::Vec<T> as imp::vec::VecExt<T>>::insert_slice_clone":{"T":["std::clone::Clone","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::Ord","std::clone::Clone","std::cmp::Eq","std::cmp::PartialOrd","std::hash::Hash","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<std::vec::Vec<T> as imp::vec::VecExt<T>>::insert_slice_clone":{"T":["arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<T>
let mut p1 = 0usize; // None+usize
let mut p2 = & MaybeUninit::uninit().assume_init(); // [T]
+p0.insert_slice_clone(p1, p2);
+<std::vec::Vec<T> as imp::vec::VecExt<T>>::insert_slice_clone(p0, p1, p2);
+crate::<std::vec::Vec<T> as imp::vec::VecExt<T>>::insert_slice_clone(p0, p1, p2);
+<std::vec::Vec<T>>::insert_slice_clone(p0, p1, p2);
-----------------
src/imp/vec.rs <std::vec::Vec<T> as imp::vec::VecExt<T>>::extend_from_slice_copy
deps:{"<std::vec::Vec<T> as imp::vec::VecExt<T>>::extend_from_slice_copy":{"T":["std::marker::Copy","std::marker::Sized"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
candidates:{"<std::vec::Vec<T> as imp::vec::VecExt<T>>::extend_from_slice_copy":{"T":["i16","bool","usize","i8","u8","std::marker::copy_impls::<impl std::marker::Copy for *mut T>","char","i64","std::marker::copy_impls::<impl std::marker::Copy for &T>","i32","u32","u16","u64"]},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [T]
+p0.extend_from_slice_copy(p1);
+<std::vec::Vec<T> as imp::vec::VecExt<T>>::extend_from_slice_copy(p0, p1);
+crate::<std::vec::Vec<T> as imp::vec::VecExt<T>>::extend_from_slice_copy(p0, p1);
+<std::vec::Vec<T>>::extend_from_slice_copy(p0, p1);
-----------------
src/imp/result.rs <std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::unwrap_nodebug
deps:{"<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::unwrap_nodebug":{"E":["std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::unwrap_nodebug":{"E":["RUG_ANY"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::result::Result<T, E>
+p0.unwrap_nodebug();
+<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::unwrap_nodebug(p0);
+crate::<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::unwrap_nodebug(p0);
+<std::result::Result<T, E>>::unwrap_nodebug(p0);
-----------------
src/imp/result.rs <std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::expect_nodebug
deps:{"<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::expect_nodebug":{"E":["std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::expect_nodebug":{"E":["RUG_ANY"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::result::Result<T, E>
let mut p1 = "sample"; // None+&str
+p0.expect_nodebug(&p1);
+<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::expect_nodebug(p0, &p1);
+crate::<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::expect_nodebug(p0, &p1);
+<std::result::Result<T, E>>::expect_nodebug(p0, &p1);
-----------------
src/imp/result.rs <std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::unwrap_err_nodebug
deps:{"<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::unwrap_err_nodebug":{"E":["std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::unwrap_err_nodebug":{"E":["RUG_ANY"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::result::Result<T, E>
+p0.unwrap_err_nodebug();
+<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::unwrap_err_nodebug(p0);
+crate::<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::unwrap_err_nodebug(p0);
+<std::result::Result<T, E>>::unwrap_err_nodebug(p0);
-----------------
src/imp/result.rs <std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::expect_err_nodebug
deps:{"<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::expect_err_nodebug":{"E":["std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::expect_err_nodebug":{"E":["RUG_ANY"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::result::Result<T, E>
let mut p1 = "sample"; // None+&str
+p0.expect_err_nodebug(&p1);
+<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::expect_err_nodebug(p0, &p1);
+crate::<std::result::Result<T, E> as imp::result::ResultNonDebugUnwrap<T, E>>::expect_err_nodebug(p0, &p1);
+<std::result::Result<T, E>>::expect_err_nodebug(p0, &p1);
-----------------
src/imp/boolext.rs <bool as imp::boolext::BoolExtOption>::option
deps:{}
candidates:{}
let mut p0 = & true; // None+bool
+p0.option();
+<bool as imp::boolext::BoolExtOption>::option(p0);
+crate::<bool as imp::boolext::BoolExtOption>::option(p0);
+<bool>::option(p0);
-----------------
src/imp/boolext.rs <bool as imp::boolext::BoolExtOption>::result
deps:{}
candidates:{}
let mut p0 = & true; // None+bool
+p0.result();
+<bool as imp::boolext::BoolExtOption>::result(p0);
+crate::<bool as imp::boolext::BoolExtOption>::result(p0);
+<bool>::result(p0);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::with
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::with":{"R":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::with":{"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::panic::AssertUnwindSafe<F>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.with(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::with(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::with(p0, p1);
+<std::option::Option<T>>::with(p0, p1);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::with_mut
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::with_mut":{"R":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::with_mut":{"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.with_mut(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::with_mut(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::with_mut(p0, p1);
+<std::option::Option<T>>::with_mut(p0, p1);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::with_if
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::with_if":{"R":["std::marker::Sized"],"T":["std::marker::Sized"],"U":["std::marker::Sized"],"impl FnOnce(&T, &U) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::with_if":{"R":["RUG_ANY"],"T":["RUG_ANY"],"U":["RUG_ANY"],"impl FnOnce(&T, &U) -> R":["core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::CharEscapeDebugContinue"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::option::Option<U>
let mut p2 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T, &U) -> R
+p0.with_if(p1, p2);
+<std::option::Option<T> as imp::option::OptionExt<T>>::with_if(p0, p1, p2);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::with_if(p0, p1, p2);
+<std::option::Option<T>>::with_if(p0, p1, p2);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::with_mut_if
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::with_mut_if":{"R":["std::marker::Sized"],"T":["std::marker::Sized"],"U":["std::marker::Sized"],"impl FnOnce(&mut T, &U) -> R":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::with_mut_if":{"R":["RUG_ANY"],"T":["RUG_ANY"],"U":["RUG_ANY"],"impl FnOnce(&mut T, &U) -> R":["core::str::IsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::panic::AssertUnwindSafe<F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::option::Option<U>
let mut p2 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T, &U) -> R
+p0.with_mut_if(p1, p2);
+<std::option::Option<T> as imp::option::OptionExt<T>>::with_mut_if(p0, p1, p2);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::with_mut_if(p0, p1, p2);
+<std::option::Option<T>>::with_mut_if(p0, p1, p2);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::with_mut_if_saturating
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::with_mut_if_saturating":{"R":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&mut T, &T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::with_mut_if_saturating":{"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&mut T, &T) -> R":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::panic::AssertUnwindSafe<F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p2 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T, &T) -> R
+p0.with_mut_if_saturating(p1, p2);
+<std::option::Option<T> as imp::option::OptionExt<T>>::with_mut_if_saturating(p0, p1, p2);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::with_mut_if_saturating(p0, p1, p2);
+<std::option::Option<T>>::with_mut_if_saturating(p0, p1, p2);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::add_to
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::add_to":{"T":["std::marker::Sized","std::ops::AddAssign"],"V":["std::marker::Sized"]}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::add_to":{"T":["std::simd::Simd<T, LANES>","std::time::SystemTime","std::time::Duration","std::time::Instant","std::string::String"],"V":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.add_to(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::add_to(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::add_to(p0, p1);
+<std::option::Option<T>>::add_to(p0, p1);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::sub_to
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::sub_to":{"T":["std::ops::SubAssign","std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::sub_to":{"T":["std::time::Duration","std::simd::Simd<T, LANES>","std::time::SystemTime","std::time::Instant"],"V":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.sub_to(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::sub_to(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::sub_to(p0, p1);
+<std::option::Option<T>>::sub_to(p0, p1);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::mul_to
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::mul_to":{"T":["std::ops::MulAssign","std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::mul_to":{"T":["std::time::Duration","std::simd::Simd<T, LANES>"],"V":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.mul_to(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::mul_to(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::mul_to(p0, p1);
+<std::option::Option<T>>::mul_to(p0, p1);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::div_to
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::div_to":{"T":["std::marker::Sized","std::ops::DivAssign"],"V":["std::marker::Sized"]}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::div_to":{"T":["std::simd::Simd<T, LANES>","std::time::Duration"],"V":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.div_to(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::div_to(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::div_to(p0, p1);
+<std::option::Option<T>>::div_to(p0, p1);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::add_to_lossy
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::add_to_lossy":{"T":["std::ops::AddAssign","std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::add_to_lossy":{"T":["std::string::String","std::time::Instant","std::simd::Simd<T, LANES>","std::time::Duration","std::time::SystemTime"],"V":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.add_to_lossy(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::add_to_lossy(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::add_to_lossy(p0, p1);
+<std::option::Option<T>>::add_to_lossy(p0, p1);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::sub_to_lossy
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::sub_to_lossy":{"T":["std::ops::SubAssign","std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::sub_to_lossy":{"T":["std::time::SystemTime","std::time::Duration","std::simd::Simd<T, LANES>","std::time::Instant"],"V":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.sub_to_lossy(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::sub_to_lossy(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::sub_to_lossy(p0, p1);
+<std::option::Option<T>>::sub_to_lossy(p0, p1);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::mul_to_lossy
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::mul_to_lossy":{"T":["std::marker::Sized","std::ops::MulAssign"],"V":["std::marker::Sized"]}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::mul_to_lossy":{"T":["std::time::Duration","std::simd::Simd<T, LANES>"],"V":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.mul_to_lossy(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::mul_to_lossy(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::mul_to_lossy(p0, p1);
+<std::option::Option<T>>::mul_to_lossy(p0, p1);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::div_to_lossy
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::div_to_lossy":{"T":["std::marker::Sized","std::ops::DivAssign"],"V":["std::marker::Sized"]}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::div_to_lossy":{"T":["std::time::Duration","std::simd::Simd<T, LANES>"],"V":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.div_to_lossy(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::div_to_lossy(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::div_to_lossy(p0, p1);
+<std::option::Option<T>>::div_to_lossy(p0, p1);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::add_to_if
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::add_to_if":{"T":["std::marker::Sized","std::ops::AddAssign"],"V":["std::marker::Sized"]}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::add_to_if":{"T":["std::simd::Simd<T, LANES>","std::time::Instant","std::time::Duration","std::string::String","std::time::SystemTime"],"V":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.add_to_if(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::add_to_if(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::add_to_if(p0, p1);
+<std::option::Option<T>>::add_to_if(p0, p1);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::sub_to_if
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::sub_to_if":{"T":["std::ops::SubAssign","std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::sub_to_if":{"T":["std::simd::Simd<T, LANES>","std::time::Duration","std::time::Instant","std::time::SystemTime"],"V":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.sub_to_if(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::sub_to_if(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::sub_to_if(p0, p1);
+<std::option::Option<T>>::sub_to_if(p0, p1);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::mul_to_if
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::mul_to_if":{"T":["std::ops::MulAssign","std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::mul_to_if":{"T":["std::simd::Simd<T, LANES>","std::time::Duration"],"V":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.mul_to_if(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::mul_to_if(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::mul_to_if(p0, p1);
+<std::option::Option<T>>::mul_to_if(p0, p1);
-----------------
src/imp/option.rs <std::option::Option<T> as imp::option::OptionExt<T>>::div_to_if
deps:{"<std::option::Option<T> as imp::option::OptionExt<T>>::div_to_if":{"T":["std::marker::Sized","std::ops::DivAssign"],"V":["std::marker::Sized"]}}
candidates:{"<std::option::Option<T> as imp::option::OptionExt<T>>::div_to_if":{"T":["std::simd::Simd<T, LANES>","std::time::Duration"],"V":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<V>
+p0.div_to_if(p1);
+<std::option::Option<T> as imp::option::OptionExt<T>>::div_to_if(p0, p1);
+crate::<std::option::Option<T> as imp::option::OptionExt<T>>::div_to_if(p0, p1);
+<std::option::Option<T>>::div_to_if(p0, p1);
-----------------
src/imp/tuple.rs <[T; 32] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; 32] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; 32] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; 32]
+p0.as_tuple();
+<[T; 32] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; 32] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; 32]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; 32] as imp::tuple::TupleFns<T>>::avg
deps:{"<*const T as std::fmt::Debug>":{},"<[T; 32] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::iter::Sum","std::marker::Sized","std::ops::DivAssign","std::convert::From"]},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Ord","std::hash::Hash","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialOrd"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<[T; 32] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test","macros::Test2"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","<*const T as std::fmt::Debug>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; 32]
+p0.avg();
+<[T; 32] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; 32] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; 32]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::iter::Sum","std::ops::DivAssign","std::marker::Sized","std::convert::From"]},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::Ord","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test2","macros::Test","arc_slice::ArcSlice"],"T":["arc_slice::ArcSlice","macros::Test","macros::Test2","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *const T>"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","<*mut T as std::fmt::Debug>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::convert::From","std::ops::DivAssign","std::iter::Sum","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::cmp::Ord","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::PartialOrd","std::hash::Hash","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test2"],"U":["macros::Test","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::convert::From","std::marker::Sized","std::ops::DivAssign","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialOrd","std::cmp::Ord","std::cmp::PartialEq","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test","arc_slice::ArcSlice","macros::Test2"],"T":["macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","macros::Test"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::ops::DivAssign","std::marker::Sized","std::convert::From","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialOrd","std::cmp::Ord","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for &mut T>","arc_slice::ArcSlice","macros::Test2","macros::Test"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::marker::Sized","std::ops::DivAssign","std::iter::Sum","std::convert::From"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Ord","std::cmp::PartialOrd","std::cmp::Eq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["macros::Test","std::clone::impls::<impl std::clone::Clone for &T>","arc_slice::ArcSlice","macros::Test2"],"T":["arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::Ord for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::convert::From","std::ops::DivAssign","std::iter::Sum","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::hash::Hash","std::cmp::Ord","std::marker::Sized","std::cmp::PartialOrd"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::Ord for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::iter::Sum","std::convert::From","std::marker::Sized","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::cmp::Ord","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::hash::Hash","std::cmp::PartialOrd","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice","macros::Test2","macros::Test"],"T":["macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice"],"U":["macros::Test2","macros::Test","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::hash::impls::<impl std::hash::Hash for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::ops::DivAssign","std::marker::Sized","std::convert::From","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::hash::Hash","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialOrd","std::cmp::Ord"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for &T>","arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test"],"U":["macros::Test","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::marker::Sized","std::iter::Sum","std::ops::DivAssign","std::convert::From"]},"arc_slice::ArcSlice":{"T":["std::clone::Clone","std::cmp::PartialOrd","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Sized","std::cmp::Ord"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test2","macros::Test","arc_slice::ArcSlice"],"T":["arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2","std::clone::impls::<impl std::clone::Clone for &T>"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::hash::impls::<impl std::hash::Hash for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<*mut T as std::fmt::Debug>":{},"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::marker::Sized","std::convert::From","std::ops::DivAssign","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::cmp::Eq","std::hash::Hash","std::cmp::PartialEq","std::cmp::Ord","std::marker::Sized","std::clone::Clone","std::cmp::PartialOrd"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice","macros::Test"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["<*mut T as std::fmt::Debug>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::ops::DivAssign","std::marker::Sized","std::convert::From","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::hash::Hash","std::cmp::PartialEq","std::cmp::Ord","std::clone::Clone","std::fmt::Debug","std::cmp::PartialOrd","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test","macros::Test2"],"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::marker::Sized","std::convert::From","std::iter::Sum","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::cmp::Ord","std::cmp::PartialEq","std::hash::Hash","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice","macros::Test2","macros::Test"],"U":["macros::Test","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::ops::DivAssign","std::convert::From","std::marker::Sized","std::iter::Sum"]},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::cmp::Ord","std::hash::Hash","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::PartialOrd"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["macros::Test2","std::clone::impls::<impl std::clone::Clone for &mut T>","arc_slice::ArcSlice","macros::Test"],"T":["std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test","arc_slice::ArcSlice","macros::Test2"],"U":["macros::Test2","macros::Test","arc_slice::ArcSlice"]},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["<*mut T as std::fmt::Debug>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::marker::Sized","std::iter::Sum","std::convert::From","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialEq","std::marker::Sized","std::hash::Hash","std::cmp::PartialOrd","std::cmp::Eq","std::fmt::Debug","std::cmp::Ord","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test","macros::Test2","arc_slice::ArcSlice"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::convert::From","std::marker::Sized","std::iter::Sum","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::cmp::Ord","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::hash::Hash","std::cmp::PartialOrd","std::cmp::PartialEq","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["macros::Test2","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test"],"T":["macros::Test2","macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::marker::Sized","std::iter::Sum","std::convert::From","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Ord","std::hash::Hash","std::cmp::PartialEq","std::cmp::PartialOrd"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2"],"U":["macros::Test2","arc_slice::ArcSlice","macros::Test"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::marker::Sized","std::iter::Sum","std::ops::DivAssign","std::convert::From"]},"arc_slice::ArcSlice":{"T":["std::clone::Clone","std::cmp::PartialOrd","std::cmp::Ord","std::marker::Sized","std::hash::Hash","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test2"],"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2"],"U":["macros::Test2","macros::Test","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<*const T as std::fmt::Debug>":{},"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::marker::Sized","std::convert::From","std::iter::Sum","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialEq","std::cmp::PartialOrd","std::marker::Sized","std::cmp::Ord","std::clone::Clone","std::cmp::Eq","std::hash::Hash","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["macros::Test2","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","<*const T as std::fmt::Debug>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::iter::Sum","std::ops::DivAssign","std::convert::From","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::cmp::Ord","std::cmp::PartialOrd","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2","arc_slice::ArcSlice"],"T":["macros::Test2","macros::Test","std::clone::impls::<impl std::clone::Clone for &T>","arc_slice::ArcSlice"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::ops::DivAssign","std::marker::Sized","std::convert::From","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::cmp::Ord","std::hash::Hash","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::PartialOrd","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test2","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>"],"U":["macros::Test","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::hash::impls::<impl std::hash::Hash for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::iter::Sum","std::convert::From","std::ops::DivAssign","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::Ord","std::cmp::PartialEq","std::cmp::Eq","std::cmp::PartialOrd","std::hash::Hash","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["macros::Test2","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test"],"T":["macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::convert::From","std::iter::Sum","std::ops::DivAssign","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::cmp::Eq","std::cmp::Ord","std::hash::Hash","std::cmp::PartialOrd","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["macros::Test","macros::Test2","std::clone::impls::<impl std::clone::Clone for &T>","arc_slice::ArcSlice"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["std::hash::impls::<impl std::hash::Hash for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::ops::DivAssign","std::iter::Sum","std::convert::From","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::hash::Hash","std::cmp::Eq","std::cmp::Ord","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["macros::Test2","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test"],"T":["macros::Test2","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *mut T>"],"U":["macros::Test2","arc_slice::ArcSlice","macros::Test"]},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::hash::impls::<impl std::hash::Hash for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::convert::From","std::marker::Sized","std::iter::Sum","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::cmp::PartialOrd","std::hash::Hash","std::cmp::Ord","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::Ord for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::convert::From","std::iter::Sum","std::marker::Sized","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::PartialOrd","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test","macros::Test2"],"T":["macros::Test2","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>"],"U":["arc_slice::ArcSlice","macros::Test","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::marker::Sized","std::iter::Sum","std::convert::From","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::cmp::PartialOrd","std::clone::Clone","std::cmp::Eq","std::hash::Hash","std::cmp::PartialEq","std::marker::Sized","std::cmp::Ord"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test","arc_slice::ArcSlice","macros::Test2"],"U":["macros::Test","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::marker::Sized","std::convert::From","std::iter::Sum","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialEq","std::cmp::PartialOrd","std::clone::Clone","std::fmt::Debug","std::cmp::Ord","std::marker::Sized","std::cmp::Eq","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::impls::<impl std::clone::Clone for &T>","macros::Test2","macros::Test","arc_slice::ArcSlice"],"T":["arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2"],"U":["macros::Test2","macros::Test","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::ops::DivAssign","std::marker::Sized","std::convert::From","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::cmp::PartialOrd","std::clone::Clone","std::cmp::Ord","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2","macros::Test","arc_slice::ArcSlice"],"U":["macros::Test","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::marker::Sized","std::convert::From","std::ops::DivAssign","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::cmp::Ord","std::clone::Clone","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test","macros::Test2","arc_slice::ArcSlice"],"T":["arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test","std::clone::impls::<impl std::clone::Clone for &T>"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["std::hash::impls::<impl std::hash::Hash for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<*mut T as std::fmt::Debug>":{},"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::ops::DivAssign","std::marker::Sized","std::iter::Sum","std::convert::From"]},"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::hash::Hash","std::clone::Clone","std::cmp::PartialOrd","std::cmp::Ord","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","<*mut T as std::fmt::Debug>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::marker::Sized","std::ops::DivAssign","std::convert::From","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::cmp::Ord","std::hash::Hash","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::cmp::PartialOrd"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::impls::<impl std::clone::Clone for &mut T>","arc_slice::ArcSlice","macros::Test2","macros::Test"],"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2","arc_slice::ArcSlice","macros::Test"],"U":["macros::Test","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::convert::From","std::marker::Sized","std::ops::DivAssign","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::marker::Sized","std::cmp::Eq","std::cmp::Ord","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::PartialOrd"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["macros::Test2","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::marker::Sized","std::convert::From","std::ops::DivAssign","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::cmp::Ord","std::marker::Sized","std::cmp::PartialOrd"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["macros::Test2","macros::Test","std::clone::impls::<impl std::clone::Clone for &T>","arc_slice::ArcSlice"],"T":["arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::ops::DivAssign","std::marker::Sized","std::iter::Sum","std::convert::From"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialOrd","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Ord"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["arc_slice::ArcSlice","macros::Test2","macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>"],"U":["macros::Test2","arc_slice::ArcSlice","macros::Test"]},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::marker::Sized","std::convert::From","std::iter::Sum","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::Ord"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::impls::<impl std::clone::Clone for &T>","arc_slice::ArcSlice","macros::Test2","macros::Test"],"T":["macros::Test","std::clone::impls::<impl std::clone::Clone for &T>","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2"],"U":["macros::Test","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<*mut T as std::fmt::Debug>":{},"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::marker::Sized","std::ops::DivAssign","std::convert::From","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialOrd","std::fmt::Debug","std::cmp::Ord","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["<*mut T as std::fmt::Debug>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::iter::Sum","std::convert::From","std::marker::Sized","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::cmp::Ord","std::marker::Sized","std::cmp::PartialOrd","std::hash::Hash","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T, T)":["macros::Test","macros::Test2","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &T>"],"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test2"],"U":["arc_slice::ArcSlice","macros::Test","macros::Test2"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::hash::impls::<impl std::hash::Hash for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::iter::Sum","std::ops::DivAssign","std::marker::Sized","std::convert::From"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::cmp::PartialOrd","std::hash::Hash","std::fmt::Debug","std::marker::Sized","std::cmp::Ord"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for &T>","macros::Test2","macros::Test","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &mut T>"],"U":["macros::Test2","arc_slice::ArcSlice","macros::Test"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::ops::DivAssign","std::marker::Sized","std::iter::Sum","std::convert::From"]},"<*const T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::fmt::Debug","std::cmp::Ord","std::cmp::PartialEq","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::impls::<impl std::clone::Clone for &mut T>","arc_slice::ArcSlice","macros::Test","macros::Test2"],"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","macros::Test2"],"U":["arc_slice::ArcSlice","macros::Test","macros::Test2"]},"<*const T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::marker::Sized","std::convert::From","std::iter::Sum","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::cmp::PartialOrd","std::cmp::PartialEq","std::cmp::Eq","std::cmp::Ord","std::clone::Clone","std::marker::Sized","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["macros::Test","macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice"],"U":["arc_slice::ArcSlice","macros::Test","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::convert::From","std::ops::DivAssign","std::marker::Sized","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::hash::Hash","std::fmt::Debug","std::cmp::PartialEq","std::cmp::PartialOrd","std::cmp::Ord","std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T, T)":["std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test","arc_slice::ArcSlice","macros::Test2"],"T":["std::clone::impls::<impl std::clone::Clone for &T>","arc_slice::ArcSlice","macros::Test2","macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>"],"U":["macros::Test2","macros::Test","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::marker::Sized","std::convert::From","std::ops::DivAssign","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::hash::Hash","std::cmp::Ord"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice","macros::Test"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::ops::DivAssign","std::marker::Sized","std::convert::From","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::hash::Hash","std::clone::Clone","std::cmp::Ord","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::cmp::PartialOrd"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T, T)":["std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","macros::Test2","macros::Test"],"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test2","macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>"],"U":["macros::Test2","macros::Test","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::convert::From","std::marker::Sized","std::iter::Sum","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::cmp::PartialOrd","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::Ord","std::marker::Sized","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test","macros::Test2"],"U":["macros::Test2","arc_slice::ArcSlice","macros::Test"]},"arc_slice::ArcSlice":{"T":["<*mut T as std::fmt::Debug>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::iter::Sum","std::ops::DivAssign","std::convert::From","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::cmp::Ord","std::cmp::PartialEq","std::hash::Hash","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialOrd"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T, T)":["macros::Test","macros::Test2","std::clone::impls::<impl std::clone::Clone for &T>","arc_slice::ArcSlice"],"T":["macros::Test2","macros::Test","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &T>"],"U":["arc_slice::ArcSlice","macros::Test","macros::Test2"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::marker::Sized","std::convert::From","std::ops::DivAssign","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::Ord","std::clone::Clone","std::hash::Hash","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["macros::Test","macros::Test2","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>"],"U":["macros::Test","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::iter::Sum","std::convert::From","std::ops::DivAssign","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::cmp::PartialEq","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T, T)":["macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice","macros::Test2"],"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test2"],"U":["macros::Test2","arc_slice::ArcSlice","macros::Test"]},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::iter::Sum","std::ops::DivAssign","std::convert::From","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Ord","std::cmp::Eq","std::marker::Sized","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["macros::Test","macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &T>"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::convert::From","std::iter::Sum","std::marker::Sized","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<(T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T, T)":["macros::Test2","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test"],"T":["arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test2"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::ops::DivAssign","std::marker::Sized","std::convert::From","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::convert::From","std::iter::Sum","std::ops::DivAssign","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::clone::Clone","std::marker::Sized","std::cmp::Ord","std::fmt::Debug","std::cmp::PartialEq","std::hash::Hash","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T, T)":["macros::Test2","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice"],"T":["arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>"],"U":["arc_slice::ArcSlice","macros::Test","macros::Test2"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::hash::impls::<impl std::hash::Hash for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::ops::DivAssign","std::iter::Sum","std::marker::Sized","std::convert::From"]},"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::cmp::PartialOrd","std::hash::Hash","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Ord","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice","macros::Test2"],"U":["macros::Test2","macros::Test","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::marker::Sized","std::iter::Sum","std::ops::DivAssign","std::convert::From"]},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::cmp::PartialOrd","std::hash::Hash","std::fmt::Debug","std::cmp::Ord"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<(T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T, T)":["macros::Test2","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *const T>"],"T":["macros::Test2","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &T>"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T, T)
+p0.as_array();
+<(T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::convert::From","std::ops::DivAssign","std::iter::Sum","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::hash::Hash","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["macros::Test2","macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>","arc_slice::ArcSlice"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::iter::Sum","std::ops::DivAssign","std::convert::From","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::clone::Clone","std::fmt::Debug","std::cmp::Ord","std::marker::Sized","std::cmp::PartialOrd","std::cmp::Eq","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<(T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T, T)":["std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test","macros::Test2","arc_slice::ArcSlice"],"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2","arc_slice::ArcSlice","macros::Test"],"U":["macros::Test2","macros::Test","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["std::hash::impls::<impl std::hash::Hash for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T, T)
+p0.avg();
+<(T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T, T)
+p0.as_array();
+<(T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<*mut T as std::fmt::Debug>":{},"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::convert::From","std::marker::Sized","std::ops::DivAssign","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::PartialOrd","std::cmp::Eq","std::cmp::Ord","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test2","macros::Test"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["<*mut T as std::fmt::Debug>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::marker::Sized","std::convert::From","std::iter::Sum","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::hash::Hash","std::marker::Sized","std::cmp::PartialEq","std::cmp::PartialOrd","std::cmp::Ord"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<(T, T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T, T)":["arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test"],"T":["std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test2"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::hash::impls::<impl std::hash::Hash for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T, T)
+p0.avg();
+<(T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T, T)
+p0.as_array();
+<(T, T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::convert::From","std::marker::Sized","std::iter::Sum","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::cmp::Ord","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice"],"U":["macros::Test2","macros::Test","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::marker::Sized","std::iter::Sum","std::convert::From","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::cmp::Ord","std::hash::Hash","std::clone::Clone","std::cmp::PartialOrd","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<(T, T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T, T)":["arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test2"],"T":["macros::Test2","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","macros::Test"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T, T)
+p0.avg();
+<(T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T, T) as imp::tuple::AsArray>::as_array
deps:{"<(T, T) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T, T) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T, T)
+p0.as_array();
+<(T, T) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T, T) as imp::tuple::AsArray>::as_array(p0);
+<(T, T)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::Clone","std::marker::Sized"],"U":["std::ops::DivAssign","std::marker::Sized","std::convert::From","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test"],"U":["macros::Test","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T, T) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T)":["std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"],"U":["std::convert::From","std::iter::Sum","std::marker::Sized","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::hash::Hash","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<(T, T) as imp::tuple::TupleFns<T>>::avg":{"(T, T)":["macros::Test","arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>"],"T":["arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test"],"U":["macros::Test","macros::Test2","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T, T)
+p0.avg();
+<(T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T, T) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T, T)>::avg(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::AsTuple>::as_tuple
deps:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["std::marker::Sized"]}}
candidates:{"<[T; _] as imp::tuple::AsTuple>::as_tuple":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [T; _]
+p0.as_tuple();
+<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+crate::<[T; _] as imp::tuple::AsTuple>::as_tuple(p0);
+<[T; _]>::as_tuple(p0);
-----------------
src/imp/tuple.rs <(T,) as imp::tuple::AsArray>::as_array
deps:{"<(T,) as imp::tuple::AsArray>::as_array":{"T":["std::marker::Sized"]}}
candidates:{"<(T,) as imp::tuple::AsArray>::as_array":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (T,)
+p0.as_array();
+<(T,) as imp::tuple::AsArray>::as_array(p0);
+crate::<(T,) as imp::tuple::AsArray>::as_array(p0);
+<(T,)>::as_array(p0);
-----------------
src/imp/tuple.rs <[T; _] as imp::tuple::TupleFns<T>>::avg
deps:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["std::marker::Sized","std::clone::Clone"],"U":["std::convert::From","std::marker::Sized","std::ops::DivAssign","std::iter::Sum"]},"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialOrd","std::cmp::PartialEq","std::hash::Hash","std::fmt::Debug","std::cmp::Ord"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
candidates:{"<[T; _] as imp::tuple::TupleFns<T>>::avg":{"T":["arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test"],"U":["arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::hash::impls::<impl std::hash::Hash for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; _]
+p0.avg();
+<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<[T; _] as imp::tuple::TupleFns<T>>::avg(p0);
+<[T; _]>::avg(p0);
-----------------
src/imp/tuple.rs <(T,) as imp::tuple::TupleFns<T>>::avg
deps:{"<(T,) as imp::tuple::TupleFns<T>>::avg":{"(T,)":["std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"],"U":["std::marker::Sized","std::iter::Sum","std::convert::From","std::ops::DivAssign"]},"arc_slice::ArcSlice":{"T":["std::cmp::Ord","std::cmp::PartialOrd","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<(T,) as imp::tuple::TupleFns<T>>::avg":{"(T,)":["std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice","macros::Test","macros::Test2"],"T":["std::clone::impls::<impl std::clone::Clone for &T>","macros::Test2","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>"],"U":["macros::Test","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (T,)
+p0.avg();
+<(T,) as imp::tuple::TupleFns<T>>::avg(p0);
+crate::<(T,) as imp::tuple::TupleFns<T>>::avg(p0);
+<(T,)>::avg(p0);
-----------------
src/imp/numext.rs <u8 as imp::numext::DivOrNop>::div_or_nop
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
+p0.div_or_nop(p1);
+<u8 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+crate::<u8 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+<u8>::div_or_nop(p0, p1);
-----------------
src/imp/numext.rs <i8 as imp::numext::DivOrNop>::div_or_nop
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0i8; // None+i8
+p0.div_or_nop(p1);
+<i8 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+crate::<i8 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+<i8>::div_or_nop(p0, p1);
-----------------
src/imp/numext.rs <u16 as imp::numext::DivOrNop>::div_or_nop
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = 0u16; // None+u16
+p0.div_or_nop(p1);
+<u16 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+crate::<u16 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+<u16>::div_or_nop(p0, p1);
-----------------
src/imp/numext.rs <i16 as imp::numext::DivOrNop>::div_or_nop
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = 0i16; // None+i16
+p0.div_or_nop(p1);
+<i16 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+crate::<i16 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+<i16>::div_or_nop(p0, p1);
-----------------
src/imp/numext.rs <u32 as imp::numext::DivOrNop>::div_or_nop
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+p0.div_or_nop(p1);
+<u32 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+crate::<u32 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+<u32>::div_or_nop(p0, p1);
-----------------
src/imp/numext.rs <i32 as imp::numext::DivOrNop>::div_or_nop
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0i32; // None+i32
+p0.div_or_nop(p1);
+<i32 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+crate::<i32 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+<i32>::div_or_nop(p0, p1);
-----------------
src/imp/numext.rs <u64 as imp::numext::DivOrNop>::div_or_nop
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
let mut p1 = 0u64; // None+u64
+p0.div_or_nop(p1);
+<u64 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+crate::<u64 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+<u64>::div_or_nop(p0, p1);
-----------------
src/imp/numext.rs <i64 as imp::numext::DivOrNop>::div_or_nop
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0i64; // None+i64
+p0.div_or_nop(p1);
+<i64 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+crate::<i64 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+<i64>::div_or_nop(p0, p1);
-----------------
src/imp/numext.rs <u128 as imp::numext::DivOrNop>::div_or_nop
deps:{}
candidates:{}
let mut p0 = 0u128; // None+u128
let mut p1 = 0u128; // None+u128
+p0.div_or_nop(p1);
+<u128 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+crate::<u128 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+<u128>::div_or_nop(p0, p1);
-----------------
src/imp/numext.rs <i128 as imp::numext::DivOrNop>::div_or_nop
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
let mut p1 = 0i128; // None+i128
+p0.div_or_nop(p1);
+<i128 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+crate::<i128 as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+<i128>::div_or_nop(p0, p1);
-----------------
src/imp/numext.rs <usize as imp::numext::DivOrNop>::div_or_nop
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+p0.div_or_nop(p1);
+<usize as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+crate::<usize as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+<usize>::div_or_nop(p0, p1);
-----------------
src/imp/numext.rs <isize as imp::numext::DivOrNop>::div_or_nop
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
let mut p1 = 0isize; // None+isize
+p0.div_or_nop(p1);
+<isize as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+crate::<isize as imp::numext::DivOrNop>::div_or_nop(p0, p1);
+<isize>::div_or_nop(p0, p1);
-----------------
src/refc/imp.rs refc::imp::<impl refc::RefClonable for std::sync::Arc<T>>::refc
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::Arc<T>
+p0.refc();
+refc::imp::<impl refc::RefClonable for std::sync::Arc<T>>::refc(p0);
+crate::refc::imp::<impl refc::RefClonable for std::sync::Arc<T>>::refc(p0);
+<std::sync::Arc<T>>::refc(p0);
-----------------
src/refc/imp.rs refc::imp::<impl refc::RefClonable for std::rc::Rc<T>>::refc
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::rc::Rc<T>
+p0.refc();
+refc::imp::<impl refc::RefClonable for std::rc::Rc<T>>::refc(p0);
+crate::refc::imp::<impl refc::RefClonable for std::rc::Rc<T>>::refc(p0);
+<std::rc::Rc<T>>::refc(p0);
-----------------
src/refc/imp.rs refc::imp::<impl refc::RefClonable for std::boxed::Box<T>>::refc
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::cmp::Ord","std::cmp::PartialOrd","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::hash::Hash","std::clone::Clone","std::fmt::Debug"]},"refc::imp::<impl refc::RefClonable for std::boxed::Box<T>>::refc":{"T":["refc::RefClonable","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","<*mut T as std::fmt::Debug>"]},"refc::imp::<impl refc::RefClonable for std::boxed::Box<T>>::refc":{"T":["std::rc::Rc","std::sync::Arc","arc_slice::ArcSlice","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::boxed::Box<T>
+p0.refc();
+refc::imp::<impl refc::RefClonable for std::boxed::Box<T>>::refc(p0);
+crate::refc::imp::<impl refc::RefClonable for std::boxed::Box<T>>::refc(p0);
+<std::boxed::Box<T>>::refc(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::new
deps:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::new":{"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::new":{"T":["RUG_ANY"]}}
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::new();
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::new();
+<arc_slice::ArcSlice<T>>::new();
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::with_capacity
deps:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::with_capacity":{"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::with_capacity":{"T":["RUG_ANY"]}}
let mut p0 = 0usize; // None+usize
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::with_capacity(p0);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::with_capacity(p0);
+<arc_slice::ArcSlice<T>>::with_capacity(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::slice
deps:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::slice":{"S":["std::marker::Sized","std::ops::RangeBounds"],"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::slice":{"S":["std::ops::Range<T>","(std::collections::Bound<&'a T>, std::collections::Bound<&'a T>)","std::ops::RangeInclusive<T>","std::ops::RangeFrom<&T>","std::ops::RangeTo<&T>","std::ops::RangeInclusive<&T>","std::ops::RangeFull","(std::collections::Bound<T>, std::collections::Bound<T>)","std::ops::RangeFrom<T>","std::ops::RangeToInclusive<T>","std::ops::Range<&T>","std::ops::RangeToInclusive<&T>","std::ops::RangeTo<T>"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.slice(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::slice(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::slice(p0, p1);
+<arc_slice::ArcSlice<T>>::slice(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extract
deps:{"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::marker::Sized","std::cmp::Eq","std::cmp::Ord","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::hash::Hash"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extract":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::hash::impls::<impl std::hash::Hash for *const T>"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extract":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.extract();
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extract(p0);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extract(p0);
+<arc_slice::ArcSlice<T>>::extract(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extracted
deps:{"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::cmp::PartialOrd","std::hash::Hash","std::cmp::Ord","std::clone::Clone"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extracted":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"arc_slice::ArcSlice":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extracted":{"T":["std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2","arc_slice::ArcSlice","macros::Test"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.extracted();
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extracted(p0);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extracted(p0);
+<arc_slice::ArcSlice<T>>::extracted(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extract_with_capacity
deps:{"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::PartialEq","std::cmp::Ord","std::hash::Hash","std::clone::Clone"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extract_with_capacity":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"arc_slice::ArcSlice":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extract_with_capacity":{"T":["macros::Test2","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
+p0.extract_with_capacity(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extract_with_capacity(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extract_with_capacity(p0, p1);
+<arc_slice::ArcSlice<T>>::extract_with_capacity(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extracted_with_capacity
deps:{"arc_slice::ArcSlice":{"T":["std::cmp::Ord","std::hash::Hash","std::marker::Sized","std::fmt::Debug","std::cmp::PartialOrd","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extracted_with_capacity":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","arc_slice::ArcSlice"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extracted_with_capacity":{"T":["macros::Test","std::clone::impls::<impl std::clone::Clone for &T>","arc_slice::ArcSlice","macros::Test2"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
+p0.extracted_with_capacity(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extracted_with_capacity(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extracted_with_capacity(p0, p1);
+<arc_slice::ArcSlice<T>>::extracted_with_capacity(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::len
deps:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::len":{"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::len":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.len();
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::len(p0);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::len(p0);
+<arc_slice::ArcSlice<T>>::len(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::is_empty
deps:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::is_empty":{"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::is_empty":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.is_empty();
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::is_empty(p0);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::is_empty(p0);
+<arc_slice::ArcSlice<T>>::is_empty(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::is_unsliced
deps:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::is_unsliced":{"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::is_unsliced":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.is_unsliced();
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::is_unsliced(p0);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::is_unsliced(p0);
+<arc_slice::ArcSlice<T>>::is_unsliced(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::compact
deps:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::compact":{"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::compact":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.compact();
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::compact(p0);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::compact(p0);
+<arc_slice::ArcSlice<T>>::compact(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::truncate
deps:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::truncate":{"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::truncate":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
+p0.truncate(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::truncate(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::truncate(p0, p1);
+<arc_slice::ArcSlice<T>>::truncate(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::swap_remove
deps:{"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::Ord","std::hash::Hash"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::swap_remove":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{}}
candidates:{"arc_slice::ArcSlice":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::swap_remove":{"T":["macros::Test2","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
+p0.swap_remove(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::swap_remove(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::swap_remove(p0, p1);
+<arc_slice::ArcSlice<T>>::swap_remove(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::remove
deps:{"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::clone::Clone","std::marker::Sized","std::cmp::PartialOrd","std::hash::Hash","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::cmp::Ord"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::remove":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::remove":{"T":["arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
+p0.remove(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::remove(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::remove(p0, p1);
+<arc_slice::ArcSlice<T>>::remove(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::retain
deps:{"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::hash::Hash","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::cmp::PartialOrd","std::cmp::Ord","std::clone::Clone"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::retain":{"F":["std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["<*mut T as std::fmt::Debug>","arc_slice::ArcSlice"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::retain":{"F":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"],"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.retain(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::retain(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::retain(p0, p1);
+<arc_slice::ArcSlice<T>>::retain(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::insert
deps:{"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::hash::Hash","std::cmp::PartialEq","std::cmp::Ord","std::clone::Clone","std::cmp::PartialOrd","std::fmt::Debug","std::cmp::Eq"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::insert":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","arc_slice::ArcSlice"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::insert":{"T":["macros::Test","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.insert(p1, p2);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::insert(p0, p1, p2);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::insert(p0, p1, p2);
+<arc_slice::ArcSlice<T>>::insert(p0, p1, p2);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::insert_slice
deps:{"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::PartialOrd","std::cmp::Eq","std::hash::Hash","std::cmp::Ord","std::marker::Sized"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::insert_slice":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{}}
candidates:{"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::insert_slice":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test","macros::Test2"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
let mut p2 = & MaybeUninit::uninit().assume_init(); // [T]
+p0.insert_slice(p1, p2);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::insert_slice(p0, p1, p2);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::insert_slice(p0, p1, p2);
+<arc_slice::ArcSlice<T>>::insert_slice(p0, p1, p2);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::split_at
deps:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::split_at":{"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::split_at":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
+p0.split_at(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::split_at(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::split_at(p0, p1);
+<arc_slice::ArcSlice<T>>::split_at(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::split_off
deps:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::split_off":{"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::split_off":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
+p0.split_off(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::split_off(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::split_off(p0, p1);
+<arc_slice::ArcSlice<T>>::split_off(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize_with
deps:{"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::cmp::Ord","std::hash::Hash","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::PartialOrd"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize_with":{"F":["std::ops::FnMut","std::marker::Sized"],"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize_with":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"],"T":["macros::Test","std::clone::impls::<impl std::clone::Clone for &T>","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test2"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+p0.resize_with(p1, p2);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize_with(p0, p1, p2);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize_with(p0, p1, p2);
+<arc_slice::ArcSlice<T>>::resize_with(p0, p1, p2);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize
deps:{"<*const T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::cmp::Ord","std::marker::Sized","std::clone::Clone","std::hash::Hash"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize":{"F":["std::marker::Sized"],"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","<*const T as std::fmt::Debug>"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize":{"F":["RUG_ANY"],"T":["std::clone::impls::<impl std::clone::Clone for &T>","macros::Test","arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.resize(p1, p2);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize(p0, p1, p2);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize(p0, p1, p2);
+<arc_slice::ArcSlice<T>>::resize(p0, p1, p2);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize_default
deps:{"<*const T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::cmp::Ord","std::cmp::PartialEq","std::hash::Hash","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialOrd"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize_default":{"F":["std::marker::Sized"],"T":["std::clone::Clone","std::default::Default","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["<*const T as std::fmt::Debug>","arc_slice::ArcSlice"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize_default":{"F":["RUG_ANY"],"T":["arc_slice::ArcSlice"]},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
+p0.resize_default(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize_default(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::resize_default(p0, p1);
+<arc_slice::ArcSlice<T>>::resize_default(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::push
deps:{"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::cmp::PartialEq","std::cmp::PartialOrd","std::hash::Hash","std::clone::Clone","std::fmt::Debug","std::cmp::Ord","std::marker::Sized","std::cmp::Eq"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::push":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","<*mut T as std::fmt::Debug>"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::push":{"T":["macros::Test2","std::clone::impls::<impl std::clone::Clone for &mut T>","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.push(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::push(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::push(p0, p1);
+<arc_slice::ArcSlice<T>>::push(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::pop
deps:{"<*const T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Ord","std::marker::Sized","std::cmp::Eq","std::cmp::PartialOrd","std::hash::Hash"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::pop":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::hash::impls::<impl std::hash::Hash for *mut T>","arc_slice::ArcSlice"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::pop":{"T":["macros::Test2","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.pop();
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::pop(p0);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::pop(p0);
+<arc_slice::ArcSlice<T>>::pop(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::append
deps:{"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::hash::Hash","std::clone::Clone","std::cmp::PartialEq","std::cmp::PartialOrd","std::cmp::Ord"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::append":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
candidates:{"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::hash::impls::<impl std::hash::Hash for *mut T>"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::append":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test","macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<T>
+p0.append(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::append(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::append(p0, p1);
+<arc_slice::ArcSlice<T>>::append(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extend_from_slice
deps:{"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Ord","std::hash::Hash","std::clone::Clone","std::cmp::PartialOrd","std::cmp::Eq","std::fmt::Debug"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extend_from_slice":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extend_from_slice":{"T":["macros::Test2","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [T]
+p0.extend_from_slice(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extend_from_slice(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::extend_from_slice(p0, p1);
+<arc_slice::ArcSlice<T>>::extend_from_slice(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::clear
deps:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::clear":{"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::clear":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.clear();
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::clear(p0);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::clear(p0);
+<arc_slice::ArcSlice<T>>::clear(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut
deps:{"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::PartialOrd","std::hash::Hash","std::marker::Sized","std::cmp::Ord"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test","macros::Test2","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0._make_mut();
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut(p0);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut(p0);
+<arc_slice::ArcSlice<T>>::_make_mut(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_with_capacity
deps:{"arc_slice::ArcSlice":{"T":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::cmp::PartialOrd","std::cmp::Ord","std::hash::Hash","std::fmt::Debug"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_with_capacity":{"T":["std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_with_capacity":{"T":["macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
+p0._make_mut_with_capacity(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_with_capacity(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_with_capacity(p0, p1);
+<arc_slice::ArcSlice<T>>::_make_mut_with_capacity(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_extracted
deps:{"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::hash::Hash","std::marker::Sized","std::cmp::Ord","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_extracted":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{}}
candidates:{"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::Ord for *const T>","arc_slice::ArcSlice"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_extracted":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &mut T>","macros::Test","macros::Test2"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0._make_mut_extracted();
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_extracted(p0);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_extracted(p0);
+<arc_slice::ArcSlice<T>>::_make_mut_extracted(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_extracted_with_capacity
deps:{"<*const T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::clone::Clone","std::cmp::Ord","std::cmp::PartialOrd","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_extracted_with_capacity":{"T":["std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["<*const T as std::fmt::Debug>","arc_slice::ArcSlice"]},"arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_extracted_with_capacity":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = 0usize; // None+usize
+p0._make_mut_extracted_with_capacity(p1);
+arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_extracted_with_capacity(p0, p1);
+crate::arc_slice::imp::<impl arc_slice::ArcSlice<T>>::_make_mut_extracted_with_capacity(p0, p1);
+<arc_slice::ArcSlice<T>>::_make_mut_extracted_with_capacity(p0, p1);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl std::default::Default for arc_slice::ArcSlice<T>>::default
deps:{"arc_slice::imp::<impl std::default::Default for arc_slice::ArcSlice<T>>::default":{"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl std::default::Default for arc_slice::ArcSlice<T>>::default":{"T":["RUG_ANY"]}}
+arc_slice::imp::<impl std::default::Default for arc_slice::ArcSlice<T>>::default();
+crate::arc_slice::imp::<impl std::default::Default for arc_slice::ArcSlice<T>>::default();
+<arc_slice::ArcSlice<T>>::default();
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl std::convert::From<std::vec::Vec<T>> for arc_slice::ArcSlice<T>>::from
deps:{"arc_slice::imp::<impl std::convert::From<std::vec::Vec<T>> for arc_slice::ArcSlice<T>>::from":{"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl std::convert::From<std::vec::Vec<T>> for arc_slice::ArcSlice<T>>::from":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<T>
+arc_slice::imp::<impl std::convert::From<std::vec::Vec<T>> for arc_slice::ArcSlice<T>>::from(p0);
+crate::arc_slice::imp::<impl std::convert::From<std::vec::Vec<T>> for arc_slice::ArcSlice<T>>::from(p0);
+<arc_slice::ArcSlice<T>>::from(p0);
-----------------
src/arc_slice/imp.rs arc_slice::imp::<impl std::convert::From<std::sync::Arc<std::vec::Vec<T>>> for arc_slice::ArcSlice<T>>::from
deps:{"arc_slice::imp::<impl std::convert::From<std::sync::Arc<std::vec::Vec<T>>> for arc_slice::ArcSlice<T>>::from":{"T":["std::marker::Sized"]}}
candidates:{"arc_slice::imp::<impl std::convert::From<std::sync::Arc<std::vec::Vec<T>>> for arc_slice::ArcSlice<T>>::from":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::sync::Arc<std::vec::Vec<T>>
+arc_slice::imp::<impl std::convert::From<std::sync::Arc<std::vec::Vec<T>>> for arc_slice::ArcSlice<T>>::from(p0);
+crate::arc_slice::imp::<impl std::convert::From<std::sync::Arc<std::vec::Vec<T>>> for arc_slice::ArcSlice<T>>::from(p0);
+<arc_slice::ArcSlice<T>>::from(p0);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::ops::Deref>::deref
deps:{"<arc_slice::ArcSlice<T> as std::ops::Deref>::deref":{"T":["std::marker::Sized"]}}
candidates:{"<arc_slice::ArcSlice<T> as std::ops::Deref>::deref":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.deref();
+<arc_slice::ArcSlice<T> as std::ops::Deref>::deref(p0);
+crate::<arc_slice::ArcSlice<T> as std::ops::Deref>::deref(p0);
+<arc_slice::ArcSlice<T>>::deref(p0);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::ops::DerefMut>::deref_mut
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::ops::DerefMut>::deref_mut":{"T":["std::clone::Clone","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::marker::Sized","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialOrd"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::ops::DerefMut>::deref_mut":{"T":["macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["<*mut T as std::fmt::Debug>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.deref_mut();
+<arc_slice::ArcSlice<T> as std::ops::DerefMut>::deref_mut(p0);
+crate::<arc_slice::ArcSlice<T> as std::ops::DerefMut>::deref_mut(p0);
+<arc_slice::ArcSlice<T>>::deref_mut(p0);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::clone::Clone>::clone
deps:{"<arc_slice::ArcSlice<T> as std::clone::Clone>::clone":{"T":["std::marker::Sized"]}}
candidates:{"<arc_slice::ArcSlice<T> as std::clone::Clone>::clone":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.clone();
+<arc_slice::ArcSlice<T> as std::clone::Clone>::clone(p0);
+crate::<arc_slice::ArcSlice<T> as std::clone::Clone>::clone(p0);
+<arc_slice::ArcSlice<T>>::clone(p0);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as refc::RefClonable>::refc
deps:{"<arc_slice::ArcSlice<T> as refc::RefClonable>::refc":{"T":["std::marker::Sized"]}}
candidates:{"<arc_slice::ArcSlice<T> as refc::RefClonable>::refc":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.refc();
+<arc_slice::ArcSlice<T> as refc::RefClonable>::refc(p0);
+crate::<arc_slice::ArcSlice<T> as refc::RefClonable>::refc(p0);
+<arc_slice::ArcSlice<T>>::refc(p0);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::convert::From<&[T]>>::from
deps:{"<arc_slice::ArcSlice<T> as std::convert::From<&[T]>>::from":{"T":["std::marker::Sized","std::clone::Clone"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::cmp::Ord","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::Eq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<arc_slice::ArcSlice<T> as std::convert::From<&[T]>>::from":{"T":["macros::Test2","std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T]
+<arc_slice::ArcSlice<T> as std::convert::From<&[T]>>::from(p0);
+crate::<arc_slice::ArcSlice<T> as std::convert::From<&[T]>>::from(p0);
+<arc_slice::ArcSlice<T>>::from(p0);
-----------------
src/arc_slice/mod.rs <&arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into
deps:{"<&arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into":{"T":["std::marker::Sized","std::clone::Clone"]},"<*const T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Ord","std::cmp::Eq","std::clone::Clone","std::cmp::PartialOrd","std::hash::Hash","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test","arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"<*const T as std::fmt::Debug>":{},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.into();
+<&arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into(p0);
+crate::<&arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into(p0);
+<&arc_slice::ArcSlice<T>>::into(p0);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into
deps:{"<arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into":{"T":["std::clone::Clone","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::hash::Hash","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into":{"T":["macros::Test2","std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &T>"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::hash::impls::<impl std::hash::Hash for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.into();
+<arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into(p0);
+crate::<arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into(p0);
+<arc_slice::ArcSlice<T>>::into(p0);
-----------------
src/arc_slice/mod.rs <&mut arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into
deps:{"<&mut arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into":{"T":["std::marker::Sized","std::clone::Clone"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialEq","std::hash::Hash","std::cmp::PartialOrd","std::cmp::Eq","std::cmp::Ord","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<&mut arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into":{"T":["arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.into();
+<&mut arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into(p0);
+crate::<&mut arc_slice::ArcSlice<T> as std::convert::Into<std::vec::Vec<T>>>::into(p0);
+<&mut arc_slice::ArcSlice<T>>::into(p0);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::convert::AsRef<[T]>>::as_ref
deps:{"<arc_slice::ArcSlice<T> as std::convert::AsRef<[T]>>::as_ref":{"T":["std::marker::Sized"]}}
candidates:{"<arc_slice::ArcSlice<T> as std::convert::AsRef<[T]>>::as_ref":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.as_ref();
+<arc_slice::ArcSlice<T> as std::convert::AsRef<[T]>>::as_ref(p0);
+crate::<arc_slice::ArcSlice<T> as std::convert::AsRef<[T]>>::as_ref(p0);
+<arc_slice::ArcSlice<T>>::as_ref(p0);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::convert::AsMut<[T]>>::as_mut
deps:{"<arc_slice::ArcSlice<T> as std::convert::AsMut<[T]>>::as_mut":{"T":["std::marker::Sized","std::clone::Clone"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::cmp::PartialEq","std::cmp::Eq","std::cmp::PartialOrd","std::cmp::Ord","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<arc_slice::ArcSlice<T> as std::convert::AsMut<[T]>>::as_mut":{"T":["macros::Test2","macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.as_mut();
+<arc_slice::ArcSlice<T> as std::convert::AsMut<[T]>>::as_mut(p0);
+crate::<arc_slice::ArcSlice<T> as std::convert::AsMut<[T]>>::as_mut(p0);
+<arc_slice::ArcSlice<T>>::as_mut(p0);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::borrow::Borrow<[T]>>::borrow
deps:{"<arc_slice::ArcSlice<T> as std::borrow::Borrow<[T]>>::borrow":{"T":["std::marker::Sized"]}}
candidates:{"<arc_slice::ArcSlice<T> as std::borrow::Borrow<[T]>>::borrow":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.borrow();
+<arc_slice::ArcSlice<T> as std::borrow::Borrow<[T]>>::borrow(p0);
+crate::<arc_slice::ArcSlice<T> as std::borrow::Borrow<[T]>>::borrow(p0);
+<arc_slice::ArcSlice<T>>::borrow(p0);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::borrow::BorrowMut<[T]>>::borrow_mut
deps:{"<*mut T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::borrow::BorrowMut<[T]>>::borrow_mut":{"T":["std::clone::Clone","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Ord","std::marker::Sized","std::cmp::PartialOrd","std::hash::Hash","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::borrow::BorrowMut<[T]>>::borrow_mut":{"T":["arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test"]},"arc_slice::ArcSlice":{"T":["<*mut T as std::fmt::Debug>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.borrow_mut();
+<arc_slice::ArcSlice<T> as std::borrow::BorrowMut<[T]>>::borrow_mut(p0);
+crate::<arc_slice::ArcSlice<T> as std::borrow::BorrowMut<[T]>>::borrow_mut(p0);
+<arc_slice::ArcSlice<T>>::borrow_mut(p0);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::fmt::Debug","std::cmp::PartialOrd","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::cmp::Ord","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::fmt::Debug>::fmt":{"T":["<*mut T as std::fmt::Debug>","arc_slice::ArcSlice","<&mut T as std::fmt::Debug>"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<arc_slice::ArcSlice<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<arc_slice::ArcSlice<T> as std::fmt::Debug>::fmt(p0, p1);
+<arc_slice::ArcSlice<T>>::fmt(p0, p1);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::cmp::PartialEq<O>>::eq
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<*mut T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::cmp::PartialEq<O>>::eq":{"O":["std::marker::Sized","std::convert::AsRef"],"T":["std::marker::Sized","std::cmp::PartialEq"]},"arc_slice::ArcSlice":{"T":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::Ord","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<*mut T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::cmp::PartialEq<O>>::eq":{"O":["<&mut T as std::convert::AsRef<U>>","<&T as std::convert::AsRef<U>>","arc_slice::ArcSlice"],"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // O
+p0.eq(p1);
+<arc_slice::ArcSlice<T> as std::cmp::PartialEq<O>>::eq(p0, p1);
+crate::<arc_slice::ArcSlice<T> as std::cmp::PartialEq<O>>::eq(p0, p1);
+<arc_slice::ArcSlice<T>>::eq(p0, p1);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::cmp::PartialOrd>::partial_cmp
deps:{"<*const T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::cmp::PartialOrd>::partial_cmp":{"T":["std::marker::Sized","std::cmp::PartialOrd"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::fmt::Debug","std::cmp::Ord","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::cmp::PartialOrd>::partial_cmp":{"T":["std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>","arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","<*const T as std::fmt::Debug>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.partial_cmp(p1);
+<arc_slice::ArcSlice<T> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<arc_slice::ArcSlice<T> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<arc_slice::ArcSlice<T>>::partial_cmp(p0, p1);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::cmp::Ord>::cmp
deps:{"<arc_slice::ArcSlice<T> as std::cmp::Ord>::cmp":{"T":["std::marker::Sized","std::cmp::Ord"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::cmp::Ord","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialOrd"]},"std::cmp::impls::<impl std::cmp::Ord for &A>":{},"std::cmp::impls::<impl std::cmp::Ord for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<arc_slice::ArcSlice<T> as std::cmp::Ord>::cmp":{"T":["std::ptr::const_ptr::<impl std::cmp::Ord for *const T>","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::Ord for *const T>"]},"std::cmp::impls::<impl std::cmp::Ord for &A>":{},"std::cmp::impls::<impl std::cmp::Ord for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.cmp(p1);
+<arc_slice::ArcSlice<T> as std::cmp::Ord>::cmp(p0, p1);
+crate::<arc_slice::ArcSlice<T> as std::cmp::Ord>::cmp(p0, p1);
+<arc_slice::ArcSlice<T>>::cmp(p0, p1);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::iter::Extend<T>>::extend
deps:{"<&'a arc_slice::ArcSlice<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut arc_slice::ArcSlice<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<arc_slice::ArcSlice<T> as std::iter::Extend<T>>::extend":{"I":["std::iter::IntoIterator","std::marker::Sized"],"T":["std::marker::Sized","std::clone::Clone"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::cmp::Ord","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<&'a arc_slice::ArcSlice<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut arc_slice::ArcSlice<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::os::unix::net::ScmCredentials<'a>","std::char::EscapeDebug","std::iter::Once<T>","std::slice::Iter<'a, T>","std::slice::SplitInclusiveMut<'a, T, P>","std::slice::IterMut<'a, T>","std::slice::RChunksExactMut<'a, T>","std::collections::hash_map::Keys<'a, K, V>","std::collections::hash_map::IntoValues<K, V>","std::str::SplitInclusive<'a, P>","std::iter::SkipWhile<I, P>","std::str::SplitWhitespace<'a>","std::str::RMatchIndices<'a, P>","std::string::Drain<'_>","std::collections::btree_map::Values<'a, K, V>","std::collections::btree_set::Iter<'a, T>","std::collections::btree_set::Intersection<'a, T, A>","std::collections::vec_deque::Drain<'_, T, A>","std::boxed::Box<I, A>","std::iter::FilterMap<I, F>","std::os::unix::net::Messages<'a>","std::iter::TakeWhile<I, P>","std::iter::Cycle<I>","std::iter::sources::from_generator::FromGenerator<G>","std::env::VarsOs","std::slice::RSplit<'a, T, P>","std::net::IntoIncoming","std::slice::ChunksMut<'a, T>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::slice::Windows<'a, T>","std::iter::Fuse<I>","std::str::SplitN<'a, P>","std::str::RSplit<'a, P>","std::collections::linked_list::IterMut<'a, T>","std::collections::btree_map::IntoValues<K, V, A>","std::io::Bytes<R>","std::collections::vec_deque::Iter<'a, T>","std::collections::btree_map::RangeMut<'a, K, V>","std::collections::hash_set::Intersection<'a, T, S>","std::sys::unix::args::Args","std::collections::binary_heap::Iter<'a, T>","std::collections::btree_map::Iter<'a, K, V>","std::char::DecodeUtf16<I>","std::collections::binary_heap::IntoIterSorted<T>","std::str::EscapeDefault<'a>","std::sys::unix::os::Env","std::slice::RChunksExact<'a, T>","std::ascii::EscapeDefault","std::collections::binary_heap::IntoIter<T>","std::iter::ByRefSized<'_, I>","std::sync::mpsc::TryIter<'a, T>","std::slice::SplitInclusive<'a, T, P>","std::path::Components<'a>","std::iter::Empty<T>","std::collections::hash_set::Iter<'a, K>","std::fs::ReadDir","std::slice::ArrayWindows<'a, T, N>","std::option::Iter<'a, A>","std::iter::IntersperseWith<I, G>","std::result::IntoIter<T>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::collections::hash_set::IntoIter<K>","std::collections::linked_list::DrainFilter<'_, T, F>","std::sys_common::wstr::WStrUnits<'_>","std::path::Iter<'a>","std::iter::Take<I>","std::ops::RangeFrom<A>","std::sys_common::wtf8::EncodeWide<'a>","std::iter::Chain<A, B>","std::str::SplitTerminator<'a, P>","std::collections::btree_map::Keys<'a, K, V>","std::iter::Enumerate<I>","std::iter::Successors<T, F>","std::iter::Flatten<I>","std::os::unix::net::Incoming<'a>","std::collections::linked_list::IntoIter<T>","std::str::Chars<'a>","std::vec::DrainFilter<'_, T, F, A>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::iter::MapWhile<I, P>","std::collections::btree_map::IntoKeys<K, V, A>","std::vec::Splice<'_, I, A>","std::io::Split<B>","std::str::Bytes<'_>","std::result::Iter<'a, T>","std::collections::btree_set::Range<'a, T>","std::str::EscapeDebug<'a>","std::result::IterMut<'a, T>","std::collections::vec_deque::IterMut<'a, T>","std::slice::RChunksMut<'a, T>","std::collections::hash_map::Values<'a, K, V>","std::iter::OnceWith<F>","std::process::CommandArgs<'a>","std::collections::hash_set::DrainFilter<'_, K, F>","std::option::Item<A>","std::str::SplitAsciiWhitespace<'a>","std::collections::btree_map::Range<'a, K, V>","std::env::SplitPaths<'a>","std::char::EscapeUnicode","std::iter::Scan<I, St, F>","std::slice::SplitMut<'a, T, P>","std::iter::adapters::GenericShunt<'_, I, R>","std::collections::btree_set::IntoIter<T, A>","std::str::Lines<'a>","std::collections::hash_map::Iter<'a, K, V>","core::slice::iter::GenericSplitN<I>","std::str::LinesAny<'a>","std::iter::Map<I, F>","std::slice::ArrayChunksMut<'a, T, N>","std::iter::Zip<A, B>","std::iter::Rev<I>","std::slice::SplitN<'a, T, P>","std::collections::hash_map::IntoIter<K, V>","std::iter::FlatMap<I, U, F>","<&mut I as std::iter::Iterator>","std::slice::GroupBy<'a, T, P>","std::str::Matches<'a, P>","std::iter::Cloned<I>","std::iter::ArrayChunks<I, N>","std::path::Ancestors<'a>","std::char::ToUppercase","std::collections::hash_set::Union<'a, T, S>","std::slice::Split<'a, T, P>","std::env::Args","std::collections::hash_map::ValuesMut<'a, K, V>","std::iter::Repeat<A>","std::collections::vec_deque::IntoIter<T, A>","std::ops::Range<A>","std::slice::GroupByMut<'a, T, P>","std::sync::mpsc::Iter<'a, T>","std::char::CaseMappingIter","std::process::CommandEnvs<'a>","std::iter::Filter<I, P>","std::slice::RSplitMut<'a, T, P>","std::iter::Skip<I>","std::vec::Drain<'_, T, A>","std::slice::SplitNMut<'a, T, P>","std::char::ToLowercase","std::option::IntoIter<A>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::sync::mpsc::IntoIter<T>","std::collections::hash_map::IntoKeys<K, V>","std::collections::btree_map::ValuesMut<'a, K, V>","std::slice::ChunksExactMut<'a, T>","std::ops::RangeInclusive<A>","std::slice::RSplitNMut<'a, T, P>","std::collections::btree_set::Difference<'a, T, A>","std::slice::ChunksExact<'a, T>","std::sys_common::net::LookupHost","std::collections::binary_heap::DrainSorted<'_, T>","std::iter::Inspect<I, F>","std::str::RSplitTerminator<'a, P>","std::env::ArgsOs","std::str::CharIndices<'a>","std::collections::hash_map::IterMut<'a, K, V>","std::env::Vars","std::net::Incoming<'a>","std::iter::RepeatWith<F>","std::slice::ArrayChunks<'a, T, N>","std::ops::index_range::IndexRange","std::iter::Intersperse<I>","std::sys::unix::os::SplitPaths<'a>","std::iter::StepBy<I>","std::str::RSplitN<'a, P>","std::collections::binary_heap::Drain<'_, T>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::collections::linked_list::Iter<'a, T>","core::error::Source<'a>","std::collections::hash_set::Drain<'a, K>","std::str::Utf8Chunks<'a>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::slice::Chunks<'a, T>","std::collections::btree_map::IterMut<'a, K, V>","std::iter::FromFn<F>","std::io::Lines<B>","std::str::MatchIndices<'a, P>","std::iter::Peekable<I>","std::slice::RChunks<'a, T>","std::collections::btree_map::IntoIter<K, V, A>","std::collections::hash_set::Difference<'a, T, S>","std::iter::RepeatN<A>","std::vec::IntoIter<T, A>","std::sys::unix::fs::ReadDir","std::array::IntoIter<T, N>","std::str::EncodeUtf16<'a>","std::str::Split<'a, P>","std::slice::RSplitN<'a, T, P>","std::char::EscapeDefault","std::os::unix::net::ScmRights<'a>","std::collections::btree_set::SymmetricDifference<'a, T>","std::slice::EscapeAscii<'a>","std::iter::Copied<I>","std::str::RMatches<'a, P>","std::collections::hash_map::Drain<'a, K, V>","std::sys::unix::process::process_common::CommandArgs<'a>","std::collections::btree_set::Union<'a, T>","std::option::IterMut<'a, A>","std::str::EscapeUnicode<'a>"]},"<arc_slice::ArcSlice<T> as std::iter::Extend<T>>::extend":{"I":["<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>","<&'a mut arc_slice::ArcSlice<T> as std::iter::IntoIterator>","arc_slice::ArcSlice"],"T":["macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.extend(p1);
+<arc_slice::ArcSlice<T> as std::iter::Extend<T>>::extend(p0, p1);
+crate::<arc_slice::ArcSlice<T> as std::iter::Extend<T>>::extend(p0, p1);
+<arc_slice::ArcSlice<T>>::extend(p0, p1);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::iter::Extend<&'a T>>::extend
'a
deps:{"<&'a arc_slice::ArcSlice<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut arc_slice::ArcSlice<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<arc_slice::ArcSlice<T> as std::iter::Extend<&'a T>>::extend":{"I":["std::iter::IntoIterator","std::marker::Sized"],"T":["std::marker::Sized","std::clone::Clone"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::marker::Sized","std::cmp::Eq","std::cmp::PartialOrd","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Ord"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
candidates:{"<&'a arc_slice::ArcSlice<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut arc_slice::ArcSlice<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::env::VarsOs","std::path::Components<'a>","std::sys::unix::os::SplitPaths<'a>","std::result::Iter<'a, T>","std::iter::TakeWhile<I, P>","std::iter::StepBy<I>","std::str::LinesAny<'a>","std::str::Chars<'a>","std::slice::ChunksExactMut<'a, T>","std::char::EscapeDebug","std::slice::Windows<'a, T>","std::collections::btree_set::Range<'a, T>","std::slice::ArrayWindows<'a, T, N>","std::collections::vec_deque::IterMut<'a, T>","std::iter::Inspect<I, F>","std::sys::unix::process::process_common::CommandArgs<'a>","std::slice::EscapeAscii<'a>","std::option::IterMut<'a, A>","std::collections::btree_map::Range<'a, K, V>","std::env::Args","std::collections::binary_heap::Iter<'a, T>","std::process::CommandArgs<'a>","std::slice::RChunksMut<'a, T>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::collections::btree_set::Intersection<'a, T, A>","std::fs::ReadDir","std::collections::btree_map::IntoIter<K, V, A>","std::str::EscapeUnicode<'a>","std::slice::Split<'a, T, P>","std::iter::Rev<I>","core::slice::iter::GenericSplitN<I>","std::net::Incoming<'a>","std::iter::Intersperse<I>","std::collections::vec_deque::IntoIter<T, A>","std::iter::Flatten<I>","std::str::RSplitN<'a, P>","std::vec::Splice<'_, I, A>","std::env::Vars","std::env::ArgsOs","std::ops::index_range::IndexRange","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::str::Bytes<'_>","std::slice::RChunksExactMut<'a, T>","std::iter::FlatMap<I, U, F>","std::iter::Successors<T, F>","std::slice::SplitInclusive<'a, T, P>","std::collections::hash_map::IterMut<'a, K, V>","std::iter::Take<I>","std::slice::RSplitNMut<'a, T, P>","std::iter::Peekable<I>","std::collections::btree_set::SymmetricDifference<'a, T>","std::iter::ByRefSized<'_, I>","std::slice::RChunksExact<'a, T>","std::ascii::EscapeDefault","<&mut I as std::iter::Iterator>","core::error::Source<'a>","std::slice::ArrayChunksMut<'a, T, N>","std::collections::btree_map::IntoValues<K, V, A>","std::str::SplitInclusive<'a, P>","std::sys::unix::os::Env","std::str::RSplit<'a, P>","std::collections::btree_map::Iter<'a, K, V>","std::sync::mpsc::Iter<'a, T>","std::slice::RSplitMut<'a, T, P>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::process::CommandEnvs<'a>","std::str::Split<'a, P>","std::path::Ancestors<'a>","std::iter::FromFn<F>","std::char::CaseMappingIter","std::collections::linked_list::Iter<'a, T>","std::ops::RangeInclusive<A>","std::str::SplitWhitespace<'a>","std::iter::Repeat<A>","std::sys::unix::args::Args","std::collections::hash_set::Iter<'a, K>","std::collections::hash_map::ValuesMut<'a, K, V>","std::slice::ChunksExact<'a, T>","std::iter::Empty<T>","std::iter::Enumerate<I>","std::slice::IterMut<'a, T>","std::os::unix::net::Incoming<'a>","std::sync::mpsc::IntoIter<T>","std::collections::vec_deque::Drain<'_, T, A>","std::str::Matches<'a, P>","std::os::unix::net::ScmRights<'a>","std::collections::btree_map::ValuesMut<'a, K, V>","std::collections::hash_set::Union<'a, T, S>","std::iter::Map<I, F>","std::str::RSplitTerminator<'a, P>","std::str::EscapeDefault<'a>","std::collections::hash_set::DrainFilter<'_, K, F>","std::net::IntoIncoming","std::collections::hash_set::IntoIter<K>","std::iter::Skip<I>","std::os::unix::net::Messages<'a>","std::slice::SplitN<'a, T, P>","std::str::SplitN<'a, P>","std::slice::ChunksMut<'a, T>","std::iter::FilterMap<I, F>","std::char::ToUppercase","std::char::EscapeDefault","std::collections::hash_set::Intersection<'a, T, S>","std::slice::GroupByMut<'a, T, P>","std::path::Iter<'a>","std::slice::RSplitN<'a, T, P>","std::collections::btree_set::IntoIter<T, A>","std::slice::RSplit<'a, T, P>","std::io::Lines<B>","std::boxed::Box<I, A>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::collections::btree_map::IntoKeys<K, V, A>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::string::Drain<'_>","std::str::SplitTerminator<'a, P>","std::collections::btree_map::RangeMut<'a, K, V>","std::iter::ArrayChunks<I, N>","std::vec::IntoIter<T, A>","std::str::Lines<'a>","std::collections::binary_heap::IntoIterSorted<T>","std::slice::Iter<'a, T>","std::char::DecodeUtf16<I>","std::collections::binary_heap::DrainSorted<'_, T>","std::iter::Filter<I, P>","std::result::IntoIter<T>","std::str::RMatches<'a, P>","std::io::Split<B>","std::ops::Range<A>","std::str::MatchIndices<'a, P>","std::sys_common::net::LookupHost","std::collections::hash_map::Values<'a, K, V>","std::collections::linked_list::IntoIter<T>","std::sync::mpsc::TryIter<'a, T>","std::collections::hash_map::Drain<'a, K, V>","std::option::Item<A>","std::iter::Scan<I, St, F>","std::str::Utf8Chunks<'a>","std::result::IterMut<'a, T>","std::collections::btree_set::Iter<'a, T>","std::collections::btree_set::Union<'a, T>","std::collections::btree_map::IterMut<'a, K, V>","std::iter::RepeatN<A>","std::iter::SkipWhile<I, P>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::iter::Copied<I>","std::collections::hash_map::IntoValues<K, V>","std::char::EscapeUnicode","std::iter::Chain<A, B>","std::collections::vec_deque::Iter<'a, T>","std::vec::DrainFilter<'_, T, F, A>","std::slice::SplitInclusiveMut<'a, T, P>","std::char::ToLowercase","std::sys_common::wstr::WStrUnits<'_>","std::iter::RepeatWith<F>","std::iter::Cloned<I>","std::sys_common::wtf8::EncodeWide<'a>","std::iter::OnceWith<F>","std::slice::SplitMut<'a, T, P>","std::slice::SplitNMut<'a, T, P>","std::slice::ArrayChunks<'a, T, N>","std::option::IntoIter<A>","std::iter::adapters::GenericShunt<'_, I, R>","std::str::CharIndices<'a>","std::vec::Drain<'_, T, A>","std::collections::binary_heap::Drain<'_, T>","std::iter::IntersperseWith<I, G>","std::slice::Chunks<'a, T>","std::iter::MapWhile<I, P>","std::collections::linked_list::IterMut<'a, T>","std::collections::hash_map::Keys<'a, K, V>","std::collections::hash_set::Difference<'a, T, S>","std::str::SplitAsciiWhitespace<'a>","std::collections::hash_set::Drain<'a, K>","std::collections::hash_map::Iter<'a, K, V>","std::slice::GroupBy<'a, T, P>","std::iter::Once<T>","std::iter::Fuse<I>","std::io::Bytes<R>","std::os::unix::net::ScmCredentials<'a>","std::collections::linked_list::DrainFilter<'_, T, F>","std::iter::Cycle<I>","std::collections::hash_map::IntoKeys<K, V>","std::str::RMatchIndices<'a, P>","std::iter::Zip<A, B>","std::collections::btree_map::Values<'a, K, V>","std::array::IntoIter<T, N>","std::str::EscapeDebug<'a>","std::env::SplitPaths<'a>","std::collections::btree_set::Difference<'a, T, A>","std::sys::unix::fs::ReadDir","std::collections::btree_map::Keys<'a, K, V>","std::ops::RangeFrom<A>","std::option::Iter<'a, A>","std::collections::binary_heap::IntoIter<T>","std::slice::RChunks<'a, T>","std::iter::sources::from_generator::FromGenerator<G>","std::str::EncodeUtf16<'a>","std::collections::hash_map::IntoIter<K, V>"]},"<arc_slice::ArcSlice<T> as std::iter::Extend<&'a T>>::extend":{"I":["<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>","arc_slice::ArcSlice","<&'a std::result::Result<T, E> as std::iter::IntoIterator>"],"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test"]},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.extend(p1);
+<arc_slice::ArcSlice<T> as std::iter::Extend<&'a T>>::extend(p0, p1);
+crate::<arc_slice::ArcSlice<T> as std::iter::Extend<&'a T>>::extend(p0, p1);
+<arc_slice::ArcSlice<T>>::extend(p0, p1);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::hash::Hash>::hash":{"H":["std::marker::Sized","std::hash::Hasher"],"T":["std::hash::Hash","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialEq","std::cmp::PartialOrd","std::cmp::Eq","std::clone::Clone","std::cmp::Ord","std::marker::Sized","std::fmt::Debug","std::hash::Hash"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::hash::Hash>::hash":{"H":["std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>","std::hash::SipHasher"],"T":["std::hash::impls::<impl std::hash::Hash for *mut T>","std::hash::impls::<impl std::hash::Hash for *const T>","arc_slice::ArcSlice"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","<*mut T as std::fmt::Debug>"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<arc_slice::ArcSlice<T> as std::hash::Hash>::hash(p0, p1);
+crate::<arc_slice::ArcSlice<T> as std::hash::Hash>::hash(p0, p1);
+<arc_slice::ArcSlice<T>>::hash(p0, p1);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter
deps:{"<*mut T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter":{"T":["std::clone::Clone","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::PartialOrd","std::cmp::Eq","std::hash::Hash","std::cmp::Ord"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter":{"T":["std::clone::impls::<impl std::clone::Clone for &T>","macros::Test","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.into_iter();
+<arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter(p0);
+<arc_slice::ArcSlice<T>>::into_iter(p0);
-----------------
src/arc_slice/mod.rs <&'a arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter
'a
deps:{"<&'a arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<&'a arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.into_iter();
+<&'a arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter(p0);
+<&'a arc_slice::ArcSlice<T>>::into_iter(p0);
-----------------
src/arc_slice/mod.rs <&'a mut arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter
'a
deps:{"<&'a mut arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter":{"T":["std::clone::Clone","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialOrd","std::cmp::Ord","std::hash::Hash","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&'a mut arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter":{"T":["macros::Test2","arc_slice::ArcSlice","macros::Test","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<T>
+p0.into_iter();
+<&'a mut arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a mut arc_slice::ArcSlice<T> as std::iter::IntoIterator>::into_iter(p0);
+<&'a mut arc_slice::ArcSlice<T>>::into_iter(p0);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<u8> as std::io::Write>::write
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<u8>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.write(p1);
+<arc_slice::ArcSlice<u8> as std::io::Write>::write(p0, p1);
+crate::<arc_slice::ArcSlice<u8> as std::io::Write>::write(p0, p1);
+<arc_slice::ArcSlice<u8>>::write(p0, p1);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<u8> as std::io::Write>::write_vectored
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<u8>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [std::io::IoSlice<'_>]
+p0.write_vectored(p1);
+<arc_slice::ArcSlice<u8> as std::io::Write>::write_vectored(p0, p1);
+crate::<arc_slice::ArcSlice<u8> as std::io::Write>::write_vectored(p0, p1);
+<arc_slice::ArcSlice<u8>>::write_vectored(p0, p1);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<u8> as std::io::Write>::write_all
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<u8>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.write_all(p1);
+<arc_slice::ArcSlice<u8> as std::io::Write>::write_all(p0, p1);
+crate::<arc_slice::ArcSlice<u8> as std::io::Write>::write_all(p0, p1);
+<arc_slice::ArcSlice<u8>>::write_all(p0, p1);
-----------------
src/arc_slice/mod.rs <arc_slice::ArcSlice<u8> as std::io::Write>::flush
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // arc_slice::ArcSlice<u8>
+p0.flush();
+<arc_slice::ArcSlice<u8> as std::io::Write>::flush(p0);
+crate::<arc_slice::ArcSlice<u8> as std::io::Write>::flush(p0);
+<arc_slice::ArcSlice<u8>>::flush(p0);
-----------------
src/scoped/imp/scoped.rs scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>::access
'a
deps:{"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>::access":{"R":["std::marker::Sized"],"S":["std::clone::Clone","std::marker::Sized","scoped::ScopedMut"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>::access":{"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::panic::AssertUnwindSafe<F>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","std::boxed::Box<F, A>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // S
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.access(p1);
+scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>::access(p0, p1);
+crate::scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>::access(p0, p1);
+<&'a mut S>::access(p0, p1);
-----------------
src/scoped/imp/scoped.rs scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>::access_mut
'a
deps:{"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>::access_mut":{"R":["std::marker::Sized"],"S":["scoped::ScopedMut","std::clone::Clone","std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>::access_mut":{"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // S
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.access_mut(p1);
+scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>::access_mut(p0, p1);
+crate::scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>::access_mut(p0, p1);
+<&'a mut S>::access_mut(p0, p1);
-----------------
src/scoped/imp/scoped.rs scoped::imp::scoped::<impl scoped::ScopedMut for std::boxed::Box<S>>::access
'a
deps:{"scoped::imp::scoped::<impl scoped::ScopedMut for std::boxed::Box<S>>::access":{"R":["std::marker::Sized"],"S":["std::clone::Clone","std::marker::Sized","scoped::ScopedMut"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"scoped::imp::scoped::<impl scoped::ScopedMut for std::boxed::Box<S>>::access":{"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::panic::AssertUnwindSafe<F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::boxed::Box<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.access(p1);
+scoped::imp::scoped::<impl scoped::ScopedMut for std::boxed::Box<S>>::access(p0, p1);
+crate::scoped::imp::scoped::<impl scoped::ScopedMut for std::boxed::Box<S>>::access(p0, p1);
+<std::boxed::Box<S>>::access(p0, p1);
-----------------
src/scoped/imp/scoped.rs scoped::imp::scoped::<impl scoped::ScopedMut for std::boxed::Box<S>>::access_mut
'a
deps:{"scoped::imp::scoped::<impl scoped::ScopedMut for std::boxed::Box<S>>::access_mut":{"R":["std::marker::Sized"],"S":["std::clone::Clone","std::marker::Sized","scoped::ScopedMut"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"scoped::imp::scoped::<impl scoped::ScopedMut for std::boxed::Box<S>>::access_mut":{"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::LinesAnyMap","std::panic::AssertUnwindSafe<F>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::boxed::Box<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.access_mut(p1);
+scoped::imp::scoped::<impl scoped::ScopedMut for std::boxed::Box<S>>::access_mut(p0, p1);
+crate::scoped::imp::scoped::<impl scoped::ScopedMut for std::boxed::Box<S>>::access_mut(p0, p1);
+<std::boxed::Box<S>>::access_mut(p0, p1);
-----------------
src/scoped/imp/scoped.rs scoped::imp::scoped::<impl scoped::ScopedMut for std::borrow::Cow<'_, S>>::access
deps:{"scoped::imp::scoped::<impl scoped::ScopedMut for std::borrow::Cow<'_, S>>::access":{"R":["std::marker::Sized"],"S":["scoped::ScopedMut","std::clone::Clone","std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"scoped::imp::scoped::<impl scoped::ScopedMut for std::borrow::Cow<'_, S>>::access":{"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::panic::AssertUnwindSafe<F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'_, S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.access(p1);
+scoped::imp::scoped::<impl scoped::ScopedMut for std::borrow::Cow<'_, S>>::access(p0, p1);
+crate::scoped::imp::scoped::<impl scoped::ScopedMut for std::borrow::Cow<'_, S>>::access(p0, p1);
+<std::borrow::Cow<'_, S>>::access(p0, p1);
-----------------
src/scoped/imp/scoped.rs scoped::imp::scoped::<impl scoped::ScopedMut for std::borrow::Cow<'_, S>>::access_mut
deps:{"scoped::imp::scoped::<impl scoped::ScopedMut for std::borrow::Cow<'_, S>>::access_mut":{"R":["std::marker::Sized"],"S":["scoped::ScopedMut","std::marker::Sized","std::clone::Clone"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"scoped::imp::scoped::<impl scoped::ScopedMut for std::borrow::Cow<'_, S>>::access_mut":{"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::panic::AssertUnwindSafe<F>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'_, S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.access_mut(p1);
+scoped::imp::scoped::<impl scoped::ScopedMut for std::borrow::Cow<'_, S>>::access_mut(p0, p1);
+crate::scoped::imp::scoped::<impl scoped::ScopedMut for std::borrow::Cow<'_, S>>::access_mut(p0, p1);
+<std::borrow::Cow<'_, S>>::access_mut(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for std::cell::RefCell<S>>::interior_access
deps:{"<&A as std::alloc::Allocator>":{},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Ord","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::Eq","std::clone::Clone","std::hash::Hash"]},"scoped::imp::interior::<impl scoped::Interior for std::cell::RefCell<S>>::interior_access":{"R":["std::marker::Sized"],"S":["std::marker::Sized","scoped::ScopedMut"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<T as std::borrow::ToOwned>":{"T":["macros::Test","std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","arc_slice::ArcSlice"]},"scoped::imp::interior::<impl scoped::Interior for std::cell::RefCell<S>>::interior_access":{"R":["RUG_ANY"],"S":["std::cell::RefCell","std::sync::RwLock","std::borrow::Cow","std::boxed::Box","scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>","std::rc::Rc","std::sync::Arc"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::IsWhitespace","std::panic::AssertUnwindSafe<F>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::ffi::CStr","<T as std::borrow::ToOwned>","std::path::Path","std::ffi::OsStr"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.interior_access(p1);
+scoped::imp::interior::<impl scoped::Interior for std::cell::RefCell<S>>::interior_access(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for std::cell::RefCell<S>>::interior_access(p0, p1);
+<std::cell::RefCell<S>>::interior_access(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for std::cell::RefCell<S>>::interior_access_mut
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<T as std::borrow::ToOwned>":{"T":["std::clone::Clone","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::cmp::PartialOrd","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::Ord"]},"scoped::imp::interior::<impl scoped::Interior for std::cell::RefCell<S>>::interior_access_mut":{"R":["std::marker::Sized"],"S":["scoped::ScopedMut","std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<T as std::borrow::ToOwned>":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2","arc_slice::ArcSlice","macros::Test"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"scoped::imp::interior::<impl scoped::Interior for std::cell::RefCell<S>>::interior_access_mut":{"R":["RUG_ANY"],"S":["scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>","std::borrow::Cow","std::boxed::Box","std::sync::Arc","std::cell::RefCell","std::rc::Rc","std::sync::RwLock"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["<T as std::borrow::ToOwned>","std::ffi::OsStr","std::path::Path","std::ffi::CStr"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.interior_access_mut(p1);
+scoped::imp::interior::<impl scoped::Interior for std::cell::RefCell<S>>::interior_access_mut(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for std::cell::RefCell<S>>::interior_access_mut(p0, p1);
+<std::cell::RefCell<S>>::interior_access_mut(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for std::sync::RwLock<S>>::interior_access
deps:{"<&A as std::alloc::Allocator>":{},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::hash::Hash","std::cmp::Ord","std::cmp::PartialOrd","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"scoped::imp::interior::<impl scoped::Interior for std::sync::RwLock<S>>::interior_access":{"R":["std::marker::Sized"],"S":["scoped::ScopedMut","std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<T as std::borrow::ToOwned>":{"T":["macros::Test2","macros::Test","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for &T>"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"scoped::imp::interior::<impl scoped::Interior for std::sync::RwLock<S>>::interior_access":{"R":["RUG_ANY"],"S":["scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>","std::rc::Rc","std::sync::Arc","std::borrow::Cow","std::sync::RwLock","std::cell::RefCell","std::boxed::Box"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","std::panic::AssertUnwindSafe<F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::ffi::OsStr","std::path::Path","std::ffi::CStr","<T as std::borrow::ToOwned>"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::RwLock<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.interior_access(p1);
+scoped::imp::interior::<impl scoped::Interior for std::sync::RwLock<S>>::interior_access(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for std::sync::RwLock<S>>::interior_access(p0, p1);
+<std::sync::RwLock<S>>::interior_access(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for std::sync::RwLock<S>>::interior_access_mut
deps:{"<&A as std::alloc::Allocator>":{},"<T as std::borrow::ToOwned>":{"T":["std::clone::Clone","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::PartialOrd","std::hash::Hash","std::cmp::Ord","std::marker::Sized"]},"scoped::imp::interior::<impl scoped::Interior for std::sync::RwLock<S>>::interior_access_mut":{"R":["std::marker::Sized"],"S":["std::marker::Sized","scoped::ScopedMut"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<T as std::borrow::ToOwned>":{"T":["arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","arc_slice::ArcSlice"]},"scoped::imp::interior::<impl scoped::Interior for std::sync::RwLock<S>>::interior_access_mut":{"R":["RUG_ANY"],"S":["std::borrow::Cow","std::sync::Arc","scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>","std::boxed::Box","std::sync::RwLock","std::rc::Rc","std::cell::RefCell"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","std::panic::AssertUnwindSafe<F>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::ffi::OsStr","std::ffi::CStr","<T as std::borrow::ToOwned>","std::path::Path"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::RwLock<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.interior_access_mut(p1);
+scoped::imp::interior::<impl scoped::Interior for std::sync::RwLock<S>>::interior_access_mut(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for std::sync::RwLock<S>>::interior_access_mut(p0, p1);
+<std::sync::RwLock<S>>::interior_access_mut(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for &'a C>::interior_access
'a
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>::interior_access":{"C":["std::marker::Sized","scoped::Interior"],"R":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>::interior_access":{"C":["std::sync::RwLock","std::rc::Rc","std::sync::Arc","scoped::imp::interior::<impl scoped::Interior for &'a C>","std::boxed::Box","scoped::imp::interior::<impl scoped::Interior for &'a mut C>","std::cell::RefCell"],"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","std::panic::AssertUnwindSafe<F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr"]},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // C
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.interior_access(p1);
+scoped::imp::interior::<impl scoped::Interior for &'a C>::interior_access(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for &'a C>::interior_access(p0, p1);
+<&'a C>::interior_access(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for &'a C>::interior_access_mut
'a
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>::interior_access_mut":{"C":["scoped::Interior","std::marker::Sized"],"R":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>::interior_access_mut":{"C":["std::sync::RwLock","std::cell::RefCell","std::boxed::Box","std::rc::Rc","scoped::imp::interior::<impl scoped::Interior for &'a mut C>","std::sync::Arc"],"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::panic::AssertUnwindSafe<F>","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // C
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.interior_access_mut(p1);
+scoped::imp::interior::<impl scoped::Interior for &'a C>::interior_access_mut(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for &'a C>::interior_access_mut(p0, p1);
+<&'a C>::interior_access_mut(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for &'a mut C>::interior_access
'a
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>::interior_access":{"C":["std::marker::Sized","scoped::Interior"],"R":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>::interior_access":{"C":["scoped::imp::interior::<impl scoped::Interior for &'a mut C>","std::rc::Rc","std::cell::RefCell","std::sync::Arc","std::boxed::Box","std::sync::RwLock"],"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // C
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.interior_access(p1);
+scoped::imp::interior::<impl scoped::Interior for &'a mut C>::interior_access(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for &'a mut C>::interior_access(p0, p1);
+<&'a mut C>::interior_access(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for &'a mut C>::interior_access_mut
'a
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>::interior_access_mut":{"C":["std::marker::Sized","scoped::Interior"],"R":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>::interior_access_mut":{"C":["scoped::imp::interior::<impl scoped::Interior for &'a mut C>","scoped::imp::interior::<impl scoped::Interior for &'a C>","std::sync::RwLock","std::rc::Rc","std::cell::RefCell","std::boxed::Box","std::sync::Arc"],"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","std::panic::AssertUnwindSafe<F>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // C
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.interior_access_mut(p1);
+scoped::imp::interior::<impl scoped::Interior for &'a mut C>::interior_access_mut(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for &'a mut C>::interior_access_mut(p0, p1);
+<&'a mut C>::interior_access_mut(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for std::boxed::Box<C>>::interior_access
'a
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for std::boxed::Box<C>>::interior_access":{"C":["std::marker::Sized","scoped::Interior"],"R":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for std::boxed::Box<C>>::interior_access":{"C":["scoped::imp::interior::<impl scoped::Interior for &'a mut C>","std::cell::RefCell","scoped::imp::interior::<impl scoped::Interior for &'a C>","std::sync::Arc","std::boxed::Box","std::sync::RwLock","std::rc::Rc"],"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::panic::AssertUnwindSafe<F>"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::boxed::Box<C>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.interior_access(p1);
+scoped::imp::interior::<impl scoped::Interior for std::boxed::Box<C>>::interior_access(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for std::boxed::Box<C>>::interior_access(p0, p1);
+<std::boxed::Box<C>>::interior_access(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for std::boxed::Box<C>>::interior_access_mut
'a
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for std::boxed::Box<C>>::interior_access_mut":{"C":["std::marker::Sized","scoped::Interior"],"R":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for std::boxed::Box<C>>::interior_access_mut":{"C":["scoped::imp::interior::<impl scoped::Interior for &'a C>","scoped::imp::interior::<impl scoped::Interior for &'a mut C>","std::rc::Rc","std::sync::RwLock","std::boxed::Box","std::cell::RefCell","std::sync::Arc"],"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::LinesAnyMap","std::panic::AssertUnwindSafe<F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::boxed::Box<C>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.interior_access_mut(p1);
+scoped::imp::interior::<impl scoped::Interior for std::boxed::Box<C>>::interior_access_mut(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for std::boxed::Box<C>>::interior_access_mut(p0, p1);
+<std::boxed::Box<C>>::interior_access_mut(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for std::rc::Rc<C>>::interior_access
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for std::rc::Rc<C>>::interior_access":{"C":["scoped::Interior","std::marker::Sized"],"R":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for std::rc::Rc<C>>::interior_access":{"C":["std::cell::RefCell","std::boxed::Box","std::sync::RwLock","std::sync::Arc","scoped::imp::interior::<impl scoped::Interior for &'a mut C>","std::rc::Rc","scoped::imp::interior::<impl scoped::Interior for &'a C>"],"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","std::panic::AssertUnwindSafe<F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::rc::Rc<C>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.interior_access(p1);
+scoped::imp::interior::<impl scoped::Interior for std::rc::Rc<C>>::interior_access(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for std::rc::Rc<C>>::interior_access(p0, p1);
+<std::rc::Rc<C>>::interior_access(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for std::rc::Rc<C>>::interior_access_mut
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for std::rc::Rc<C>>::interior_access_mut":{"C":["std::marker::Sized","scoped::Interior"],"R":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for std::rc::Rc<C>>::interior_access_mut":{"C":["std::cell::RefCell","std::sync::RwLock","std::rc::Rc","std::sync::Arc","std::boxed::Box","scoped::imp::interior::<impl scoped::Interior for &'a mut C>","scoped::imp::interior::<impl scoped::Interior for &'a C>"],"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["std::panic::AssertUnwindSafe<F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::BytesIsNotEmpty"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::rc::Rc<C>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.interior_access_mut(p1);
+scoped::imp::interior::<impl scoped::Interior for std::rc::Rc<C>>::interior_access_mut(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for std::rc::Rc<C>>::interior_access_mut(p0, p1);
+<std::rc::Rc<C>>::interior_access_mut(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for std::sync::Arc<C>>::interior_access
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for std::sync::Arc<C>>::interior_access":{"C":["std::marker::Sized","scoped::Interior"],"R":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for std::sync::Arc<C>>::interior_access":{"C":["std::cell::RefCell","scoped::imp::interior::<impl scoped::Interior for &'a C>","std::rc::Rc","scoped::imp::interior::<impl scoped::Interior for &'a mut C>","std::boxed::Box","std::sync::RwLock","std::sync::Arc"],"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::CharEscapeDefault","std::panic::AssertUnwindSafe<F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::Arc<C>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.interior_access(p1);
+scoped::imp::interior::<impl scoped::Interior for std::sync::Arc<C>>::interior_access(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for std::sync::Arc<C>>::interior_access(p0, p1);
+<std::sync::Arc<C>>::interior_access(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::Interior for std::sync::Arc<C>>::interior_access_mut
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for std::sync::Arc<C>>::interior_access_mut":{"C":["scoped::Interior","std::marker::Sized"],"R":["std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::Interior for std::sync::Arc<C>>::interior_access_mut":{"C":["std::sync::RwLock","std::rc::Rc","scoped::imp::interior::<impl scoped::Interior for &'a mut C>","std::sync::Arc","std::cell::RefCell","std::boxed::Box","scoped::imp::interior::<impl scoped::Interior for &'a C>"],"R":["RUG_ANY"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::Arc<C>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.interior_access_mut(p1);
+scoped::imp::interior::<impl scoped::Interior for std::sync::Arc<C>>::interior_access_mut(p0, p1);
+crate::scoped::imp::interior::<impl scoped::Interior for std::sync::Arc<C>>::interior_access_mut(p0, p1);
+<std::sync::Arc<C>>::interior_access_mut(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::ScopedMut for std::cell::RefCell<S>>::access
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<T as std::borrow::ToOwned>":{"T":["std::clone::Clone","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::PartialOrd","std::cmp::Ord","std::hash::Hash","std::marker::Sized"]},"scoped::imp::interior::<impl scoped::ScopedMut for std::cell::RefCell<S>>::access":{"R":["std::marker::Sized"],"S":["std::marker::Sized","scoped::ScopedMut"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<T as std::borrow::ToOwned>":{"T":["macros::Test","macros::Test2","arc_slice::ArcSlice","std::clone::impls::<impl std::clone::Clone for *const T>"]},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","arc_slice::ArcSlice"]},"scoped::imp::interior::<impl scoped::ScopedMut for std::cell::RefCell<S>>::access":{"R":["RUG_ANY"],"S":["scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>","std::sync::Arc","std::boxed::Box","std::rc::Rc","std::cell::RefCell","std::borrow::Cow","std::sync::RwLock"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::panic::AssertUnwindSafe<F>","std::boxed::Box<F, A>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::ffi::OsStr","<T as std::borrow::ToOwned>","std::ffi::CStr","std::path::Path"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.access(p1);
+scoped::imp::interior::<impl scoped::ScopedMut for std::cell::RefCell<S>>::access(p0, p1);
+crate::scoped::imp::interior::<impl scoped::ScopedMut for std::cell::RefCell<S>>::access(p0, p1);
+<std::cell::RefCell<S>>::access(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::ScopedMut for std::cell::RefCell<S>>::access_mut
deps:{"<&A as std::alloc::Allocator>":{},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"arc_slice::ArcSlice":{"T":["std::marker::Sized","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::cmp::Eq","std::cmp::Ord","std::clone::Clone"]},"scoped::imp::interior::<impl scoped::ScopedMut for std::cell::RefCell<S>>::access_mut":{"R":["std::marker::Sized"],"S":["std::marker::Sized","scoped::ScopedMut"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<T as std::borrow::ToOwned>":{"T":["std::clone::impls::<impl std::clone::Clone for &T>","arc_slice::ArcSlice","macros::Test2","macros::Test"]},"arc_slice::ArcSlice":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","arc_slice::ArcSlice"]},"scoped::imp::interior::<impl scoped::ScopedMut for std::cell::RefCell<S>>::access_mut":{"R":["RUG_ANY"],"S":["std::rc::Rc","std::cell::RefCell","std::boxed::Box","std::sync::Arc","std::sync::RwLock","scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>","std::borrow::Cow"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::panic::AssertUnwindSafe<F>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::ffi::CStr","std::path::Path","<T as std::borrow::ToOwned>","std::ffi::OsStr"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::cell::RefCell<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.access_mut(p1);
+scoped::imp::interior::<impl scoped::ScopedMut for std::cell::RefCell<S>>::access_mut(p0, p1);
+crate::scoped::imp::interior::<impl scoped::ScopedMut for std::cell::RefCell<S>>::access_mut(p0, p1);
+<std::cell::RefCell<S>>::access_mut(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::ScopedMut for std::sync::RwLock<S>>::access
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"arc_slice::ArcSlice":{"T":["std::hash::Hash","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::cmp::PartialOrd","std::clone::Clone","std::cmp::Ord","std::fmt::Debug"]},"scoped::imp::interior::<impl scoped::ScopedMut for std::sync::RwLock<S>>::access":{"R":["std::marker::Sized"],"S":["std::marker::Sized","scoped::ScopedMut"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<T as std::borrow::ToOwned>":{"T":["arc_slice::ArcSlice","macros::Test2","std::clone::impls::<impl std::clone::Clone for &T>","macros::Test"]},"arc_slice::ArcSlice":{"T":["arc_slice::ArcSlice","std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>"]},"scoped::imp::interior::<impl scoped::ScopedMut for std::sync::RwLock<S>>::access":{"R":["RUG_ANY"],"S":["std::sync::Arc","std::cell::RefCell","scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>","std::boxed::Box","std::borrow::Cow","std::sync::RwLock","std::rc::Rc"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::panic::AssertUnwindSafe<F>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::ffi::CStr","<T as std::borrow::ToOwned>","std::ffi::OsStr","std::path::Path"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::RwLock<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.access(p1);
+scoped::imp::interior::<impl scoped::ScopedMut for std::sync::RwLock<S>>::access(p0, p1);
+crate::scoped::imp::interior::<impl scoped::ScopedMut for std::sync::RwLock<S>>::access(p0, p1);
+<std::sync::RwLock<S>>::access(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::ScopedMut for std::sync::RwLock<S>>::access_mut
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<T as std::borrow::ToOwned>":{"T":["std::clone::Clone","std::marker::Sized"]},"arc_slice::ArcSlice":{"T":["std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::cmp::Ord","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::hash::Hash"]},"scoped::imp::interior::<impl scoped::ScopedMut for std::sync::RwLock<S>>::access_mut":{"R":["std::marker::Sized"],"S":["std::marker::Sized","scoped::ScopedMut"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<T as std::borrow::ToOwned>":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","arc_slice::ArcSlice","macros::Test","macros::Test2"]},"arc_slice::ArcSlice":{"T":["std::hash::impls::<impl std::hash::Hash for *mut T>","arc_slice::ArcSlice"]},"scoped::imp::interior::<impl scoped::ScopedMut for std::sync::RwLock<S>>::access_mut":{"R":["RUG_ANY"],"S":["std::sync::RwLock","std::cell::RefCell","scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>","std::boxed::Box","std::sync::Arc","std::rc::Rc","std::borrow::Cow"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","std::panic::AssertUnwindSafe<F>","core::str::IsAsciiWhitespace"]},"scoped::imp::scoped::<impl scoped::ScopedMut for &'a mut S>":{},"std::borrow::Cow":{"B":["std::ffi::CStr","std::ffi::OsStr","<T as std::borrow::ToOwned>","std::path::Path"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::sync::RwLock<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.access_mut(p1);
+scoped::imp::interior::<impl scoped::ScopedMut for std::sync::RwLock<S>>::access_mut(p0, p1);
+crate::scoped::imp::interior::<impl scoped::ScopedMut for std::sync::RwLock<S>>::access_mut(p0, p1);
+<std::sync::RwLock<S>>::access_mut(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::ScopedMut for std::rc::Rc<S>>::access
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::ScopedMut for std::rc::Rc<S>>::access":{"R":["std::marker::Sized"],"S":["scoped::Interior","std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::ScopedMut for std::rc::Rc<S>>::access":{"R":["RUG_ANY"],"S":["std::boxed::Box","std::sync::Arc","std::rc::Rc","scoped::imp::interior::<impl scoped::Interior for &'a C>","std::cell::RefCell","std::sync::RwLock"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::panic::AssertUnwindSafe<F>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::rc::Rc<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.access(p1);
+scoped::imp::interior::<impl scoped::ScopedMut for std::rc::Rc<S>>::access(p0, p1);
+crate::scoped::imp::interior::<impl scoped::ScopedMut for std::rc::Rc<S>>::access(p0, p1);
+<std::rc::Rc<S>>::access(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::ScopedMut for std::rc::Rc<S>>::access_mut
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::ScopedMut for std::rc::Rc<S>>::access_mut":{"R":["std::marker::Sized"],"S":["std::marker::Sized","scoped::Interior"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::ScopedMut for std::rc::Rc<S>>::access_mut":{"R":["RUG_ANY"],"S":["scoped::imp::interior::<impl scoped::Interior for &'a C>","std::sync::RwLock","std::cell::RefCell","std::sync::Arc","scoped::imp::interior::<impl scoped::Interior for &'a mut C>","std::boxed::Box","std::rc::Rc"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","std::panic::AssertUnwindSafe<F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::rc::Rc<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.access_mut(p1);
+scoped::imp::interior::<impl scoped::ScopedMut for std::rc::Rc<S>>::access_mut(p0, p1);
+crate::scoped::imp::interior::<impl scoped::ScopedMut for std::rc::Rc<S>>::access_mut(p0, p1);
+<std::rc::Rc<S>>::access_mut(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::ScopedMut for std::sync::Arc<S>>::access
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::ScopedMut for std::sync::Arc<S>>::access":{"R":["std::marker::Sized"],"S":["scoped::Interior","std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&T) -> R":["std::marker::Sized","std::ops::FnOnce"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::ScopedMut for std::sync::Arc<S>>::access":{"R":["RUG_ANY"],"S":["std::cell::RefCell","scoped::imp::interior::<impl scoped::Interior for &'a mut C>","std::sync::RwLock","std::rc::Rc","std::boxed::Box","scoped::imp::interior::<impl scoped::Interior for &'a C>","std::sync::Arc"],"T":["RUG_ANY"],"impl FnOnce(&T) -> R":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::Arc<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&T) -> R
+p0.access(p1);
+scoped::imp::interior::<impl scoped::ScopedMut for std::sync::Arc<S>>::access(p0, p1);
+crate::scoped::imp::interior::<impl scoped::ScopedMut for std::sync::Arc<S>>::access(p0, p1);
+<std::sync::Arc<S>>::access(p0, p1);
-----------------
src/scoped/imp/interior.rs scoped::imp::interior::<impl scoped::ScopedMut for std::sync::Arc<S>>::access_mut
deps:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::ScopedMut for std::sync::Arc<S>>::access_mut":{"R":["std::marker::Sized"],"S":["scoped::Interior","std::marker::Sized"],"T":["std::marker::Sized"],"impl FnOnce(&mut T) -> R":["std::ops::FnOnce","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"scoped::imp::interior::<impl scoped::Interior for &'a C>":{},"scoped::imp::interior::<impl scoped::Interior for &'a mut C>":{},"scoped::imp::interior::<impl scoped::ScopedMut for std::sync::Arc<S>>::access_mut":{"R":["RUG_ANY"],"S":["std::cell::RefCell","std::boxed::Box","std::sync::RwLock","std::sync::Arc","scoped::imp::interior::<impl scoped::Interior for &'a mut C>","std::rc::Rc"],"T":["RUG_ANY"],"impl FnOnce(&mut T) -> R":["core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","std::panic::AssertUnwindSafe<F>","core::str::IsNotEmpty"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::sync::Arc<S>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut T) -> R
+p0.access_mut(p1);
+scoped::imp::interior::<impl scoped::ScopedMut for std::sync::Arc<S>>::access_mut(p0, p1);
+crate::scoped::imp::interior::<impl scoped::ScopedMut for std::sync::Arc<S>>::access_mut(p0, p1);
+<std::sync::Arc<S>>::access_mut(p0, p1);
-----------------
src/not_empty.rs <&std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty
deps:{"<&std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty":{"T":["std::marker::Sized"]}}
candidates:{"<&std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty":{"T":["RUG_ANY"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // std::vec::Vec<T>
+p0._is_empty();
+<&std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty(p0);
+crate::<&std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty(p0);
+<&std::vec::Vec<T>>::_is_empty(p0);
-----------------
src/not_empty.rs <&mut std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty
deps:{"<&mut std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty":{"T":["std::marker::Sized"]}}
candidates:{"<&mut std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty":{"T":["RUG_ANY"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // std::vec::Vec<T>
+p0._is_empty();
+<&mut std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty(p0);
+crate::<&mut std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty(p0);
+<&mut std::vec::Vec<T>>::_is_empty(p0);
-----------------
src/not_empty.rs <std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty
deps:{"<std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty":{"T":["std::marker::Sized"]}}
candidates:{"<std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::vec::Vec<T>
+p0._is_empty();
+<std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty(p0);
+crate::<std::vec::Vec<T> as not_empty::NotEmpty>::_is_empty(p0);
+<std::vec::Vec<T>>::_is_empty(p0);
-----------------
src/not_empty.rs <&str as not_empty::NotEmpty>::_is_empty
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&str
+p0._is_empty();
+<&str as not_empty::NotEmpty>::_is_empty(p0);
+crate::<&str as not_empty::NotEmpty>::_is_empty(p0);
+<&str>::_is_empty(p0);
-----------------
src/not_empty.rs <&mut str as not_empty::NotEmpty>::_is_empty
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&mut str
+p0._is_empty();
+<&mut str as not_empty::NotEmpty>::_is_empty(p0);
+crate::<&mut str as not_empty::NotEmpty>::_is_empty(p0);
+<&mut str>::_is_empty(p0);
-----------------
src/not_empty.rs <&std::string::String as not_empty::NotEmpty>::_is_empty
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+&std::string::String
+p0._is_empty();
+<&std::string::String as not_empty::NotEmpty>::_is_empty(p0);
+crate::<&std::string::String as not_empty::NotEmpty>::_is_empty(p0);
+<&std::string::String>::_is_empty(p0);
-----------------
src/not_empty.rs <&mut std::string::String as not_empty::NotEmpty>::_is_empty
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+&mut std::string::String
+p0._is_empty();
+<&mut std::string::String as not_empty::NotEmpty>::_is_empty(p0);
+crate::<&mut std::string::String as not_empty::NotEmpty>::_is_empty(p0);
+<&mut std::string::String>::_is_empty(p0);
-----------------
src/not_empty.rs <std::string::String as not_empty::NotEmpty>::_is_empty
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+p0._is_empty();
+<std::string::String as not_empty::NotEmpty>::_is_empty(p0);
+crate::<std::string::String as not_empty::NotEmpty>::_is_empty(p0);
+<std::string::String>::_is_empty(p0);
-----------------
src/not_empty.rs <&std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty
deps:{"<&std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty":{"T":["std::marker::Sized"]}}
candidates:{"<&std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty":{"T":["RUG_ANY"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // std::collections::HashSet<T>
+p0._is_empty();
+<&std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty(p0);
+crate::<&std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty(p0);
+<&std::collections::HashSet<T>>::_is_empty(p0);
-----------------
src/not_empty.rs <&mut std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty
deps:{"<&mut std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty":{"T":["std::marker::Sized"]}}
candidates:{"<&mut std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty":{"T":["RUG_ANY"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // std::collections::HashSet<T>
+p0._is_empty();
+<&mut std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty(p0);
+crate::<&mut std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty(p0);
+<&mut std::collections::HashSet<T>>::_is_empty(p0);
-----------------
src/not_empty.rs <std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty
deps:{"<std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty":{"T":["std::marker::Sized"]}}
candidates:{"<std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::collections::HashSet<T>
+p0._is_empty();
+<std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty(p0);
+crate::<std::collections::HashSet<T> as not_empty::NotEmpty>::_is_empty(p0);
+<std::collections::HashSet<T>>::_is_empty(p0);
-----------------
src/not_empty.rs <&std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty
deps:{"<&std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<&std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // std::collections::HashMap<K, V>
+p0._is_empty();
+<&std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty(p0);
+crate::<&std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty(p0);
+<&std::collections::HashMap<K, V>>::_is_empty(p0);
-----------------
src/not_empty.rs <&mut std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty
deps:{"<&mut std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<&mut std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // std::collections::HashMap<K, V>
+p0._is_empty();
+<&mut std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty(p0);
+crate::<&mut std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty(p0);
+<&mut std::collections::HashMap<K, V>>::_is_empty(p0);
-----------------
src/not_empty.rs <std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty
deps:{"<std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::collections::HashMap<K, V>
+p0._is_empty();
+<std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty(p0);
+crate::<std::collections::HashMap<K, V> as not_empty::NotEmpty>::_is_empty(p0);
+<std::collections::HashMap<K, V>>::_is_empty(p0);
-----------------
src/from_into.rs <T as from_into::FromInto<U>>::qfrom
deps:{"<T as from_into::FromInto<U>>::qfrom":{"T":["std::convert::From","std::convert::Into","std::marker::Sized"],"U":["std::marker::Sized"]}}
candidates:{"<T as from_into::FromInto<U>>::qfrom":{"T":["u8","i8"],"U":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // U
+<T as from_into::FromInto<U>>::qfrom(p0);
+crate::<T as from_into::FromInto<U>>::qfrom(p0);
+<T>::qfrom(p0);
-----------------
src/from_into.rs <T as from_into::FromInto<U>>::qinto
deps:{"<T as from_into::FromInto<U>>::qinto":{"T":["std::convert::Into","std::marker::Sized","std::convert::From"],"U":["std::marker::Sized"]}}
candidates:{"<T as from_into::FromInto<U>>::qinto":{"T":["u8","i8"],"U":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.qinto();
+<T as from_into::FromInto<U>>::qinto(p0);
+crate::<T as from_into::FromInto<U>>::qinto(p0);
+<T>::qinto(p0);
-----------------
src/macros.rs <macros::Test as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.clone();
+<macros::Test as std::clone::Clone>::clone(p0);
+crate::<macros::Test as std::clone::Clone>::clone(p0);
+<macros::Test>::clone(p0);
-----------------
src/macros.rs <macros::Test as std::ops::AddAssign>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add_assign(p1);
+<macros::Test as std::ops::AddAssign>::add_assign(p0, p1);
+crate::<macros::Test as std::ops::AddAssign>::add_assign(p0, p1);
+<macros::Test>::add_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::AddAssign<macros::Test>>::add_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add_assign(p1);
+<&'a mut macros::Test as std::ops::AddAssign<macros::Test>>::add_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::AddAssign<macros::Test>>::add_assign(p0, p1);
+<&'a mut macros::Test>::add_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Add>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add(p1);
+<macros::Test as std::ops::Add>::add(p0, p1);
+crate::<macros::Test as std::ops::Add>::add(p0, p1);
+<macros::Test>::add(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Add<macros::Test>>::add
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add(p1);
+<&'a macros::Test as std::ops::Add<macros::Test>>::add(p0, p1);
+crate::<&'a macros::Test as std::ops::Add<macros::Test>>::add(p0, p1);
+<&'a macros::Test>::add(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Add<macros::Test>>::add
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add(p1);
+<&'a mut macros::Test as std::ops::Add<macros::Test>>::add(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Add<macros::Test>>::add(p0, p1);
+<&'a mut macros::Test>::add(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::AddAssign<&macros::Test>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add_assign(p1);
+<macros::Test as std::ops::AddAssign<&macros::Test>>::add_assign(p0, p1);
+crate::<macros::Test as std::ops::AddAssign<&macros::Test>>::add_assign(p0, p1);
+<macros::Test>::add_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::AddAssign<&macros::Test>>::add_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add_assign(p1);
+<&'a mut macros::Test as std::ops::AddAssign<&macros::Test>>::add_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::AddAssign<&macros::Test>>::add_assign(p0, p1);
+<&'a mut macros::Test>::add_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Add<&macros::Test>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add(p1);
+<macros::Test as std::ops::Add<&macros::Test>>::add(p0, p1);
+crate::<macros::Test as std::ops::Add<&macros::Test>>::add(p0, p1);
+<macros::Test>::add(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Add<&macros::Test>>::add
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add(p1);
+<&'a macros::Test as std::ops::Add<&macros::Test>>::add(p0, p1);
+crate::<&'a macros::Test as std::ops::Add<&macros::Test>>::add(p0, p1);
+<&'a macros::Test>::add(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Add<&macros::Test>>::add
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add(p1);
+<&'a mut macros::Test as std::ops::Add<&macros::Test>>::add(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Add<&macros::Test>>::add(p0, p1);
+<&'a mut macros::Test>::add(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::AddAssign<&mut macros::Test>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add_assign(p1);
+<macros::Test as std::ops::AddAssign<&mut macros::Test>>::add_assign(p0, p1);
+crate::<macros::Test as std::ops::AddAssign<&mut macros::Test>>::add_assign(p0, p1);
+<macros::Test>::add_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::AddAssign<&mut macros::Test>>::add_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add_assign(p1);
+<&'a mut macros::Test as std::ops::AddAssign<&mut macros::Test>>::add_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::AddAssign<&mut macros::Test>>::add_assign(p0, p1);
+<&'a mut macros::Test>::add_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Add<&mut macros::Test>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add(p1);
+<macros::Test as std::ops::Add<&mut macros::Test>>::add(p0, p1);
+crate::<macros::Test as std::ops::Add<&mut macros::Test>>::add(p0, p1);
+<macros::Test>::add(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Add<&mut macros::Test>>::add
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add(p1);
+<&'a macros::Test as std::ops::Add<&mut macros::Test>>::add(p0, p1);
+crate::<&'a macros::Test as std::ops::Add<&mut macros::Test>>::add(p0, p1);
+<&'a macros::Test>::add(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Add<&mut macros::Test>>::add
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.add(p1);
+<&'a mut macros::Test as std::ops::Add<&mut macros::Test>>::add(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Add<&mut macros::Test>>::add(p0, p1);
+<&'a mut macros::Test>::add(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::SubAssign>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub_assign(p1);
+<macros::Test as std::ops::SubAssign>::sub_assign(p0, p1);
+crate::<macros::Test as std::ops::SubAssign>::sub_assign(p0, p1);
+<macros::Test>::sub_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::SubAssign<macros::Test>>::sub_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub_assign(p1);
+<&'a mut macros::Test as std::ops::SubAssign<macros::Test>>::sub_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::SubAssign<macros::Test>>::sub_assign(p0, p1);
+<&'a mut macros::Test>::sub_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Sub>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub(p1);
+<macros::Test as std::ops::Sub>::sub(p0, p1);
+crate::<macros::Test as std::ops::Sub>::sub(p0, p1);
+<macros::Test>::sub(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Sub<macros::Test>>::sub
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub(p1);
+<&'a macros::Test as std::ops::Sub<macros::Test>>::sub(p0, p1);
+crate::<&'a macros::Test as std::ops::Sub<macros::Test>>::sub(p0, p1);
+<&'a macros::Test>::sub(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Sub<macros::Test>>::sub
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub(p1);
+<&'a mut macros::Test as std::ops::Sub<macros::Test>>::sub(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Sub<macros::Test>>::sub(p0, p1);
+<&'a mut macros::Test>::sub(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::SubAssign<&macros::Test>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub_assign(p1);
+<macros::Test as std::ops::SubAssign<&macros::Test>>::sub_assign(p0, p1);
+crate::<macros::Test as std::ops::SubAssign<&macros::Test>>::sub_assign(p0, p1);
+<macros::Test>::sub_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::SubAssign<&macros::Test>>::sub_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub_assign(p1);
+<&'a mut macros::Test as std::ops::SubAssign<&macros::Test>>::sub_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::SubAssign<&macros::Test>>::sub_assign(p0, p1);
+<&'a mut macros::Test>::sub_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Sub<&macros::Test>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub(p1);
+<macros::Test as std::ops::Sub<&macros::Test>>::sub(p0, p1);
+crate::<macros::Test as std::ops::Sub<&macros::Test>>::sub(p0, p1);
+<macros::Test>::sub(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Sub<&macros::Test>>::sub
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub(p1);
+<&'a macros::Test as std::ops::Sub<&macros::Test>>::sub(p0, p1);
+crate::<&'a macros::Test as std::ops::Sub<&macros::Test>>::sub(p0, p1);
+<&'a macros::Test>::sub(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Sub<&macros::Test>>::sub
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub(p1);
+<&'a mut macros::Test as std::ops::Sub<&macros::Test>>::sub(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Sub<&macros::Test>>::sub(p0, p1);
+<&'a mut macros::Test>::sub(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::SubAssign<&mut macros::Test>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub_assign(p1);
+<macros::Test as std::ops::SubAssign<&mut macros::Test>>::sub_assign(p0, p1);
+crate::<macros::Test as std::ops::SubAssign<&mut macros::Test>>::sub_assign(p0, p1);
+<macros::Test>::sub_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::SubAssign<&mut macros::Test>>::sub_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub_assign(p1);
+<&'a mut macros::Test as std::ops::SubAssign<&mut macros::Test>>::sub_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::SubAssign<&mut macros::Test>>::sub_assign(p0, p1);
+<&'a mut macros::Test>::sub_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Sub<&mut macros::Test>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub(p1);
+<macros::Test as std::ops::Sub<&mut macros::Test>>::sub(p0, p1);
+crate::<macros::Test as std::ops::Sub<&mut macros::Test>>::sub(p0, p1);
+<macros::Test>::sub(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Sub<&mut macros::Test>>::sub
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub(p1);
+<&'a macros::Test as std::ops::Sub<&mut macros::Test>>::sub(p0, p1);
+crate::<&'a macros::Test as std::ops::Sub<&mut macros::Test>>::sub(p0, p1);
+<&'a macros::Test>::sub(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Sub<&mut macros::Test>>::sub
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.sub(p1);
+<&'a mut macros::Test as std::ops::Sub<&mut macros::Test>>::sub(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Sub<&mut macros::Test>>::sub(p0, p1);
+<&'a mut macros::Test>::sub(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::MulAssign>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul_assign(p1);
+<macros::Test as std::ops::MulAssign>::mul_assign(p0, p1);
+crate::<macros::Test as std::ops::MulAssign>::mul_assign(p0, p1);
+<macros::Test>::mul_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::MulAssign<macros::Test>>::mul_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul_assign(p1);
+<&'a mut macros::Test as std::ops::MulAssign<macros::Test>>::mul_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::MulAssign<macros::Test>>::mul_assign(p0, p1);
+<&'a mut macros::Test>::mul_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Mul>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul(p1);
+<macros::Test as std::ops::Mul>::mul(p0, p1);
+crate::<macros::Test as std::ops::Mul>::mul(p0, p1);
+<macros::Test>::mul(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Mul<macros::Test>>::mul
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul(p1);
+<&'a macros::Test as std::ops::Mul<macros::Test>>::mul(p0, p1);
+crate::<&'a macros::Test as std::ops::Mul<macros::Test>>::mul(p0, p1);
+<&'a macros::Test>::mul(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Mul<macros::Test>>::mul
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul(p1);
+<&'a mut macros::Test as std::ops::Mul<macros::Test>>::mul(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Mul<macros::Test>>::mul(p0, p1);
+<&'a mut macros::Test>::mul(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::MulAssign<&macros::Test>>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul_assign(p1);
+<macros::Test as std::ops::MulAssign<&macros::Test>>::mul_assign(p0, p1);
+crate::<macros::Test as std::ops::MulAssign<&macros::Test>>::mul_assign(p0, p1);
+<macros::Test>::mul_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::MulAssign<&macros::Test>>::mul_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul_assign(p1);
+<&'a mut macros::Test as std::ops::MulAssign<&macros::Test>>::mul_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::MulAssign<&macros::Test>>::mul_assign(p0, p1);
+<&'a mut macros::Test>::mul_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Mul<&macros::Test>>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul(p1);
+<macros::Test as std::ops::Mul<&macros::Test>>::mul(p0, p1);
+crate::<macros::Test as std::ops::Mul<&macros::Test>>::mul(p0, p1);
+<macros::Test>::mul(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Mul<&macros::Test>>::mul
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul(p1);
+<&'a macros::Test as std::ops::Mul<&macros::Test>>::mul(p0, p1);
+crate::<&'a macros::Test as std::ops::Mul<&macros::Test>>::mul(p0, p1);
+<&'a macros::Test>::mul(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Mul<&macros::Test>>::mul
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul(p1);
+<&'a mut macros::Test as std::ops::Mul<&macros::Test>>::mul(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Mul<&macros::Test>>::mul(p0, p1);
+<&'a mut macros::Test>::mul(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::MulAssign<&mut macros::Test>>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul_assign(p1);
+<macros::Test as std::ops::MulAssign<&mut macros::Test>>::mul_assign(p0, p1);
+crate::<macros::Test as std::ops::MulAssign<&mut macros::Test>>::mul_assign(p0, p1);
+<macros::Test>::mul_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::MulAssign<&mut macros::Test>>::mul_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul_assign(p1);
+<&'a mut macros::Test as std::ops::MulAssign<&mut macros::Test>>::mul_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::MulAssign<&mut macros::Test>>::mul_assign(p0, p1);
+<&'a mut macros::Test>::mul_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Mul<&mut macros::Test>>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul(p1);
+<macros::Test as std::ops::Mul<&mut macros::Test>>::mul(p0, p1);
+crate::<macros::Test as std::ops::Mul<&mut macros::Test>>::mul(p0, p1);
+<macros::Test>::mul(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Mul<&mut macros::Test>>::mul
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul(p1);
+<&'a macros::Test as std::ops::Mul<&mut macros::Test>>::mul(p0, p1);
+crate::<&'a macros::Test as std::ops::Mul<&mut macros::Test>>::mul(p0, p1);
+<&'a macros::Test>::mul(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Mul<&mut macros::Test>>::mul
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.mul(p1);
+<&'a mut macros::Test as std::ops::Mul<&mut macros::Test>>::mul(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Mul<&mut macros::Test>>::mul(p0, p1);
+<&'a mut macros::Test>::mul(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::DivAssign>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div_assign(p1);
+<macros::Test as std::ops::DivAssign>::div_assign(p0, p1);
+crate::<macros::Test as std::ops::DivAssign>::div_assign(p0, p1);
+<macros::Test>::div_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::DivAssign<macros::Test>>::div_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div_assign(p1);
+<&'a mut macros::Test as std::ops::DivAssign<macros::Test>>::div_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::DivAssign<macros::Test>>::div_assign(p0, p1);
+<&'a mut macros::Test>::div_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Div>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div(p1);
+<macros::Test as std::ops::Div>::div(p0, p1);
+crate::<macros::Test as std::ops::Div>::div(p0, p1);
+<macros::Test>::div(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Div<macros::Test>>::div
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div(p1);
+<&'a macros::Test as std::ops::Div<macros::Test>>::div(p0, p1);
+crate::<&'a macros::Test as std::ops::Div<macros::Test>>::div(p0, p1);
+<&'a macros::Test>::div(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Div<macros::Test>>::div
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div(p1);
+<&'a mut macros::Test as std::ops::Div<macros::Test>>::div(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Div<macros::Test>>::div(p0, p1);
+<&'a mut macros::Test>::div(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::DivAssign<&macros::Test>>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div_assign(p1);
+<macros::Test as std::ops::DivAssign<&macros::Test>>::div_assign(p0, p1);
+crate::<macros::Test as std::ops::DivAssign<&macros::Test>>::div_assign(p0, p1);
+<macros::Test>::div_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::DivAssign<&macros::Test>>::div_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div_assign(p1);
+<&'a mut macros::Test as std::ops::DivAssign<&macros::Test>>::div_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::DivAssign<&macros::Test>>::div_assign(p0, p1);
+<&'a mut macros::Test>::div_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Div<&macros::Test>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div(p1);
+<macros::Test as std::ops::Div<&macros::Test>>::div(p0, p1);
+crate::<macros::Test as std::ops::Div<&macros::Test>>::div(p0, p1);
+<macros::Test>::div(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Div<&macros::Test>>::div
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div(p1);
+<&'a macros::Test as std::ops::Div<&macros::Test>>::div(p0, p1);
+crate::<&'a macros::Test as std::ops::Div<&macros::Test>>::div(p0, p1);
+<&'a macros::Test>::div(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Div<&macros::Test>>::div
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div(p1);
+<&'a mut macros::Test as std::ops::Div<&macros::Test>>::div(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Div<&macros::Test>>::div(p0, p1);
+<&'a mut macros::Test>::div(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::DivAssign<&mut macros::Test>>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div_assign(p1);
+<macros::Test as std::ops::DivAssign<&mut macros::Test>>::div_assign(p0, p1);
+crate::<macros::Test as std::ops::DivAssign<&mut macros::Test>>::div_assign(p0, p1);
+<macros::Test>::div_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::DivAssign<&mut macros::Test>>::div_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div_assign(p1);
+<&'a mut macros::Test as std::ops::DivAssign<&mut macros::Test>>::div_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::DivAssign<&mut macros::Test>>::div_assign(p0, p1);
+<&'a mut macros::Test>::div_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Div<&mut macros::Test>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div(p1);
+<macros::Test as std::ops::Div<&mut macros::Test>>::div(p0, p1);
+crate::<macros::Test as std::ops::Div<&mut macros::Test>>::div(p0, p1);
+<macros::Test>::div(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Div<&mut macros::Test>>::div
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div(p1);
+<&'a macros::Test as std::ops::Div<&mut macros::Test>>::div(p0, p1);
+crate::<&'a macros::Test as std::ops::Div<&mut macros::Test>>::div(p0, p1);
+<&'a macros::Test>::div(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Div<&mut macros::Test>>::div
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.div(p1);
+<&'a mut macros::Test as std::ops::Div<&mut macros::Test>>::div(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Div<&mut macros::Test>>::div(p0, p1);
+<&'a mut macros::Test>::div(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitAndAssign>::bitand_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand_assign(p1);
+<macros::Test as std::ops::BitAndAssign>::bitand_assign(p0, p1);
+crate::<macros::Test as std::ops::BitAndAssign>::bitand_assign(p0, p1);
+<macros::Test>::bitand_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitAndAssign<macros::Test>>::bitand_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand_assign(p1);
+<&'a mut macros::Test as std::ops::BitAndAssign<macros::Test>>::bitand_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitAndAssign<macros::Test>>::bitand_assign(p0, p1);
+<&'a mut macros::Test>::bitand_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitAnd>::bitand
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand(p1);
+<macros::Test as std::ops::BitAnd>::bitand(p0, p1);
+crate::<macros::Test as std::ops::BitAnd>::bitand(p0, p1);
+<macros::Test>::bitand(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::BitAnd<macros::Test>>::bitand
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand(p1);
+<&'a macros::Test as std::ops::BitAnd<macros::Test>>::bitand(p0, p1);
+crate::<&'a macros::Test as std::ops::BitAnd<macros::Test>>::bitand(p0, p1);
+<&'a macros::Test>::bitand(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitAnd<macros::Test>>::bitand
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand(p1);
+<&'a mut macros::Test as std::ops::BitAnd<macros::Test>>::bitand(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitAnd<macros::Test>>::bitand(p0, p1);
+<&'a mut macros::Test>::bitand(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitAndAssign<&macros::Test>>::bitand_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand_assign(p1);
+<macros::Test as std::ops::BitAndAssign<&macros::Test>>::bitand_assign(p0, p1);
+crate::<macros::Test as std::ops::BitAndAssign<&macros::Test>>::bitand_assign(p0, p1);
+<macros::Test>::bitand_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitAndAssign<&macros::Test>>::bitand_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand_assign(p1);
+<&'a mut macros::Test as std::ops::BitAndAssign<&macros::Test>>::bitand_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitAndAssign<&macros::Test>>::bitand_assign(p0, p1);
+<&'a mut macros::Test>::bitand_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitAnd<&macros::Test>>::bitand
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand(p1);
+<macros::Test as std::ops::BitAnd<&macros::Test>>::bitand(p0, p1);
+crate::<macros::Test as std::ops::BitAnd<&macros::Test>>::bitand(p0, p1);
+<macros::Test>::bitand(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::BitAnd<&macros::Test>>::bitand
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand(p1);
+<&'a macros::Test as std::ops::BitAnd<&macros::Test>>::bitand(p0, p1);
+crate::<&'a macros::Test as std::ops::BitAnd<&macros::Test>>::bitand(p0, p1);
+<&'a macros::Test>::bitand(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitAnd<&macros::Test>>::bitand
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand(p1);
+<&'a mut macros::Test as std::ops::BitAnd<&macros::Test>>::bitand(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitAnd<&macros::Test>>::bitand(p0, p1);
+<&'a mut macros::Test>::bitand(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitAndAssign<&mut macros::Test>>::bitand_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand_assign(p1);
+<macros::Test as std::ops::BitAndAssign<&mut macros::Test>>::bitand_assign(p0, p1);
+crate::<macros::Test as std::ops::BitAndAssign<&mut macros::Test>>::bitand_assign(p0, p1);
+<macros::Test>::bitand_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitAndAssign<&mut macros::Test>>::bitand_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand_assign(p1);
+<&'a mut macros::Test as std::ops::BitAndAssign<&mut macros::Test>>::bitand_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitAndAssign<&mut macros::Test>>::bitand_assign(p0, p1);
+<&'a mut macros::Test>::bitand_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitAnd<&mut macros::Test>>::bitand
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand(p1);
+<macros::Test as std::ops::BitAnd<&mut macros::Test>>::bitand(p0, p1);
+crate::<macros::Test as std::ops::BitAnd<&mut macros::Test>>::bitand(p0, p1);
+<macros::Test>::bitand(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::BitAnd<&mut macros::Test>>::bitand
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand(p1);
+<&'a macros::Test as std::ops::BitAnd<&mut macros::Test>>::bitand(p0, p1);
+crate::<&'a macros::Test as std::ops::BitAnd<&mut macros::Test>>::bitand(p0, p1);
+<&'a macros::Test>::bitand(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitAnd<&mut macros::Test>>::bitand
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitand(p1);
+<&'a mut macros::Test as std::ops::BitAnd<&mut macros::Test>>::bitand(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitAnd<&mut macros::Test>>::bitand(p0, p1);
+<&'a mut macros::Test>::bitand(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitOrAssign>::bitor_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor_assign(p1);
+<macros::Test as std::ops::BitOrAssign>::bitor_assign(p0, p1);
+crate::<macros::Test as std::ops::BitOrAssign>::bitor_assign(p0, p1);
+<macros::Test>::bitor_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitOrAssign<macros::Test>>::bitor_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor_assign(p1);
+<&'a mut macros::Test as std::ops::BitOrAssign<macros::Test>>::bitor_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitOrAssign<macros::Test>>::bitor_assign(p0, p1);
+<&'a mut macros::Test>::bitor_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitOr>::bitor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor(p1);
+<macros::Test as std::ops::BitOr>::bitor(p0, p1);
+crate::<macros::Test as std::ops::BitOr>::bitor(p0, p1);
+<macros::Test>::bitor(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::BitOr<macros::Test>>::bitor
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor(p1);
+<&'a macros::Test as std::ops::BitOr<macros::Test>>::bitor(p0, p1);
+crate::<&'a macros::Test as std::ops::BitOr<macros::Test>>::bitor(p0, p1);
+<&'a macros::Test>::bitor(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitOr<macros::Test>>::bitor
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor(p1);
+<&'a mut macros::Test as std::ops::BitOr<macros::Test>>::bitor(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitOr<macros::Test>>::bitor(p0, p1);
+<&'a mut macros::Test>::bitor(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitOrAssign<&macros::Test>>::bitor_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor_assign(p1);
+<macros::Test as std::ops::BitOrAssign<&macros::Test>>::bitor_assign(p0, p1);
+crate::<macros::Test as std::ops::BitOrAssign<&macros::Test>>::bitor_assign(p0, p1);
+<macros::Test>::bitor_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitOrAssign<&macros::Test>>::bitor_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor_assign(p1);
+<&'a mut macros::Test as std::ops::BitOrAssign<&macros::Test>>::bitor_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitOrAssign<&macros::Test>>::bitor_assign(p0, p1);
+<&'a mut macros::Test>::bitor_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitOr<&macros::Test>>::bitor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor(p1);
+<macros::Test as std::ops::BitOr<&macros::Test>>::bitor(p0, p1);
+crate::<macros::Test as std::ops::BitOr<&macros::Test>>::bitor(p0, p1);
+<macros::Test>::bitor(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::BitOr<&macros::Test>>::bitor
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor(p1);
+<&'a macros::Test as std::ops::BitOr<&macros::Test>>::bitor(p0, p1);
+crate::<&'a macros::Test as std::ops::BitOr<&macros::Test>>::bitor(p0, p1);
+<&'a macros::Test>::bitor(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitOr<&macros::Test>>::bitor
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor(p1);
+<&'a mut macros::Test as std::ops::BitOr<&macros::Test>>::bitor(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitOr<&macros::Test>>::bitor(p0, p1);
+<&'a mut macros::Test>::bitor(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitOrAssign<&mut macros::Test>>::bitor_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor_assign(p1);
+<macros::Test as std::ops::BitOrAssign<&mut macros::Test>>::bitor_assign(p0, p1);
+crate::<macros::Test as std::ops::BitOrAssign<&mut macros::Test>>::bitor_assign(p0, p1);
+<macros::Test>::bitor_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitOrAssign<&mut macros::Test>>::bitor_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor_assign(p1);
+<&'a mut macros::Test as std::ops::BitOrAssign<&mut macros::Test>>::bitor_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitOrAssign<&mut macros::Test>>::bitor_assign(p0, p1);
+<&'a mut macros::Test>::bitor_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitOr<&mut macros::Test>>::bitor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor(p1);
+<macros::Test as std::ops::BitOr<&mut macros::Test>>::bitor(p0, p1);
+crate::<macros::Test as std::ops::BitOr<&mut macros::Test>>::bitor(p0, p1);
+<macros::Test>::bitor(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::BitOr<&mut macros::Test>>::bitor
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor(p1);
+<&'a macros::Test as std::ops::BitOr<&mut macros::Test>>::bitor(p0, p1);
+crate::<&'a macros::Test as std::ops::BitOr<&mut macros::Test>>::bitor(p0, p1);
+<&'a macros::Test>::bitor(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitOr<&mut macros::Test>>::bitor
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitor(p1);
+<&'a mut macros::Test as std::ops::BitOr<&mut macros::Test>>::bitor(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitOr<&mut macros::Test>>::bitor(p0, p1);
+<&'a mut macros::Test>::bitor(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitXorAssign>::bitxor_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor_assign(p1);
+<macros::Test as std::ops::BitXorAssign>::bitxor_assign(p0, p1);
+crate::<macros::Test as std::ops::BitXorAssign>::bitxor_assign(p0, p1);
+<macros::Test>::bitxor_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitXorAssign<macros::Test>>::bitxor_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor_assign(p1);
+<&'a mut macros::Test as std::ops::BitXorAssign<macros::Test>>::bitxor_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitXorAssign<macros::Test>>::bitxor_assign(p0, p1);
+<&'a mut macros::Test>::bitxor_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitXor>::bitxor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor(p1);
+<macros::Test as std::ops::BitXor>::bitxor(p0, p1);
+crate::<macros::Test as std::ops::BitXor>::bitxor(p0, p1);
+<macros::Test>::bitxor(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::BitXor<macros::Test>>::bitxor
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor(p1);
+<&'a macros::Test as std::ops::BitXor<macros::Test>>::bitxor(p0, p1);
+crate::<&'a macros::Test as std::ops::BitXor<macros::Test>>::bitxor(p0, p1);
+<&'a macros::Test>::bitxor(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitXor<macros::Test>>::bitxor
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor(p1);
+<&'a mut macros::Test as std::ops::BitXor<macros::Test>>::bitxor(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitXor<macros::Test>>::bitxor(p0, p1);
+<&'a mut macros::Test>::bitxor(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitXorAssign<&macros::Test>>::bitxor_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor_assign(p1);
+<macros::Test as std::ops::BitXorAssign<&macros::Test>>::bitxor_assign(p0, p1);
+crate::<macros::Test as std::ops::BitXorAssign<&macros::Test>>::bitxor_assign(p0, p1);
+<macros::Test>::bitxor_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitXorAssign<&macros::Test>>::bitxor_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor_assign(p1);
+<&'a mut macros::Test as std::ops::BitXorAssign<&macros::Test>>::bitxor_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitXorAssign<&macros::Test>>::bitxor_assign(p0, p1);
+<&'a mut macros::Test>::bitxor_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitXor<&macros::Test>>::bitxor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor(p1);
+<macros::Test as std::ops::BitXor<&macros::Test>>::bitxor(p0, p1);
+crate::<macros::Test as std::ops::BitXor<&macros::Test>>::bitxor(p0, p1);
+<macros::Test>::bitxor(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::BitXor<&macros::Test>>::bitxor
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor(p1);
+<&'a macros::Test as std::ops::BitXor<&macros::Test>>::bitxor(p0, p1);
+crate::<&'a macros::Test as std::ops::BitXor<&macros::Test>>::bitxor(p0, p1);
+<&'a macros::Test>::bitxor(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitXor<&macros::Test>>::bitxor
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor(p1);
+<&'a mut macros::Test as std::ops::BitXor<&macros::Test>>::bitxor(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitXor<&macros::Test>>::bitxor(p0, p1);
+<&'a mut macros::Test>::bitxor(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitXorAssign<&mut macros::Test>>::bitxor_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor_assign(p1);
+<macros::Test as std::ops::BitXorAssign<&mut macros::Test>>::bitxor_assign(p0, p1);
+crate::<macros::Test as std::ops::BitXorAssign<&mut macros::Test>>::bitxor_assign(p0, p1);
+<macros::Test>::bitxor_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitXorAssign<&mut macros::Test>>::bitxor_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor_assign(p1);
+<&'a mut macros::Test as std::ops::BitXorAssign<&mut macros::Test>>::bitxor_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitXorAssign<&mut macros::Test>>::bitxor_assign(p0, p1);
+<&'a mut macros::Test>::bitxor_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::BitXor<&mut macros::Test>>::bitxor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor(p1);
+<macros::Test as std::ops::BitXor<&mut macros::Test>>::bitxor(p0, p1);
+crate::<macros::Test as std::ops::BitXor<&mut macros::Test>>::bitxor(p0, p1);
+<macros::Test>::bitxor(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::BitXor<&mut macros::Test>>::bitxor
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor(p1);
+<&'a macros::Test as std::ops::BitXor<&mut macros::Test>>::bitxor(p0, p1);
+crate::<&'a macros::Test as std::ops::BitXor<&mut macros::Test>>::bitxor(p0, p1);
+<&'a macros::Test>::bitxor(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::BitXor<&mut macros::Test>>::bitxor
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.bitxor(p1);
+<&'a mut macros::Test as std::ops::BitXor<&mut macros::Test>>::bitxor(p0, p1);
+crate::<&'a mut macros::Test as std::ops::BitXor<&mut macros::Test>>::bitxor(p0, p1);
+<&'a mut macros::Test>::bitxor(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::RemAssign>::rem_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem_assign(p1);
+<macros::Test as std::ops::RemAssign>::rem_assign(p0, p1);
+crate::<macros::Test as std::ops::RemAssign>::rem_assign(p0, p1);
+<macros::Test>::rem_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::RemAssign<macros::Test>>::rem_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem_assign(p1);
+<&'a mut macros::Test as std::ops::RemAssign<macros::Test>>::rem_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::RemAssign<macros::Test>>::rem_assign(p0, p1);
+<&'a mut macros::Test>::rem_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Rem>::rem
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem(p1);
+<macros::Test as std::ops::Rem>::rem(p0, p1);
+crate::<macros::Test as std::ops::Rem>::rem(p0, p1);
+<macros::Test>::rem(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Rem<macros::Test>>::rem
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem(p1);
+<&'a macros::Test as std::ops::Rem<macros::Test>>::rem(p0, p1);
+crate::<&'a macros::Test as std::ops::Rem<macros::Test>>::rem(p0, p1);
+<&'a macros::Test>::rem(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Rem<macros::Test>>::rem
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem(p1);
+<&'a mut macros::Test as std::ops::Rem<macros::Test>>::rem(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Rem<macros::Test>>::rem(p0, p1);
+<&'a mut macros::Test>::rem(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::RemAssign<&macros::Test>>::rem_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem_assign(p1);
+<macros::Test as std::ops::RemAssign<&macros::Test>>::rem_assign(p0, p1);
+crate::<macros::Test as std::ops::RemAssign<&macros::Test>>::rem_assign(p0, p1);
+<macros::Test>::rem_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::RemAssign<&macros::Test>>::rem_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem_assign(p1);
+<&'a mut macros::Test as std::ops::RemAssign<&macros::Test>>::rem_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::RemAssign<&macros::Test>>::rem_assign(p0, p1);
+<&'a mut macros::Test>::rem_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Rem<&macros::Test>>::rem
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem(p1);
+<macros::Test as std::ops::Rem<&macros::Test>>::rem(p0, p1);
+crate::<macros::Test as std::ops::Rem<&macros::Test>>::rem(p0, p1);
+<macros::Test>::rem(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Rem<&macros::Test>>::rem
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem(p1);
+<&'a macros::Test as std::ops::Rem<&macros::Test>>::rem(p0, p1);
+crate::<&'a macros::Test as std::ops::Rem<&macros::Test>>::rem(p0, p1);
+<&'a macros::Test>::rem(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Rem<&macros::Test>>::rem
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem(p1);
+<&'a mut macros::Test as std::ops::Rem<&macros::Test>>::rem(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Rem<&macros::Test>>::rem(p0, p1);
+<&'a mut macros::Test>::rem(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::RemAssign<&mut macros::Test>>::rem_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem_assign(p1);
+<macros::Test as std::ops::RemAssign<&mut macros::Test>>::rem_assign(p0, p1);
+crate::<macros::Test as std::ops::RemAssign<&mut macros::Test>>::rem_assign(p0, p1);
+<macros::Test>::rem_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::RemAssign<&mut macros::Test>>::rem_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem_assign(p1);
+<&'a mut macros::Test as std::ops::RemAssign<&mut macros::Test>>::rem_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::RemAssign<&mut macros::Test>>::rem_assign(p0, p1);
+<&'a mut macros::Test>::rem_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Rem<&mut macros::Test>>::rem
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem(p1);
+<macros::Test as std::ops::Rem<&mut macros::Test>>::rem(p0, p1);
+crate::<macros::Test as std::ops::Rem<&mut macros::Test>>::rem(p0, p1);
+<macros::Test>::rem(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Rem<&mut macros::Test>>::rem
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem(p1);
+<&'a macros::Test as std::ops::Rem<&mut macros::Test>>::rem(p0, p1);
+crate::<&'a macros::Test as std::ops::Rem<&mut macros::Test>>::rem(p0, p1);
+<&'a macros::Test>::rem(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Rem<&mut macros::Test>>::rem
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.rem(p1);
+<&'a mut macros::Test as std::ops::Rem<&mut macros::Test>>::rem(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Rem<&mut macros::Test>>::rem(p0, p1);
+<&'a mut macros::Test>::rem(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::ShlAssign>::shl_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl_assign(p1);
+<macros::Test as std::ops::ShlAssign>::shl_assign(p0, p1);
+crate::<macros::Test as std::ops::ShlAssign>::shl_assign(p0, p1);
+<macros::Test>::shl_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::ShlAssign<macros::Test>>::shl_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl_assign(p1);
+<&'a mut macros::Test as std::ops::ShlAssign<macros::Test>>::shl_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::ShlAssign<macros::Test>>::shl_assign(p0, p1);
+<&'a mut macros::Test>::shl_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Shl>::shl
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl(p1);
+<macros::Test as std::ops::Shl>::shl(p0, p1);
+crate::<macros::Test as std::ops::Shl>::shl(p0, p1);
+<macros::Test>::shl(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Shl<macros::Test>>::shl
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl(p1);
+<&'a macros::Test as std::ops::Shl<macros::Test>>::shl(p0, p1);
+crate::<&'a macros::Test as std::ops::Shl<macros::Test>>::shl(p0, p1);
+<&'a macros::Test>::shl(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Shl<macros::Test>>::shl
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl(p1);
+<&'a mut macros::Test as std::ops::Shl<macros::Test>>::shl(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Shl<macros::Test>>::shl(p0, p1);
+<&'a mut macros::Test>::shl(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::ShlAssign<&macros::Test>>::shl_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl_assign(p1);
+<macros::Test as std::ops::ShlAssign<&macros::Test>>::shl_assign(p0, p1);
+crate::<macros::Test as std::ops::ShlAssign<&macros::Test>>::shl_assign(p0, p1);
+<macros::Test>::shl_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::ShlAssign<&macros::Test>>::shl_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl_assign(p1);
+<&'a mut macros::Test as std::ops::ShlAssign<&macros::Test>>::shl_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::ShlAssign<&macros::Test>>::shl_assign(p0, p1);
+<&'a mut macros::Test>::shl_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Shl<&macros::Test>>::shl
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl(p1);
+<macros::Test as std::ops::Shl<&macros::Test>>::shl(p0, p1);
+crate::<macros::Test as std::ops::Shl<&macros::Test>>::shl(p0, p1);
+<macros::Test>::shl(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Shl<&macros::Test>>::shl
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl(p1);
+<&'a macros::Test as std::ops::Shl<&macros::Test>>::shl(p0, p1);
+crate::<&'a macros::Test as std::ops::Shl<&macros::Test>>::shl(p0, p1);
+<&'a macros::Test>::shl(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Shl<&macros::Test>>::shl
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl(p1);
+<&'a mut macros::Test as std::ops::Shl<&macros::Test>>::shl(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Shl<&macros::Test>>::shl(p0, p1);
+<&'a mut macros::Test>::shl(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::ShlAssign<&mut macros::Test>>::shl_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl_assign(p1);
+<macros::Test as std::ops::ShlAssign<&mut macros::Test>>::shl_assign(p0, p1);
+crate::<macros::Test as std::ops::ShlAssign<&mut macros::Test>>::shl_assign(p0, p1);
+<macros::Test>::shl_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::ShlAssign<&mut macros::Test>>::shl_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl_assign(p1);
+<&'a mut macros::Test as std::ops::ShlAssign<&mut macros::Test>>::shl_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::ShlAssign<&mut macros::Test>>::shl_assign(p0, p1);
+<&'a mut macros::Test>::shl_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Shl<&mut macros::Test>>::shl
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl(p1);
+<macros::Test as std::ops::Shl<&mut macros::Test>>::shl(p0, p1);
+crate::<macros::Test as std::ops::Shl<&mut macros::Test>>::shl(p0, p1);
+<macros::Test>::shl(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Shl<&mut macros::Test>>::shl
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl(p1);
+<&'a macros::Test as std::ops::Shl<&mut macros::Test>>::shl(p0, p1);
+crate::<&'a macros::Test as std::ops::Shl<&mut macros::Test>>::shl(p0, p1);
+<&'a macros::Test>::shl(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Shl<&mut macros::Test>>::shl
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shl(p1);
+<&'a mut macros::Test as std::ops::Shl<&mut macros::Test>>::shl(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Shl<&mut macros::Test>>::shl(p0, p1);
+<&'a mut macros::Test>::shl(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::ShrAssign>::shr_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr_assign(p1);
+<macros::Test as std::ops::ShrAssign>::shr_assign(p0, p1);
+crate::<macros::Test as std::ops::ShrAssign>::shr_assign(p0, p1);
+<macros::Test>::shr_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::ShrAssign<macros::Test>>::shr_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr_assign(p1);
+<&'a mut macros::Test as std::ops::ShrAssign<macros::Test>>::shr_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::ShrAssign<macros::Test>>::shr_assign(p0, p1);
+<&'a mut macros::Test>::shr_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Shr>::shr
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr(p1);
+<macros::Test as std::ops::Shr>::shr(p0, p1);
+crate::<macros::Test as std::ops::Shr>::shr(p0, p1);
+<macros::Test>::shr(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Shr<macros::Test>>::shr
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr(p1);
+<&'a macros::Test as std::ops::Shr<macros::Test>>::shr(p0, p1);
+crate::<&'a macros::Test as std::ops::Shr<macros::Test>>::shr(p0, p1);
+<&'a macros::Test>::shr(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Shr<macros::Test>>::shr
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr(p1);
+<&'a mut macros::Test as std::ops::Shr<macros::Test>>::shr(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Shr<macros::Test>>::shr(p0, p1);
+<&'a mut macros::Test>::shr(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::ShrAssign<&macros::Test>>::shr_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr_assign(p1);
+<macros::Test as std::ops::ShrAssign<&macros::Test>>::shr_assign(p0, p1);
+crate::<macros::Test as std::ops::ShrAssign<&macros::Test>>::shr_assign(p0, p1);
+<macros::Test>::shr_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::ShrAssign<&macros::Test>>::shr_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr_assign(p1);
+<&'a mut macros::Test as std::ops::ShrAssign<&macros::Test>>::shr_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::ShrAssign<&macros::Test>>::shr_assign(p0, p1);
+<&'a mut macros::Test>::shr_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Shr<&macros::Test>>::shr
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr(p1);
+<macros::Test as std::ops::Shr<&macros::Test>>::shr(p0, p1);
+crate::<macros::Test as std::ops::Shr<&macros::Test>>::shr(p0, p1);
+<macros::Test>::shr(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Shr<&macros::Test>>::shr
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr(p1);
+<&'a macros::Test as std::ops::Shr<&macros::Test>>::shr(p0, p1);
+crate::<&'a macros::Test as std::ops::Shr<&macros::Test>>::shr(p0, p1);
+<&'a macros::Test>::shr(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Shr<&macros::Test>>::shr
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr(p1);
+<&'a mut macros::Test as std::ops::Shr<&macros::Test>>::shr(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Shr<&macros::Test>>::shr(p0, p1);
+<&'a mut macros::Test>::shr(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::ShrAssign<&mut macros::Test>>::shr_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr_assign(p1);
+<macros::Test as std::ops::ShrAssign<&mut macros::Test>>::shr_assign(p0, p1);
+crate::<macros::Test as std::ops::ShrAssign<&mut macros::Test>>::shr_assign(p0, p1);
+<macros::Test>::shr_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::ShrAssign<&mut macros::Test>>::shr_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr_assign(p1);
+<&'a mut macros::Test as std::ops::ShrAssign<&mut macros::Test>>::shr_assign(p0, p1);
+crate::<&'a mut macros::Test as std::ops::ShrAssign<&mut macros::Test>>::shr_assign(p0, p1);
+<&'a mut macros::Test>::shr_assign(p0, p1);
-----------------
src/macros.rs <macros::Test as std::ops::Shr<&mut macros::Test>>::shr
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr(p1);
+<macros::Test as std::ops::Shr<&mut macros::Test>>::shr(p0, p1);
+crate::<macros::Test as std::ops::Shr<&mut macros::Test>>::shr(p0, p1);
+<macros::Test>::shr(p0, p1);
-----------------
src/macros.rs <&'a macros::Test as std::ops::Shr<&mut macros::Test>>::shr
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr(p1);
+<&'a macros::Test as std::ops::Shr<&mut macros::Test>>::shr(p0, p1);
+crate::<&'a macros::Test as std::ops::Shr<&mut macros::Test>>::shr(p0, p1);
+<&'a macros::Test>::shr(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test as std::ops::Shr<&mut macros::Test>>::shr
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test
+p0.shr(p1);
+<&'a mut macros::Test as std::ops::Shr<&mut macros::Test>>::shr(p0, p1);
+crate::<&'a mut macros::Test as std::ops::Shr<&mut macros::Test>>::shr(p0, p1);
+<&'a mut macros::Test>::shr(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.clone();
+<macros::Test2 as std::clone::Clone>::clone(p0);
+crate::<macros::Test2 as std::clone::Clone>::clone(p0);
+<macros::Test2>::clone(p0);
-----------------
src/macros.rs <macros::Test2 as std::ops::AddAssign>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add_assign(p1);
+<macros::Test2 as std::ops::AddAssign>::add_assign(p0, p1);
+crate::<macros::Test2 as std::ops::AddAssign>::add_assign(p0, p1);
+<macros::Test2>::add_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::AddAssign<macros::Test2>>::add_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add_assign(p1);
+<&'a mut macros::Test2 as std::ops::AddAssign<macros::Test2>>::add_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::AddAssign<macros::Test2>>::add_assign(p0, p1);
+<&'a mut macros::Test2>::add_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Add>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add(p1);
+<macros::Test2 as std::ops::Add>::add(p0, p1);
+crate::<macros::Test2 as std::ops::Add>::add(p0, p1);
+<macros::Test2>::add(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Add<macros::Test2>>::add
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add(p1);
+<&'a macros::Test2 as std::ops::Add<macros::Test2>>::add(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Add<macros::Test2>>::add(p0, p1);
+<&'a macros::Test2>::add(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Add<macros::Test2>>::add
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add(p1);
+<&'a mut macros::Test2 as std::ops::Add<macros::Test2>>::add(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Add<macros::Test2>>::add(p0, p1);
+<&'a mut macros::Test2>::add(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::AddAssign<&macros::Test2>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add_assign(p1);
+<macros::Test2 as std::ops::AddAssign<&macros::Test2>>::add_assign(p0, p1);
+crate::<macros::Test2 as std::ops::AddAssign<&macros::Test2>>::add_assign(p0, p1);
+<macros::Test2>::add_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::AddAssign<&macros::Test2>>::add_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add_assign(p1);
+<&'a mut macros::Test2 as std::ops::AddAssign<&macros::Test2>>::add_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::AddAssign<&macros::Test2>>::add_assign(p0, p1);
+<&'a mut macros::Test2>::add_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Add<&macros::Test2>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add(p1);
+<macros::Test2 as std::ops::Add<&macros::Test2>>::add(p0, p1);
+crate::<macros::Test2 as std::ops::Add<&macros::Test2>>::add(p0, p1);
+<macros::Test2>::add(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Add<&macros::Test2>>::add
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add(p1);
+<&'a macros::Test2 as std::ops::Add<&macros::Test2>>::add(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Add<&macros::Test2>>::add(p0, p1);
+<&'a macros::Test2>::add(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Add<&macros::Test2>>::add
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add(p1);
+<&'a mut macros::Test2 as std::ops::Add<&macros::Test2>>::add(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Add<&macros::Test2>>::add(p0, p1);
+<&'a mut macros::Test2>::add(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::AddAssign<&mut macros::Test2>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add_assign(p1);
+<macros::Test2 as std::ops::AddAssign<&mut macros::Test2>>::add_assign(p0, p1);
+crate::<macros::Test2 as std::ops::AddAssign<&mut macros::Test2>>::add_assign(p0, p1);
+<macros::Test2>::add_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::AddAssign<&mut macros::Test2>>::add_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add_assign(p1);
+<&'a mut macros::Test2 as std::ops::AddAssign<&mut macros::Test2>>::add_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::AddAssign<&mut macros::Test2>>::add_assign(p0, p1);
+<&'a mut macros::Test2>::add_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Add<&mut macros::Test2>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add(p1);
+<macros::Test2 as std::ops::Add<&mut macros::Test2>>::add(p0, p1);
+crate::<macros::Test2 as std::ops::Add<&mut macros::Test2>>::add(p0, p1);
+<macros::Test2>::add(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Add<&mut macros::Test2>>::add
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add(p1);
+<&'a macros::Test2 as std::ops::Add<&mut macros::Test2>>::add(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Add<&mut macros::Test2>>::add(p0, p1);
+<&'a macros::Test2>::add(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Add<&mut macros::Test2>>::add
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.add(p1);
+<&'a mut macros::Test2 as std::ops::Add<&mut macros::Test2>>::add(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Add<&mut macros::Test2>>::add(p0, p1);
+<&'a mut macros::Test2>::add(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::SubAssign>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub_assign(p1);
+<macros::Test2 as std::ops::SubAssign>::sub_assign(p0, p1);
+crate::<macros::Test2 as std::ops::SubAssign>::sub_assign(p0, p1);
+<macros::Test2>::sub_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::SubAssign<macros::Test2>>::sub_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub_assign(p1);
+<&'a mut macros::Test2 as std::ops::SubAssign<macros::Test2>>::sub_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::SubAssign<macros::Test2>>::sub_assign(p0, p1);
+<&'a mut macros::Test2>::sub_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Sub>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub(p1);
+<macros::Test2 as std::ops::Sub>::sub(p0, p1);
+crate::<macros::Test2 as std::ops::Sub>::sub(p0, p1);
+<macros::Test2>::sub(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Sub<macros::Test2>>::sub
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub(p1);
+<&'a macros::Test2 as std::ops::Sub<macros::Test2>>::sub(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Sub<macros::Test2>>::sub(p0, p1);
+<&'a macros::Test2>::sub(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Sub<macros::Test2>>::sub
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub(p1);
+<&'a mut macros::Test2 as std::ops::Sub<macros::Test2>>::sub(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Sub<macros::Test2>>::sub(p0, p1);
+<&'a mut macros::Test2>::sub(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::SubAssign<&macros::Test2>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub_assign(p1);
+<macros::Test2 as std::ops::SubAssign<&macros::Test2>>::sub_assign(p0, p1);
+crate::<macros::Test2 as std::ops::SubAssign<&macros::Test2>>::sub_assign(p0, p1);
+<macros::Test2>::sub_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::SubAssign<&macros::Test2>>::sub_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub_assign(p1);
+<&'a mut macros::Test2 as std::ops::SubAssign<&macros::Test2>>::sub_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::SubAssign<&macros::Test2>>::sub_assign(p0, p1);
+<&'a mut macros::Test2>::sub_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Sub<&macros::Test2>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub(p1);
+<macros::Test2 as std::ops::Sub<&macros::Test2>>::sub(p0, p1);
+crate::<macros::Test2 as std::ops::Sub<&macros::Test2>>::sub(p0, p1);
+<macros::Test2>::sub(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Sub<&macros::Test2>>::sub
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub(p1);
+<&'a macros::Test2 as std::ops::Sub<&macros::Test2>>::sub(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Sub<&macros::Test2>>::sub(p0, p1);
+<&'a macros::Test2>::sub(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Sub<&macros::Test2>>::sub
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub(p1);
+<&'a mut macros::Test2 as std::ops::Sub<&macros::Test2>>::sub(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Sub<&macros::Test2>>::sub(p0, p1);
+<&'a mut macros::Test2>::sub(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::SubAssign<&mut macros::Test2>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub_assign(p1);
+<macros::Test2 as std::ops::SubAssign<&mut macros::Test2>>::sub_assign(p0, p1);
+crate::<macros::Test2 as std::ops::SubAssign<&mut macros::Test2>>::sub_assign(p0, p1);
+<macros::Test2>::sub_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::SubAssign<&mut macros::Test2>>::sub_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub_assign(p1);
+<&'a mut macros::Test2 as std::ops::SubAssign<&mut macros::Test2>>::sub_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::SubAssign<&mut macros::Test2>>::sub_assign(p0, p1);
+<&'a mut macros::Test2>::sub_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Sub<&mut macros::Test2>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub(p1);
+<macros::Test2 as std::ops::Sub<&mut macros::Test2>>::sub(p0, p1);
+crate::<macros::Test2 as std::ops::Sub<&mut macros::Test2>>::sub(p0, p1);
+<macros::Test2>::sub(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Sub<&mut macros::Test2>>::sub
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub(p1);
+<&'a macros::Test2 as std::ops::Sub<&mut macros::Test2>>::sub(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Sub<&mut macros::Test2>>::sub(p0, p1);
+<&'a macros::Test2>::sub(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Sub<&mut macros::Test2>>::sub
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.sub(p1);
+<&'a mut macros::Test2 as std::ops::Sub<&mut macros::Test2>>::sub(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Sub<&mut macros::Test2>>::sub(p0, p1);
+<&'a mut macros::Test2>::sub(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::MulAssign>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul_assign(p1);
+<macros::Test2 as std::ops::MulAssign>::mul_assign(p0, p1);
+crate::<macros::Test2 as std::ops::MulAssign>::mul_assign(p0, p1);
+<macros::Test2>::mul_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::MulAssign<macros::Test2>>::mul_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul_assign(p1);
+<&'a mut macros::Test2 as std::ops::MulAssign<macros::Test2>>::mul_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::MulAssign<macros::Test2>>::mul_assign(p0, p1);
+<&'a mut macros::Test2>::mul_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Mul>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul(p1);
+<macros::Test2 as std::ops::Mul>::mul(p0, p1);
+crate::<macros::Test2 as std::ops::Mul>::mul(p0, p1);
+<macros::Test2>::mul(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Mul<macros::Test2>>::mul
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul(p1);
+<&'a macros::Test2 as std::ops::Mul<macros::Test2>>::mul(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Mul<macros::Test2>>::mul(p0, p1);
+<&'a macros::Test2>::mul(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Mul<macros::Test2>>::mul
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul(p1);
+<&'a mut macros::Test2 as std::ops::Mul<macros::Test2>>::mul(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Mul<macros::Test2>>::mul(p0, p1);
+<&'a mut macros::Test2>::mul(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::MulAssign<&macros::Test2>>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul_assign(p1);
+<macros::Test2 as std::ops::MulAssign<&macros::Test2>>::mul_assign(p0, p1);
+crate::<macros::Test2 as std::ops::MulAssign<&macros::Test2>>::mul_assign(p0, p1);
+<macros::Test2>::mul_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::MulAssign<&macros::Test2>>::mul_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul_assign(p1);
+<&'a mut macros::Test2 as std::ops::MulAssign<&macros::Test2>>::mul_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::MulAssign<&macros::Test2>>::mul_assign(p0, p1);
+<&'a mut macros::Test2>::mul_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Mul<&macros::Test2>>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul(p1);
+<macros::Test2 as std::ops::Mul<&macros::Test2>>::mul(p0, p1);
+crate::<macros::Test2 as std::ops::Mul<&macros::Test2>>::mul(p0, p1);
+<macros::Test2>::mul(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Mul<&macros::Test2>>::mul
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul(p1);
+<&'a macros::Test2 as std::ops::Mul<&macros::Test2>>::mul(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Mul<&macros::Test2>>::mul(p0, p1);
+<&'a macros::Test2>::mul(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Mul<&macros::Test2>>::mul
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul(p1);
+<&'a mut macros::Test2 as std::ops::Mul<&macros::Test2>>::mul(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Mul<&macros::Test2>>::mul(p0, p1);
+<&'a mut macros::Test2>::mul(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::MulAssign<&mut macros::Test2>>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul_assign(p1);
+<macros::Test2 as std::ops::MulAssign<&mut macros::Test2>>::mul_assign(p0, p1);
+crate::<macros::Test2 as std::ops::MulAssign<&mut macros::Test2>>::mul_assign(p0, p1);
+<macros::Test2>::mul_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::MulAssign<&mut macros::Test2>>::mul_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul_assign(p1);
+<&'a mut macros::Test2 as std::ops::MulAssign<&mut macros::Test2>>::mul_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::MulAssign<&mut macros::Test2>>::mul_assign(p0, p1);
+<&'a mut macros::Test2>::mul_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Mul<&mut macros::Test2>>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul(p1);
+<macros::Test2 as std::ops::Mul<&mut macros::Test2>>::mul(p0, p1);
+crate::<macros::Test2 as std::ops::Mul<&mut macros::Test2>>::mul(p0, p1);
+<macros::Test2>::mul(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Mul<&mut macros::Test2>>::mul
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul(p1);
+<&'a macros::Test2 as std::ops::Mul<&mut macros::Test2>>::mul(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Mul<&mut macros::Test2>>::mul(p0, p1);
+<&'a macros::Test2>::mul(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Mul<&mut macros::Test2>>::mul
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.mul(p1);
+<&'a mut macros::Test2 as std::ops::Mul<&mut macros::Test2>>::mul(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Mul<&mut macros::Test2>>::mul(p0, p1);
+<&'a mut macros::Test2>::mul(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::DivAssign>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div_assign(p1);
+<macros::Test2 as std::ops::DivAssign>::div_assign(p0, p1);
+crate::<macros::Test2 as std::ops::DivAssign>::div_assign(p0, p1);
+<macros::Test2>::div_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::DivAssign<macros::Test2>>::div_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div_assign(p1);
+<&'a mut macros::Test2 as std::ops::DivAssign<macros::Test2>>::div_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::DivAssign<macros::Test2>>::div_assign(p0, p1);
+<&'a mut macros::Test2>::div_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Div>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div(p1);
+<macros::Test2 as std::ops::Div>::div(p0, p1);
+crate::<macros::Test2 as std::ops::Div>::div(p0, p1);
+<macros::Test2>::div(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Div<macros::Test2>>::div
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div(p1);
+<&'a macros::Test2 as std::ops::Div<macros::Test2>>::div(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Div<macros::Test2>>::div(p0, p1);
+<&'a macros::Test2>::div(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Div<macros::Test2>>::div
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div(p1);
+<&'a mut macros::Test2 as std::ops::Div<macros::Test2>>::div(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Div<macros::Test2>>::div(p0, p1);
+<&'a mut macros::Test2>::div(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::DivAssign<&macros::Test2>>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div_assign(p1);
+<macros::Test2 as std::ops::DivAssign<&macros::Test2>>::div_assign(p0, p1);
+crate::<macros::Test2 as std::ops::DivAssign<&macros::Test2>>::div_assign(p0, p1);
+<macros::Test2>::div_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::DivAssign<&macros::Test2>>::div_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div_assign(p1);
+<&'a mut macros::Test2 as std::ops::DivAssign<&macros::Test2>>::div_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::DivAssign<&macros::Test2>>::div_assign(p0, p1);
+<&'a mut macros::Test2>::div_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Div<&macros::Test2>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div(p1);
+<macros::Test2 as std::ops::Div<&macros::Test2>>::div(p0, p1);
+crate::<macros::Test2 as std::ops::Div<&macros::Test2>>::div(p0, p1);
+<macros::Test2>::div(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Div<&macros::Test2>>::div
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div(p1);
+<&'a macros::Test2 as std::ops::Div<&macros::Test2>>::div(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Div<&macros::Test2>>::div(p0, p1);
+<&'a macros::Test2>::div(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Div<&macros::Test2>>::div
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div(p1);
+<&'a mut macros::Test2 as std::ops::Div<&macros::Test2>>::div(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Div<&macros::Test2>>::div(p0, p1);
+<&'a mut macros::Test2>::div(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::DivAssign<&mut macros::Test2>>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div_assign(p1);
+<macros::Test2 as std::ops::DivAssign<&mut macros::Test2>>::div_assign(p0, p1);
+crate::<macros::Test2 as std::ops::DivAssign<&mut macros::Test2>>::div_assign(p0, p1);
+<macros::Test2>::div_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::DivAssign<&mut macros::Test2>>::div_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div_assign(p1);
+<&'a mut macros::Test2 as std::ops::DivAssign<&mut macros::Test2>>::div_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::DivAssign<&mut macros::Test2>>::div_assign(p0, p1);
+<&'a mut macros::Test2>::div_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Div<&mut macros::Test2>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div(p1);
+<macros::Test2 as std::ops::Div<&mut macros::Test2>>::div(p0, p1);
+crate::<macros::Test2 as std::ops::Div<&mut macros::Test2>>::div(p0, p1);
+<macros::Test2>::div(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Div<&mut macros::Test2>>::div
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div(p1);
+<&'a macros::Test2 as std::ops::Div<&mut macros::Test2>>::div(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Div<&mut macros::Test2>>::div(p0, p1);
+<&'a macros::Test2>::div(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Div<&mut macros::Test2>>::div
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.div(p1);
+<&'a mut macros::Test2 as std::ops::Div<&mut macros::Test2>>::div(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Div<&mut macros::Test2>>::div(p0, p1);
+<&'a mut macros::Test2>::div(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitAndAssign>::bitand_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand_assign(p1);
+<macros::Test2 as std::ops::BitAndAssign>::bitand_assign(p0, p1);
+crate::<macros::Test2 as std::ops::BitAndAssign>::bitand_assign(p0, p1);
+<macros::Test2>::bitand_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitAndAssign<macros::Test2>>::bitand_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand_assign(p1);
+<&'a mut macros::Test2 as std::ops::BitAndAssign<macros::Test2>>::bitand_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitAndAssign<macros::Test2>>::bitand_assign(p0, p1);
+<&'a mut macros::Test2>::bitand_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitAnd>::bitand
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand(p1);
+<macros::Test2 as std::ops::BitAnd>::bitand(p0, p1);
+crate::<macros::Test2 as std::ops::BitAnd>::bitand(p0, p1);
+<macros::Test2>::bitand(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::BitAnd<macros::Test2>>::bitand
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand(p1);
+<&'a macros::Test2 as std::ops::BitAnd<macros::Test2>>::bitand(p0, p1);
+crate::<&'a macros::Test2 as std::ops::BitAnd<macros::Test2>>::bitand(p0, p1);
+<&'a macros::Test2>::bitand(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitAnd<macros::Test2>>::bitand
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand(p1);
+<&'a mut macros::Test2 as std::ops::BitAnd<macros::Test2>>::bitand(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitAnd<macros::Test2>>::bitand(p0, p1);
+<&'a mut macros::Test2>::bitand(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitAndAssign<&macros::Test2>>::bitand_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand_assign(p1);
+<macros::Test2 as std::ops::BitAndAssign<&macros::Test2>>::bitand_assign(p0, p1);
+crate::<macros::Test2 as std::ops::BitAndAssign<&macros::Test2>>::bitand_assign(p0, p1);
+<macros::Test2>::bitand_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitAndAssign<&macros::Test2>>::bitand_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand_assign(p1);
+<&'a mut macros::Test2 as std::ops::BitAndAssign<&macros::Test2>>::bitand_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitAndAssign<&macros::Test2>>::bitand_assign(p0, p1);
+<&'a mut macros::Test2>::bitand_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitAnd<&macros::Test2>>::bitand
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand(p1);
+<macros::Test2 as std::ops::BitAnd<&macros::Test2>>::bitand(p0, p1);
+crate::<macros::Test2 as std::ops::BitAnd<&macros::Test2>>::bitand(p0, p1);
+<macros::Test2>::bitand(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::BitAnd<&macros::Test2>>::bitand
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand(p1);
+<&'a macros::Test2 as std::ops::BitAnd<&macros::Test2>>::bitand(p0, p1);
+crate::<&'a macros::Test2 as std::ops::BitAnd<&macros::Test2>>::bitand(p0, p1);
+<&'a macros::Test2>::bitand(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitAnd<&macros::Test2>>::bitand
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand(p1);
+<&'a mut macros::Test2 as std::ops::BitAnd<&macros::Test2>>::bitand(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitAnd<&macros::Test2>>::bitand(p0, p1);
+<&'a mut macros::Test2>::bitand(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitAndAssign<&mut macros::Test2>>::bitand_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand_assign(p1);
+<macros::Test2 as std::ops::BitAndAssign<&mut macros::Test2>>::bitand_assign(p0, p1);
+crate::<macros::Test2 as std::ops::BitAndAssign<&mut macros::Test2>>::bitand_assign(p0, p1);
+<macros::Test2>::bitand_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitAndAssign<&mut macros::Test2>>::bitand_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand_assign(p1);
+<&'a mut macros::Test2 as std::ops::BitAndAssign<&mut macros::Test2>>::bitand_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitAndAssign<&mut macros::Test2>>::bitand_assign(p0, p1);
+<&'a mut macros::Test2>::bitand_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitAnd<&mut macros::Test2>>::bitand
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand(p1);
+<macros::Test2 as std::ops::BitAnd<&mut macros::Test2>>::bitand(p0, p1);
+crate::<macros::Test2 as std::ops::BitAnd<&mut macros::Test2>>::bitand(p0, p1);
+<macros::Test2>::bitand(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::BitAnd<&mut macros::Test2>>::bitand
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand(p1);
+<&'a macros::Test2 as std::ops::BitAnd<&mut macros::Test2>>::bitand(p0, p1);
+crate::<&'a macros::Test2 as std::ops::BitAnd<&mut macros::Test2>>::bitand(p0, p1);
+<&'a macros::Test2>::bitand(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitAnd<&mut macros::Test2>>::bitand
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitand(p1);
+<&'a mut macros::Test2 as std::ops::BitAnd<&mut macros::Test2>>::bitand(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitAnd<&mut macros::Test2>>::bitand(p0, p1);
+<&'a mut macros::Test2>::bitand(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitOrAssign>::bitor_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor_assign(p1);
+<macros::Test2 as std::ops::BitOrAssign>::bitor_assign(p0, p1);
+crate::<macros::Test2 as std::ops::BitOrAssign>::bitor_assign(p0, p1);
+<macros::Test2>::bitor_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitOrAssign<macros::Test2>>::bitor_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor_assign(p1);
+<&'a mut macros::Test2 as std::ops::BitOrAssign<macros::Test2>>::bitor_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitOrAssign<macros::Test2>>::bitor_assign(p0, p1);
+<&'a mut macros::Test2>::bitor_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitOr>::bitor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor(p1);
+<macros::Test2 as std::ops::BitOr>::bitor(p0, p1);
+crate::<macros::Test2 as std::ops::BitOr>::bitor(p0, p1);
+<macros::Test2>::bitor(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::BitOr<macros::Test2>>::bitor
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor(p1);
+<&'a macros::Test2 as std::ops::BitOr<macros::Test2>>::bitor(p0, p1);
+crate::<&'a macros::Test2 as std::ops::BitOr<macros::Test2>>::bitor(p0, p1);
+<&'a macros::Test2>::bitor(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitOr<macros::Test2>>::bitor
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor(p1);
+<&'a mut macros::Test2 as std::ops::BitOr<macros::Test2>>::bitor(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitOr<macros::Test2>>::bitor(p0, p1);
+<&'a mut macros::Test2>::bitor(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitOrAssign<&macros::Test2>>::bitor_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor_assign(p1);
+<macros::Test2 as std::ops::BitOrAssign<&macros::Test2>>::bitor_assign(p0, p1);
+crate::<macros::Test2 as std::ops::BitOrAssign<&macros::Test2>>::bitor_assign(p0, p1);
+<macros::Test2>::bitor_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitOrAssign<&macros::Test2>>::bitor_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor_assign(p1);
+<&'a mut macros::Test2 as std::ops::BitOrAssign<&macros::Test2>>::bitor_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitOrAssign<&macros::Test2>>::bitor_assign(p0, p1);
+<&'a mut macros::Test2>::bitor_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitOr<&macros::Test2>>::bitor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor(p1);
+<macros::Test2 as std::ops::BitOr<&macros::Test2>>::bitor(p0, p1);
+crate::<macros::Test2 as std::ops::BitOr<&macros::Test2>>::bitor(p0, p1);
+<macros::Test2>::bitor(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::BitOr<&macros::Test2>>::bitor
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor(p1);
+<&'a macros::Test2 as std::ops::BitOr<&macros::Test2>>::bitor(p0, p1);
+crate::<&'a macros::Test2 as std::ops::BitOr<&macros::Test2>>::bitor(p0, p1);
+<&'a macros::Test2>::bitor(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitOr<&macros::Test2>>::bitor
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor(p1);
+<&'a mut macros::Test2 as std::ops::BitOr<&macros::Test2>>::bitor(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitOr<&macros::Test2>>::bitor(p0, p1);
+<&'a mut macros::Test2>::bitor(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitOrAssign<&mut macros::Test2>>::bitor_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor_assign(p1);
+<macros::Test2 as std::ops::BitOrAssign<&mut macros::Test2>>::bitor_assign(p0, p1);
+crate::<macros::Test2 as std::ops::BitOrAssign<&mut macros::Test2>>::bitor_assign(p0, p1);
+<macros::Test2>::bitor_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitOrAssign<&mut macros::Test2>>::bitor_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor_assign(p1);
+<&'a mut macros::Test2 as std::ops::BitOrAssign<&mut macros::Test2>>::bitor_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitOrAssign<&mut macros::Test2>>::bitor_assign(p0, p1);
+<&'a mut macros::Test2>::bitor_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitOr<&mut macros::Test2>>::bitor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor(p1);
+<macros::Test2 as std::ops::BitOr<&mut macros::Test2>>::bitor(p0, p1);
+crate::<macros::Test2 as std::ops::BitOr<&mut macros::Test2>>::bitor(p0, p1);
+<macros::Test2>::bitor(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::BitOr<&mut macros::Test2>>::bitor
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor(p1);
+<&'a macros::Test2 as std::ops::BitOr<&mut macros::Test2>>::bitor(p0, p1);
+crate::<&'a macros::Test2 as std::ops::BitOr<&mut macros::Test2>>::bitor(p0, p1);
+<&'a macros::Test2>::bitor(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitOr<&mut macros::Test2>>::bitor
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitor(p1);
+<&'a mut macros::Test2 as std::ops::BitOr<&mut macros::Test2>>::bitor(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitOr<&mut macros::Test2>>::bitor(p0, p1);
+<&'a mut macros::Test2>::bitor(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitXorAssign>::bitxor_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor_assign(p1);
+<macros::Test2 as std::ops::BitXorAssign>::bitxor_assign(p0, p1);
+crate::<macros::Test2 as std::ops::BitXorAssign>::bitxor_assign(p0, p1);
+<macros::Test2>::bitxor_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitXorAssign<macros::Test2>>::bitxor_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor_assign(p1);
+<&'a mut macros::Test2 as std::ops::BitXorAssign<macros::Test2>>::bitxor_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitXorAssign<macros::Test2>>::bitxor_assign(p0, p1);
+<&'a mut macros::Test2>::bitxor_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitXor>::bitxor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor(p1);
+<macros::Test2 as std::ops::BitXor>::bitxor(p0, p1);
+crate::<macros::Test2 as std::ops::BitXor>::bitxor(p0, p1);
+<macros::Test2>::bitxor(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::BitXor<macros::Test2>>::bitxor
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor(p1);
+<&'a macros::Test2 as std::ops::BitXor<macros::Test2>>::bitxor(p0, p1);
+crate::<&'a macros::Test2 as std::ops::BitXor<macros::Test2>>::bitxor(p0, p1);
+<&'a macros::Test2>::bitxor(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitXor<macros::Test2>>::bitxor
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor(p1);
+<&'a mut macros::Test2 as std::ops::BitXor<macros::Test2>>::bitxor(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitXor<macros::Test2>>::bitxor(p0, p1);
+<&'a mut macros::Test2>::bitxor(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitXorAssign<&macros::Test2>>::bitxor_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor_assign(p1);
+<macros::Test2 as std::ops::BitXorAssign<&macros::Test2>>::bitxor_assign(p0, p1);
+crate::<macros::Test2 as std::ops::BitXorAssign<&macros::Test2>>::bitxor_assign(p0, p1);
+<macros::Test2>::bitxor_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitXorAssign<&macros::Test2>>::bitxor_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor_assign(p1);
+<&'a mut macros::Test2 as std::ops::BitXorAssign<&macros::Test2>>::bitxor_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitXorAssign<&macros::Test2>>::bitxor_assign(p0, p1);
+<&'a mut macros::Test2>::bitxor_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitXor<&macros::Test2>>::bitxor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor(p1);
+<macros::Test2 as std::ops::BitXor<&macros::Test2>>::bitxor(p0, p1);
+crate::<macros::Test2 as std::ops::BitXor<&macros::Test2>>::bitxor(p0, p1);
+<macros::Test2>::bitxor(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::BitXor<&macros::Test2>>::bitxor
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor(p1);
+<&'a macros::Test2 as std::ops::BitXor<&macros::Test2>>::bitxor(p0, p1);
+crate::<&'a macros::Test2 as std::ops::BitXor<&macros::Test2>>::bitxor(p0, p1);
+<&'a macros::Test2>::bitxor(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitXor<&macros::Test2>>::bitxor
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor(p1);
+<&'a mut macros::Test2 as std::ops::BitXor<&macros::Test2>>::bitxor(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitXor<&macros::Test2>>::bitxor(p0, p1);
+<&'a mut macros::Test2>::bitxor(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitXorAssign<&mut macros::Test2>>::bitxor_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor_assign(p1);
+<macros::Test2 as std::ops::BitXorAssign<&mut macros::Test2>>::bitxor_assign(p0, p1);
+crate::<macros::Test2 as std::ops::BitXorAssign<&mut macros::Test2>>::bitxor_assign(p0, p1);
+<macros::Test2>::bitxor_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitXorAssign<&mut macros::Test2>>::bitxor_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor_assign(p1);
+<&'a mut macros::Test2 as std::ops::BitXorAssign<&mut macros::Test2>>::bitxor_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitXorAssign<&mut macros::Test2>>::bitxor_assign(p0, p1);
+<&'a mut macros::Test2>::bitxor_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::BitXor<&mut macros::Test2>>::bitxor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor(p1);
+<macros::Test2 as std::ops::BitXor<&mut macros::Test2>>::bitxor(p0, p1);
+crate::<macros::Test2 as std::ops::BitXor<&mut macros::Test2>>::bitxor(p0, p1);
+<macros::Test2>::bitxor(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::BitXor<&mut macros::Test2>>::bitxor
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor(p1);
+<&'a macros::Test2 as std::ops::BitXor<&mut macros::Test2>>::bitxor(p0, p1);
+crate::<&'a macros::Test2 as std::ops::BitXor<&mut macros::Test2>>::bitxor(p0, p1);
+<&'a macros::Test2>::bitxor(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::BitXor<&mut macros::Test2>>::bitxor
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.bitxor(p1);
+<&'a mut macros::Test2 as std::ops::BitXor<&mut macros::Test2>>::bitxor(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::BitXor<&mut macros::Test2>>::bitxor(p0, p1);
+<&'a mut macros::Test2>::bitxor(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::RemAssign>::rem_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem_assign(p1);
+<macros::Test2 as std::ops::RemAssign>::rem_assign(p0, p1);
+crate::<macros::Test2 as std::ops::RemAssign>::rem_assign(p0, p1);
+<macros::Test2>::rem_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::RemAssign<macros::Test2>>::rem_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem_assign(p1);
+<&'a mut macros::Test2 as std::ops::RemAssign<macros::Test2>>::rem_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::RemAssign<macros::Test2>>::rem_assign(p0, p1);
+<&'a mut macros::Test2>::rem_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Rem>::rem
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem(p1);
+<macros::Test2 as std::ops::Rem>::rem(p0, p1);
+crate::<macros::Test2 as std::ops::Rem>::rem(p0, p1);
+<macros::Test2>::rem(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Rem<macros::Test2>>::rem
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem(p1);
+<&'a macros::Test2 as std::ops::Rem<macros::Test2>>::rem(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Rem<macros::Test2>>::rem(p0, p1);
+<&'a macros::Test2>::rem(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Rem<macros::Test2>>::rem
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem(p1);
+<&'a mut macros::Test2 as std::ops::Rem<macros::Test2>>::rem(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Rem<macros::Test2>>::rem(p0, p1);
+<&'a mut macros::Test2>::rem(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::RemAssign<&macros::Test2>>::rem_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem_assign(p1);
+<macros::Test2 as std::ops::RemAssign<&macros::Test2>>::rem_assign(p0, p1);
+crate::<macros::Test2 as std::ops::RemAssign<&macros::Test2>>::rem_assign(p0, p1);
+<macros::Test2>::rem_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::RemAssign<&macros::Test2>>::rem_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem_assign(p1);
+<&'a mut macros::Test2 as std::ops::RemAssign<&macros::Test2>>::rem_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::RemAssign<&macros::Test2>>::rem_assign(p0, p1);
+<&'a mut macros::Test2>::rem_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Rem<&macros::Test2>>::rem
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem(p1);
+<macros::Test2 as std::ops::Rem<&macros::Test2>>::rem(p0, p1);
+crate::<macros::Test2 as std::ops::Rem<&macros::Test2>>::rem(p0, p1);
+<macros::Test2>::rem(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Rem<&macros::Test2>>::rem
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem(p1);
+<&'a macros::Test2 as std::ops::Rem<&macros::Test2>>::rem(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Rem<&macros::Test2>>::rem(p0, p1);
+<&'a macros::Test2>::rem(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Rem<&macros::Test2>>::rem
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem(p1);
+<&'a mut macros::Test2 as std::ops::Rem<&macros::Test2>>::rem(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Rem<&macros::Test2>>::rem(p0, p1);
+<&'a mut macros::Test2>::rem(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::RemAssign<&mut macros::Test2>>::rem_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem_assign(p1);
+<macros::Test2 as std::ops::RemAssign<&mut macros::Test2>>::rem_assign(p0, p1);
+crate::<macros::Test2 as std::ops::RemAssign<&mut macros::Test2>>::rem_assign(p0, p1);
+<macros::Test2>::rem_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::RemAssign<&mut macros::Test2>>::rem_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem_assign(p1);
+<&'a mut macros::Test2 as std::ops::RemAssign<&mut macros::Test2>>::rem_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::RemAssign<&mut macros::Test2>>::rem_assign(p0, p1);
+<&'a mut macros::Test2>::rem_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Rem<&mut macros::Test2>>::rem
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem(p1);
+<macros::Test2 as std::ops::Rem<&mut macros::Test2>>::rem(p0, p1);
+crate::<macros::Test2 as std::ops::Rem<&mut macros::Test2>>::rem(p0, p1);
+<macros::Test2>::rem(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Rem<&mut macros::Test2>>::rem
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem(p1);
+<&'a macros::Test2 as std::ops::Rem<&mut macros::Test2>>::rem(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Rem<&mut macros::Test2>>::rem(p0, p1);
+<&'a macros::Test2>::rem(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Rem<&mut macros::Test2>>::rem
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.rem(p1);
+<&'a mut macros::Test2 as std::ops::Rem<&mut macros::Test2>>::rem(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Rem<&mut macros::Test2>>::rem(p0, p1);
+<&'a mut macros::Test2>::rem(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::ShlAssign>::shl_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl_assign(p1);
+<macros::Test2 as std::ops::ShlAssign>::shl_assign(p0, p1);
+crate::<macros::Test2 as std::ops::ShlAssign>::shl_assign(p0, p1);
+<macros::Test2>::shl_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::ShlAssign<macros::Test2>>::shl_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl_assign(p1);
+<&'a mut macros::Test2 as std::ops::ShlAssign<macros::Test2>>::shl_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::ShlAssign<macros::Test2>>::shl_assign(p0, p1);
+<&'a mut macros::Test2>::shl_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Shl>::shl
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl(p1);
+<macros::Test2 as std::ops::Shl>::shl(p0, p1);
+crate::<macros::Test2 as std::ops::Shl>::shl(p0, p1);
+<macros::Test2>::shl(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Shl<macros::Test2>>::shl
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl(p1);
+<&'a macros::Test2 as std::ops::Shl<macros::Test2>>::shl(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Shl<macros::Test2>>::shl(p0, p1);
+<&'a macros::Test2>::shl(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Shl<macros::Test2>>::shl
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl(p1);
+<&'a mut macros::Test2 as std::ops::Shl<macros::Test2>>::shl(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Shl<macros::Test2>>::shl(p0, p1);
+<&'a mut macros::Test2>::shl(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::ShlAssign<&macros::Test2>>::shl_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl_assign(p1);
+<macros::Test2 as std::ops::ShlAssign<&macros::Test2>>::shl_assign(p0, p1);
+crate::<macros::Test2 as std::ops::ShlAssign<&macros::Test2>>::shl_assign(p0, p1);
+<macros::Test2>::shl_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::ShlAssign<&macros::Test2>>::shl_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl_assign(p1);
+<&'a mut macros::Test2 as std::ops::ShlAssign<&macros::Test2>>::shl_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::ShlAssign<&macros::Test2>>::shl_assign(p0, p1);
+<&'a mut macros::Test2>::shl_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Shl<&macros::Test2>>::shl
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl(p1);
+<macros::Test2 as std::ops::Shl<&macros::Test2>>::shl(p0, p1);
+crate::<macros::Test2 as std::ops::Shl<&macros::Test2>>::shl(p0, p1);
+<macros::Test2>::shl(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Shl<&macros::Test2>>::shl
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl(p1);
+<&'a macros::Test2 as std::ops::Shl<&macros::Test2>>::shl(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Shl<&macros::Test2>>::shl(p0, p1);
+<&'a macros::Test2>::shl(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Shl<&macros::Test2>>::shl
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl(p1);
+<&'a mut macros::Test2 as std::ops::Shl<&macros::Test2>>::shl(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Shl<&macros::Test2>>::shl(p0, p1);
+<&'a mut macros::Test2>::shl(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::ShlAssign<&mut macros::Test2>>::shl_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl_assign(p1);
+<macros::Test2 as std::ops::ShlAssign<&mut macros::Test2>>::shl_assign(p0, p1);
+crate::<macros::Test2 as std::ops::ShlAssign<&mut macros::Test2>>::shl_assign(p0, p1);
+<macros::Test2>::shl_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::ShlAssign<&mut macros::Test2>>::shl_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl_assign(p1);
+<&'a mut macros::Test2 as std::ops::ShlAssign<&mut macros::Test2>>::shl_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::ShlAssign<&mut macros::Test2>>::shl_assign(p0, p1);
+<&'a mut macros::Test2>::shl_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Shl<&mut macros::Test2>>::shl
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl(p1);
+<macros::Test2 as std::ops::Shl<&mut macros::Test2>>::shl(p0, p1);
+crate::<macros::Test2 as std::ops::Shl<&mut macros::Test2>>::shl(p0, p1);
+<macros::Test2>::shl(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Shl<&mut macros::Test2>>::shl
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl(p1);
+<&'a macros::Test2 as std::ops::Shl<&mut macros::Test2>>::shl(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Shl<&mut macros::Test2>>::shl(p0, p1);
+<&'a macros::Test2>::shl(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Shl<&mut macros::Test2>>::shl
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shl(p1);
+<&'a mut macros::Test2 as std::ops::Shl<&mut macros::Test2>>::shl(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Shl<&mut macros::Test2>>::shl(p0, p1);
+<&'a mut macros::Test2>::shl(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::ShrAssign>::shr_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr_assign(p1);
+<macros::Test2 as std::ops::ShrAssign>::shr_assign(p0, p1);
+crate::<macros::Test2 as std::ops::ShrAssign>::shr_assign(p0, p1);
+<macros::Test2>::shr_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::ShrAssign<macros::Test2>>::shr_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr_assign(p1);
+<&'a mut macros::Test2 as std::ops::ShrAssign<macros::Test2>>::shr_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::ShrAssign<macros::Test2>>::shr_assign(p0, p1);
+<&'a mut macros::Test2>::shr_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Shr>::shr
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr(p1);
+<macros::Test2 as std::ops::Shr>::shr(p0, p1);
+crate::<macros::Test2 as std::ops::Shr>::shr(p0, p1);
+<macros::Test2>::shr(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Shr<macros::Test2>>::shr
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr(p1);
+<&'a macros::Test2 as std::ops::Shr<macros::Test2>>::shr(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Shr<macros::Test2>>::shr(p0, p1);
+<&'a macros::Test2>::shr(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Shr<macros::Test2>>::shr
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr(p1);
+<&'a mut macros::Test2 as std::ops::Shr<macros::Test2>>::shr(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Shr<macros::Test2>>::shr(p0, p1);
+<&'a mut macros::Test2>::shr(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::ShrAssign<&macros::Test2>>::shr_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr_assign(p1);
+<macros::Test2 as std::ops::ShrAssign<&macros::Test2>>::shr_assign(p0, p1);
+crate::<macros::Test2 as std::ops::ShrAssign<&macros::Test2>>::shr_assign(p0, p1);
+<macros::Test2>::shr_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::ShrAssign<&macros::Test2>>::shr_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr_assign(p1);
+<&'a mut macros::Test2 as std::ops::ShrAssign<&macros::Test2>>::shr_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::ShrAssign<&macros::Test2>>::shr_assign(p0, p1);
+<&'a mut macros::Test2>::shr_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Shr<&macros::Test2>>::shr
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr(p1);
+<macros::Test2 as std::ops::Shr<&macros::Test2>>::shr(p0, p1);
+crate::<macros::Test2 as std::ops::Shr<&macros::Test2>>::shr(p0, p1);
+<macros::Test2>::shr(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Shr<&macros::Test2>>::shr
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr(p1);
+<&'a macros::Test2 as std::ops::Shr<&macros::Test2>>::shr(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Shr<&macros::Test2>>::shr(p0, p1);
+<&'a macros::Test2>::shr(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Shr<&macros::Test2>>::shr
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = & MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr(p1);
+<&'a mut macros::Test2 as std::ops::Shr<&macros::Test2>>::shr(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Shr<&macros::Test2>>::shr(p0, p1);
+<&'a mut macros::Test2>::shr(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::ShrAssign<&mut macros::Test2>>::shr_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr_assign(p1);
+<macros::Test2 as std::ops::ShrAssign<&mut macros::Test2>>::shr_assign(p0, p1);
+crate::<macros::Test2 as std::ops::ShrAssign<&mut macros::Test2>>::shr_assign(p0, p1);
+<macros::Test2>::shr_assign(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::ShrAssign<&mut macros::Test2>>::shr_assign
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr_assign(p1);
+<&'a mut macros::Test2 as std::ops::ShrAssign<&mut macros::Test2>>::shr_assign(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::ShrAssign<&mut macros::Test2>>::shr_assign(p0, p1);
+<&'a mut macros::Test2>::shr_assign(p0, p1);
-----------------
src/macros.rs <macros::Test2 as std::ops::Shr<&mut macros::Test2>>::shr
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr(p1);
+<macros::Test2 as std::ops::Shr<&mut macros::Test2>>::shr(p0, p1);
+crate::<macros::Test2 as std::ops::Shr<&mut macros::Test2>>::shr(p0, p1);
+<macros::Test2>::shr(p0, p1);
-----------------
src/macros.rs <&'a macros::Test2 as std::ops::Shr<&mut macros::Test2>>::shr
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr(p1);
+<&'a macros::Test2 as std::ops::Shr<&mut macros::Test2>>::shr(p0, p1);
+crate::<&'a macros::Test2 as std::ops::Shr<&mut macros::Test2>>::shr(p0, p1);
+<&'a macros::Test2>::shr(p0, p1);
-----------------
src/macros.rs <&'a mut macros::Test2 as std::ops::Shr<&mut macros::Test2>>::shr
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // macros::Test2
+p0.shr(p1);
+<&'a mut macros::Test2 as std::ops::Shr<&mut macros::Test2>>::shr(p0, p1);
+crate::<&'a mut macros::Test2 as std::ops::Shr<&mut macros::Test2>>::shr(p0, p1);
+<&'a mut macros::Test2>::shr(p0, p1);