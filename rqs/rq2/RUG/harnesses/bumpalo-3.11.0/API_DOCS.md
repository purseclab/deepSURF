# Crate Documentation

**Version:** 3.11.0

**Format Version:** 45

# Module `bumpalo`

<!-- Generated by cargo-onedoc v0.2.2. DO NOT EDIT. -->

# bumpalo

[![Crates.io Version](https://badgers.space/crates/version/bumpalo)](https://crates.io/crates/bumpalo)
[![Docs.rs Latest](https://badgers.space/badge/docs.rs/latest/blue)](https://docs.rs/bumpalo)
[![Build Status](https://badgers.space/github/checks/fitzgen/bumpalo?label=build)](https://github.com/fitzgen/bumpalo/actions/workflows/build.yaml)





## License

This project is distributed under the terms of both the MIT license and the Apache License (Version 2.0).

See [LICENSE-APACHE](LICENSE-APACHE) and [LICENSE-MIT](LICENSE-MIT) for details.

## Types

### Enum `AllocOrInitError`

An error returned from [`Bump::try_alloc_try_with`].

```rust
pub enum AllocOrInitError<E> {
    Alloc(AllocErr),
    Init(E),
}
```

#### Variants

##### `Alloc`

Indicates that the initial allocation failed.

Fields:

| Index | Type | Documentation |
|-------|------|---------------|
| 0 | `AllocErr` |  |

##### `Init`

Indicates that the initializer failed with the contained error after
allocation.

It is possible but not guaranteed that the allocated memory has been
released back to the allocator at this point.

Fields:

| Index | Type | Documentation |
|-------|------|---------------|
| 0 | `E` |  |

#### Implementations

##### Trait Implementations

- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

- **CloneToUninit**
  - ```rust
    unsafe fn clone_to_uninit(self: &Self, dest: *mut u8) { /* ... */ }
    ```

- **ToString**
  - ```rust
    fn to_string(self: &Self) -> String { /* ... */ }
    ```

- **Freeze**
- **Display**
  - ```rust
    fn fmt(self: &Self, f: &mut core::fmt::Formatter<''_>) -> core::fmt::Result { /* ... */ }
    ```

- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **ToOwned**
  - ```rust
    fn to_owned(self: &Self) -> T { /* ... */ }
    ```

  - ```rust
    fn clone_into(self: &Self, target: &mut T) { /* ... */ }
    ```

- **StructuralPartialEq**
- **Send**
- **Sync**
- **Debug**
  - ```rust
    fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<''_>) -> $crate::fmt::Result { /* ... */ }
    ```

- **Unpin**
- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **Clone**
  - ```rust
    fn clone(self: &Self) -> AllocOrInitError<E> { /* ... */ }
    ```

- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

- **PartialEq**
  - ```rust
    fn eq(self: &Self, other: &AllocOrInitError<E>) -> bool { /* ... */ }
    ```

- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

- **UnwindSafe**
- **Eq**
- **RefUnwindSafe**
- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

  - ```rust
    fn from(e: AllocErr) -> Self { /* ... */ }
    ```

### Struct `Bump`

 An arena to bump allocate into.

 ## No `Drop`s

 Objects that are bump-allocated will never have their [`Drop`] implementation
 called &mdash; unless you do it manually yourself. This makes it relatively
 easy to leak memory or other resources.

 If you have a type which internally manages

 * an allocation from the global heap (e.g. [`Vec<T>`]),
 * open file descriptors (e.g. [`std::fs::File`]), or
 * any other resource that must be cleaned up (e.g. an `mmap`)

 and relies on its `Drop` implementation to clean up the internal resource,
 then if you allocate that type with a `Bump`, you need to find a new way to
 clean up after it yourself.

 Potential solutions are:

 * Using [`bumpalo::boxed::Box::new_in`] instead of [`Bump::alloc`], that
   will drop wrapped values similarly to [`std::boxed::Box`]. Note that this
   requires enabling the `"boxed"` Cargo feature for this crate. **This is
   often the easiest solution.**

 * Calling [`drop_in_place`][drop_in_place] or using
   [`std::mem::ManuallyDrop`][manuallydrop] to manually drop these types.

 * Using [`bumpalo::collections::Vec`] instead of [`std::vec::Vec`].

 * Avoiding allocating these problematic types within a `Bump`.

 Note that not calling `Drop` is memory safe! Destructors are never
 guaranteed to run in Rust, you can't rely on them for enforcing memory
 safety.

 [`Drop`]: https://doc.rust-lang.org/std/ops/trait.Drop.html
 [`Vec<T>`]: https://doc.rust-lang.org/std/vec/struct.Vec.html
 [`std::fs::File`]: https://doc.rust-lang.org/std/fs/struct.File.html
 [drop_in_place]: https://doc.rust-lang.org/std/ptr/fn.drop_in_place.html
 [manuallydrop]: https://doc.rust-lang.org/std/mem/struct.ManuallyDrop.html
 [`bumpalo::collections::Vec`]: collections/vec/struct.Vec.html
 [`std::vec::Vec`]: https://doc.rust-lang.org/std/vec/struct.Vec.html
 [`bumpalo::boxed::Box::new_in`]: boxed/struct.Box.html#method.new_in
 [`std::boxed::Box`]: https://doc.rust-lang.org/std/boxed/struct.Box.html

 ## Example

 ```
 use bumpalo::Bump;

 // Create a new bump arena.
 let bump = Bump::new();

 // Allocate values into the arena.
 let forty_two = bump.alloc(42);
 assert_eq!(*forty_two, 42);

 // Mutable references are returned from allocation.
 let mut s = bump.alloc("bumpalo");
 *s = "the bump allocator; and also is a buffalo";
 ```

 ## Allocation Methods Come in Many Flavors

 There are various allocation methods on `Bump`, the simplest being
 [`alloc`][Bump::alloc]. The others exist to satisfy some combination of
 fallible allocation and initialization. The allocation methods are
 summarized in the following table:

 <table>
   <thead>
     <tr>
       <th></th>
       <th>Infallible Allocation</th>
       <th>Fallible Allocation</th>
     </tr>
   </thead>
     <tr>
       <th>By Value</th>
       <td><a href="#method.alloc"><code>alloc</code></a></td>
       <td><a href="#method.try_alloc"><code>try_alloc</code></a></td>
     </tr>
     <tr>
       <th>Infallible Initializer Function</th>
       <td><a href="#method.alloc_with"><code>alloc_with</code></a></td>
       <td><a href="#method.try_alloc_with"><code>try_alloc_with</code></a></td>
     </tr>
     <tr>
       <th>Fallible Initializer Function</th>
       <td><a href="#method.alloc_try_with"><code>alloc_try_with</code></a></td>
       <td><a href="#method.try_alloc_try_with"><code>try_alloc_try_with</code></a></td>
     </tr>
   <tbody>
   </tbody>
 </table>

 ### Fallible Allocation: The `try_alloc_` Method Prefix

 These allocation methods let you recover from out-of-memory (OOM)
 scenarioes, rather than raising a panic on OOM.

 ```
 use bumpalo::Bump;

 let bump = Bump::new();

 match bump.try_alloc(MyStruct {
     // ...
 }) {
     Ok(my_struct) => {
         // Allocation succeeded.
     }
     Err(e) => {
         // Out of memory.
     }
 }

 struct MyStruct {
     // ...
 }
 ```

 ### Initializer Functions: The `_with` Method Suffix

 Calling one of the generic `…alloc(x)` methods is essentially equivalent to
 the matching [`…alloc_with(|| x)`](?search=alloc_with). However if you use
 `…alloc_with`, then the closure will not be invoked until after allocating
 space for storing `x` on the heap.

 This can be useful in certain edge-cases related to compiler optimizations.
 When evaluating for example `bump.alloc(x)`, semantically `x` is first put
 on the stack and then moved onto the heap. In some cases, the compiler is
 able to optimize this into constructing `x` directly on the heap, however
 in many cases it does not.

 The `…alloc_with` functions try to help the compiler be smarter. In most
 cases doing for example `bump.try_alloc_with(|| x)` on release mode will be
 enough to help the compiler realize that this optimization is valid and
 to construct `x` directly onto the heap.

 #### Warning

 These functions critically depend on compiler optimizations to achieve their
 desired effect. This means that it is not an effective tool when compiling
 without optimizations on.

 Even when optimizations are on, these functions do not **guarantee** that
 the value is constructed on the heap. To the best of our knowledge no such
 guarantee can be made in stable Rust as of 1.54.

 ### Fallible Initialization: The `_try_with` Method Suffix

 The generic [`…alloc_try_with(|| x)`](?search=_try_with) methods behave
 like the purely `_with` suffixed methods explained above. However, they
 allow for fallible initialization by accepting a closure that returns a
 [`Result`] and will attempt to undo the initial allocation if this closure
 returns [`Err`].

 #### Warning

 If the inner closure returns [`Ok`], space for the entire [`Result`] remains
 allocated inside `self`. This can be a problem especially if the [`Err`]
 variant is larger, but even otherwise there may be overhead for the
 [`Result`]'s discriminant.

 <p><details><summary>Undoing the allocation in the <code>Err</code> case
 always fails if <code>f</code> successfully made any additional allocations
 in <code>self</code>.</summary>

 For example, the following will always leak also space for the [`Result`]
 into this `Bump`, even though the inner reference isn't kept and the [`Err`]
 payload is returned semantically by value:

 ```rust
 let bump = bumpalo::Bump::new();

 let r: Result<&mut [u8; 1000], ()> = bump.alloc_try_with(|| {
     let _ = bump.alloc(0_u8);
     Err(())
 });

 assert!(r.is_err());
 ```

</details></p>

 Since [`Err`] payloads are first placed on the heap and then moved to the
 stack, `bump.…alloc_try_with(|| x)?` is likely to execute more slowly than
 the matching `bump.…alloc(x?)` in case of initialization failure. If this
 happens frequently, using the plain un-suffixed method may perform better.

 [`Result`]: https://doc.rust-lang.org/std/result/enum.Result.html
 [`Ok`]: https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok
 [`Err`]: https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err

 ### `Bump` Allocation Limits

 `bumpalo` supports setting a limit on the maximum bytes of memory that can
 be allocated for use in a particular `Bump` arena. This limit can be set and removed with
 [`set_allocation_limit`][Bump::set_allocation_limit].
 The allocation limit is only enforced when allocating new backing chunks for
 a `Bump`. Updating the allocation limit will not affect existing allocations
 or any future allocations within the `Bump`'s current chunk.

 #### Example

 ```
 let bump = bumpalo::Bump::new();

 assert_eq!(bump.allocation_limit(), None);
 bump.set_allocation_limit(Some(0));

 assert!(bump.try_alloc(5).is_err());

 bump.set_allocation_limit(Some(6));

 assert_eq!(bump.allocation_limit(), Some(6));

 bump.set_allocation_limit(None);

 assert_eq!(bump.allocation_limit(), None);
 ```

 #### Warning

 Because of backwards compatibility, allocations that fail
 due to allocation limits will not present differently than
 errors due to resource exhaustion.

```rust
pub struct Bump {
    // Some fields omitted
}
```

#### Fields

| Name | Type | Documentation |
|------|------|---------------|
| *private fields* | ... | *Some fields have been omitted* |

#### Implementations

##### Methods

- ```rust
  pub fn new() -> Bump { /* ... */ }
  ```
  Construct a new arena to bump allocate into.

- ```rust
  pub fn try_new() -> Result<Bump, AllocErr> { /* ... */ }
  ```
  Attempt to construct a new arena to bump allocate into.

- ```rust
  pub fn with_capacity(capacity: usize) -> Bump { /* ... */ }
  ```
  Construct a new arena with the specified byte capacity to bump allocate into.

- ```rust
  pub fn try_with_capacity(capacity: usize) -> Result<Self, AllocErr> { /* ... */ }
  ```
  Attempt to construct a new arena with the specified byte capacity to bump allocate into.

- ```rust
  pub fn allocation_limit(self: &Self) -> Option<usize> { /* ... */ }
  ```
  The allocation limit for this arena in bytes.

- ```rust
  pub fn set_allocation_limit(self: &Self, limit: Option<usize>) { /* ... */ }
  ```
  Set the allocation limit in bytes for this arena.

- ```rust
  pub fn reset(self: &mut Self) { /* ... */ }
  ```
   Reset this bump allocator.

- ```rust
  pub fn alloc<T>(self: &Self, val: T) -> &mut T { /* ... */ }
  ```
  Allocate an object in this `Bump` and return an exclusive reference to

- ```rust
  pub fn try_alloc<T>(self: &Self, val: T) -> Result<&mut T, AllocErr> { /* ... */ }
  ```
  Try to allocate an object in this `Bump` and return an exclusive

- ```rust
  pub fn alloc_with<F, T>(self: &Self, f: F) -> &mut T
where
    F: FnOnce() -> T { /* ... */ }
  ```
  Pre-allocate space for an object in this `Bump`, initializes it using

- ```rust
  pub fn try_alloc_with<F, T>(self: &Self, f: F) -> Result<&mut T, AllocErr>
where
    F: FnOnce() -> T { /* ... */ }
  ```
  Tries to pre-allocate space for an object in this `Bump`, initializes

- ```rust
  pub fn alloc_try_with<F, T, E>(self: &Self, f: F) -> Result<&mut T, E>
where
    F: FnOnce() -> Result<T, E> { /* ... */ }
  ```
  Pre-allocates space for a [`Result`] in this `Bump`, initializes it using

- ```rust
  pub fn try_alloc_try_with<F, T, E>(self: &Self, f: F) -> Result<&mut T, AllocOrInitError<E>>
where
    F: FnOnce() -> Result<T, E> { /* ... */ }
  ```
  Tries to pre-allocates space for a [`Result`] in this `Bump`,

- ```rust
  pub fn alloc_slice_copy<T>(self: &Self, src: &[T]) -> &mut [T]
where
    T: Copy { /* ... */ }
  ```
  `Copy` a slice into this `Bump` and return an exclusive reference to

- ```rust
  pub fn alloc_slice_clone<T>(self: &Self, src: &[T]) -> &mut [T]
where
    T: Clone { /* ... */ }
  ```
  `Clone` a slice into this `Bump` and return an exclusive reference to

- ```rust
  pub fn alloc_str(self: &Self, src: &str) -> &mut str { /* ... */ }
  ```
  `Copy` a string slice into this `Bump` and return an exclusive reference to it.

- ```rust
  pub fn alloc_slice_fill_with<T, F>(self: &Self, len: usize, f: F) -> &mut [T]
where
    F: FnMut(usize) -> T { /* ... */ }
  ```
  Allocates a new slice of size `len` into this `Bump` and returns an

- ```rust
  pub fn alloc_slice_fill_copy<T: Copy>(self: &Self, len: usize, value: T) -> &mut [T] { /* ... */ }
  ```
  Allocates a new slice of size `len` into this `Bump` and returns an

- ```rust
  pub fn alloc_slice_fill_clone<T: Clone>(self: &Self, len: usize, value: &T) -> &mut [T] { /* ... */ }
  ```
  Allocates a new slice of size `len` slice into this `Bump` and return an

- ```rust
  pub fn alloc_slice_fill_iter<T, I>(self: &Self, iter: I) -> &mut [T]
where
    I: IntoIterator<Item = T>,
    <I as >::IntoIter: ExactSizeIterator { /* ... */ }
  ```
  Allocates a new slice of size `len` slice into this `Bump` and return an

- ```rust
  pub fn alloc_slice_fill_default<T: Default>(self: &Self, len: usize) -> &mut [T] { /* ... */ }
  ```
  Allocates a new slice of size `len` slice into this `Bump` and return an

- ```rust
  pub fn alloc_layout(self: &Self, layout: Layout) -> NonNull<u8> { /* ... */ }
  ```
  Allocate space for an object with the given `Layout`.

- ```rust
  pub fn try_alloc_layout(self: &Self, layout: Layout) -> Result<NonNull<u8>, AllocErr> { /* ... */ }
  ```
  Attempts to allocate space for an object with the given `Layout` or else returns

- ```rust
  pub fn chunk_capacity(self: &Self) -> usize { /* ... */ }
  ```
  Gets the remaining capacity in the current chunk (in bytes).

- ```rust
  pub fn iter_allocated_chunks(self: &mut Self) -> ChunkIter<''_> { /* ... */ }
  ```
  Returns an iterator over each chunk of allocated memory that

- ```rust
  pub unsafe fn iter_allocated_chunks_raw(self: &Self) -> ChunkRawIter<''_> { /* ... */ }
  ```
  Returns an iterator over raw pointers to chunks of allocated memory that

- ```rust
  pub fn allocated_bytes(self: &Self) -> usize { /* ... */ }
  ```
  Calculates the number of bytes currently allocated across all chunks in

##### Trait Implementations

- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

- **Default**
  - ```rust
    fn default() -> Bump { /* ... */ }
    ```

- **Send**
- **Freeze**
- **Unpin**
- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

- **Debug**
  - ```rust
    fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<''_>) -> $crate::fmt::Result { /* ... */ }
    ```

- **Sync**
- **Drop**
  - ```rust
    fn drop(self: &mut Self) { /* ... */ }
    ```

- **RefUnwindSafe**
- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

- **UnwindSafe**
- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

### Struct `ChunkIter`

An iterator over each chunk of allocated memory that
an arena has bump allocated into.

The chunks are returned ordered by allocation time, with the most recently
allocated chunk being returned first.

The values inside each chunk are also ordered by allocation time, with the most
recent allocation being earlier in the slice.

This struct is created by the [`iter_allocated_chunks`] method on
[`Bump`]. See that function for a safety description regarding reading from the returned items.

[`Bump`]: struct.Bump.html
[`iter_allocated_chunks`]: struct.Bump.html#method.iter_allocated_chunks

```rust
pub struct ChunkIter<''a> {
    // Some fields omitted
}
```

#### Fields

| Name | Type | Documentation |
|------|------|---------------|
| *private fields* | ... | *Some fields have been omitted* |

#### Implementations

##### Trait Implementations

- **RefUnwindSafe**
- **Sync**
- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

- **UnwindSafe**
- **Send**
- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **Iterator**
  - ```rust
    fn next(self: &mut Self) -> Option<&''a [mem::MaybeUninit<u8>]> { /* ... */ }
    ```

- **IntoIterator**
  - ```rust
    fn into_iter(self: Self) -> I { /* ... */ }
    ```

- **Unpin**
- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

- **FusedIterator**
- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **Freeze**
- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

- **Debug**
  - ```rust
    fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<''_>) -> $crate::fmt::Result { /* ... */ }
    ```

### Struct `ChunkRawIter`

An iterator over raw pointers to chunks of allocated memory that this
arena has bump allocated into.

See [`ChunkIter`] for details regarding the returned chunks.

This struct is created by the [`iter_allocated_chunks_raw`] method on
[`Bump`]. See that function for a safety description regarding reading from
the returned items.

[`Bump`]: struct.Bump.html
[`iter_allocated_chunks_raw`]: struct.Bump.html#method.iter_allocated_chunks_raw

```rust
pub struct ChunkRawIter<''a> {
    // Some fields omitted
}
```

#### Fields

| Name | Type | Documentation |
|------|------|---------------|
| *private fields* | ... | *Some fields have been omitted* |

#### Implementations

##### Trait Implementations

- **Send**
- **UnwindSafe**
- **RefUnwindSafe**
- **Into**
  - ```rust
    fn into(self: Self) -> U { /* ... */ }
    ```
    Calls `U::from(self)`.

- **Borrow**
  - ```rust
    fn borrow(self: &Self) -> &T { /* ... */ }
    ```

- **Sync**
- **FusedIterator**
- **TryFrom**
  - ```rust
    fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error> { /* ... */ }
    ```

- **TryInto**
  - ```rust
    fn try_into(self: Self) -> Result<U, <U as TryFrom<T>>::Error> { /* ... */ }
    ```

- **Unpin**
- **IntoIterator**
  - ```rust
    fn into_iter(self: Self) -> I { /* ... */ }
    ```

- **From**
  - ```rust
    fn from(t: T) -> T { /* ... */ }
    ```
    Returns the argument unchanged.

- **BorrowMut**
  - ```rust
    fn borrow_mut(self: &mut Self) -> &mut T { /* ... */ }
    ```

- **Any**
  - ```rust
    fn type_id(self: &Self) -> TypeId { /* ... */ }
    ```

- **Iterator**
  - ```rust
    fn next(self: &mut Self) -> Option<(*mut u8, usize)> { /* ... */ }
    ```

- **Debug**
  - ```rust
    fn fmt(self: &Self, f: &mut $crate::fmt::Formatter<''_>) -> $crate::fmt::Result { /* ... */ }
    ```

- **Freeze**
## Re-exports

### Re-export `AllocErr`

```rust
pub use alloc::AllocErr;
```

