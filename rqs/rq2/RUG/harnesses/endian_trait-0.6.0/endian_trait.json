{"dependencies":{"<bool as Endian>::from_be":[],"<bool as Endian>::from_le":[],"<bool as Endian>::to_be":[],"<bool as Endian>::to_le":[],"<char as Endian>::from_be":[],"<char as Endian>::from_le":[],"<char as Endian>::to_be":[],"<char as Endian>::to_le":[],"<f32 as Endian>::from_be":[],"<f32 as Endian>::from_le":[],"<f32 as Endian>::to_be":[],"<f32 as Endian>::to_le":[],"<f64 as Endian>::from_be":[],"<f64 as Endian>::from_le":[],"<f64 as Endian>::to_be":[],"<f64 as Endian>::to_le":[],"<i128 as Endian>::from_be":[],"<i128 as Endian>::from_le":[],"<i128 as Endian>::to_be":[],"<i128 as Endian>::to_le":[],"<i16 as Endian>::from_be":[],"<i16 as Endian>::from_le":[],"<i16 as Endian>::to_be":[],"<i16 as Endian>::to_le":[],"<i32 as Endian>::from_be":[],"<i32 as Endian>::from_le":[],"<i32 as Endian>::to_be":[],"<i32 as Endian>::to_le":[],"<i64 as Endian>::from_be":[],"<i64 as Endian>::from_le":[],"<i64 as Endian>::to_be":[],"<i64 as Endian>::to_le":[],"<i8 as Endian>::from_be":[],"<i8 as Endian>::from_le":[],"<i8 as Endian>::to_be":[],"<i8 as Endian>::to_le":[],"<u128 as Endian>::from_be":[],"<u128 as Endian>::from_le":[],"<u128 as Endian>::to_be":[],"<u128 as Endian>::to_le":[],"<u16 as Endian>::from_be":[],"<u16 as Endian>::from_le":[],"<u16 as Endian>::to_be":[],"<u16 as Endian>::to_le":[],"<u32 as Endian>::from_be":[],"<u32 as Endian>::from_le":[],"<u32 as Endian>::to_be":[],"<u32 as Endian>::to_le":[],"<u64 as Endian>::from_be":[],"<u64 as Endian>::from_le":[],"<u64 as Endian>::to_be":[],"<u64 as Endian>::to_le":[],"<u8 as Endian>::from_be":[],"<u8 as Endian>::from_le":[],"<u8 as Endian>::to_be":[],"<u8 as Endian>::to_le":[],"Endian::from_be":[],"Endian::from_le":[],"Endian::to_be":[],"Endian::to_le":[],"slices::<impl Endian for &'a mut [T]>::from_be":[],"slices::<impl Endian for &'a mut [T]>::from_le":[],"slices::<impl Endian for &'a mut [T]>::to_be":[],"slices::<impl Endian for &'a mut [T]>::to_le":[]},"glob_path_import":{"endian_trait_derive":""},"self_to_fn":{},"single_path_import":{},"srcs":{"<bool as Endian>::from_be":["fn from_be(self) -> Self{ self }","Real(LocalPath(\"src/lib.rs\"))"],"<bool as Endian>::from_le":["fn from_le(self) -> Self{ self }","Real(LocalPath(\"src/lib.rs\"))"],"<bool as Endian>::to_be":["fn to_be(self) -> Self{ self }","Real(LocalPath(\"src/lib.rs\"))"],"<bool as Endian>::to_le":["fn to_le(self) -> Self{ self }","Real(LocalPath(\"src/lib.rs\"))"],"<char as Endian>::from_be":["/// Attempts to create a local `char` from a big-endian value.\n///\n/// This function WILL panic if the local value exceeds the maximum Unicode\n/// Scalar Value permissible.\nfn from_be(self) -> Self{\n\t\tlet flip: u32 = (self as u32).from_be();\n\t\tif flip > ::std::char::MAX as u32 {\n\t\t\tpanic!(\"A `char` cannot have a value of {:X}\", flip);\n\t\t}\n\t\tunsafe { ::std::mem::transmute(flip) }\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<char as Endian>::from_le":["/// Attempts to create a local `char` from a little-endian value.\n///\n/// This function WILL panic if the local value exceeds the maximum Unicode\n/// Scalar Value permissible.\nfn from_le(self) -> Self{\n\t\tlet flip: u32 = (self as u32).from_le();\n\t\tif flip > ::std::char::MAX as u32 {\n\t\t\tpanic!(\"A `char` cannot have a value of {:X}\", flip);\n\t\t}\n\t\tunsafe { ::std::mem::transmute(flip) }\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<char as Endian>::to_be":["/// Converts a local `char` to big-endian.\n///\n/// This may result in a byte value that is not a valid Unicode Scalar Value\n/// and the result of this transform should be passed into a `from_be()`\n/// before using it in anything that requires `char` semantics.\nfn to_be(self) -> Self{\n\t\tunsafe { ::std::mem::transmute((self as u32).to_be()) }\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<char as Endian>::to_le":["/// Converts a local `char` to little-endian.\n///\n/// This may result in a byte value that is not a valid Unicode Scalar Value\n/// and the result of this transform should be passed into a `from_le()`\n/// before using it in anything that requires `char` semantics.\nfn to_le(self) -> Self{\n\t\tunsafe { ::std::mem::transmute((self as u32).to_le()) }\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<f32 as Endian>::from_be":["fn from_be(self) -> Self{\n\t\t\t\tSelf::from_bits(self.to_bits().from_be())\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<f32 as Endian>::from_le":["fn from_le(self) -> Self{\n\t\t\t\tSelf::from_bits(self.to_bits().from_le())\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<f32 as Endian>::to_be":["fn to_be(self) -> Self{\n\t\t\t\tSelf::from_bits(self.to_bits().to_be())\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<f32 as Endian>::to_le":["fn to_le(self) -> Self{\n\t\t\t\tSelf::from_bits(self.to_bits().to_le())\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<f64 as Endian>::from_be":["fn from_be(self) -> Self{\n\t\t\t\tSelf::from_bits(self.to_bits().from_be())\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<f64 as Endian>::from_le":["fn from_le(self) -> Self{\n\t\t\t\tSelf::from_bits(self.to_bits().from_le())\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<f64 as Endian>::to_be":["fn to_be(self) -> Self{\n\t\t\t\tSelf::from_bits(self.to_bits().to_be())\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<f64 as Endian>::to_le":["fn to_le(self) -> Self{\n\t\t\t\tSelf::from_bits(self.to_bits().to_le())\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i128 as Endian>::from_be":["#[inline(always)]\nfn from_be(self) -> Self{\n\t\t\t\t$t::from_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i128 as Endian>::from_le":["#[inline(always)]\nfn from_le(self) -> Self{\n\t\t\t\t$t::from_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i128 as Endian>::to_be":["#[inline(always)]\nfn to_be(self) -> Self{\n\t\t\t\t$t::to_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i128 as Endian>::to_le":["#[inline(always)]\nfn to_le(self) -> Self{\n\t\t\t\t$t::to_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i16 as Endian>::from_be":["#[inline(always)]\nfn from_be(self) -> Self{\n\t\t\t\t$t::from_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i16 as Endian>::from_le":["#[inline(always)]\nfn from_le(self) -> Self{\n\t\t\t\t$t::from_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i16 as Endian>::to_be":["#[inline(always)]\nfn to_be(self) -> Self{\n\t\t\t\t$t::to_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i16 as Endian>::to_le":["#[inline(always)]\nfn to_le(self) -> Self{\n\t\t\t\t$t::to_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i32 as Endian>::from_be":["#[inline(always)]\nfn from_be(self) -> Self{\n\t\t\t\t$t::from_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i32 as Endian>::from_le":["#[inline(always)]\nfn from_le(self) -> Self{\n\t\t\t\t$t::from_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i32 as Endian>::to_be":["#[inline(always)]\nfn to_be(self) -> Self{\n\t\t\t\t$t::to_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i32 as Endian>::to_le":["#[inline(always)]\nfn to_le(self) -> Self{\n\t\t\t\t$t::to_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i64 as Endian>::from_be":["#[inline(always)]\nfn from_be(self) -> Self{\n\t\t\t\t$t::from_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i64 as Endian>::from_le":["#[inline(always)]\nfn from_le(self) -> Self{\n\t\t\t\t$t::from_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i64 as Endian>::to_be":["#[inline(always)]\nfn to_be(self) -> Self{\n\t\t\t\t$t::to_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i64 as Endian>::to_le":["#[inline(always)]\nfn to_le(self) -> Self{\n\t\t\t\t$t::to_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i8 as Endian>::from_be":["#[inline(always)]\nfn from_be(self) -> Self{\n\t\t\t\t$t::from_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i8 as Endian>::from_le":["#[inline(always)]\nfn from_le(self) -> Self{\n\t\t\t\t$t::from_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i8 as Endian>::to_be":["#[inline(always)]\nfn to_be(self) -> Self{\n\t\t\t\t$t::to_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<i8 as Endian>::to_le":["#[inline(always)]\nfn to_le(self) -> Self{\n\t\t\t\t$t::to_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u128 as Endian>::from_be":["#[inline(always)]\nfn from_be(self) -> Self{\n\t\t\t\t$t::from_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u128 as Endian>::from_le":["#[inline(always)]\nfn from_le(self) -> Self{\n\t\t\t\t$t::from_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u128 as Endian>::to_be":["#[inline(always)]\nfn to_be(self) -> Self{\n\t\t\t\t$t::to_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u128 as Endian>::to_le":["#[inline(always)]\nfn to_le(self) -> Self{\n\t\t\t\t$t::to_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u16 as Endian>::from_be":["#[inline(always)]\nfn from_be(self) -> Self{\n\t\t\t\t$t::from_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u16 as Endian>::from_le":["#[inline(always)]\nfn from_le(self) -> Self{\n\t\t\t\t$t::from_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u16 as Endian>::to_be":["#[inline(always)]\nfn to_be(self) -> Self{\n\t\t\t\t$t::to_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u16 as Endian>::to_le":["#[inline(always)]\nfn to_le(self) -> Self{\n\t\t\t\t$t::to_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u32 as Endian>::from_be":["#[inline(always)]\nfn from_be(self) -> Self{\n\t\t\t\t$t::from_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u32 as Endian>::from_le":["#[inline(always)]\nfn from_le(self) -> Self{\n\t\t\t\t$t::from_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u32 as Endian>::to_be":["#[inline(always)]\nfn to_be(self) -> Self{\n\t\t\t\t$t::to_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u32 as Endian>::to_le":["#[inline(always)]\nfn to_le(self) -> Self{\n\t\t\t\t$t::to_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u64 as Endian>::from_be":["#[inline(always)]\nfn from_be(self) -> Self{\n\t\t\t\t$t::from_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u64 as Endian>::from_le":["#[inline(always)]\nfn from_le(self) -> Self{\n\t\t\t\t$t::from_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u64 as Endian>::to_be":["#[inline(always)]\nfn to_be(self) -> Self{\n\t\t\t\t$t::to_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u64 as Endian>::to_le":["#[inline(always)]\nfn to_le(self) -> Self{\n\t\t\t\t$t::to_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u8 as Endian>::from_be":["#[inline(always)]\nfn from_be(self) -> Self{\n\t\t\t\t$t::from_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u8 as Endian>::from_le":["#[inline(always)]\nfn from_le(self) -> Self{\n\t\t\t\t$t::from_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u8 as Endian>::to_be":["#[inline(always)]\nfn to_be(self) -> Self{\n\t\t\t\t$t::to_be(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"<u8 as Endian>::to_le":["#[inline(always)]\nfn to_le(self) -> Self{\n\t\t\t\t$t::to_le(self)\n\t\t\t}","Real(LocalPath(\"src/lib.rs\"))"],"Endian":["/// Convert a type from one endian order to another.\n///\n/// The standard implementation of this trait is simply to call the methods on\n/// the component members of a data type which are themselves `Endian`, until the\n/// call stack bottoms out at one of Rust's primitives.\npub trait Endian {\n\t/// Converts from host endian to big-endian order.\n\t///\n\t/// On big-endian platforms, this is a no-op and should be compiled out.\n\tfn to_be(self) -> Self;\n\n\t/// Converts from host endian to little-endian order.\n\t///\n\t/// On little-endian platforms, this is a no-op and should be compiled out.\n\tfn to_le(self) -> Self;\n\n\t/// Converts from big-endian order to host endian.\n\t///\n\t/// On big-endian platforms, this is a no-op and should be compiled out.\n\tfn from_be(self) -> Self;\n\n\t/// Converts from little-endian order to host endian.\n\t///\n\t/// On little-endian platforms, this is a no-op and should be compiled out.\n\tfn from_le(self) -> Self;\n}","Real(LocalPath(\"src/lib.rs\"))"],"slices::<impl Endian for &'a mut [T]>::from_be":["fn from_be(self) -> Self{\n\t\tfor elt in self.iter_mut() { unsafe {\n\t\t\tptr::write(elt, ptr::read(elt).from_be());\n\t\t} }\n\t\tself\n\t}","Real(LocalPath(\"src/slices.rs\"))"],"slices::<impl Endian for &'a mut [T]>::from_le":["fn from_le(self) -> Self{\n\t\tfor elt in self.iter_mut() { unsafe {\n\t\t\tptr::write(elt, ptr::read(elt).from_le());\n\t\t} }\n\t\tself\n\t}","Real(LocalPath(\"src/slices.rs\"))"],"slices::<impl Endian for &'a mut [T]>::to_be":["fn to_be(self) -> Self{\n\t\tfor elt in self.iter_mut() { unsafe {\n\t\t\tptr::write(elt, ptr::read(elt).to_be());\n\t\t} }\n\t\tself\n\t}","Real(LocalPath(\"src/slices.rs\"))"],"slices::<impl Endian for &'a mut [T]>::to_le":["fn to_le(self) -> Self{\n\t\tfor elt in self.iter_mut() { unsafe {\n\t\t\tptr::write(elt, ptr::read(elt).to_le());\n\t\t} }\n\t\tself\n\t}","Real(LocalPath(\"src/slices.rs\"))"]},"struct_constructor":{},"struct_to_trait":{},"targets":{"<bool as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<bool as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<bool as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<bool as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<char as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<char as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<char as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<char as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<f32 as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<f32 as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<f32 as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<f32 as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<f64 as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<f64 as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<f64 as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<f64 as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i128 as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i128 as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i128 as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i128 as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i16 as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i16 as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i16 as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i16 as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i32 as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i32 as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i32 as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i32 as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i64 as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i64 as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i64 as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i64 as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i8 as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i8 as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i8 as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<i8 as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u128 as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u128 as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u128 as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u128 as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u16 as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u16 as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u16 as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u16 as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u32 as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u32 as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u32 as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u32 as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u64 as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u64 as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u64 as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u64 as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u8 as Endian>::from_be":["from_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u8 as Endian>::from_le":["from_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u8 as Endian>::to_be":["to_be","Real(LocalPath(\"src/lib.rs\"))","Endian"],"<u8 as Endian>::to_le":["to_le","Real(LocalPath(\"src/lib.rs\"))","Endian"],"slices::<impl Endian for &'a mut [T]>::from_be":["from_be","Real(LocalPath(\"src/slices.rs\"))","Endian"],"slices::<impl Endian for &'a mut [T]>::from_le":["from_le","Real(LocalPath(\"src/slices.rs\"))","Endian"],"slices::<impl Endian for &'a mut [T]>::to_be":["to_be","Real(LocalPath(\"src/slices.rs\"))","Endian"],"slices::<impl Endian for &'a mut [T]>::to_le":["to_le","Real(LocalPath(\"src/slices.rs\"))","Endian"]},"trait_to_struct":{},"type_to_def_path":{}}