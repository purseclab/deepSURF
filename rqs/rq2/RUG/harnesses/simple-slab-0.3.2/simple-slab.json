{"dependencies":{"<&'a Slab<T> as std::iter::IntoIterator>::into_iter":["Slab","SlabIter","std::marker::Sized"],"<&'a mut Slab<T> as std::iter::IntoIterator>::into_iter":["Slab","SlabIter","SlabMutIter","std::marker::Sized"],"<Slab<T> as std::ops::Drop>::drop":["Slab","std::marker::Sized"],"<Slab<T> as std::ops::Index<usize>>::index":["Slab","std::marker::Sized"],"<SlabIter<'a, T> as std::iter::Iterator>::next":["Slab","SlabIter","std::marker::Sized","std::option::Option"],"<SlabMutIter<'a, T> as std::iter::Iterator>::next":["Slab","SlabIter","SlabMutIter","std::marker::Sized","std::option::Option"],"Slab":["Slab","std::marker::Sized"],"Slab::<T>::insert":["Slab","std::marker::Sized"],"Slab::<T>::iter":["Slab","SlabIter","std::marker::Sized"],"Slab::<T>::iter_mut":["Slab","SlabIter","SlabMutIter","std::marker::Sized"],"Slab::<T>::len":["Slab","std::marker::Sized"],"Slab::<T>::new":["Slab","std::marker::Sized"],"Slab::<T>::reallocate":["Slab","std::marker::Sized"],"Slab::<T>::remove":["Slab","std::marker::Sized"],"Slab::<T>::with_capacity":["Slab","std::marker::Sized"],"SlabIter":["Slab","SlabIter","std::marker::Sized"],"SlabMutIter":["Slab","SlabIter","SlabMutIter","std::marker::Sized"]},"glob_path_import":{},"self_to_fn":{"Slab":["impl<T> Drop for Slab<T> {\n    fn drop(&mut self) {\n        for x in 0..self.len() {\n            unsafe {\n                let elem_ptr = self.mem.offset(x as isize);\n                ptr::drop_in_place(elem_ptr);\n            }\n        }\n\n        unsafe { libc::free(self.mem as *mut _ as *mut libc::c_void) };\n    }\n}","impl<T> Index<usize> for Slab<T> {\n    type Output = T;\n    fn index(&self, index: usize) -> &Self::Output {\n        //println!(\"Here: len: {:?}, index: {:?}\", self.len(), index);\n        unsafe { &(*(self.mem.offset(index as isize))) }\n    }\n}","impl<T> Slab<T> {\n    /// Creates a new Slab\n    pub fn new() -> Slab<T> { Slab::with_capacity(1) }\n\n    /// Creates a new, empty Slab with room for `capacity` elems\n    ///\n    /// # Panics\n    ///\n    /// * If the host system is out of memory\n    pub fn with_capacity(capacity: usize) -> Slab<T> {\n        let maybe_ptr = unsafe {\n            libc::malloc((mem::size_of::<T>() * capacity)) as *mut T\n        };\n\n        // malloc will return NULL if called with zero\n        if maybe_ptr.is_null() && capacity != 0 {\n            panic!(\"Unable to allocate requested capacity\")\n        }\n\n        return Slab {\n            capacity: capacity,\n            len: 0,\n            mem: maybe_ptr\n        }\n    }\n\n    /// Inserts a new element into the slab, re-allocating if neccessary.\n    ///\n    /// # Panics\n    ///\n    /// * If the host system is out of memory.\n    #[inline]\n    pub fn insert(&mut self, elem: T) {\n        if self.len == self.capacity { self.reallocate(); }\n\n        unsafe {\n            let ptr = self.mem.offset(self.len as isize);\n            ptr::write(ptr, elem);\n        }\n\n        self.len += 1;\n    }\n\n    /// Removes the element at `offset`.\n    ///\n    /// # Panics\n    ///\n    /// * If `offset` is out of bounds.\n    #[inline]\n    pub fn remove(&mut self, offset: usize) -> T {\n        assert!(offset < self.len, \"Offset out of bounds\");\n\n        let elem: T;\n        let last_elem: T;\n        let elem_ptr: *mut T;\n        let last_elem_ptr: *mut T;\n\n        unsafe {\n            elem_ptr = self.mem.offset(offset as isize);\n            last_elem_ptr = self.mem.offset(self.len as isize);\n\n            elem = ptr::read(elem_ptr);\n            last_elem = ptr::read(last_elem_ptr);\n\n            ptr::write(elem_ptr, last_elem);\n        }\n\n        self.len -= 1;\n        return elem;\n    }\n\n    /// Returns the number of elements in the slab\n    #[inline]\n    pub fn len(&self) -> usize { self.len }\n\n    /// Returns an iterator over the slab\n    #[inline]\n    pub fn iter(&self) -> SlabIter<T> {\n        SlabIter {\n            slab: self,\n            current_offset: 0\n        }\n    }\n\n    /// Returns a mutable iterator over the slab\n    #[inline]\n    pub fn iter_mut(&mut self) -> SlabMutIter<T> {\n        SlabMutIter { iter: self.iter() }\n    }\n\n    /// Reserves capacity * 2 extra space in this slab\n    ///\n    /// # Panics\n    ///\n    /// Panics if the host system is out of memory\n    #[inline]\n    fn reallocate(&mut self) {\n        let new_capacity = if self.capacity != 0 {\n            self.capacity * 2\n        } else { 1 };\n\n        let maybe_ptr = unsafe {\n            libc::realloc(self.mem as *mut libc::c_void,\n                          (mem::size_of::<T>() * new_capacity)) as *mut T\n        };\n\n        assert!(!maybe_ptr.is_null(), \"Out of Memory\");\n\n        self.capacity = new_capacity;\n        self.mem = maybe_ptr;\n    }\n}"],"SlabIter":["impl<'a, T> Iterator for SlabIter<'a, T> {\n    type Item = &'a T;\n    fn next(&mut self) -> Option<&'a T> {\n        while self.current_offset < self.slab.len() {\n            let offset = self.current_offset;\n            self.current_offset += 1;\n            unsafe {\n                return Some(&(*self.slab.mem.offset(offset as isize)));\n            }\n        }\n\n        None\n    }\n}"],"SlabMutIter":["impl<'a, T> Iterator for SlabMutIter<'a, T> {\n    type Item = &'a mut T;\n    fn next(&mut self) -> Option<&'a mut T> {\n        unsafe { mem::transmute(self.iter.next()) }\n    }\n}"]},"single_path_import":{},"srcs":{"<&'a Slab<T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> SlabIter<'a, T>{ self.iter() }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a mut Slab<T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> SlabMutIter<'a, T>{ self.iter_mut() }","Real(LocalPath(\"src/lib.rs\"))"],"<Slab<T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        for x in 0..self.len() {\n            unsafe {\n                let elem_ptr = self.mem.offset(x as isize);\n                ptr::drop_in_place(elem_ptr);\n            }\n        }\n\n        unsafe { libc::free(self.mem as *mut _ as *mut libc::c_void) };\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Slab<T> as std::ops::Index<usize>>::index":["fn index(&self, index: usize) -> &Self::Output{\n        //println!(\"Here: len: {:?}, index: {:?}\", self.len(), index);\n        unsafe { &(*(self.mem.offset(index as isize))) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SlabIter<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a T>{\n        while self.current_offset < self.slab.len() {\n            let offset = self.current_offset;\n            self.current_offset += 1;\n            unsafe {\n                return Some(&(*self.slab.mem.offset(offset as isize)));\n            }\n        }\n\n        None\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SlabMutIter<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a mut T>{\n        unsafe { mem::transmute(self.iter.next()) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab":["pub struct Slab<T> {\n    capacity: usize,\n    len: usize,\n    mem: *mut T\n}","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::insert":["/// Inserts a new element into the slab, re-allocating if neccessary.\n///\n/// # Panics\n///\n/// * If the host system is out of memory.\n#[inline]\npub fn insert(&mut self, elem: T){\n        if self.len == self.capacity { self.reallocate(); }\n\n        unsafe {\n            let ptr = self.mem.offset(self.len as isize);\n            ptr::write(ptr, elem);\n        }\n\n        self.len += 1;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::iter":["/// Returns an iterator over the slab\n#[inline]\npub fn iter(&self) -> SlabIter<T>{\n        SlabIter {\n            slab: self,\n            current_offset: 0\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::iter_mut":["/// Returns a mutable iterator over the slab\n#[inline]\npub fn iter_mut(&mut self) -> SlabMutIter<T>{\n        SlabMutIter { iter: self.iter() }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::len":["/// Returns the number of elements in the slab\n#[inline]\npub fn len(&self) -> usize{ self.len }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::new":["/// Creates a new Slab\npub fn new() -> Slab<T>{ Slab::with_capacity(1) }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::reallocate":["/// Reserves capacity * 2 extra space in this slab\n///\n/// # Panics\n///\n/// Panics if the host system is out of memory\n#[inline]\nfn reallocate(&mut self){\n        let new_capacity = if self.capacity != 0 {\n            self.capacity * 2\n        } else { 1 };\n\n        let maybe_ptr = unsafe {\n            libc::realloc(self.mem as *mut libc::c_void,\n                          (mem::size_of::<T>() * new_capacity)) as *mut T\n        };\n\n        assert!(!maybe_ptr.is_null(), \"Out of Memory\");\n\n        self.capacity = new_capacity;\n        self.mem = maybe_ptr;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::remove":["/// Removes the element at `offset`.\n///\n/// # Panics\n///\n/// * If `offset` is out of bounds.\n#[inline]\npub fn remove(&mut self, offset: usize) -> T{\n        assert!(offset < self.len, \"Offset out of bounds\");\n\n        let elem: T;\n        let last_elem: T;\n        let elem_ptr: *mut T;\n        let last_elem_ptr: *mut T;\n\n        unsafe {\n            elem_ptr = self.mem.offset(offset as isize);\n            last_elem_ptr = self.mem.offset(self.len as isize);\n\n            elem = ptr::read(elem_ptr);\n            last_elem = ptr::read(last_elem_ptr);\n\n            ptr::write(elem_ptr, last_elem);\n        }\n\n        self.len -= 1;\n        return elem;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::with_capacity":["/// Creates a new, empty Slab with room for `capacity` elems\n///\n/// # Panics\n///\n/// * If the host system is out of memory\npub fn with_capacity(capacity: usize) -> Slab<T>{\n        let maybe_ptr = unsafe {\n            libc::malloc((mem::size_of::<T>() * capacity)) as *mut T\n        };\n\n        // malloc will return NULL if called with zero\n        if maybe_ptr.is_null() && capacity != 0 {\n            panic!(\"Unable to allocate requested capacity\")\n        }\n\n        return Slab {\n            capacity: capacity,\n            len: 0,\n            mem: maybe_ptr\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SlabIter":["pub struct SlabIter<'a, T: 'a> {\n    slab: &'a Slab<T>,\n    current_offset: usize\n}","Real(LocalPath(\"src/lib.rs\"))"],"SlabMutIter":["pub struct SlabMutIter<'a, T: 'a> {\n    iter: SlabIter<'a, T>\n}","Real(LocalPath(\"src/lib.rs\"))"]},"struct_constructor":{"&<Slab<T> as std::ops::Index<usize>>::Output":["index"],"Slab":["new","with_capacity"],"SlabIter":["into_iter","iter"],"SlabMutIter":["into_iter","iter_mut"],"usize":["len"]},"struct_to_trait":{"Slab":["std::ops::Drop","std::ops::Index"],"SlabIter":["std::iter::Iterator"],"SlabMutIter":["std::iter::Iterator"]},"targets":{"<&'a Slab<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<&'a mut Slab<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<Slab<T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","std::ops::Drop"],"<Slab<T> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/lib.rs\"))","std::ops::Index"],"<SlabIter<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<SlabMutIter<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"Slab::<T>::insert":["insert","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::iter":["iter","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::iter_mut":["iter_mut","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::len":["len","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::reallocate":["reallocate","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::remove":["remove","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::with_capacity":["with_capacity","Real(LocalPath(\"src/lib.rs\"))",""]},"trait_to_struct":{"std::iter::Iterator":["SlabIter","SlabMutIter"],"std::ops::Drop":["Slab"],"std::ops::Index":["Slab"]},"type_to_def_path":{"Slab<T>":"Slab","SlabIter<'a, T>":"SlabIter","SlabMutIter<'a, T>":"SlabMutIter"}}