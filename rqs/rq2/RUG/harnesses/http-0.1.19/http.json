{"dependencies":{"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":["header::map::Danger","header::map::HeaderMap","header::map::Iter","header::map::IterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::as_str":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::entry":["header::map::Danger","header::map::HeaderMap","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find":["header::map::Danger","header::map::HeaderMap","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::append":["header::map::Danger","header::map::HeaderMap","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::insert":["header::map::Danger","header::map::HeaderMap","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"<&'a header::name::HeaderName as std::cmp::PartialEq<header::name::HeaderName>>::eq":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<&'a header::value::HeaderValue as std::cmp::PartialEq<header::value::HeaderValue>>::eq":["bytes::Bytes","header::value::HeaderValue"],"<&'a header::value::HeaderValue as std::cmp::PartialOrd<header::value::HeaderValue>>::partial_cmp":["bytes::Bytes","header::value::HeaderValue","std::marker::Sized","std::option::Option"],"<&'a method::Method as std::cmp::PartialEq<method::Method>>::eq":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":["header::map::Danger","header::map::HeaderMap","header::map::IterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<&'a std::string::String as header::map::as_header_name::Sealed>::as_str":["std::string::String"],"<&'a std::string::String as header::map::as_header_name::Sealed>::entry":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec"],"<&'a std::string::String as header::map::as_header_name::Sealed>::find":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"<&'a str as header::map::as_header_name::Sealed>::as_str":[],"<&'a str as header::map::as_header_name::Sealed>::entry":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a str as header::map::as_header_name::Sealed>::find":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter":["header::map::Danger","header::map::GetAll","header::map::HeaderMap","header::map::ValueIter","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","header::map::ValueIter","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","header::map::ValueIterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<&'static str as header::map::into_header_name::Sealed>::append":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"<&'static str as header::map::into_header_name::Sealed>::insert":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"<T as convert::HttpTryInto<U>>::http_try_into":["std::marker::Sized","std::result::Result"],"<byte_str::ByteStr as std::clone::Clone>::clone":["byte_str::ByteStr","bytes::Bytes"],"<byte_str::ByteStr as std::cmp::Eq>::assert_receiver_is_total_eq":["byte_str::ByteStr","bytes::Bytes"],"<byte_str::ByteStr as std::cmp::Ord>::cmp":["byte_str::ByteStr","bytes::Bytes","std::cmp::Ordering"],"<byte_str::ByteStr as std::cmp::PartialEq>::eq":["byte_str::ByteStr","bytes::Bytes"],"<byte_str::ByteStr as std::cmp::PartialOrd>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option"],"<byte_str::ByteStr as std::convert::From<&'a str>>::from":["byte_str::ByteStr","bytes::Bytes"],"<byte_str::ByteStr as std::convert::From<std::string::String>>::from":["byte_str::ByteStr","bytes::Bytes","std::string::String"],"<byte_str::ByteStr as std::fmt::Debug>::fmt":["byte_str::ByteStr","bytes::Bytes","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<byte_str::ByteStr as std::hash::Hash>::hash":["byte_str::ByteStr","bytes::Bytes","extensions::IdHasher","std::hash::Hasher","std::marker::Sized"],"<byte_str::ByteStr as std::ops::Deref>::deref":["byte_str::ByteStr","bytes::Bytes"],"<error::Error as std::convert::From<error::Never>>::from":["error::Error","error::ErrorKind","error::Never","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Error as std::convert::From<header::name::InvalidHeaderName>>::from":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Error as std::convert::From<header::name::InvalidHeaderNameBytes>>::from":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Error as std::convert::From<header::value::InvalidHeaderValue>>::from":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Error as std::convert::From<header::value::InvalidHeaderValueBytes>>::from":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Error as std::convert::From<method::InvalidMethod>>::from":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Error as std::convert::From<status::InvalidStatusCode>>::from":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Error as std::convert::From<uri::InvalidUri>>::from":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Error as std::convert::From<uri::InvalidUriBytes>>::from":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Error as std::convert::From<uri::InvalidUriParts>>::from":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Error as std::error::Error>::cause":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","std::marker::Sized","std::option::Option","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Error as std::error::Error>::description":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Error as std::fmt::Debug>::fmt":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Error as std::fmt::Display>::fmt":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"<error::Never as std::error::Error>::description":["error::Never"],"<error::Never as std::fmt::Debug>::fmt":["error::Never","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Never as std::fmt::Display>::fmt":["error::Never","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<extensions::Extensions as std::default::Default>::default":["extensions::Extensions","std::marker::Sized","std::option::Option"],"<extensions::Extensions as std::fmt::Debug>::fmt":["extensions::Extensions","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<extensions::IdHasher as std::default::Default>::default":["extensions::IdHasher"],"<extensions::IdHasher as std::hash::Hasher>::finish":["extensions::IdHasher"],"<extensions::IdHasher as std::hash::Hasher>::write":["extensions::IdHasher"],"<extensions::IdHasher as std::hash::Hasher>::write_u64":["extensions::IdHasher"],"<header::map::Bucket<T> as std::clone::Clone>::clone":["header::map::Bucket","header::map::HashValue","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized","std::option::Option"],"<header::map::Bucket<T> as std::fmt::Debug>::fmt":["header::map::Bucket","header::map::HashValue","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<header::map::Cursor as std::clone::Clone>::clone":["header::map::Cursor"],"<header::map::Cursor as std::cmp::Eq>::assert_receiver_is_total_eq":["header::map::Cursor"],"<header::map::Cursor as std::cmp::PartialEq>::eq":["header::map::Cursor"],"<header::map::Cursor as std::fmt::Debug>::fmt":["header::map::Cursor","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::map::Danger as std::clone::Clone>::clone":["header::map::Danger","std::collections::hash_map::RandomState"],"<header::map::Drain<'a, T> as std::fmt::Debug>::fmt":["header::map::Danger","header::map::Drain","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::vec::Vec"],"<header::map::Drain<'a, T> as std::iter::Iterator>::next":["header::map::Danger","header::map::Drain","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::Drain<'a, T> as std::iter::Iterator>::size_hint":["header::map::Danger","header::map::Drain","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::Drain<'a, T> as std::ops::Drop>::drop":["header::map::Danger","header::map::Drain","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<header::map::Entry<'a, T> as std::fmt::Debug>::fmt":["header::map::Danger","header::map::Entry","header::map::HashValue","header::map::HeaderMap","header::map::OccupiedEntry","header::map::VacantEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<header::map::ExtraValue<T> as std::clone::Clone>::clone":["header::map::ExtraValue","header::map::Link","std::marker::Sized"],"<header::map::ExtraValue<T> as std::fmt::Debug>::fmt":["header::map::ExtraValue","header::map::Link","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq":["header::map::Danger","header::map::GetAll","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::GetAll<'a, T> as std::fmt::Debug>::fmt":["header::map::Danger","header::map::GetAll","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter":["header::map::Danger","header::map::GetAll","header::map::HeaderMap","header::map::ValueIter","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::HashValue as std::clone::Clone>::clone":["header::map::HashValue"],"<header::map::HashValue as std::cmp::Eq>::assert_receiver_is_total_eq":["header::map::HashValue"],"<header::map::HashValue as std::cmp::PartialEq>::eq":["header::map::HashValue"],"<header::map::HashValue as std::fmt::Debug>::fmt":["header::map::HashValue","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::map::HeaderMap<T> as convert::HttpTryFrom<&'a std::collections::HashMap<K, V>>>::try_from":["std::collections::HashMap","std::marker::Sized","std::result::Result"],"<header::map::HeaderMap<T> as convert::HttpTryFrom<header::map::HeaderMap<T>>>::try_from":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::result::Result","std::vec::Vec"],"<header::map::HeaderMap<T> as std::clone::Clone>::clone":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"<header::map::HeaderMap<T> as std::cmp::PartialEq>::eq":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"<header::map::HeaderMap<T> as std::default::Default>::default":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"<header::map::HeaderMap<T> as std::fmt::Debug>::fmt":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend":["header::map::Danger","header::map::GetAll","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::iter::IntoIterator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend":["header::map::Danger","header::map::GetAll","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::iter::IntoIterator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter":["header::map::Danger","header::map::GetAll","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::iter::IntoIterator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":["header::map::Danger","header::map::HeaderMap","header::map::IntoIter","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::IntoIter","std::vec::Vec"],"<header::map::HeaderMap<T> as std::ops::Index<K>>::index":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"<header::map::IntoIter<T> as std::fmt::Debug>::fmt":["header::map::IntoIter","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::IntoIter","std::vec::Vec"],"<header::map::IntoIter<T> as std::iter::Iterator>::next":["header::map::IntoIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::IntoIter","std::vec::Vec"],"<header::map::IntoIter<T> as std::iter::Iterator>::size_hint":["header::map::IntoIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::IntoIter","std::vec::Vec"],"<header::map::IntoIter<T> as std::ops::Drop>::drop":["header::map::IntoIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::IntoIter","std::vec::Vec"],"<header::map::Iter<'a, T> as std::fmt::Debug>::fmt":["header::map::Danger","header::map::HeaderMap","header::map::Iter","header::map::IterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<header::map::Iter<'a, T> as std::iter::Iterator>::next":["header::map::Danger","header::map::HeaderMap","header::map::Iter","header::map::IterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::Iter<'a, T> as std::iter::Iterator>::size_hint":["header::map::Danger","header::map::HeaderMap","header::map::Iter","header::map::IterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::IterMut<'a, T> as std::fmt::Debug>::fmt":["header::map::Danger","header::map::HeaderMap","header::map::IterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<header::map::IterMut<'a, T> as std::iter::Iterator>::next":["header::map::Danger","header::map::HeaderMap","header::map::IterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint":["header::map::Danger","header::map::HeaderMap","header::map::IterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::Keys<'a, T> as std::fmt::Debug>::fmt":["header::map::Keys","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::slice::Iter"],"<header::map::Keys<'a, T> as std::iter::Iterator>::next":["header::map::Keys","std::marker::Sized","std::option::Option","std::slice::Iter"],"<header::map::Keys<'a, T> as std::iter::Iterator>::size_hint":["header::map::Keys","std::marker::Sized","std::option::Option","std::slice::Iter"],"<header::map::Link as std::clone::Clone>::clone":["header::map::Link"],"<header::map::Link as std::cmp::Eq>::assert_receiver_is_total_eq":["header::map::Link"],"<header::map::Link as std::cmp::PartialEq>::eq":["header::map::Link"],"<header::map::Link as std::fmt::Debug>::fmt":["header::map::Link","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::map::Links as std::clone::Clone>::clone":["header::map::Links"],"<header::map::Links as std::fmt::Debug>::fmt":["header::map::Links","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::map::OccupiedEntry<'a, T> as std::fmt::Debug>::fmt":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","header::map::ValueIterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::Pos as std::clone::Clone>::clone":["header::map::HashValue","header::map::Pos"],"<header::map::VacantEntry<'a, T> as std::fmt::Debug>::fmt":["header::map::Danger","header::map::HashValue","header::map::HeaderMap","header::map::VacantEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<header::map::ValueDrain<'a, T> as std::fmt::Debug>::fmt":["header::map::Danger","header::map::HeaderMap","header::map::ValueDrain","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<header::map::ValueDrain<'a, T> as std::iter::Iterator>::next":["header::map::Danger","header::map::HeaderMap","header::map::ValueDrain","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint":["header::map::Danger","header::map::HeaderMap","header::map::ValueDrain","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::ValueDrain<'a, T> as std::ops::Drop>::drop":["header::map::Danger","header::map::HeaderMap","header::map::ValueDrain","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::ValueIter<'a, T> as std::fmt::Debug>::fmt":["header::map::Danger","header::map::HeaderMap","header::map::ValueIter","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back":["header::map::Danger","header::map::HeaderMap","header::map::ValueIter","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::ValueIter<'a, T> as std::iter::Iterator>::next":["header::map::Danger","header::map::HeaderMap","header::map::ValueIter","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint":["header::map::Danger","header::map::HeaderMap","header::map::ValueIter","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::ValueIterMut<'a, T> as std::fmt::Debug>::fmt":["header::map::Danger","header::map::HeaderMap","header::map::ValueIterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back":["header::map::Danger","header::map::HeaderMap","header::map::ValueIterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next":["header::map::Danger","header::map::HeaderMap","header::map::ValueIterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::Values<'a, T> as std::fmt::Debug>::fmt":["header::map::Danger","header::map::HeaderMap","header::map::Iter","header::map::IterMut","header::map::Values","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<header::map::Values<'a, T> as std::iter::Iterator>::next":["header::map::Danger","header::map::HeaderMap","header::map::Iter","header::map::IterMut","header::map::Values","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::Values<'a, T> as std::iter::Iterator>::size_hint":["header::map::Danger","header::map::HeaderMap","header::map::Iter","header::map::IterMut","header::map::Values","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::ValuesMut<'a, T> as std::fmt::Debug>::fmt":["header::map::Danger","header::map::HeaderMap","header::map::IterMut","header::map::ValuesMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<header::map::ValuesMut<'a, T> as std::iter::Iterator>::next":["header::map::Danger","header::map::HeaderMap","header::map::IterMut","header::map::ValuesMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint":["header::map::Danger","header::map::HeaderMap","header::map::IterMut","header::map::ValuesMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::name::Custom as std::clone::Clone>::clone":["byte_str::ByteStr","bytes::Bytes","header::name::Custom"],"<header::name::Custom as std::cmp::Eq>::assert_receiver_is_total_eq":["byte_str::ByteStr","bytes::Bytes","header::name::Custom"],"<header::name::Custom as std::cmp::PartialEq>::eq":["byte_str::ByteStr","bytes::Bytes","header::name::Custom"],"<header::name::Custom as std::fmt::Debug>::fmt":["byte_str::ByteStr","bytes::Bytes","header::name::Custom","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::name::Custom as std::hash::Hash>::hash":["byte_str::ByteStr","bytes::Bytes","extensions::IdHasher","header::name::Custom","std::hash::Hasher","std::marker::Sized"],"<header::name::HdrName<'a> as std::convert::From<header::name::StandardHeader>>::from":["header::name::HdrName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HdrName<'a> as std::fmt::Debug>::fmt":["header::name::HdrName","header::name::Repr","header::name::StandardHeader","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::name::HdrName<'a> as std::hash::Hash>::hash":["extensions::IdHasher","header::name::HdrName","header::name::Repr","header::name::StandardHeader","std::hash::Hasher","std::marker::Sized"],"<header::name::HeaderName as convert::HttpTryFrom<&'a [u8]>>::try_from":["std::marker::Sized","std::result::Result"],"<header::name::HeaderName as convert::HttpTryFrom<&'a header::name::HeaderName>>::try_from":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized","std::result::Result"],"<header::name::HeaderName as convert::HttpTryFrom<&'a std::string::String>>::try_from":["std::marker::Sized","std::result::Result","std::string::String"],"<header::name::HeaderName as convert::HttpTryFrom<&'a str>>::try_from":["std::marker::Sized","std::result::Result"],"<header::name::HeaderName as convert::HttpTryFrom<bytes::Bytes>>::try_from":["bytes::Bytes","std::marker::Sized","std::result::Result"],"<header::name::HeaderName as convert::HttpTryFrom<header::name::HeaderName>>::try_from":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized","std::result::Result"],"<header::name::HeaderName as header::map::as_header_name::Sealed>::as_str":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as header::map::as_header_name::Sealed>::entry":["header::map::Danger","header::map::HeaderMap","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::result::Result","std::vec::Vec"],"<header::name::HeaderName as header::map::as_header_name::Sealed>::find":["header::map::Danger","header::map::HeaderMap","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::name::HeaderName as header::map::into_header_name::Sealed>::append":["header::map::Danger","header::map::HeaderMap","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"<header::name::HeaderName as header::map::into_header_name::Sealed>::insert":["header::map::Danger","header::map::HeaderMap","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"<header::name::HeaderName as std::borrow::Borrow<str>>::borrow":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::clone::Clone>::clone":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::cmp::Eq>::assert_receiver_is_total_eq":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::cmp::PartialEq<&'a header::name::HeaderName>>::eq":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::cmp::PartialEq<&'a str>>::eq":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::cmp::PartialEq<header::name::HdrName<'a>>>::eq":["header::name::HdrName","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::cmp::PartialEq<str>>::eq":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::cmp::PartialEq>::eq":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::convert::AsRef<[u8]>>::as_ref":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::convert::AsRef<str>>::as_ref":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::convert::From<&'a header::name::HeaderName>>::from":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::convert::From<header::name::Custom>>::from":["byte_str::ByteStr","bytes::Bytes","header::name::Custom","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::convert::From<header::name::HdrName<'a>>>::from":["header::name::HdrName","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::convert::From<header::name::StandardHeader>>::from":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::HeaderName as std::fmt::Debug>::fmt":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::name::HeaderName as std::fmt::Display>::fmt":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::name::HeaderName as std::hash::Hash>::hash":["extensions::IdHasher","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::hash::Hasher","std::marker::Sized"],"<header::name::HeaderName as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<header::name::InvalidHeaderName as std::error::Error>::description":["header::name::InvalidHeaderName"],"<header::name::InvalidHeaderName as std::fmt::Debug>::fmt":["header::name::InvalidHeaderName","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::name::InvalidHeaderName as std::fmt::Display>::fmt":["header::name::InvalidHeaderName","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::name::InvalidHeaderNameBytes as std::error::Error>::description":["header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes"],"<header::name::InvalidHeaderNameBytes as std::fmt::Debug>::fmt":["header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::name::InvalidHeaderNameBytes as std::fmt::Display>::fmt":["header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::name::MaybeLower<'a> as std::clone::Clone>::clone":["header::name::MaybeLower"],"<header::name::MaybeLower<'a> as std::fmt::Debug>::fmt":["header::name::MaybeLower","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::name::MaybeLower<'a> as std::hash::Hash>::hash":["extensions::IdHasher","header::name::MaybeLower","std::hash::Hasher","std::marker::Sized"],"<header::name::Repr<T> as std::clone::Clone>::clone":["header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::Repr<T> as std::cmp::Eq>::assert_receiver_is_total_eq":["header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::Repr<T> as std::cmp::PartialEq>::eq":["header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"<header::name::Repr<T> as std::fmt::Debug>::fmt":["header::name::Repr","header::name::StandardHeader","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::name::Repr<T> as std::hash::Hash>::hash":["extensions::IdHasher","header::name::Repr","header::name::StandardHeader","std::hash::Hasher","std::marker::Sized"],"<header::name::StandardHeader as std::clone::Clone>::clone":["header::name::StandardHeader"],"<header::name::StandardHeader as std::cmp::Eq>::assert_receiver_is_total_eq":["header::name::StandardHeader"],"<header::name::StandardHeader as std::cmp::PartialEq>::eq":["header::name::StandardHeader"],"<header::name::StandardHeader as std::fmt::Debug>::fmt":["header::name::StandardHeader","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::name::StandardHeader as std::hash::Hash>::hash":["extensions::IdHasher","header::name::StandardHeader","std::hash::Hasher","std::marker::Sized"],"<header::value::HeaderValue as convert::HttpTryFrom<&'a [u8]>>::try_from":["std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as convert::HttpTryFrom<&'a header::value::HeaderValue>>::try_from":["bytes::Bytes","header::value::HeaderValue","std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as convert::HttpTryFrom<&'a std::string::String>>::try_from":["std::marker::Sized","std::result::Result","std::string::String"],"<header::value::HeaderValue as convert::HttpTryFrom<&'a str>>::try_from":["std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as convert::HttpTryFrom<bytes::Bytes>>::try_from":["bytes::Bytes","std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as convert::HttpTryFrom<header::name::HeaderName>>::try_from":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as convert::HttpTryFrom<header::value::HeaderValue>>::try_from":["bytes::Bytes","header::value::HeaderValue","std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as convert::HttpTryFrom<i16>>::try_from":["std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as convert::HttpTryFrom<i32>>::try_from":["std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as convert::HttpTryFrom<i64>>::try_from":["std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as convert::HttpTryFrom<isize>>::try_from":["std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as convert::HttpTryFrom<std::string::String>>::try_from":["std::marker::Sized","std::result::Result","std::string::String"],"<header::value::HeaderValue as convert::HttpTryFrom<u16>>::try_from":["std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as convert::HttpTryFrom<u32>>::try_from":["std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as convert::HttpTryFrom<u64>>::try_from":["std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as convert::HttpTryFrom<usize>>::try_from":["std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as std::clone::Clone>::clone":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::cmp::Ord>::cmp":["bytes::Bytes","header::value::HeaderValue","std::cmp::Ordering"],"<header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::cmp::PartialEq<[u8]>>::eq":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::cmp::PartialEq<std::string::String>>::eq":["bytes::Bytes","header::value::HeaderValue","std::string::String"],"<header::value::HeaderValue as std::cmp::PartialEq<str>>::eq":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::cmp::PartialEq>::eq":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp":["bytes::Bytes","header::value::HeaderValue","std::marker::Sized","std::option::Option"],"<header::value::HeaderValue as std::cmp::PartialOrd<[u8]>>::partial_cmp":["bytes::Bytes","header::value::HeaderValue","std::marker::Sized","std::option::Option"],"<header::value::HeaderValue as std::cmp::PartialOrd<std::string::String>>::partial_cmp":["bytes::Bytes","header::value::HeaderValue","std::marker::Sized","std::option::Option","std::string::String"],"<header::value::HeaderValue as std::cmp::PartialOrd<str>>::partial_cmp":["bytes::Bytes","header::value::HeaderValue","std::marker::Sized","std::option::Option"],"<header::value::HeaderValue as std::cmp::PartialOrd>::partial_cmp":["bytes::Bytes","header::value::HeaderValue","std::marker::Sized","std::option::Option"],"<header::value::HeaderValue as std::convert::AsRef<[u8]>>::as_ref":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::convert::From<&'a header::value::HeaderValue>>::from":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::convert::From<header::name::HeaderName>>::from":["bytes::Bytes","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","header::value::HeaderValue","std::marker::Sized"],"<header::value::HeaderValue as std::convert::From<i16>>::from":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::convert::From<i32>>::from":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::convert::From<i64>>::from":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::convert::From<isize>>::from":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::convert::From<u16>>::from":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::convert::From<u32>>::from":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::convert::From<u64>>::from":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::convert::From<usize>>::from":["bytes::Bytes","header::value::HeaderValue"],"<header::value::HeaderValue as std::fmt::Debug>::fmt":["bytes::Bytes","header::value::HeaderValue","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::value::HeaderValue as std::hash::Hash>::hash":["bytes::Bytes","extensions::IdHasher","header::value::HeaderValue","std::hash::Hasher","std::marker::Sized"],"<header::value::HeaderValue as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<header::value::InvalidHeaderValue as std::error::Error>::description":["header::value::InvalidHeaderValue"],"<header::value::InvalidHeaderValue as std::fmt::Debug>::fmt":["header::value::InvalidHeaderValue","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::value::InvalidHeaderValue as std::fmt::Display>::fmt":["header::value::InvalidHeaderValue","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::value::InvalidHeaderValueBytes as std::error::Error>::description":["header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes"],"<header::value::InvalidHeaderValueBytes as std::fmt::Debug>::fmt":["header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::value::InvalidHeaderValueBytes as std::fmt::Display>::fmt":["header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::value::ToStrError as std::error::Error>::description":["header::value::ToStrError"],"<header::value::ToStrError as std::fmt::Debug>::fmt":["header::value::ToStrError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<header::value::ToStrError as std::fmt::Display>::fmt":["header::value::ToStrError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<method::Inner as std::clone::Clone>::clone":["method::Inner","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<method::Inner as std::cmp::Eq>::assert_receiver_is_total_eq":["method::Inner","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<method::Inner as std::cmp::PartialEq>::eq":["method::Inner","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<method::Inner as std::hash::Hash>::hash":["extensions::IdHasher","method::Inner","std::alloc::Allocator","std::boxed::Box","std::hash::Hasher","std::marker::Sized"],"<method::InvalidMethod as std::error::Error>::description":["method::InvalidMethod"],"<method::InvalidMethod as std::fmt::Debug>::fmt":["method::InvalidMethod","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<method::InvalidMethod as std::fmt::Display>::fmt":["method::InvalidMethod","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<method::Method as convert::HttpTryFrom<&'a [u8]>>::try_from":["std::marker::Sized","std::result::Result"],"<method::Method as convert::HttpTryFrom<&'a method::Method>>::try_from":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<method::Method as convert::HttpTryFrom<&'a str>>::try_from":["std::marker::Sized","std::result::Result"],"<method::Method as convert::HttpTryFrom<method::Method>>::try_from":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<method::Method as std::clone::Clone>::clone":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<method::Method as std::cmp::Eq>::assert_receiver_is_total_eq":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<method::Method as std::cmp::PartialEq<&'a method::Method>>::eq":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<method::Method as std::cmp::PartialEq<&'a str>>::eq":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<method::Method as std::cmp::PartialEq<str>>::eq":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<method::Method as std::cmp::PartialEq>::eq":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<method::Method as std::convert::AsRef<str>>::as_ref":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<method::Method as std::convert::From<&'a method::Method>>::from":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<method::Method as std::default::Default>::default":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<method::Method as std::fmt::Debug>::fmt":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<method::Method as std::fmt::Display>::fmt":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<method::Method as std::hash::Hash>::hash":["extensions::IdHasher","method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::hash::Hasher","std::marker::Sized"],"<method::Method as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<request::Builder as std::default::Default>::default":["request::Builder","std::marker::Sized","std::option::Option"],"<request::Builder as std::fmt::Debug>::fmt":["request::Builder","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<request::Parts as std::fmt::Debug>::fmt":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"<request::Request<T> as std::default::Default>::default":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"<request::Request<T> as std::fmt::Debug>::fmt":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"<response::Builder as std::default::Default>::default":["response::Builder","std::marker::Sized","std::option::Option"],"<response::Builder as std::fmt::Debug>::fmt":["response::Builder","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<response::Parts as std::fmt::Debug>::fmt":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","version::Http","version::Version"],"<response::Response<T> as std::default::Default>::default":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"<response::Response<T> as std::fmt::Debug>::fmt":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","version::Http","version::Version"],"<status::InvalidStatusCode as std::error::Error>::description":["status::InvalidStatusCode"],"<status::InvalidStatusCode as std::fmt::Debug>::fmt":["status::InvalidStatusCode","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<status::InvalidStatusCode as std::fmt::Display>::fmt":["status::InvalidStatusCode","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<status::StatusCode as convert::HttpTryFrom<&'a [u8]>>::try_from":["std::marker::Sized","std::result::Result"],"<status::StatusCode as convert::HttpTryFrom<&'a status::StatusCode>>::try_from":["status::StatusCode","std::marker::Sized","std::result::Result"],"<status::StatusCode as convert::HttpTryFrom<&'a str>>::try_from":["std::marker::Sized","std::result::Result"],"<status::StatusCode as convert::HttpTryFrom<status::StatusCode>>::try_from":["status::StatusCode","std::marker::Sized","std::result::Result"],"<status::StatusCode as convert::HttpTryFrom<u16>>::try_from":["std::marker::Sized","std::result::Result"],"<status::StatusCode as std::clone::Clone>::clone":["status::StatusCode"],"<status::StatusCode as std::cmp::Eq>::assert_receiver_is_total_eq":["status::StatusCode"],"<status::StatusCode as std::cmp::Ord>::cmp":["status::StatusCode","std::cmp::Ordering"],"<status::StatusCode as std::cmp::PartialEq<u16>>::eq":["status::StatusCode"],"<status::StatusCode as std::cmp::PartialEq>::eq":["status::StatusCode"],"<status::StatusCode as std::cmp::PartialOrd>::partial_cmp":["status::StatusCode","std::marker::Sized","std::option::Option"],"<status::StatusCode as std::convert::From<&'a status::StatusCode>>::from":["status::StatusCode"],"<status::StatusCode as std::default::Default>::default":["status::StatusCode"],"<status::StatusCode as std::fmt::Debug>::fmt":["status::StatusCode","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<status::StatusCode as std::fmt::Display>::fmt":["status::StatusCode","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<status::StatusCode as std::hash::Hash>::hash":["extensions::IdHasher","status::StatusCode","std::hash::Hasher","std::marker::Sized"],"<status::StatusCode as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<std::string::String as header::map::as_header_name::Sealed>::as_str":["std::string::String"],"<std::string::String as header::map::as_header_name::Sealed>::entry":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec"],"<std::string::String as header::map::as_header_name::Sealed>::find":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"<uri::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq":["uri::ErrorKind"],"<uri::ErrorKind as std::cmp::PartialEq>::eq":["uri::ErrorKind"],"<uri::ErrorKind as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::ErrorKind"],"<uri::InvalidUri as std::convert::From<uri::ErrorKind>>::from":["uri::ErrorKind","uri::InvalidUri"],"<uri::InvalidUri as std::error::Error>::description":["uri::ErrorKind","uri::InvalidUri"],"<uri::InvalidUri as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::ErrorKind","uri::InvalidUri"],"<uri::InvalidUri as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::ErrorKind","uri::InvalidUri"],"<uri::InvalidUriBytes as std::convert::From<uri::ErrorKind>>::from":["uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes"],"<uri::InvalidUriBytes as std::error::Error>::description":["uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes"],"<uri::InvalidUriBytes as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes"],"<uri::InvalidUriBytes as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes"],"<uri::InvalidUriParts as std::convert::From<uri::ErrorKind>>::from":["uri::ErrorKind","uri::InvalidUri","uri::InvalidUriParts"],"<uri::InvalidUriParts as std::error::Error>::description":["uri::ErrorKind","uri::InvalidUri","uri::InvalidUriParts"],"<uri::InvalidUriParts as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriParts"],"<uri::InvalidUriParts as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriParts"],"<uri::Parts as std::convert::From<uri::Uri>>::from":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::Parts","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::Parts as std::default::Default>::default":["std::marker::Sized","std::option::Option","uri::Parts"],"<uri::Parts as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","uri::Parts"],"<uri::Uri as convert::HttpTryFrom<&'a std::string::String>>::try_from":["std::marker::Sized","std::result::Result","std::string::String"],"<uri::Uri as convert::HttpTryFrom<&'a str>>::try_from":["std::marker::Sized","std::result::Result"],"<uri::Uri as convert::HttpTryFrom<&'a uri::Uri>>::try_from":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::result::Result","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::Uri as convert::HttpTryFrom<bytes::Bytes>>::try_from":["bytes::Bytes","std::marker::Sized","std::result::Result"],"<uri::Uri as convert::HttpTryFrom<std::string::String>>::try_from":["std::marker::Sized","std::result::Result","std::string::String"],"<uri::Uri as convert::HttpTryFrom<uri::Parts>>::try_from":["std::marker::Sized","std::option::Option","std::result::Result","uri::Parts"],"<uri::Uri as convert::HttpTryFrom<uri::Uri>>::try_from":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::result::Result","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::Uri as std::clone::Clone>::clone":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::Uri as std::cmp::PartialEq<&'a str>>::eq":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::Uri as std::cmp::PartialEq<str>>::eq":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::Uri as std::cmp::PartialEq>::eq":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::Uri as std::default::Default>::default":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::Uri as std::fmt::Debug>::fmt":["byte_str::ByteStr","bytes::Bytes","std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::Uri as std::fmt::Display>::fmt":["byte_str::ByteStr","bytes::Bytes","std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::Uri as std::hash::Hash>::hash":["byte_str::ByteStr","bytes::Bytes","extensions::IdHasher","std::hash::Hasher","std::marker::Sized","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::Uri as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<uri::authority::Authority as convert::HttpTryFrom<&'a [u8]>>::try_from":["std::marker::Sized","std::result::Result"],"<uri::authority::Authority as convert::HttpTryFrom<&'a str>>::try_from":["std::marker::Sized","std::result::Result"],"<uri::authority::Authority as convert::HttpTryFrom<bytes::Bytes>>::try_from":["bytes::Bytes","std::marker::Sized","std::result::Result"],"<uri::authority::Authority as convert::HttpTryFrom<uri::authority::Authority>>::try_from":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::result::Result","uri::authority::Authority"],"<uri::authority::Authority as std::clone::Clone>::clone":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"<uri::authority::Authority as std::cmp::PartialEq<&'a str>>::eq":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"<uri::authority::Authority as std::cmp::PartialEq<std::string::String>>::eq":["byte_str::ByteStr","bytes::Bytes","std::string::String","uri::authority::Authority"],"<uri::authority::Authority as std::cmp::PartialEq<str>>::eq":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"<uri::authority::Authority as std::cmp::PartialEq>::eq":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"<uri::authority::Authority as std::cmp::PartialOrd<&'a str>>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::authority::Authority"],"<uri::authority::Authority as std::cmp::PartialOrd<std::string::String>>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","std::string::String","uri::authority::Authority"],"<uri::authority::Authority as std::cmp::PartialOrd<str>>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::authority::Authority"],"<uri::authority::Authority as std::cmp::PartialOrd>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::authority::Authority"],"<uri::authority::Authority as std::convert::AsRef<str>>::as_ref":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"<uri::authority::Authority as std::fmt::Debug>::fmt":["byte_str::ByteStr","bytes::Bytes","std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::authority::Authority"],"<uri::authority::Authority as std::fmt::Display>::fmt":["byte_str::ByteStr","bytes::Bytes","std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::authority::Authority"],"<uri::authority::Authority as std::hash::Hash>::hash":["byte_str::ByteStr","bytes::Bytes","extensions::IdHasher","std::hash::Hasher","std::marker::Sized","uri::authority::Authority"],"<uri::authority::Authority as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<uri::builder::Builder as std::default::Default>::default":["std::marker::Sized","std::option::Option","uri::builder::Builder"],"<uri::builder::Builder as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","uri::builder::Builder"],"<uri::path::PathAndQuery as convert::HttpTryFrom<&'a [u8]>>::try_from":["std::marker::Sized","std::result::Result"],"<uri::path::PathAndQuery as convert::HttpTryFrom<&'a str>>::try_from":["std::marker::Sized","std::result::Result"],"<uri::path::PathAndQuery as convert::HttpTryFrom<bytes::Bytes>>::try_from":["bytes::Bytes","std::marker::Sized","std::result::Result"],"<uri::path::PathAndQuery as convert::HttpTryFrom<uri::path::PathAndQuery>>::try_from":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::result::Result","uri::path::PathAndQuery"],"<uri::path::PathAndQuery as std::clone::Clone>::clone":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"<uri::path::PathAndQuery as std::cmp::PartialEq<&'a str>>::eq":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"<uri::path::PathAndQuery as std::cmp::PartialEq<std::string::String>>::eq":["byte_str::ByteStr","bytes::Bytes","std::string::String","uri::path::PathAndQuery"],"<uri::path::PathAndQuery as std::cmp::PartialEq<str>>::eq":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"<uri::path::PathAndQuery as std::cmp::PartialEq>::eq":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"<uri::path::PathAndQuery as std::cmp::PartialOrd<&'a str>>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::path::PathAndQuery"],"<uri::path::PathAndQuery as std::cmp::PartialOrd<std::string::String>>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","std::string::String","uri::path::PathAndQuery"],"<uri::path::PathAndQuery as std::cmp::PartialOrd<str>>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::path::PathAndQuery"],"<uri::path::PathAndQuery as std::cmp::PartialOrd>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::path::PathAndQuery"],"<uri::path::PathAndQuery as std::fmt::Debug>::fmt":["byte_str::ByteStr","bytes::Bytes","std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::path::PathAndQuery"],"<uri::path::PathAndQuery as std::fmt::Display>::fmt":["byte_str::ByteStr","bytes::Bytes","std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::path::PathAndQuery"],"<uri::path::PathAndQuery as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq":["std::marker::Sized","uri::port::Port"],"<uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq":["std::marker::Sized","uri::port::Port"],"<uri::port::Port<T> as std::convert::AsRef<str>>::as_ref":["std::marker::Sized","uri::port::Port"],"<uri::port::Port<T> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::port::Port"],"<uri::port::Port<T> as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::port::Port"],"<uri::scheme::Protocol as std::clone::Clone>::clone":["uri::scheme::Protocol"],"<uri::scheme::Protocol as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::scheme::Protocol"],"<uri::scheme::Scheme as convert::HttpTryFrom<&'a [u8]>>::try_from":["std::marker::Sized","std::result::Result"],"<uri::scheme::Scheme as convert::HttpTryFrom<&'a str>>::try_from":["std::marker::Sized","std::result::Result"],"<uri::scheme::Scheme as convert::HttpTryFrom<bytes::Bytes>>::try_from":["bytes::Bytes","std::marker::Sized","std::result::Result"],"<uri::scheme::Scheme as convert::HttpTryFrom<uri::scheme::Scheme>>::try_from":["std::marker::Sized","std::result::Result","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::scheme::Scheme as std::clone::Clone>::clone":["std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::scheme::Scheme as std::cmp::PartialEq<str>>::eq":["std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::scheme::Scheme as std::cmp::PartialEq>::eq":["std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::scheme::Scheme as std::convert::AsRef<str>>::as_ref":["std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::scheme::Scheme as std::convert::From<uri::scheme::Scheme2>>::from":["std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::scheme::Scheme as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::scheme::Scheme as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::scheme::Scheme as std::hash::Hash>::hash":["extensions::IdHasher","std::hash::Hasher","std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"<uri::scheme::Scheme as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<uri::scheme::Scheme2<T> as std::clone::Clone>::clone":["std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme2"],"<uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from":["std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme2"],"<uri::scheme::Scheme2<T> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","uri::scheme::Protocol","uri::scheme::Scheme2"],"<version::Http as std::clone::Clone>::clone":["version::Http"],"<version::Http as std::cmp::Eq>::assert_receiver_is_total_eq":["version::Http"],"<version::Http as std::cmp::Ord>::cmp":["std::cmp::Ordering","version::Http"],"<version::Http as std::cmp::PartialEq>::eq":["version::Http"],"<version::Http as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","version::Http"],"<version::Http as std::hash::Hash>::hash":["extensions::IdHasher","std::hash::Hasher","std::marker::Sized","version::Http"],"<version::Version as std::clone::Clone>::clone":["version::Http","version::Version"],"<version::Version as std::cmp::Eq>::assert_receiver_is_total_eq":["version::Http","version::Version"],"<version::Version as std::cmp::Ord>::cmp":["std::cmp::Ordering","version::Http","version::Version"],"<version::Version as std::cmp::PartialEq>::eq":["version::Http","version::Version"],"<version::Version as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","version::Http","version::Version"],"<version::Version as std::default::Default>::default":["version::Http","version::Version"],"<version::Version as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","version::Http","version::Version"],"<version::Version as std::hash::Hash>::hash":["extensions::IdHasher","std::hash::Hasher","std::marker::Sized","version::Http","version::Version"],"_assert_types":[],"_assert_types::assert_send":["header::map::Danger","header::map::Drain","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::vec::Vec"],"_assert_types::assert_sync":["header::map::Danger","header::map::Drain","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::marker::Sync","std::vec::Vec"],"byte_str::<impl std::convert::From<byte_str::ByteStr> for bytes::Bytes>::from":["byte_str::ByteStr","bytes::Bytes"],"byte_str::ByteStr":["byte_str::ByteStr","bytes::Bytes"],"byte_str::ByteStr::from_static":["byte_str::ByteStr","bytes::Bytes"],"byte_str::ByteStr::from_utf8_unchecked":["byte_str::ByteStr","bytes::Bytes"],"byte_str::ByteStr::new":["byte_str::ByteStr","bytes::Bytes"],"convert::HttpTryFrom::try_from":["std::marker::Sized","std::result::Result"],"convert::HttpTryInto::http_try_into":["std::marker::Sized","std::result::Result"],"error::Error":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"error::Error::get_ref":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"error::Error::is":["error::Error","error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","std::error::Error","std::marker::Sized","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"error::ErrorKind":["error::ErrorKind","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"error::Never":["error::Never"],"extensions::Extensions":["extensions::Extensions","std::marker::Sized","std::option::Option"],"extensions::Extensions::clear":["extensions::Extensions","std::marker::Sized","std::option::Option"],"extensions::Extensions::get":["extensions::Extensions","header::map::Danger","header::map::Drain","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::option::Option","std::vec::Vec"],"extensions::Extensions::get_mut":["extensions::Extensions","header::map::Danger","header::map::Drain","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::option::Option","std::vec::Vec"],"extensions::Extensions::insert":["extensions::Extensions","header::map::Danger","header::map::Drain","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::option::Option","std::vec::Vec"],"extensions::Extensions::new":["extensions::Extensions","std::marker::Sized","std::option::Option"],"extensions::Extensions::remove":["extensions::Extensions","header::map::Danger","header::map::Drain","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::option::Option","std::vec::Vec"],"extensions::IdHasher":["extensions::IdHasher"],"header::map::Bucket":["header::map::Bucket","header::map::HashValue","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized","std::option::Option"],"header::map::Cursor":["header::map::Cursor"],"header::map::Danger":["header::map::Danger","std::collections::hash_map::RandomState"],"header::map::Danger::is_red":["header::map::Danger","std::collections::hash_map::RandomState"],"header::map::Danger::is_yellow":["header::map::Danger","std::collections::hash_map::RandomState"],"header::map::Danger::to_green":["header::map::Danger","std::collections::hash_map::RandomState"],"header::map::Danger::to_red":["header::map::Danger","std::collections::hash_map::RandomState"],"header::map::Danger::to_yellow":["header::map::Danger","std::collections::hash_map::RandomState"],"header::map::Drain":["header::map::Danger","header::map::Drain","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"header::map::Entry":["header::map::Danger","header::map::Entry","header::map::HashValue","header::map::HeaderMap","header::map::OccupiedEntry","header::map::VacantEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::Entry::<'a, T>::key":["header::map::Danger","header::map::Entry","header::map::HashValue","header::map::HeaderMap","header::map::OccupiedEntry","header::map::VacantEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::Entry::<'a, T>::or_insert":["header::map::Danger","header::map::Entry","header::map::HashValue","header::map::HeaderMap","header::map::OccupiedEntry","header::map::VacantEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::Entry::<'a, T>::or_insert_with":["header::map::Danger","header::map::Entry","header::map::HashValue","header::map::HeaderMap","header::map::OccupiedEntry","header::map::VacantEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::ops::FnOnce","std::vec::Vec"],"header::map::ExtraValue":["header::map::ExtraValue","header::map::Link","std::marker::Sized"],"header::map::GetAll":["header::map::Danger","header::map::GetAll","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::GetAll::<'a, T>::iter":["header::map::Danger","header::map::GetAll","header::map::HeaderMap","header::map::ValueIter","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HashValue":["header::map::HashValue"],"header::map::HeaderMap":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::append":["header::map::Danger","header::map::HeaderMap","header::map::into_header_name::IntoHeaderName","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::append2":["byte_str::ByteStr","bytes::Bytes","header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::cmp::PartialEq","std::collections::hash_map::RandomState","std::convert::Into","std::hash::Hash","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::capacity":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::clear":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::contains_key":["header::map::Danger","header::map::HeaderMap","header::map::as_header_name::AsHeaderName","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::drain":["header::map::Danger","header::map::Drain","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::entry":["header::map::Danger","header::map::HeaderMap","header::map::as_header_name::AsHeaderName","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::result::Result","std::vec::Vec"],"header::map::HeaderMap::<T>::entry2":["byte_str::ByteStr","bytes::Bytes","header::map::Danger","header::map::Entry","header::map::HashValue","header::map::HeaderMap","header::map::OccupiedEntry","header::map::VacantEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::cmp::PartialEq","std::collections::hash_map::RandomState","std::convert::Into","std::hash::Hash","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::find":["byte_str::ByteStr","bytes::Bytes","header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::cmp::PartialEq","std::collections::hash_map::RandomState","std::convert::Into","std::hash::Hash","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::get":["header::map::Danger","header::map::HeaderMap","header::map::as_header_name::AsHeaderName","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::get2":["header::map::Danger","header::map::HeaderMap","header::map::as_header_name::AsHeaderName","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::get_all":["header::map::Danger","header::map::GetAll","header::map::HeaderMap","header::map::as_header_name::AsHeaderName","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::get_mut":["header::map::Danger","header::map::HeaderMap","header::map::as_header_name::AsHeaderName","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::grow":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::insert":["header::map::Danger","header::map::HeaderMap","header::map::into_header_name::IntoHeaderName","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::insert2":["byte_str::ByteStr","bytes::Bytes","header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::cmp::PartialEq","std::collections::hash_map::RandomState","std::convert::Into","std::hash::Hash","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::insert_entry":["header::map::Danger","header::map::HashValue","header::map::HeaderMap","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::insert_occupied":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::insert_occupied_mult":["header::map::Danger","header::map::HeaderMap","header::map::ValueDrain","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::insert_phase_two":["header::map::Danger","header::map::HashValue","header::map::HeaderMap","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::is_empty":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::iter":["header::map::Danger","header::map::HeaderMap","header::map::Iter","header::map::IterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::iter_mut":["header::map::Danger","header::map::HeaderMap","header::map::IterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::keys":["header::map::Danger","header::map::HeaderMap","header::map::Keys","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::slice::Iter","std::vec::Vec"],"header::map::HeaderMap::<T>::keys_len":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::len":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::rebuild":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::reinsert_entry_in_order":["header::map::Danger","header::map::HashValue","header::map::HeaderMap","header::map::Pos","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::remove":["header::map::Danger","header::map::HeaderMap","header::map::as_header_name::AsHeaderName","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::remove_all_extra_values":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::remove_extra_value":["header::map::Danger","header::map::ExtraValue","header::map::HeaderMap","header::map::Link","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::remove_found":["header::map::Bucket","header::map::Danger","header::map::HashValue","header::map::HeaderMap","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::reserve":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::reserve_one":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::<T>::value_iter":["header::map::Danger","header::map::HeaderMap","header::map::ValueIter","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::value_iter_mut":["header::map::Danger","header::map::HeaderMap","header::map::ValueIterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::values":["header::map::Danger","header::map::HeaderMap","header::map::Iter","header::map::IterMut","header::map::Values","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::values_mut":["header::map::Danger","header::map::HeaderMap","header::map::IterMut","header::map::ValuesMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::HeaderMap::<T>::with_capacity":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::HeaderMap::new":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::IntoIter":["header::map::IntoIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::IntoIter","std::vec::Vec"],"header::map::Iter":["header::map::Danger","header::map::HeaderMap","header::map::Iter","header::map::IterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::IterMut":["header::map::Danger","header::map::HeaderMap","header::map::IterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::IterMut::<'a, T>::next_unsafe":["header::map::Danger","header::map::HeaderMap","header::map::IterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::Keys":["header::map::Keys","std::marker::Sized","std::slice::Iter"],"header::map::Link":["header::map::Link"],"header::map::Links":["header::map::Links"],"header::map::OccupiedEntry":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::OccupiedEntry::<'a, T>::append":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::OccupiedEntry::<'a, T>::get":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::OccupiedEntry::<'a, T>::get_mut":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::OccupiedEntry::<'a, T>::insert":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::OccupiedEntry::<'a, T>::insert_mult":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","header::map::ValueDrain","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::OccupiedEntry::<'a, T>::into_mut":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::OccupiedEntry::<'a, T>::iter":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","header::map::ValueIter","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::OccupiedEntry::<'a, T>::iter_mut":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","header::map::ValueIterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::OccupiedEntry::<'a, T>::key":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::OccupiedEntry::<'a, T>::remove":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::OccupiedEntry::<'a, T>::remove_entry":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::OccupiedEntry::<'a, T>::remove_entry_mult":["header::map::Danger","header::map::HeaderMap","header::map::OccupiedEntry","header::map::ValueDrain","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::Pos":["header::map::HashValue","header::map::Pos"],"header::map::Pos::is_none":["header::map::HashValue","header::map::Pos"],"header::map::Pos::is_some":["header::map::HashValue","header::map::Pos"],"header::map::Pos::new":["header::map::HashValue","header::map::Pos"],"header::map::Pos::none":["header::map::HashValue","header::map::Pos"],"header::map::Pos::resolve":["header::map::HashValue","header::map::Pos","std::marker::Sized","std::option::Option"],"header::map::VacantEntry":["header::map::Danger","header::map::HashValue","header::map::HeaderMap","header::map::VacantEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::VacantEntry::<'a, T>::insert":["header::map::Danger","header::map::HashValue","header::map::HeaderMap","header::map::VacantEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::VacantEntry::<'a, T>::insert_entry":["header::map::Danger","header::map::HashValue","header::map::HeaderMap","header::map::OccupiedEntry","header::map::VacantEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::VacantEntry::<'a, T>::into_key":["header::map::Danger","header::map::HashValue","header::map::HeaderMap","header::map::VacantEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::VacantEntry::<'a, T>::key":["header::map::Danger","header::map::HashValue","header::map::HeaderMap","header::map::VacantEntry","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::ValueDrain":["header::map::Danger","header::map::HeaderMap","header::map::ValueDrain","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::ValueIter":["header::map::Danger","header::map::HeaderMap","header::map::ValueIter","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::ValueIterMut":["header::map::Danger","header::map::HeaderMap","header::map::ValueIterMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::Values":["header::map::Danger","header::map::HeaderMap","header::map::Iter","header::map::IterMut","header::map::Values","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::ValuesMut":["header::map::Danger","header::map::HeaderMap","header::map::IterMut","header::map::ValuesMut","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::append_value":["header::map::Bucket","header::map::HashValue","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::as_header_name::Sealed::as_str":[],"header::map::as_header_name::Sealed::entry":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::result::Result","std::vec::Vec"],"header::map::as_header_name::Sealed::find":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::desired_pos":["header::map::HashValue"],"header::map::do_insert_phase_two":["header::map::HashValue","header::map::Pos"],"header::map::hash_elem_using":["byte_str::ByteStr","bytes::Bytes","header::map::Danger","header::map::HashValue","std::collections::hash_map::RandomState","std::hash::Hash"],"header::map::into_header_name::Sealed::append":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::vec::Vec"],"header::map::into_header_name::Sealed::insert":["header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"header::map::probe_distance":["header::map::HashValue"],"header::map::to_raw_capacity":[],"header::map::usable_capacity":[],"header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for &'a str>::eq":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for str>::eq":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"header::name::<impl std::convert::From<header::name::Custom> for bytes::Bytes>::from":["byte_str::ByteStr","bytes::Bytes","header::name::Custom"],"header::name::<impl std::convert::From<header::name::HeaderName> for bytes::Bytes>::from":["bytes::Bytes","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from":["bytes::Bytes","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"header::name::Custom":["byte_str::ByteStr","bytes::Bytes","header::name::Custom"],"header::name::HdrName":["header::name::HdrName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"header::name::HdrName::<'a>::custom":["header::name::HdrName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"header::name::HdrName::<'a>::from_bytes":["std::marker::Sized","std::ops::FnOnce","std::result::Result"],"header::name::HdrName::<'a>::from_static":["std::marker::Sized","std::ops::FnOnce"],"header::name::HeaderName":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"header::name::HeaderName::as_str":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"header::name::HeaderName::from_bytes":["std::marker::Sized","std::result::Result"],"header::name::HeaderName::from_lowercase":["std::marker::Sized","std::result::Result"],"header::name::HeaderName::from_static":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"header::name::InvalidHeaderName":["header::name::InvalidHeaderName"],"header::name::InvalidHeaderName::new":["header::name::InvalidHeaderName"],"header::name::InvalidHeaderNameBytes":["header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes"],"header::name::MaybeLower":["header::name::MaybeLower"],"header::name::Repr":["header::name::Repr","header::name::StandardHeader","std::marker::Sized"],"header::name::StandardHeader":["header::name::StandardHeader"],"header::name::StandardHeader::as_str":["header::name::StandardHeader"],"header::name::eq_ignore_ascii_case":[],"header::name::parse_hdr":["std::marker::Sized","std::result::Result"],"header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for &'a str>::eq":["bytes::Bytes","header::value::HeaderValue"],"header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for [u8]>::eq":["bytes::Bytes","header::value::HeaderValue"],"header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for std::string::String>::eq":["bytes::Bytes","header::value::HeaderValue","std::string::String"],"header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for str>::eq":["bytes::Bytes","header::value::HeaderValue"],"header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for &'a str>::partial_cmp":["bytes::Bytes","header::value::HeaderValue","std::marker::Sized","std::option::Option"],"header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for [u8]>::partial_cmp":["bytes::Bytes","header::value::HeaderValue","std::marker::Sized","std::option::Option"],"header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for std::string::String>::partial_cmp":["bytes::Bytes","header::value::HeaderValue","std::marker::Sized","std::option::Option","std::string::String"],"header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for str>::partial_cmp":["bytes::Bytes","header::value::HeaderValue","std::marker::Sized","std::option::Option"],"header::value::<impl std::convert::From<header::value::HeaderValue> for bytes::Bytes>::from":["bytes::Bytes","header::value::HeaderValue"],"header::value::HeaderValue":["bytes::Bytes","header::value::HeaderValue"],"header::value::HeaderValue::as_bytes":["bytes::Bytes","header::value::HeaderValue"],"header::value::HeaderValue::from_bytes":["std::marker::Sized","std::result::Result"],"header::value::HeaderValue::from_name":["bytes::Bytes","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","header::value::HeaderValue","std::marker::Sized"],"header::value::HeaderValue::from_shared":["bytes::Bytes","std::marker::Sized","std::result::Result"],"header::value::HeaderValue::from_shared_unchecked":["bytes::Bytes","header::value::HeaderValue"],"header::value::HeaderValue::from_static":["bytes::Bytes","header::value::HeaderValue"],"header::value::HeaderValue::from_str":["std::marker::Sized","std::result::Result"],"header::value::HeaderValue::is_empty":["bytes::Bytes","header::value::HeaderValue"],"header::value::HeaderValue::is_sensitive":["bytes::Bytes","header::value::HeaderValue"],"header::value::HeaderValue::len":["bytes::Bytes","header::value::HeaderValue"],"header::value::HeaderValue::set_sensitive":["bytes::Bytes","header::value::HeaderValue"],"header::value::HeaderValue::to_str":["bytes::Bytes","header::value::HeaderValue","std::marker::Sized","std::result::Result"],"header::value::HeaderValue::try_from":["header::name::HeaderName","header::name::Repr","header::name::StandardHeader","std::convert::AsRef","std::convert::Into","std::marker::Sized","std::result::Result"],"header::value::InvalidHeaderValue":["header::value::InvalidHeaderValue"],"header::value::InvalidHeaderValueBytes":["header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes"],"header::value::ToStrError":["header::value::ToStrError"],"header::value::is_valid":[],"header::value::is_visible_ascii":[],"method::<impl std::cmp::PartialEq<method::Method> for &'a str>::eq":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"method::<impl std::cmp::PartialEq<method::Method> for str>::eq":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"method::Inner":["method::Inner","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"method::InvalidMethod":["method::InvalidMethod"],"method::InvalidMethod::new":["method::InvalidMethod"],"method::Method":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"method::Method::as_str":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"method::Method::extension_inline":["std::marker::Sized","std::result::Result"],"method::Method::from_bytes":["std::marker::Sized","std::result::Result"],"method::Method::is_idempotent":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"method::Method::is_safe":["method::Inner","method::Method","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"method::write_checked":["std::marker::Sized","std::result::Result"],"request::Builder":["request::Builder","std::marker::Sized","std::option::Option"],"request::Builder::body":["request::Builder","std::marker::Sized","std::option::Option","std::result::Result"],"request::Builder::extension":["header::map::Danger","header::map::Drain","header::map::HeaderMap","request::Builder","std::alloc::Allocator","std::any::Any","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::option::Option","std::vec::Vec"],"request::Builder::header":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","request::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"request::Builder::headers_mut":["request::Builder","std::marker::Sized","std::option::Option"],"request::Builder::headers_ref":["request::Builder","std::marker::Sized","std::option::Option"],"request::Builder::method":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","request::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"request::Builder::method_ref":["request::Builder","std::marker::Sized","std::option::Option"],"request::Builder::new":["request::Builder","std::marker::Sized","std::option::Option"],"request::Builder::take_parts":["request::Builder","std::marker::Sized","std::option::Option","std::result::Result"],"request::Builder::uri":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","request::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"request::Builder::uri_ref":["request::Builder","std::marker::Sized","std::option::Option"],"request::Builder::version":["request::Builder","std::marker::Sized","std::option::Option","version::Http","version::Version"],"request::Parts":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Parts::new":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<()>::builder":["request::Builder","std::marker::Sized","std::option::Option"],"request::Request::<()>::connect":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","request::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"request::Request::<()>::delete":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","request::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"request::Request::<()>::get":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","request::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"request::Request::<()>::head":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","request::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"request::Request::<()>::options":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","request::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"request::Request::<()>::patch":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","request::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"request::Request::<()>::post":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","request::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"request::Request::<()>::put":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","request::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"request::Request::<()>::trace":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","request::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"request::Request::<T>::body":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::body_mut":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::extensions":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::extensions_mut":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::from_parts":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::headers":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::headers_mut":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::into_body":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::into_parts":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::map":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::ops::FnOnce","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::method":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::method_mut":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::new":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::uri":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::uri_mut":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::version":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::Request::<T>::version_mut":["byte_str::ByteStr","bytes::Bytes","extensions::Extensions","header::map::Danger","header::map::HeaderMap","method::Inner","method::Method","request::Parts","request::Request","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"request::head":["std::marker::Sized","std::option::Option"],"response::Builder":["response::Builder","std::marker::Sized","std::option::Option"],"response::Builder::body":["response::Builder","std::marker::Sized","std::option::Option","std::result::Result"],"response::Builder::extension":["header::map::Danger","header::map::Drain","header::map::HeaderMap","response::Builder","std::alloc::Allocator","std::any::Any","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::PhantomData","std::marker::Send","std::marker::Sized","std::marker::Sync","std::option::Option","std::vec::Vec"],"response::Builder::header":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","response::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"response::Builder::headers_mut":["response::Builder","std::marker::Sized","std::option::Option"],"response::Builder::headers_ref":["response::Builder","std::marker::Sized","std::option::Option"],"response::Builder::new":["response::Builder","std::marker::Sized","std::option::Option"],"response::Builder::status":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","response::Builder","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec"],"response::Builder::take_parts":["response::Builder","std::marker::Sized","std::option::Option","std::result::Result"],"response::Builder::version":["response::Builder","std::marker::Sized","std::option::Option","version::Http","version::Version"],"response::Parts":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Parts::new":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<()>::builder":["response::Builder","std::marker::Sized","std::option::Option"],"response::Response::<T>::body":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::body_mut":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::extensions":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::extensions_mut":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::from_parts":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::headers":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::headers_mut":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::into_body":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::into_parts":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::map":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::ops::FnOnce","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::new":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::status":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::status_mut":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::version":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::Response::<T>::version_mut":["extensions::Extensions","header::map::Danger","header::map::HeaderMap","response::Parts","response::Response","status::StatusCode","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","version::Http","version::Version"],"response::head":["std::marker::Sized","std::option::Option"],"status::<impl std::cmp::PartialEq<status::StatusCode> for u16>::eq":["status::StatusCode"],"status::<impl std::convert::From<status::StatusCode> for u16>::from":["status::StatusCode"],"status::InvalidStatusCode":["status::InvalidStatusCode"],"status::InvalidStatusCode::new":["status::InvalidStatusCode"],"status::StatusCode":["status::StatusCode"],"status::StatusCode::as_str":["status::StatusCode"],"status::StatusCode::as_u16":["status::StatusCode"],"status::StatusCode::canonical_reason":["status::StatusCode","std::marker::Sized","std::option::Option"],"status::StatusCode::from_bytes":["std::marker::Sized","std::result::Result"],"status::StatusCode::from_u16":["std::marker::Sized","std::result::Result"],"status::StatusCode::is_client_error":["status::StatusCode"],"status::StatusCode::is_informational":["status::StatusCode"],"status::StatusCode::is_redirection":["status::StatusCode"],"status::StatusCode::is_server_error":["status::StatusCode"],"status::StatusCode::is_success":["status::StatusCode"],"status::canonical_reason":["std::marker::Sized","std::option::Option"],"uri::<impl std::cmp::PartialEq<uri::Uri> for &'a str>::eq":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::<impl std::cmp::PartialEq<uri::Uri> for str>::eq":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::ErrorKind":["uri::ErrorKind"],"uri::InvalidUri":["uri::ErrorKind","uri::InvalidUri"],"uri::InvalidUriBytes":["uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes"],"uri::InvalidUriParts":["uri::ErrorKind","uri::InvalidUri","uri::InvalidUriParts"],"uri::Parts":["std::marker::Sized","std::option::Option","uri::Parts"],"uri::Uri":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::authority":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::authority_part":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::builder":["std::marker::Sized","std::option::Option","uri::builder::Builder"],"uri::Uri::from_parts":["std::marker::Sized","std::option::Option","std::result::Result","uri::Parts"],"uri::Uri::from_shared":["bytes::Bytes","std::marker::Sized","std::result::Result"],"uri::Uri::from_static":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::has_path":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::host":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::into_parts":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::Parts","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::path":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::path_and_query":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::port":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::port_part":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::port_u16":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::query":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::scheme":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::scheme_part":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::Uri::scheme_str":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for &'a str>::eq":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for std::string::String>::eq":["byte_str::ByteStr","bytes::Bytes","std::string::String","uri::authority::Authority"],"uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for str>::eq":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for &'a str>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::authority::Authority"],"uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for std::string::String>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","std::string::String","uri::authority::Authority"],"uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for str>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::authority::Authority"],"uri::authority::<impl std::convert::From<uri::authority::Authority> for bytes::Bytes>::from":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"uri::authority::Authority":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"uri::authority::Authority::as_str":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"uri::authority::Authority::empty":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"uri::authority::Authority::from_shared":["bytes::Bytes","std::marker::Sized","std::result::Result"],"uri::authority::Authority::from_static":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"uri::authority::Authority::host":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"uri::authority::Authority::into_bytes":["byte_str::ByteStr","bytes::Bytes","uri::authority::Authority"],"uri::authority::Authority::parse":["std::marker::Sized","std::result::Result"],"uri::authority::Authority::parse_non_empty":["std::marker::Sized","std::result::Result"],"uri::authority::Authority::port":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::authority::Authority"],"uri::authority::Authority::port_part":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::authority::Authority"],"uri::authority::Authority::port_u16":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::authority::Authority"],"uri::authority::host":[],"uri::builder::Builder":["std::marker::Sized","std::option::Option","uri::builder::Builder"],"uri::builder::Builder::authority":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::builder::Builder"],"uri::builder::Builder::build":["std::marker::Sized","std::option::Option","std::result::Result","uri::builder::Builder"],"uri::builder::Builder::map":["std::marker::Sized","std::ops::FnOnce","std::option::Option","uri::builder::Builder"],"uri::builder::Builder::new":["std::marker::Sized","std::option::Option","uri::builder::Builder"],"uri::builder::Builder::path_and_query":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::builder::Builder"],"uri::builder::Builder::scheme":["convert::HttpTryFrom","header::map::Danger","header::map::HeaderMap","std::alloc::Allocator","std::boxed::Box","std::collections::hash_map::RandomState","std::marker::Sized","std::option::Option","std::vec::Vec","uri::builder::Builder"],"uri::parse_full":["bytes::Bytes","std::marker::Sized","std::result::Result"],"uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for &'a str>::eq":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for std::string::String>::eq":["byte_str::ByteStr","bytes::Bytes","std::string::String","uri::path::PathAndQuery"],"uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for str>::eq":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for &'a str>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::path::PathAndQuery"],"uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for std::string::String>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","std::string::String","uri::path::PathAndQuery"],"uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for str>::partial_cmp":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::path::PathAndQuery"],"uri::path::<impl std::convert::From<uri::path::PathAndQuery> for bytes::Bytes>::from":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"uri::path::PathAndQuery":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"uri::path::PathAndQuery::as_str":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"uri::path::PathAndQuery::empty":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"uri::path::PathAndQuery::from_shared":["bytes::Bytes","std::marker::Sized","std::result::Result"],"uri::path::PathAndQuery::from_static":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"uri::path::PathAndQuery::into_bytes":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"uri::path::PathAndQuery::path":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"uri::path::PathAndQuery::query":["byte_str::ByteStr","bytes::Bytes","std::marker::Sized","std::option::Option","uri::path::PathAndQuery"],"uri::path::PathAndQuery::slash":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"uri::path::PathAndQuery::star":["byte_str::ByteStr","bytes::Bytes","uri::path::PathAndQuery"],"uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq":["std::marker::Sized","uri::port::Port"],"uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from":["std::marker::Sized","uri::port::Port"],"uri::port::Port":["std::marker::Sized","uri::port::Port"],"uri::port::Port::<T>::as_str":["std::marker::Sized","uri::port::Port"],"uri::port::Port::<T>::as_u16":["std::marker::Sized","uri::port::Port"],"uri::port::Port::<T>::from_str":["std::marker::Sized","std::result::Result"],"uri::scheme::<impl std::cmp::PartialEq<uri::scheme::Scheme> for str>::eq":["std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::scheme::<impl std::convert::From<uri::scheme::Scheme> for bytes::Bytes>::from":["bytes::Bytes","std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::scheme::Protocol":["uri::scheme::Protocol"],"uri::scheme::Protocol::len":["uri::scheme::Protocol"],"uri::scheme::Scheme":["std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::scheme::Scheme2":["std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme2"],"uri::scheme::Scheme2::<T>::is_none":["std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme2"],"uri::scheme::Scheme2::<usize>::parse":["std::marker::Sized","std::result::Result"],"uri::scheme::Scheme2::<usize>::parse_exact":["std::marker::Sized","std::result::Result"],"uri::scheme::Scheme::as_str":["std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::scheme::Scheme::empty":["std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"uri::scheme::Scheme::from_shared":["bytes::Bytes","std::marker::Sized","std::result::Result"],"uri::scheme::Scheme::into_bytes":["bytes::Bytes","std::marker::Sized","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2"],"version::Http":["version::Http"],"version::Version":["version::Http","version::Version"]},"glob_path_import":{},"self_to_fn":{"<T as convert::HttpTryInto<U>>::T":["impl<T, U> HttpTryInto<U> for T\nwhere\n    U: HttpTryFrom<T>,\n    T: Sized,\n{\n    fn http_try_into(self) -> Result<U, Error> {\n        HttpTryFrom::try_from(self)\n            .map_err(|e: U::Error| e.into())\n    }\n}"],"byte_str::ByteStr":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl ByteStr {\n    #[inline]\n    pub fn new() -> ByteStr {\n        ByteStr { bytes: Bytes::new() }\n    }\n\n    #[inline]\n    pub fn from_static(val: &'static str) -> ByteStr {\n        ByteStr { bytes: Bytes::from_static(val.as_bytes()) }\n    }\n\n    #[inline]\n    pub unsafe fn from_utf8_unchecked(bytes: Bytes) -> ByteStr {\n        if cfg!(debug_assertions) {\n            match str::from_utf8(&bytes) {\n                Ok(_) => (),\n                Err(err) => panic!(\"ByteStr::from_utf8_unchecked() with invalid bytes; error = {}, bytes = {:?}\", err, bytes),\n            }\n        }\n        ByteStr { bytes: bytes }\n    }\n}","impl From<String> for ByteStr {\n    #[inline]\n    fn from(src: String) -> ByteStr {\n        ByteStr { bytes: Bytes::from(src) }\n    }\n}","impl ops::Deref for ByteStr {\n    type Target = str;\n\n    #[inline]\n    fn deref(&self) -> &str {\n        let b: &[u8] = self.bytes.as_ref();\n        unsafe { str::from_utf8_unchecked(b) }\n    }\n}","impl<'a> From<&'a str> for ByteStr {\n    #[inline]\n    fn from(src: &'a str) -> ByteStr {\n        ByteStr { bytes: Bytes::from(src) }\n    }\n}"],"bytes::Bytes":["impl From<Authority> for Bytes {\n    #[inline]\n    fn from(src: Authority) -> Bytes {\n        src.data.into()\n    }\n}","impl From<ByteStr> for Bytes {\n    fn from(src: ByteStr) -> Self {\n        src.bytes\n    }\n}","impl From<Custom> for Bytes {\n    #[inline]\n    fn from(Custom(inner): Custom) -> Bytes {\n        Bytes::from(inner)\n    }\n}","impl From<HeaderName> for Bytes {\n    #[inline]\n    fn from(name: HeaderName) -> Bytes {\n        name.inner.into()\n    }\n}","impl From<HeaderValue> for Bytes {\n    #[inline]\n    fn from(value: HeaderValue) -> Bytes {\n        value.inner\n    }\n}","impl From<PathAndQuery> for Bytes {\n    fn from(src: PathAndQuery) -> Bytes {\n        src.data.into()\n    }\n}","impl From<Scheme> for Bytes {\n    #[inline]\n    fn from(src: Scheme) -> Self {\n        use self::Scheme2::*;\n        use self::Protocol::*;\n\n        match src.inner {\n            None => Bytes::new(),\n            Standard(Http) => Bytes::from_static(b\"http\"),\n            Standard(Https) => Bytes::from_static(b\"https\"),\n            Other(v) => (*v).into(),\n        }\n    }\n}","impl<T> From<Repr<T>> for Bytes\nwhere T: Into<Bytes> {\n    fn from(repr: Repr<T>) -> Bytes {\n        match repr {\n            Repr::Standard(header) =>\n                Bytes::from_static(header.as_str().as_bytes()),\n            Repr::Custom(header) => header.into()\n        }\n    }\n}"],"error::Error":["impl Error {\n    /// Return true if the underlying error has the same type as T.\n    pub fn is<T: error::Error + 'static>(&self) -> bool {\n        self.get_ref().is::<T>()\n    }\n\n    /// Return a reference to the lower level, inner error.\n    #[allow(warnings)]\n    pub fn get_ref(&self) -> &(error::Error + 'static) {\n        use self::ErrorKind::*;\n\n        match self.inner {\n            StatusCode(ref e) => e,\n            Method(ref e) => e,\n            Uri(ref e) => e,\n            UriShared(ref e) => e,\n            UriParts(ref e) => e,\n            HeaderName(ref e) => e,\n            HeaderNameShared(ref e) => e,\n            HeaderValue(ref e) => e,\n            HeaderValueShared(ref e) => e,\n        }\n    }\n}","impl From<Never> for Error {\n    fn from(never: Never) -> Error {\n        match never {}\n    }\n}","impl From<header::InvalidHeaderName> for Error {\n    fn from(err: header::InvalidHeaderName) -> Error {\n        Error { inner: ErrorKind::HeaderName(err) }\n    }\n}","impl From<header::InvalidHeaderNameBytes> for Error {\n    fn from(err: header::InvalidHeaderNameBytes) -> Error {\n        Error { inner: ErrorKind::HeaderNameShared(err) }\n    }\n}","impl From<header::InvalidHeaderValue> for Error {\n    fn from(err: header::InvalidHeaderValue) -> Error {\n        Error { inner: ErrorKind::HeaderValue(err) }\n    }\n}","impl From<header::InvalidHeaderValueBytes> for Error {\n    fn from(err: header::InvalidHeaderValueBytes) -> Error {\n        Error { inner: ErrorKind::HeaderValueShared(err) }\n    }\n}","impl From<method::InvalidMethod> for Error {\n    fn from(err: method::InvalidMethod) -> Error {\n        Error { inner: ErrorKind::Method(err) }\n    }\n}","impl From<status::InvalidStatusCode> for Error {\n    fn from(err: status::InvalidStatusCode) -> Error {\n        Error { inner: ErrorKind::StatusCode(err) }\n    }\n}","impl From<uri::InvalidUri> for Error {\n    fn from(err: uri::InvalidUri) -> Error {\n        Error { inner: ErrorKind::Uri(err) }\n    }\n}","impl From<uri::InvalidUriBytes> for Error {\n    fn from(err: uri::InvalidUriBytes) -> Error {\n        Error { inner: ErrorKind::UriShared(err) }\n    }\n}","impl From<uri::InvalidUriParts> for Error {\n    fn from(err: uri::InvalidUriParts) -> Error {\n        Error { inner: ErrorKind::UriParts(err) }\n    }\n}","impl error::Error for Error {\n    fn description(&self) -> &str {\n        use self::ErrorKind::*;\n\n        match self.inner {\n            StatusCode(ref e) => e.description(),\n            Method(ref e) => e.description(),\n            Uri(ref e) => e.description(),\n            UriShared(ref e) => e.description(),\n            UriParts(ref e) => e.description(),\n            HeaderName(ref e) => e.description(),\n            HeaderNameShared(ref e) => e.description(),\n            HeaderValue(ref e) => e.description(),\n            HeaderValueShared(ref e) => e.description(),\n        }\n    }\n\n    // Return any available cause from the inner error. Note the inner error is\n    // not itself the cause.\n    #[allow(warnings)]\n    fn cause(&self) -> Option<&error::Error> {\n        self.get_ref().cause()\n    }\n}","impl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"http::Error\")\n            // Skip the noise of the ErrorKind enum\n            .field(&self.get_ref())\n            .finish()\n    }\n}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(self.get_ref(), f)\n    }\n}"],"error::Never":["impl error::Error for Never {\n    fn description(&self) -> &str {\n        match *self {}\n    }\n}","impl fmt::Debug for Never {\n    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {}\n    }\n}","impl fmt::Display for Never {\n    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {}\n    }\n}"],"extensions::Extensions":["Default","impl Extensions {\n    /// Create an empty `Extensions`.\n    #[inline]\n    pub fn new() -> Extensions {\n        Extensions {\n            map: None,\n        }\n    }\n\n    /// Insert a type into this `Extensions`.\n    ///\n    /// If a extension of this type already existed, it will\n    /// be returned.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// assert!(ext.insert(5i32).is_none());\n    /// assert!(ext.insert(4u8).is_none());\n    /// assert_eq!(ext.insert(9i32), Some(5i32));\n    /// ```\n    pub fn insert<T: Send + Sync + 'static>(&mut self, val: T) -> Option<T> {\n        self\n            .map\n            .get_or_insert_with(|| Box::new(HashMap::default()))\n            .insert(TypeId::of::<T>(), Box::new(val))\n            .and_then(|boxed| {\n                #[allow(warnings)]\n                {\n                (boxed as Box<Any + 'static>)\n                    .downcast()\n                    .ok()\n                    .map(|boxed| *boxed)\n                }\n            })\n    }\n\n    /// Get a reference to a type previously inserted on this `Extensions`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// assert!(ext.get::<i32>().is_none());\n    /// ext.insert(5i32);\n    ///\n    /// assert_eq!(ext.get::<i32>(), Some(&5i32));\n    /// ```\n    pub fn get<T: Send + Sync + 'static>(&self) -> Option<&T> {\n        self\n            .map\n            .as_ref()\n            .and_then(|map| map.get(&TypeId::of::<T>()))\n            .and_then(|boxed| {\n                #[allow(warnings)]\n                {\n                (&**boxed as &(Any + 'static)).downcast_ref()\n                }\n            })\n    }\n\n    /// Get a mutable reference to a type previously inserted on this `Extensions`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// ext.insert(String::from(\"Hello\"));\n    /// ext.get_mut::<String>().unwrap().push_str(\" World\");\n    ///\n    /// assert_eq!(ext.get::<String>().unwrap(), \"Hello World\");\n    /// ```\n    pub fn get_mut<T: Send + Sync + 'static>(&mut self) -> Option<&mut T> {\n        self\n            .map\n            .as_mut()\n            .and_then(|map| map.get_mut(&TypeId::of::<T>()))\n            .and_then(|boxed| {\n                #[allow(warnings)]\n                {\n                (&mut **boxed as &mut (Any + 'static)).downcast_mut()\n                }\n            })\n    }\n\n\n    /// Remove a type from this `Extensions`.\n    ///\n    /// If a extension of this type existed, it will be returned.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// ext.insert(5i32);\n    /// assert_eq!(ext.remove::<i32>(), Some(5i32));\n    /// assert!(ext.get::<i32>().is_none());\n    /// ```\n    pub fn remove<T: Send + Sync + 'static>(&mut self) -> Option<T> {\n        self\n            .map\n            .as_mut()\n            .and_then(|map| map.remove(&TypeId::of::<T>()))\n            .and_then(|boxed| {\n                #[allow(warnings)]\n                {\n                (boxed as Box<Any + 'static>)\n                    .downcast()\n                    .ok()\n                    .map(|boxed| *boxed)\n                }\n            })\n    }\n\n    /// Clear the `Extensions` of all inserted extensions.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// ext.insert(5i32);\n    /// ext.clear();\n    ///\n    /// assert!(ext.get::<i32>().is_none());\n    /// ```\n    #[inline]\n    pub fn clear(&mut self) {\n        if let Some(ref mut map) = self.map {\n            map.clear();\n        }\n    }\n}","impl fmt::Debug for Extensions {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Extensions\")\n            .finish()\n    }\n}"],"extensions::IdHasher":["Default","impl Hasher for IdHasher {\n    fn write(&mut self, _: &[u8]) {\n        unreachable!(\"TypeId calls write_u64\");\n    }\n\n    #[inline]\n    fn write_u64(&mut self, id: u64) {\n        self.0 = id;\n    }\n\n    #[inline]\n    fn finish(&self) -> u64 {\n        self.0\n    }\n}"],"header::map::Bucket":["Clone","Debug"],"header::map::Cursor":["Clone","Copy","Debug","Eq","PartialEq"],"header::map::Danger":["Clone","impl Danger {\n    fn is_red(&self) -> bool {\n        match *self {\n            Danger::Red(_) => true,\n            _ => false,\n        }\n    }\n\n    fn to_red(&mut self) {\n        debug_assert!(self.is_yellow());\n        *self = Danger::Red(RandomState::new());\n    }\n\n    fn is_yellow(&self) -> bool {\n        match *self {\n            Danger::Yellow => true,\n            _ => false,\n        }\n    }\n\n    fn to_yellow(&mut self) {\n        match *self {\n            Danger::Green => {\n                *self = Danger::Yellow;\n            }\n            _ => {}\n        }\n    }\n\n    fn to_green(&mut self) {\n        debug_assert!(self.is_yellow());\n        *self = Danger::Green;\n    }\n}"],"header::map::Drain":["Debug","impl<'a, T> Drop for Drain<'a, T> {\n    fn drop(&mut self) {\n        unsafe {\n            let map = &mut *self.map;\n            debug_assert!(map.extra_values.is_empty());\n            map.entries.set_len(0);\n        }\n    }\n}","impl<'a, T> Iterator for Drain<'a, T> {\n    type Item = (HeaderName, ValueDrain<'a, T>);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let idx = self.idx;\n\n        if idx == unsafe { (*self.map).entries.len() } {\n            return None;\n        }\n\n        self.idx += 1;\n\n        let key;\n        let value;\n        let next;\n\n        unsafe {\n            let entry = &(*self.map).entries[idx];\n\n            // Read the header name\n            key = ptr::read(&entry.key as *const _);\n            value = ptr::read(&entry.value as *const _);\n            next = entry.links.map(|l| l.next);\n        };\n\n        let values = ValueDrain {\n            map: self.map,\n            first: Some(value),\n            next: next,\n            lt: PhantomData,\n        };\n\n        Some((key, values))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let lower = unsafe { (*self.map).entries.len() } - self.idx;\n        (lower, Some(lower))\n    }\n}","unsafe impl<'a, T: Send> Send for Drain<'a, T> {}","unsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}"],"header::map::Entry":["Debug","impl<'a, T> Entry<'a, T> {\n    /// Ensures a value is in the entry by inserting the default if empty.\n    ///\n    /// Returns a mutable reference to the **first** value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map: HeaderMap<u32> = HeaderMap::default();\n    ///\n    /// let headers = &[\n    ///     \"content-length\",\n    ///     \"x-hello\",\n    ///     \"Content-Length\",\n    ///     \"x-world\",\n    /// ];\n    ///\n    /// for &header in headers {\n    ///     let counter = map.entry(header)\n    ///         .expect(\"valid header names\")\n    ///         .or_insert(0);\n    ///     *counter += 1;\n    /// }\n    ///\n    /// assert_eq!(map[\"content-length\"], 2);\n    /// assert_eq!(map[\"x-hello\"], 1);\n    /// ```\n    pub fn or_insert(self, default: T) -> &'a mut T {\n        use self::Entry::*;\n\n        match self {\n            Occupied(e) => e.into_mut(),\n            Vacant(e) => e.insert(default),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default\n    /// function if empty.\n    ///\n    /// The default function is not called if the entry exists in the map.\n    /// Returns a mutable reference to the **first** value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage.\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// let res = map.entry(\"x-hello\").unwrap()\n    ///     .or_insert_with(|| \"world\".parse().unwrap());\n    ///\n    /// assert_eq!(res, \"world\");\n    /// ```\n    ///\n    /// The default function is not called if the entry exists in the map.\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    ///\n    /// let res = map.entry(\"host\")\n    ///     .expect(\"host is a valid string\")\n    ///     .or_insert_with(|| unreachable!());\n    ///\n    ///\n    /// assert_eq!(res, \"world\");\n    /// ```\n    pub fn or_insert_with<F: FnOnce() -> T>(self, default: F) -> &'a mut T {\n        use self::Entry::*;\n\n        match self {\n            Occupied(e) => e.into_mut(),\n            Vacant(e) => e.insert(default()),\n        }\n    }\n\n    /// Returns a reference to the entry's key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(map.entry(\"x-hello\").unwrap().key(), \"x-hello\");\n    /// ```\n    pub fn key(&self) -> &HeaderName {\n        use self::Entry::*;\n\n        match *self {\n            Vacant(ref e) => e.key(),\n            Occupied(ref e) => e.key(),\n        }\n    }\n}"],"header::map::ExtraValue":["Clone","Debug"],"header::map::GetAll":["Debug","impl<'a, T: 'a> GetAll<'a, T> {\n    /// Returns an iterator visiting all values associated with the entry.\n    ///\n    /// Values are iterated in insertion order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    /// map.append(HOST, \"hello.earth\".parse().unwrap());\n    ///\n    /// let values = map.get_all(\"host\");\n    /// let mut iter = values.iter();\n    /// assert_eq!(&\"hello.world\", iter.next().unwrap());\n    /// assert_eq!(&\"hello.earth\", iter.next().unwrap());\n    /// assert!(iter.next().is_none());\n    /// ```\n    pub fn iter(&self) -> ValueIter<'a, T> {\n        // This creates a new GetAll struct so that the lifetime\n        // isn't bound to &self.\n        GetAll {\n            map: self.map,\n            index: self.index,\n        }.into_iter()\n    }\n}","impl<'a, T: PartialEq> PartialEq for GetAll<'a, T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.iter().eq(other.iter())\n    }\n}","impl<'a, T> IntoIterator for GetAll<'a, T> {\n    type Item = &'a T;\n    type IntoIter = ValueIter<'a, T>;\n\n    fn into_iter(self) -> ValueIter<'a, T> {\n        self.map.value_iter(self.index)\n    }\n}"],"header::map::HashValue":["Clone","Copy","Debug","Eq","PartialEq"],"header::map::HeaderMap":["Clone","impl HeaderMap {\n    /// Create an empty `HeaderMap`.\n    ///\n    /// The map will be created without any capacity. This function will not\n    /// allocate.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let map = HeaderMap::new();\n    ///\n    /// assert!(map.is_empty());\n    /// assert_eq!(0, map.capacity());\n    /// ```\n    pub fn new() -> Self {\n        HeaderMap::with_capacity(0)\n    }\n}","impl<'a, K, T> ops::Index<K> for HeaderMap<T>\n    where K: AsHeaderName,\n{\n    type Output = T;\n\n    /// # Panics\n    /// Using the index operator will cause a panic if the header you're querying isn't set.\n    #[inline]\n    fn index(&self, index: K) -> &T {\n        match self.get2(&index) {\n            Some(val) => val,\n            None => panic!(\"no entry found for key {:?}\", index.as_str()),\n        }\n    }\n}","impl<'a, K, V, T> HttpTryFrom<&'a HashMap<K, V>> for HeaderMap<T>\n    where\n        K: Eq + Hash,\n        HeaderName: HttpTryFrom<&'a K>,\n        T: HttpTryFrom<&'a V>\n{\n    type Error = Error;\n\n    fn try_from(c: &'a HashMap<K, V>) -> Result<Self, Self::Error> {\n        c.into_iter()\n            .map(|(k, v)| {\n                let name = k.http_try_into()?;\n                let value = v.http_try_into()?;\n                Ok((name, value))\n            })\n            .collect()\n    }\n}","impl<T: Eq> Eq for HeaderMap<T> {}","impl<T: PartialEq> PartialEq for HeaderMap<T> {\n    fn eq(&self, other: &HeaderMap<T>) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.keys().all(|key| {\n            self.get_all(key) == other.get_all(key)\n        })\n    }\n}","impl<T: fmt::Debug> fmt::Debug for HeaderMap<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_map().entries(self.iter()).finish()\n    }\n}","impl<T> Default for HeaderMap<T> {\n    fn default() -> Self {\n        HeaderMap::with_capacity(0)\n    }\n}","impl<T> Extend<(HeaderName, T)> for HeaderMap<T>\n{\n    fn extend<I: IntoIterator<Item = (HeaderName, T)>>(&mut self, iter: I) {\n        // Keys may be already present or show multiple times in the iterator.\n        // Reserve the entire hint lower bound if the map is empty.\n        // Otherwise reserve half the hint (rounded up), so the map\n        // will only resize twice in the worst case.\n        let iter = iter.into_iter();\n\n        let reserve = if self.is_empty() {\n            iter.size_hint().0\n        } else {\n            (iter.size_hint().0 + 1) / 2\n        };\n\n        self.reserve(reserve);\n\n        for (k, v) in iter {\n            self.append(k, v);\n        }\n    }\n}","impl<T> Extend<(Option<HeaderName>, T)> for HeaderMap<T> {\n    /// Extend a `HeaderMap` with the contents of another `HeaderMap`.\n    ///\n    /// This function expects the yielded items to follow the same structure as\n    /// `IntoIter`.\n    ///\n    /// # Panics\n    ///\n    /// This panics if the first yielded item does not have a `HeaderName`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(ACCEPT, \"text/plain\".parse().unwrap());\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    ///\n    /// let mut extra = HeaderMap::new();\n    ///\n    /// extra.insert(HOST, \"foo.bar\".parse().unwrap());\n    /// extra.insert(COOKIE, \"hello\".parse().unwrap());\n    /// extra.append(COOKIE, \"world\".parse().unwrap());\n    ///\n    /// map.extend(extra);\n    ///\n    /// assert_eq!(map[\"host\"], \"foo.bar\");\n    /// assert_eq!(map[\"accept\"], \"text/plain\");\n    /// assert_eq!(map[\"cookie\"], \"hello\");\n    ///\n    /// let v = map.get_all(\"host\");\n    /// assert_eq!(1, v.iter().count());\n    ///\n    /// let v = map.get_all(\"cookie\");\n    /// assert_eq!(2, v.iter().count());\n    /// ```\n    fn extend<I: IntoIterator<Item = (Option<HeaderName>, T)>>(&mut self, iter: I) {\n        let mut iter = iter.into_iter();\n\n        // The structure of this is a bit weird, but it is mostly to make the\n        // borrow checker happy.\n        let (mut key, mut val) = match iter.next() {\n            Some((Some(key), val)) => (key, val),\n            Some((None, _)) => panic!(\"expected a header name, but got None\"),\n            None => return,\n        };\n\n        'outer:\n        loop {\n            let mut entry = match self.entry2(key) {\n                Entry::Occupied(mut e) => {\n                    // Replace all previous values while maintaining a handle to\n                    // the entry.\n                    e.insert(val);\n                    e\n                }\n                Entry::Vacant(e) => {\n                    e.insert_entry(val)\n                }\n            };\n\n            // As long as `HeaderName` is none, keep inserting the value into\n            // the current entry\n            'inner:\n            loop {\n                match iter.next() {\n                    Some((Some(k), v)) => {\n                        key = k;\n                        val = v;\n                        continue 'outer;\n                    }\n                    Some((None, v)) => {\n                        entry.append(v);\n                    }\n                    None => {\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}","impl<T> FromIterator<(HeaderName, T)> for HeaderMap<T>\n{\n    fn from_iter<I>(iter: I) -> Self\n        where I: IntoIterator<Item = (HeaderName, T)>\n    {\n       let mut map = HeaderMap::default();\n       map.extend(iter);\n       map\n    }\n}","impl<T> HeaderMap<T> {\n    /// Create an empty `HeaderMap` with the specified capacity.\n    ///\n    /// The returned map will allocate internal storage in order to hold about\n    /// `capacity` elements without reallocating. However, this is a \"best\n    /// effort\" as there are usage patterns that could cause additional\n    /// allocations before `capacity` headers are stored in the map.\n    ///\n    /// More capacity than requested may be allocated.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let map: HeaderMap<u32> = HeaderMap::with_capacity(10);\n    ///\n    /// assert!(map.is_empty());\n    /// assert_eq!(12, map.capacity());\n    /// ```\n    pub fn with_capacity(capacity: usize) -> HeaderMap<T> {\n        assert!(capacity <= MAX_SIZE, \"requested capacity too large\");\n\n        if capacity == 0 {\n            HeaderMap {\n                mask: 0,\n                indices: Box::new([]), // as a ZST, this doesn't actually allocate anything\n                entries: Vec::new(),\n                extra_values: Vec::new(),\n                danger: Danger::Green,\n            }\n        } else {\n            let raw_cap = to_raw_capacity(capacity).next_power_of_two();\n            debug_assert!(raw_cap > 0);\n\n            HeaderMap {\n                mask: (raw_cap - 1) as Size,\n                indices: vec![Pos::none(); raw_cap].into_boxed_slice(),\n                entries: Vec::with_capacity(raw_cap),\n                extra_values: Vec::new(),\n                danger: Danger::Green,\n            }\n        }\n    }\n\n    /// Returns the number of headers stored in the map.\n    ///\n    /// This number represents the total number of **values** stored in the map.\n    /// This number can be greater than or equal to the number of **keys**\n    /// stored given that a single key may have more than one associated value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{ACCEPT, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(0, map.len());\n    ///\n    /// map.insert(ACCEPT, \"text/plain\".parse().unwrap());\n    /// map.insert(HOST, \"localhost\".parse().unwrap());\n    ///\n    /// assert_eq!(2, map.len());\n    ///\n    /// map.append(ACCEPT, \"text/html\".parse().unwrap());\n    ///\n    /// assert_eq!(3, map.len());\n    /// ```\n    pub fn len(&self) -> usize {\n        self.entries.len() + self.extra_values.len()\n    }\n\n    /// Returns the number of keys stored in the map.\n    ///\n    /// This number will be less than or equal to `len()` as each key may have\n    /// more than one associated value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{ACCEPT, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(0, map.keys_len());\n    ///\n    /// map.insert(ACCEPT, \"text/plain\".parse().unwrap());\n    /// map.insert(HOST, \"localhost\".parse().unwrap());\n    ///\n    /// assert_eq!(2, map.keys_len());\n    ///\n    /// map.insert(ACCEPT, \"text/html\".parse().unwrap());\n    ///\n    /// assert_eq!(2, map.keys_len());\n    /// ```\n    pub fn keys_len(&self) -> usize {\n        self.entries.len()\n    }\n\n    /// Returns true if the map contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert!(map.is_empty());\n    ///\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    ///\n    /// assert!(!map.is_empty());\n    /// ```\n    pub fn is_empty(&self) -> bool {\n        self.entries.len() == 0\n    }\n\n    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n    /// for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    ///\n    /// map.clear();\n    /// assert!(map.is_empty());\n    /// assert!(map.capacity() > 0);\n    /// ```\n    pub fn clear(&mut self) {\n        self.entries.clear();\n        self.extra_values.clear();\n        self.danger = Danger::Green;\n\n        for e in self.indices.iter_mut() {\n            *e = Pos::none();\n        }\n    }\n\n    /// Returns the number of headers the map can hold without reallocating.\n    ///\n    /// This number is an approximation as certain usage patterns could cause\n    /// additional allocations before the returned capacity is filled.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(0, map.capacity());\n    ///\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    /// assert_eq!(6, map.capacity());\n    /// ```\n    pub fn capacity(&self) -> usize {\n        usable_capacity(self.indices.len())\n    }\n\n    /// Reserves capacity for at least `additional` more headers to be inserted\n    /// into the `HeaderMap`.\n    ///\n    /// The header map may reserve more space to avoid frequent reallocations.\n    /// Like with `with_capacity`, this will be a \"best effort\" to avoid\n    /// allocations until `additional` more headers are inserted. Certain usage\n    /// patterns could cause additional allocations before the number is\n    /// reached.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new allocation size overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.reserve(10);\n    /// # map.insert(HOST, \"bar\".parse().unwrap());\n    /// ```\n    pub fn reserve(&mut self, additional: usize) {\n        // TODO: This can't overflow if done properly... since the max # of\n        // elements is u16::MAX.\n        let cap = self.entries.len()\n            .checked_add(additional)\n            .expect(\"reserve overflow\");\n\n        if cap > self.indices.len() {\n            let cap = cap.next_power_of_two();\n\n            if self.entries.len() == 0 {\n                self.mask = cap - 1;\n                self.indices = vec![Pos::none(); cap].into_boxed_slice();\n                self.entries = Vec::with_capacity(usable_capacity(cap));\n            } else {\n                self.grow(cap);\n            }\n        }\n    }\n\n    /// Returns a reference to the value associated with the key.\n    ///\n    /// If there are multiple values associated with the key, then the first one\n    /// is returned. Use `get_all` to get all values associated with a given\n    /// key. Returns `None` if there are no values associated with the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(map.get(\"host\").is_none());\n    ///\n    /// map.insert(HOST, \"hello\".parse().unwrap());\n    /// assert_eq!(map.get(HOST).unwrap(), &\"hello\");\n    /// assert_eq!(map.get(\"host\").unwrap(), &\"hello\");\n    ///\n    /// map.append(HOST, \"world\".parse().unwrap());\n    /// assert_eq!(map.get(\"host\").unwrap(), &\"hello\");\n    /// ```\n    pub fn get<K>(&self, key: K) -> Option<&T>\n        where K: AsHeaderName\n    {\n        self.get2(&key)\n    }\n\n    fn get2<K>(&self, key: &K) -> Option<&T>\n        where K: AsHeaderName\n    {\n        match key.find(self) {\n            Some((_, found)) => {\n                let entry = &self.entries[found];\n                Some(&entry.value)\n            }\n            None => None,\n        }\n    }\n\n    /// Returns a mutable reference to the value associated with the key.\n    ///\n    /// If there are multiple values associated with the key, then the first one\n    /// is returned. Use `entry` to get all values associated with a given\n    /// key. Returns `None` if there are no values associated with the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::default();\n    /// map.insert(HOST, \"hello\".to_string());\n    /// map.get_mut(\"host\").unwrap().push_str(\"-world\");\n    ///\n    /// assert_eq!(map.get(HOST).unwrap(), &\"hello-world\");\n    /// ```\n    pub fn get_mut<K>(&mut self, key: K) -> Option<&mut T>\n        where K: AsHeaderName\n    {\n        match key.find(self) {\n            Some((_, found)) => {\n                let entry = &mut self.entries[found];\n                Some(&mut entry.value)\n            }\n            None => None,\n        }\n    }\n\n    /// Returns a view of all values associated with a key.\n    ///\n    /// The returned view does not incur any allocations and allows iterating\n    /// the values associated with the key.  See [`GetAll`] for more details.\n    /// Returns `None` if there are no values associated with the key.\n    ///\n    /// [`GetAll`]: struct.GetAll.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, \"hello\".parse().unwrap());\n    /// map.append(HOST, \"goodbye\".parse().unwrap());\n    ///\n    /// let view = map.get_all(\"host\");\n    ///\n    /// let mut iter = view.iter();\n    /// assert_eq!(&\"hello\", iter.next().unwrap());\n    /// assert_eq!(&\"goodbye\", iter.next().unwrap());\n    /// assert!(iter.next().is_none());\n    /// ```\n    pub fn get_all<K>(&self, key: K) -> GetAll<T>\n        where K: AsHeaderName\n    {\n        GetAll {\n            map: self,\n            index: key.find(self).map(|(_, i)| i),\n        }\n    }\n\n    /// Returns true if the map contains a value for the specified key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(!map.contains_key(HOST));\n    ///\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    /// assert!(map.contains_key(\"host\"));\n    /// ```\n    pub fn contains_key<K>(&self, key: K) -> bool\n        where K: AsHeaderName\n    {\n        key.find(self).is_some()\n    }\n\n    /// An iterator visiting all key-value pairs.\n    ///\n    /// The iteration order is arbitrary, but consistent across platforms for\n    /// the same crate version. Each key will be yielded once per associated\n    /// value. So, if a key has 3 associated values, it will be yielded 3 times.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, \"hello\".parse().unwrap());\n    /// map.append(HOST, \"goodbye\".parse().unwrap());\n    /// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n    ///\n    /// for (key, value) in map.iter() {\n    ///     println!(\"{:?}: {:?}\", key, value);\n    /// }\n    /// ```\n    pub fn iter(&self) -> Iter<T> {\n        Iter {\n            inner: IterMut {\n                map: self as *const _ as *mut _,\n                entry: 0,\n                cursor: self.entries.first().map(|_| Cursor::Head),\n                lt: PhantomData,\n            }\n        }\n    }\n\n    /// An iterator visiting all key-value pairs, with mutable value references.\n    ///\n    /// The iterator order is arbitrary, but consistent across platforms for the\n    /// same crate version. Each key will be yielded once per associated value,\n    /// so if a key has 3 associated values, it will be yielded 3 times.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::default();\n    ///\n    /// map.insert(HOST, \"hello\".to_string());\n    /// map.append(HOST, \"goodbye\".to_string());\n    /// map.insert(CONTENT_LENGTH, \"123\".to_string());\n    ///\n    /// for (key, value) in map.iter_mut() {\n    ///     value.push_str(\"-boop\");\n    /// }\n    /// ```\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut {\n            map: self as *mut _,\n            entry: 0,\n            cursor: self.entries.first().map(|_| Cursor::Head),\n            lt: PhantomData,\n        }\n    }\n\n    /// An iterator visiting all keys.\n    ///\n    /// The iteration order is arbitrary, but consistent across platforms for\n    /// the same crate version. Each key will be yielded only once even if it\n    /// has multiple associated values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, \"hello\".parse().unwrap());\n    /// map.append(HOST, \"goodbye\".parse().unwrap());\n    /// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n    ///\n    /// for key in map.keys() {\n    ///     println!(\"{:?}\", key);\n    /// }\n    /// ```\n    pub fn keys(&self) -> Keys<T> {\n        Keys { inner: self.entries.iter() }\n    }\n\n    /// An iterator visiting all values.\n    ///\n    /// The iteration order is arbitrary, but consistent across platforms for\n    /// the same crate version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, \"hello\".parse().unwrap());\n    /// map.append(HOST, \"goodbye\".parse().unwrap());\n    /// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n    ///\n    /// for value in map.values() {\n    ///     println!(\"{:?}\", value);\n    /// }\n    /// ```\n    pub fn values(&self) -> Values<T> {\n        Values { inner: self.iter() }\n    }\n\n    /// An iterator visiting all values mutably.\n    ///\n    /// The iteration order is arbitrary, but consistent across platforms for\n    /// the same crate version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::default();\n    ///\n    /// map.insert(HOST, \"hello\".to_string());\n    /// map.append(HOST, \"goodbye\".to_string());\n    /// map.insert(CONTENT_LENGTH, \"123\".to_string());\n    ///\n    /// for value in map.values_mut() {\n    ///     value.push_str(\"-boop\");\n    /// }\n    /// ```\n    pub fn values_mut(&mut self) -> ValuesMut<T> {\n        ValuesMut { inner: self.iter_mut() }\n    }\n\n    /// Clears the map, returning all entries as an iterator.\n    ///\n    /// The internal memory is kept for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, \"hello\".parse().unwrap());\n    /// map.append(HOST, \"goodbye\".parse().unwrap());\n    /// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n    ///\n    /// let mut drain = map.drain();\n    ///\n    /// let (key, mut vals) = drain.next().unwrap();\n    ///\n    /// assert_eq!(\"host\", key);\n    /// assert_eq!(\"hello\", vals.next().unwrap());\n    /// assert_eq!(\"goodbye\", vals.next().unwrap());\n    /// assert!(vals.next().is_none());\n    ///\n    /// let (key, mut vals) = drain.next().unwrap();\n    ///\n    /// assert_eq!(\"content-length\", key);\n    /// assert_eq!(\"123\", vals.next().unwrap());\n    /// assert!(vals.next().is_none());\n    /// ```\n    pub fn drain(&mut self) -> Drain<T> {\n        for i in self.indices.iter_mut() {\n            *i = Pos::none();\n        }\n\n        Drain {\n            idx: 0,\n            map: self as *mut _,\n            lt: PhantomData,\n        }\n    }\n\n    fn value_iter(&self, idx: Option<usize>) -> ValueIter<T> {\n        use self::Cursor::*;\n\n        if let Some(idx) = idx {\n            let back = {\n                let entry = &self.entries[idx];\n\n                entry.links\n                    .map(|l| Values(l.tail))\n                    .unwrap_or(Head)\n            };\n\n            ValueIter {\n                map: self,\n                index: idx,\n                front: Some(Head),\n                back: Some(back),\n            }\n        } else {\n            ValueIter {\n                map: self,\n                index: ::std::usize::MAX,\n                front: None,\n                back: None,\n            }\n        }\n    }\n\n    fn value_iter_mut(&mut self, idx: usize) -> ValueIterMut<T> {\n        use self::Cursor::*;\n\n        let back = {\n            let entry = &self.entries[idx];\n\n            entry.links\n                .map(|l| Values(l.tail))\n                .unwrap_or(Head)\n        };\n\n        ValueIterMut {\n            map: self as *mut _,\n            index: idx,\n            front: Some(Head),\n            back: Some(back),\n            lt: PhantomData,\n        }\n    }\n\n    /// Gets the given key's corresponding entry in the map for in-place\n    /// manipulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map: HeaderMap<u32> = HeaderMap::default();\n    ///\n    /// let headers = &[\n    ///     \"content-length\",\n    ///     \"x-hello\",\n    ///     \"Content-Length\",\n    ///     \"x-world\",\n    /// ];\n    ///\n    /// for &header in headers {\n    ///     let counter = map.entry(header).unwrap().or_insert(0);\n    ///     *counter += 1;\n    /// }\n    ///\n    /// assert_eq!(map[\"content-length\"], 2);\n    /// assert_eq!(map[\"x-hello\"], 1);\n    /// ```\n    pub fn entry<K>(&mut self, key: K) -> Result<Entry<T>, InvalidHeaderName>\n        where K: AsHeaderName,\n    {\n        key.entry(self)\n    }\n\n    fn entry2<K>(&mut self, key: K) -> Entry<T>\n        where K: Hash + Into<HeaderName>,\n              HeaderName: PartialEq<K>,\n    {\n        // Ensure that there is space in the map\n        self.reserve_one();\n\n        insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash: hash,\n                key: key.into(),\n                probe: probe,\n                danger: danger,\n            }),\n            Entry::Occupied(OccupiedEntry {\n                map: self,\n                index: pos,\n                probe: probe,\n            }),\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash: hash,\n                key: key.into(),\n                probe: probe,\n                danger: danger,\n            }))\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not previously have this key present, then `None` is\n    /// returned.\n    ///\n    /// If the map did have this key present, the new value is associated with\n    /// the key and all previous values are removed. **Note** that only a single\n    /// one of the previous values is returned. If there are multiple values\n    /// that have been previously associated with the key, then the first one is\n    /// returned. See `insert_mult` on `OccupiedEntry` for an API that returns\n    /// all values.\n    ///\n    /// The key is not updated, though; this matters for types that can be `==`\n    /// without being identical.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(map.insert(HOST, \"world\".parse().unwrap()).is_none());\n    /// assert!(!map.is_empty());\n    ///\n    /// let mut prev = map.insert(HOST, \"earth\".parse().unwrap()).unwrap();\n    /// assert_eq!(\"world\", prev);\n    /// ```\n    pub fn insert<K>(&mut self, key: K, val: T) -> Option<T>\n        where K: IntoHeaderName,\n    {\n        key.insert(self, val)\n    }\n\n    #[inline]\n    fn insert2<K>(&mut self, key: K, value: T) -> Option<T>\n        where K: Hash + Into<HeaderName>,\n              HeaderName: PartialEq<K>,\n    {\n        self.reserve_one();\n\n        insert_phase_one!(\n            self, key, probe, pos, hash, danger,\n            // Vacant\n            {\n                drop(danger); // Make lint happy\n                let index = self.entries.len();\n                self.insert_entry(hash, key.into(), value);\n                self.indices[probe] = Pos::new(index, hash);\n                None\n            },\n            // Occupied\n            Some(self.insert_occupied(pos, value)),\n            // Robinhood\n            {\n                self.insert_phase_two(\n                    key.into(),\n                    value,\n                    hash,\n                    probe,\n                    danger);\n                None\n            })\n    }\n\n    /// Set an occupied bucket to the given value\n    #[inline]\n    fn insert_occupied(&mut self, index: usize, value: T) -> T {\n        if let Some(links) = self.entries[index].links {\n            self.remove_all_extra_values(links.next);\n        }\n\n        let entry = &mut self.entries[index];\n        mem::replace(&mut entry.value, value)\n    }\n\n    fn insert_occupied_mult(&mut self, index: usize, value: T) -> ValueDrain<T> {\n        let old;\n        let links;\n\n        {\n            let entry = &mut self.entries[index];\n\n            old = mem::replace(&mut entry.value, value);\n            links = entry.links.take();\n        }\n\n        ValueDrain {\n            map: self as *mut _,\n            first: Some(old),\n            next: links.map(|l| l.next),\n            lt: PhantomData,\n        }\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not previously have this key present, then `false` is\n    /// returned.\n    ///\n    /// If the map did have this key present, the new value is pushed to the end\n    /// of the list of values currently associated with the key. The key is not\n    /// updated, though; this matters for types that can be `==` without being\n    /// identical.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(map.insert(HOST, \"world\".parse().unwrap()).is_none());\n    /// assert!(!map.is_empty());\n    ///\n    /// map.append(HOST, \"earth\".parse().unwrap());\n    ///\n    /// let values = map.get_all(\"host\");\n    /// let mut i = values.iter();\n    /// assert_eq!(\"world\", *i.next().unwrap());\n    /// assert_eq!(\"earth\", *i.next().unwrap());\n    /// ```\n    pub fn append<K>(&mut self, key: K, value: T) -> bool\n        where K: IntoHeaderName,\n    {\n        key.append(self, value)\n    }\n\n    #[inline]\n    fn append2<K>(&mut self, key: K, value: T) -> bool\n        where K: Hash + Into<HeaderName>,\n              HeaderName: PartialEq<K>,\n    {\n        self.reserve_one();\n\n        insert_phase_one!(\n            self, key, probe, pos, hash, danger,\n            // Vacant\n            {\n                drop(danger);\n                let index = self.entries.len();\n                self.insert_entry(hash, key.into(), value);\n                self.indices[probe] = Pos::new(index, hash);\n                false\n            },\n            // Occupied\n            {\n                append_value(pos, &mut self.entries[pos], &mut self.extra_values, value);\n                true\n            },\n            // Robinhood\n            {\n                self.insert_phase_two(\n                    key.into(),\n                    value,\n                    hash,\n                    probe,\n                    danger);\n\n                false\n            })\n    }\n\n    #[inline]\n    fn find<K: ?Sized>(&self, key: &K) -> Option<(usize, usize)>\n        where K: Hash + Into<HeaderName>,\n              HeaderName: PartialEq<K>,\n    {\n        if self.entries.is_empty() {\n            return None;\n        }\n\n        let hash = hash_elem_using(&self.danger, key);\n        let mask = self.mask;\n        let mut probe = desired_pos(mask, hash);\n        let mut dist = 0;\n\n        probe_loop!(probe < self.indices.len(), {\n            if let Some((i, entry_hash)) = self.indices[probe].resolve() {\n                if dist > probe_distance(mask, entry_hash, probe) {\n                    // give up when probe distance is too long\n                    return None;\n                } else if entry_hash == hash && self.entries[i].key == *key {\n                    return Some((probe, i));\n                }\n            } else {\n                return None;\n            }\n\n            dist += 1;\n        });\n    }\n\n    /// phase 2 is post-insert where we forward-shift `Pos` in the indices.\n    #[inline]\n    fn insert_phase_two(&mut self,\n                        key: HeaderName,\n                        value: T,\n                        hash: HashValue,\n                        probe: usize,\n                        danger: bool) -> usize\n    {\n        // Push the value and get the index\n        let index = self.entries.len();\n        self.insert_entry(hash, key, value);\n\n        let num_displaced = do_insert_phase_two(\n            &mut self.indices,\n            probe,\n            Pos::new(index, hash));\n\n        if danger || num_displaced >= DISPLACEMENT_THRESHOLD {\n            // Increase danger level\n            self.danger.to_yellow();\n        }\n\n        index\n    }\n\n    /// Removes a key from the map, returning the value associated with the key.\n    ///\n    /// Returns `None` if the map does not contain the key. If there are\n    /// multiple values associated with the key, then the first one is returned.\n    /// See `remove_entry_mult` on `OccupiedEntry` for an API that yields all\n    /// values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    ///\n    /// let prev = map.remove(HOST).unwrap();\n    /// assert_eq!(\"hello.world\", prev);\n    ///\n    /// assert!(map.remove(HOST).is_none());\n    /// ```\n    pub fn remove<K>(&mut self, key: K) -> Option<T>\n        where K: AsHeaderName\n    {\n        match key.find(self) {\n            Some((probe, idx)) => {\n                if let Some(links) = self.entries[idx].links {\n                    self.remove_all_extra_values(links.next);\n                }\n\n                let entry = self.remove_found(probe, idx);\n\n                Some(entry.value)\n            }\n            None => None,\n        }\n    }\n\n    /// Remove an entry from the map.\n    #[inline]\n    fn remove_found(&mut self, probe: usize, found: usize) -> Bucket<T> {\n        // index `probe` and entry `found` is to be removed\n        // use swap_remove, but then we need to update the index that points\n        // to the other entry that has to move\n        self.indices[probe] = Pos::none();\n        let entry = self.entries.swap_remove(found);\n\n        // correct index that points to the entry that had to swap places\n        if let Some(entry) = self.entries.get(found) {\n            // was not last element\n            // examine new element in `found` and find it in indices\n            let mut probe = desired_pos(self.mask, entry.hash);\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((i, _)) = self.indices[probe].resolve() {\n                    if i >= self.entries.len() {\n                        // found it\n                        self.indices[probe] = Pos::new(found, entry.hash);\n                        break;\n                    }\n                }\n            });\n\n            // Update links\n            if let Some(links) = entry.links {\n                self.extra_values[links.next].prev = Link::Entry(found);\n                self.extra_values[links.tail].next = Link::Entry(found);\n            }\n        }\n\n        // backward shift deletion in self.indices\n        // after probe, shift all non-ideally placed indices backward\n        if self.entries.len() > 0 {\n            let mut last_probe = probe;\n            let mut probe = probe + 1;\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((_, entry_hash)) = self.indices[probe].resolve() {\n                    if probe_distance(self.mask, entry_hash, probe) > 0 {\n                        self.indices[last_probe] = self.indices[probe];\n                        self.indices[probe] = Pos::none();\n                    } else {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n\n                last_probe = probe;\n            });\n        }\n\n        entry\n    }\n\n    /// Removes the `ExtraValue` at the given index.\n    #[inline]\n    fn remove_extra_value(&mut self, idx: usize) -> ExtraValue<T> {\n        let prev;\n        let next;\n\n        {\n            debug_assert!(self.extra_values.len() > idx);\n            let extra = &self.extra_values[idx];\n            prev = extra.prev;\n            next = extra.next;\n        }\n\n        // First unlink the extra value\n        match (prev, next) {\n            (Link::Entry(prev), Link::Entry(next)) => {\n                debug_assert_eq!(prev, next);\n                debug_assert!(self.entries.len() > prev);\n\n                self.entries[prev].links = None;\n            }\n            (Link::Entry(prev), Link::Extra(next)) => {\n                debug_assert!(self.entries.len() > prev);\n                debug_assert!(self.entries[prev].links.is_some());\n\n                self.entries[prev].links.as_mut().unwrap()\n                    .next = next;\n\n                debug_assert!(self.extra_values.len() > next);\n                self.extra_values[next].prev = Link::Entry(prev);\n            }\n            (Link::Extra(prev), Link::Entry(next)) => {\n                debug_assert!(self.entries.len() > next);\n                debug_assert!(self.entries[next].links.is_some());\n\n                self.entries[next].links.as_mut().unwrap()\n                    .tail = prev;\n\n                debug_assert!(self.extra_values.len() > prev);\n                self.extra_values[prev].next = Link::Entry(next);\n            }\n            (Link::Extra(prev), Link::Extra(next)) => {\n                debug_assert!(self.extra_values.len() > next);\n                debug_assert!(self.extra_values.len() > prev);\n\n                self.extra_values[prev].next = Link::Extra(next);\n                self.extra_values[next].prev = Link::Extra(prev);\n            }\n        }\n\n        // Remove the extra value\n        let mut extra = self.extra_values.swap_remove(idx);\n\n        // This is the index of the value that was moved (possibly `extra`)\n        let old_idx = self.extra_values.len();\n\n        // Update the links\n        if extra.prev == Link::Extra(old_idx) {\n            extra.prev = Link::Extra(idx);\n        }\n\n        if extra.next == Link::Extra(old_idx) {\n            extra.next = Link::Extra(idx);\n        }\n\n        // Check if another entry was displaced. If it was, then the links\n        // need to be fixed.\n        if idx != old_idx {\n            let next;\n            let prev;\n\n            {\n                debug_assert!(self.extra_values.len() > idx);\n                let moved = &self.extra_values[idx];\n                next = moved.next;\n                prev = moved.prev;\n            }\n\n            // An entry was moved, we have to the links\n            match prev {\n                Link::Entry(entry_idx) => {\n                    // It is critical that we do not attempt to read the\n                    // header name or value as that memory may have been\n                    // \"released\" already.\n                    debug_assert!(self.entries.len() > entry_idx);\n                    debug_assert!(self.entries[entry_idx].links.is_some());\n\n                    let links = self.entries[entry_idx].links.as_mut().unwrap();\n                    links.next = idx;\n                }\n                Link::Extra(extra_idx) => {\n                    debug_assert!(self.extra_values.len() > extra_idx);\n                    self.extra_values[extra_idx].next = Link::Extra(idx);\n                }\n            }\n\n            match next {\n                Link::Entry(entry_idx) => {\n                    debug_assert!(self.entries.len() > entry_idx);\n                    debug_assert!(self.entries[entry_idx].links.is_some());\n\n                    let links = self.entries[entry_idx].links.as_mut().unwrap();\n                    links.tail = idx;\n                }\n                Link::Extra(extra_idx) => {\n                    debug_assert!(self.extra_values.len() > extra_idx);\n                    self.extra_values[extra_idx].prev = Link::Extra(idx);\n                }\n            }\n        }\n\n        debug_assert!({\n            for v in &self.extra_values {\n                assert!(v.next != Link::Extra(old_idx));\n                assert!(v.prev != Link::Extra(old_idx));\n            }\n\n            true\n        });\n\n        extra\n    }\n\n    fn remove_all_extra_values(&mut self, mut head: usize) {\n        loop {\n            let extra = self.remove_extra_value(head);\n\n            if let Link::Extra(idx) = extra.next {\n                head = idx;\n            } else {\n                break;\n            }\n        }\n    }\n\n    #[inline]\n    fn insert_entry(&mut self, hash: HashValue, key: HeaderName, value: T) {\n        assert!(self.entries.len() < MAX_SIZE, \"header map at capacity\");\n\n        self.entries.push(Bucket {\n            hash: hash,\n            key: key,\n            value: value,\n            links: None,\n        });\n    }\n\n    fn rebuild(&mut self) {\n        // Loop over all entries and re-insert them into the map\n        'outer:\n        for (index, entry) in self.entries.iter_mut().enumerate() {\n            let hash = hash_elem_using(&self.danger, &entry.key);\n            let mut probe = desired_pos(self.mask, hash);\n            let mut dist = 0;\n\n            // Update the entry's hash code\n            entry.hash = hash;\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((_, entry_hash)) = self.indices[probe].resolve() {\n                    // if existing element probed less than us, swap\n                    let their_dist = probe_distance(self.mask, entry_hash, probe);\n\n                    if their_dist < dist {\n                        // Robinhood\n                        break;\n                    }\n                } else {\n                    // Vacant slot\n                    self.indices[probe] = Pos::new(index, hash);\n                    continue 'outer;\n                }\n\n                dist += 1;\n            });\n\n            do_insert_phase_two(\n                &mut self.indices,\n                probe,\n                Pos::new(index, hash));\n        }\n    }\n\n    fn reinsert_entry_in_order(&mut self, pos: Pos) {\n        if let Some((_, entry_hash)) = pos.resolve() {\n            // Find first empty bucket and insert there\n            let mut probe = desired_pos(self.mask, entry_hash);\n\n            probe_loop!(probe < self.indices.len(), {\n                if self.indices[probe].resolve().is_none() {\n                    // empty bucket, insert here\n                    self.indices[probe] = pos;\n                    return;\n                }\n            });\n        }\n    }\n\n    fn reserve_one(&mut self) {\n        let len = self.entries.len();\n\n        if self.danger.is_yellow() {\n            let load_factor = self.entries.len() as f32 / self.indices.len() as f32;\n\n            if load_factor >= LOAD_FACTOR_THRESHOLD {\n                // Transition back to green danger level\n                self.danger.to_green();\n\n                // Double the capacity\n                let new_cap = self.indices.len() * 2;\n\n                // Grow the capacity\n                self.grow(new_cap);\n            } else {\n                self.danger.to_red();\n\n                // Rebuild hash table\n                for index in self.indices.iter_mut() {\n                    *index = Pos::none();\n                }\n\n                self.rebuild();\n            }\n        } else if len == self.capacity() {\n            if len == 0 {\n                let new_raw_cap = 8;\n                self.mask = 8 - 1;\n                self.indices = vec![Pos::none(); new_raw_cap].into_boxed_slice();\n                self.entries = Vec::with_capacity(usable_capacity(new_raw_cap));\n            } else {\n                let raw_cap = self.indices.len();\n                self.grow(raw_cap << 1);\n            }\n        }\n    }\n\n    #[inline]\n    fn grow(&mut self, new_raw_cap: usize) {\n        // This path can never be reached when handling the first allocation in\n        // the map.\n\n        // find first ideally placed element -- start of cluster\n        let mut first_ideal = 0;\n\n        for (i, pos) in self.indices.iter().enumerate() {\n            if let Some((_, entry_hash)) = pos.resolve() {\n                if 0 == probe_distance(self.mask, entry_hash, i) {\n                    first_ideal = i;\n                    break;\n                }\n            }\n        }\n\n        // visit the entries in an order where we can simply reinsert them\n        // into self.indices without any bucket stealing.\n        let old_indices = mem::replace(&mut self.indices, vec![Pos::none(); new_raw_cap].into_boxed_slice());\n        self.mask = new_raw_cap.wrapping_sub(1) as Size;\n\n        for &pos in &old_indices[first_ideal..] {\n            self.reinsert_entry_in_order(pos);\n        }\n\n        for &pos in &old_indices[..first_ideal] {\n            self.reinsert_entry_in_order(pos);\n        }\n\n        // Reserve additional entry slots\n        let more = self.capacity() - self.entries.len();\n        self.entries.reserve_exact(more);\n    }\n}","impl<T> HttpTryFrom<HeaderMap<T>> for HeaderMap<T> {\n    type Error = Error;\n\n    fn try_from(t: Self) -> Result<Self, Self::Error> {\n        Ok(t)\n    }\n}","impl<T> IntoIterator for HeaderMap<T> {\n    type Item = (Option<HeaderName>, T);\n    type IntoIter = IntoIter<T>;\n\n    /// Creates a consuming iterator, that is, one that moves keys and values\n    /// out of the map in arbitrary order. The map cannot be used after calling\n    /// this.\n    ///\n    /// For each yielded item that has `None` provided for the `HeaderName`,\n    /// then the associated header name is the same as that of the previously\n    /// yielded item. The first yielded item will have `HeaderName` set.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage.\n    ///\n    /// ```\n    /// # use http::header;\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    /// map.insert(header::CONTENT_LENGTH, \"123\".parse().unwrap());\n    /// map.insert(header::CONTENT_TYPE, \"json\".parse().unwrap());\n    ///\n    /// let mut iter = map.into_iter();\n    /// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), \"123\".parse().unwrap())));\n    /// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), \"json\".parse().unwrap())));\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// Multiple values per key.\n    ///\n    /// ```\n    /// # use http::header;\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.append(header::CONTENT_LENGTH, \"123\".parse().unwrap());\n    /// map.append(header::CONTENT_LENGTH, \"456\".parse().unwrap());\n    ///\n    /// map.append(header::CONTENT_TYPE, \"json\".parse().unwrap());\n    /// map.append(header::CONTENT_TYPE, \"html\".parse().unwrap());\n    /// map.append(header::CONTENT_TYPE, \"xml\".parse().unwrap());\n    ///\n    /// let mut iter = map.into_iter();\n    ///\n    /// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), \"123\".parse().unwrap())));\n    /// assert_eq!(iter.next(), Some((None, \"456\".parse().unwrap())));\n    ///\n    /// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), \"json\".parse().unwrap())));\n    /// assert_eq!(iter.next(), Some((None, \"html\".parse().unwrap())));\n    /// assert_eq!(iter.next(), Some((None, \"xml\".parse().unwrap())));\n    /// assert!(iter.next().is_none());\n    /// ```\n    fn into_iter(self) -> IntoIter<T> {\n        IntoIter {\n            next: None,\n            entries: self.entries.into_iter(),\n            extra_values: self.extra_values,\n        }\n    }\n}","impl<T> Sealed for HeaderMap<T> {}"],"header::map::IntoIter":["Debug","impl<T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        // Ensure the iterator is consumed\n        for _ in self.by_ref() { }\n\n        // All the values have already been yielded out.\n        unsafe { self.extra_values.set_len(0); }\n    }\n}","impl<T> Iterator for IntoIter<T> {\n    type Item = (Option<HeaderName>, T);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Some(next) = self.next {\n            self.next = match self.extra_values[next].next {\n                Link::Entry(_) => None,\n                Link::Extra(v) => Some(v),\n            };\n\n            let value = unsafe { ptr::read(&self.extra_values[next].value) };\n\n            return Some((None, value));\n        }\n\n        if let Some(bucket) = self.entries.next() {\n            self.next = bucket.links.map(|l| l.next);\n            let name = Some(bucket.key);\n            let value = bucket.value;\n\n            return Some((name, value));\n        }\n\n        None\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (lower, _) = self.entries.size_hint();\n        // There could be more than just the entries upper, as there\n        // could be items in the `extra_values`. We could guess, saying\n        // `upper + extra_values.len()`, but that could overestimate by a lot.\n        (lower, None)\n    }\n}"],"header::map::Iter":["Debug","impl<'a, T> Iterator for Iter<'a, T> {\n    type Item = (&'a HeaderName, &'a T);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next_unsafe().map(|(key, ptr)| {\n            (key, unsafe { &*ptr })\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}","unsafe impl<'a, T: Sync> Send for Iter<'a, T> {}","unsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}"],"header::map::IterMut":["Debug","impl<'a, T> IterMut<'a, T> {\n    fn next_unsafe(&mut self) -> Option<(&'a HeaderName, *mut T)> {\n        use self::Cursor::*;\n\n        if self.cursor.is_none() {\n            if (self.entry + 1) >= unsafe { &*self.map }.entries.len() {\n                return None;\n            }\n\n            self.entry += 1;\n            self.cursor = Some(Cursor::Head);\n        }\n\n        let entry = unsafe { &(*self.map).entries[self.entry] };\n\n        match self.cursor.unwrap() {\n            Head => {\n                self.cursor = entry.links.map(|l| Values(l.next));\n                Some((&entry.key, &entry.value as *const _ as *mut _))\n            }\n            Values(idx) => {\n                let extra = unsafe { &(*self.map).extra_values[idx] };\n\n                match extra.next {\n                    Link::Entry(_) => self.cursor = None,\n                    Link::Extra(i) => self.cursor = Some(Values(i)),\n                }\n\n                Some((&entry.key, &extra.value as *const _ as *mut _))\n            }\n        }\n    }\n}","impl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = (&'a HeaderName, &'a mut T);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next_unsafe().map(|(key, ptr)| {\n            (key, unsafe { &mut *ptr })\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let map = unsafe { &*self.map };\n        debug_assert!(map.entries.len() >= self.entry);\n\n        let lower = map.entries.len() - self.entry;\n        // We could pessimistically guess at the upper bound, saying\n        // that its lower + map.extra_values.len(). That could be\n        // way over though, such as if we're near the end, and have\n        // already gone through several extra values...\n        (lower, None)\n    }\n}","unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}","unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}"],"header::map::Keys":["Debug","impl<'a, T> ExactSizeIterator for Keys<'a, T> {}","impl<'a, T> Iterator for Keys<'a, T> {\n    type Item = &'a HeaderName;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(|b| &b.key)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}"],"header::map::Link":["Clone","Copy","Debug","Eq","PartialEq"],"header::map::Links":["Clone","Copy","Debug"],"header::map::OccupiedEntry":["Debug","impl<'a, T> IntoIterator for OccupiedEntry<'a, T> {\n    type Item = &'a mut T;\n    type IntoIter = ValueIterMut<'a, T>;\n\n    fn into_iter(self) -> ValueIterMut<'a, T> {\n        self.map.value_iter_mut(self.index)\n    }\n}","impl<'a, T> OccupiedEntry<'a, T> {\n    /// Returns a reference to the entry's key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(e) = map.entry(\"host\").unwrap() {\n    ///     assert_eq!(\"host\", e.key());\n    /// }\n    /// ```\n    pub fn key(&self) -> &HeaderName {\n        &self.map.entries[self.index].key\n    }\n\n    /// Get a reference to the first value in the entry.\n    ///\n    /// Values are stored in insertion order.\n    ///\n    /// # Panics\n    ///\n    /// `get` panics if there are no values associated with the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry(\"host\").unwrap() {\n    ///     assert_eq!(e.get(), &\"hello.world\");\n    ///\n    ///     e.append(\"hello.earth\".parse().unwrap());\n    ///\n    ///     assert_eq!(e.get(), &\"hello.world\");\n    /// }\n    /// ```\n    pub fn get(&self) -> &T {\n        &self.map.entries[self.index].value\n    }\n\n    /// Get a mutable reference to the first value in the entry.\n    ///\n    /// Values are stored in insertion order.\n    ///\n    /// # Panics\n    ///\n    /// `get_mut` panics if there are no values associated with the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::default();\n    /// map.insert(HOST, \"hello.world\".to_string());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry(\"host\").unwrap() {\n    ///     e.get_mut().push_str(\"-2\");\n    ///     assert_eq!(e.get(), &\"hello.world-2\");\n    /// }\n    /// ```\n    pub fn get_mut(&mut self) -> &mut T {\n        &mut self.map.entries[self.index].value\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the **first**\n    /// value.\n    ///\n    /// The lifetime of the returned reference is bound to the original map.\n    ///\n    /// # Panics\n    ///\n    /// `into_mut` panics if there are no values associated with the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::default();\n    /// map.insert(HOST, \"hello.world\".to_string());\n    /// map.append(HOST, \"hello.earth\".to_string());\n    ///\n    /// if let Entry::Occupied(e) = map.entry(\"host\").unwrap() {\n    ///     e.into_mut().push_str(\"-2\");\n    /// }\n    ///\n    /// assert_eq!(\"hello.world-2\", map[\"host\"]);\n    /// ```\n    pub fn into_mut(self) -> &'a mut T {\n        &mut self.map.entries[self.index].value\n    }\n\n    /// Sets the value of the entry.\n    ///\n    /// All previous values associated with the entry are removed and the first\n    /// one is returned. See `insert_mult` for an API that returns all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry(\"host\").unwrap() {\n    ///     let mut prev = e.insert(\"earth\".parse().unwrap());\n    ///     assert_eq!(\"hello.world\", prev);\n    /// }\n    ///\n    /// assert_eq!(\"earth\", map[\"host\"]);\n    /// ```\n    pub fn insert(&mut self, value: T) -> T {\n        self.map.insert_occupied(self.index, value.into())\n    }\n\n    /// Sets the value of the entry.\n    ///\n    /// This function does the same as `insert` except it returns an iterator\n    /// that yields all values previously associated with the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    /// map.append(HOST, \"world2\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry(\"host\").unwrap() {\n    ///     let mut prev = e.insert_mult(\"earth\".parse().unwrap());\n    ///     assert_eq!(\"world\", prev.next().unwrap());\n    ///     assert_eq!(\"world2\", prev.next().unwrap());\n    ///     assert!(prev.next().is_none());\n    /// }\n    ///\n    /// assert_eq!(\"earth\", map[\"host\"]);\n    /// ```\n    pub fn insert_mult(&mut self, value: T) -> ValueDrain<T> {\n        self.map.insert_occupied_mult(self.index, value.into())\n    }\n\n    /// Insert the value into the entry.\n    ///\n    /// The new value is appended to the end of the entry's value list. All\n    /// previous values associated with the entry are retained.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry(\"host\").unwrap() {\n    ///     e.append(\"earth\".parse().unwrap());\n    /// }\n    ///\n    /// let values = map.get_all(\"host\");\n    /// let mut i = values.iter();\n    /// assert_eq!(\"world\", *i.next().unwrap());\n    /// assert_eq!(\"earth\", *i.next().unwrap());\n    /// ```\n    pub fn append(&mut self, value: T) {\n        let idx = self.index;\n        let entry = &mut self.map.entries[idx];\n        append_value(idx, entry, &mut self.map.extra_values, value.into());\n    }\n\n    /// Remove the entry from the map.\n    ///\n    /// All values associated with the entry are removed and the first one is\n    /// returned. See `remove_entry_mult` for an API that returns all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(e) = map.entry(\"host\").unwrap() {\n    ///     let mut prev = e.remove();\n    ///     assert_eq!(\"world\", prev);\n    /// }\n    ///\n    /// assert!(!map.contains_key(\"host\"));\n    /// ```\n    pub fn remove(self) -> T {\n        self.remove_entry().1\n    }\n\n    /// Remove the entry from the map.\n    ///\n    /// The key and all values associated with the entry are removed and the\n    /// first one is returned. See `remove_entry_mult` for an API that returns\n    /// all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(e) = map.entry(\"host\").unwrap() {\n    ///     let (key, mut prev) = e.remove_entry();\n    ///     assert_eq!(\"host\", key.as_str());\n    ///     assert_eq!(\"world\", prev);\n    /// }\n    ///\n    /// assert!(!map.contains_key(\"host\"));\n    /// ```\n    pub fn remove_entry(self) -> (HeaderName, T) {\n        let entry = self.map.remove_found(self.probe, self.index);\n\n        if let Some(links) = entry.links {\n            self.map.remove_all_extra_values(links.next);\n        }\n\n        (entry.key, entry.value)\n    }\n\n    /// Remove the entry from the map.\n    ///\n    /// The key and all values associated with the entry are removed and\n    /// returned.\n    pub fn remove_entry_mult(self) -> (HeaderName, ValueDrain<'a, T>) {\n        let entry = self.map.remove_found(self.probe, self.index);\n        let drain = ValueDrain {\n            map: self.map as *mut _,\n            first: Some(entry.value),\n            next: entry.links.map(|l| l.next),\n            lt: PhantomData,\n        };\n        (entry.key, drain)\n    }\n\n    /// Returns an iterator visiting all values associated with the entry.\n    ///\n    /// Values are iterated in insertion order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    /// map.append(HOST, \"earth\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(e) = map.entry(\"host\").unwrap() {\n    ///     let mut iter = e.iter();\n    ///     assert_eq!(&\"world\", iter.next().unwrap());\n    ///     assert_eq!(&\"earth\", iter.next().unwrap());\n    ///     assert!(iter.next().is_none());\n    /// }\n    /// ```\n    pub fn iter(&self) -> ValueIter<T> {\n        self.map.value_iter(Some(self.index))\n    }\n\n    /// Returns an iterator mutably visiting all values associated with the\n    /// entry.\n    ///\n    /// Values are iterated in insertion order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::default();\n    /// map.insert(HOST, \"world\".to_string());\n    /// map.append(HOST, \"earth\".to_string());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry(\"host\").unwrap() {\n    ///     for e in e.iter_mut() {\n    ///         e.push_str(\"-boop\");\n    ///     }\n    /// }\n    ///\n    /// let mut values = map.get_all(\"host\");\n    /// let mut i = values.iter();\n    /// assert_eq!(&\"world-boop\", i.next().unwrap());\n    /// assert_eq!(&\"earth-boop\", i.next().unwrap());\n    /// ```\n    pub fn iter_mut(&mut self) -> ValueIterMut<T> {\n        self.map.value_iter_mut(self.index)\n    }\n}"],"header::map::Pos":["Clone","Copy","impl Pos {\n    #[inline]\n    fn new(index: usize, hash: HashValue) -> Self {\n        Pos {\n            index: index as Size,\n            hash: hash,\n        }\n    }\n\n    #[inline]\n    fn none() -> Self {\n        Pos {\n            index: !0,\n            hash: HashValue(0),\n        }\n    }\n\n    #[inline]\n    fn is_some(&self) -> bool {\n        !self.is_none()\n    }\n\n    #[inline]\n    fn is_none(&self) -> bool {\n        self.index == !0\n    }\n\n    #[inline]\n    fn resolve(&self) -> Option<(usize, HashValue)> {\n        if self.is_some() {\n            Some((self.index, self.hash))\n        } else {\n            None\n        }\n    }\n}"],"header::map::VacantEntry":["Debug","impl<'a, T> VacantEntry<'a, T> {\n    /// Returns a reference to the entry's key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(map.entry(\"x-hello\").unwrap().key().as_str(), \"x-hello\");\n    /// ```\n    pub fn key(&self) -> &HeaderName {\n        &self.key\n    }\n\n    /// Take ownership of the key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry(\"x-hello\").unwrap() {\n    ///     assert_eq!(v.into_key().as_str(), \"x-hello\");\n    /// }\n    /// ```\n    pub fn into_key(self) -> HeaderName {\n        self.key\n    }\n\n    /// Insert the value into the entry.\n    ///\n    /// The value will be associated with this entry's key. A mutable reference\n    /// to the inserted value will be returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry(\"x-hello\").unwrap() {\n    ///     v.insert(\"world\".parse().unwrap());\n    /// }\n    ///\n    /// assert_eq!(map[\"x-hello\"], \"world\");\n    /// ```\n    pub fn insert(self, value: T) -> &'a mut T {\n        // Ensure that there is space in the map\n        let index = self.map.insert_phase_two(\n            self.key,\n            value.into(),\n            self.hash,\n            self.probe,\n            self.danger);\n\n        &mut self.map.entries[index].value\n    }\n\n    /// Insert the value into the entry.\n    ///\n    /// The value will be associated with this entry's key. The new\n    /// `OccupiedEntry` is returned, allowing for further manipulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry(\"x-hello\").unwrap() {\n    ///     let mut e = v.insert_entry(\"world\".parse().unwrap());\n    ///     e.insert(\"world2\".parse().unwrap());\n    /// }\n    ///\n    /// assert_eq!(map[\"x-hello\"], \"world2\");\n    /// ```\n    pub fn insert_entry(self, value: T) -> OccupiedEntry<'a, T> {\n        // Ensure that there is space in the map\n        let index = self.map.insert_phase_two(\n            self.key,\n            value.into(),\n            self.hash,\n            self.probe,\n            self.danger);\n\n        OccupiedEntry {\n            map: self.map,\n            index: index,\n            probe: self.probe,\n        }\n    }\n}"],"header::map::ValueDrain":["Debug","impl<'a, T> Drop for ValueDrain<'a, T> {\n    fn drop(&mut self) {\n        while let Some(_) = self.next() {\n        }\n    }\n}","impl<'a, T> Iterator for ValueDrain<'a, T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n        if self.first.is_some() {\n            self.first.take()\n        } else if let Some(next) = self.next {\n            // Remove the extra value\n            let extra = unsafe { &mut (*self.map) }.remove_extra_value(next);\n\n            match extra.next {\n                Link::Extra(idx) => self.next = Some(idx),\n                Link::Entry(_) => self.next = None,\n            }\n\n            Some(extra.value)\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match (&self.first, self.next) {\n            // Exactly 1\n            (&Some(_), None) => (1, Some(1)),\n            // At least 1\n            (&_, Some(_)) => (1, None),\n            // No more\n            (&None, None) => (0, Some(0)),\n        }\n    }\n}","unsafe impl<'a, T: Send> Send for ValueDrain<'a, T> {}","unsafe impl<'a, T: Sync> Sync for ValueDrain<'a, T> {}"],"header::map::ValueIter":["Debug","impl<'a, T: 'a> DoubleEndedIterator for ValueIter<'a, T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n\n        match self.back {\n            Some(Head) => {\n                self.front = None;\n                self.back = None;\n                Some(&self.map.entries[self.index].value)\n            }\n            Some(Values(idx)) => {\n                let extra = &self.map.extra_values[idx];\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.prev {\n                        Link::Entry(_) => self.back = Some(Head),\n                        Link::Extra(idx) => self.back = Some(Values(idx)),\n                    }\n                }\n\n                Some(&extra.value)\n            }\n            None => None,\n        }\n    }\n}","impl<'a, T: 'a> Iterator for ValueIter<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n\n        match self.front {\n            Some(Head) => {\n                let entry = &self.map.entries[self.index];\n\n                if self.back == Some(Head) {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    // Update the iterator state\n                    match entry.links {\n                        Some(links) => {\n                            self.front = Some(Values(links.next));\n                        }\n                        None => unreachable!(),\n                    }\n                }\n\n                Some(&entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = &self.map.extra_values[idx];\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.next {\n                        Link::Entry(_) => self.front = None,\n                        Link::Extra(i) => self.front = Some(Values(i)),\n                    }\n                }\n\n                Some(&extra.value)\n            }\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match (self.front, self.back) {\n            // Exactly 1 value...\n            (Some(Cursor::Head), Some(Cursor::Head)) => (1, Some(1)),\n            // At least 1...\n            (Some(_), _) => (1, None),\n            // No more values...\n            (None, _) => (0, Some(0)),\n        }\n    }\n}"],"header::map::ValueIterMut":["Debug","impl<'a, T: 'a> DoubleEndedIterator for ValueIterMut<'a, T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n        let entry = unsafe { &mut (*self.map).entries[self.index] };\n\n        match self.back {\n            Some(Head) => {\n                self.front = None;\n                self.back = None;\n                Some(&mut entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.prev {\n                        Link::Entry(_) => self.back = Some(Head),\n                        Link::Extra(idx) => self.back = Some(Values(idx)),\n                    }\n                }\n\n                Some(&mut extra.value)\n            }\n            None => None,\n        }\n    }\n}","impl<'a, T: 'a> Iterator for ValueIterMut<'a, T> {\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n        let entry = unsafe { &mut (*self.map).entries[self.index] };\n\n        match self.front {\n            Some(Head) => {\n                if self.back == Some(Head) {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    // Update the iterator state\n                    match entry.links {\n                        Some(links) => {\n                            self.front = Some(Values(links.next));\n                        }\n                        None => unreachable!(),\n                    }\n                }\n\n                Some(&mut entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.next {\n                        Link::Entry(_) => self.front = None,\n                        Link::Extra(i) => self.front = Some(Values(i)),\n                    }\n                }\n\n                Some(&mut extra.value)\n            }\n            None => None,\n        }\n    }\n}","unsafe impl<'a, T: Send> Send for ValueIterMut<'a, T> {}","unsafe impl<'a, T: Sync> Sync for ValueIterMut<'a, T> {}"],"header::map::Values":["Debug","impl<'a, T> Iterator for Values<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(|(_, v)| v)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}"],"header::map::ValuesMut":["Debug","impl<'a, T> Iterator for ValuesMut<'a, T> {\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(|(_, v)| v)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}"],"header::name::Custom":["Clone","Debug","Eq","PartialEq","impl Hash for Custom {\n    #[inline]\n    fn hash<H: Hasher>(&self, hasher: &mut H) {\n        hasher.write(self.0.as_bytes())\n    }\n}"],"header::name::HdrName":["Debug","Hash","impl<'a> From<StandardHeader> for HdrName<'a> {\n    fn from(hdr: StandardHeader) -> HdrName<'a> {\n        HdrName { inner: Repr::Standard(hdr) }\n    }\n}","impl<'a> HdrName<'a> {\n    fn custom(buf: &'a [u8], lower: bool) -> HdrName<'a> {\n        HdrName {\n            inner: Repr::Custom(MaybeLower {\n                buf: buf,\n                lower: lower,\n            }),\n        }\n    }\n\n    #[allow(deprecated)]\n    pub fn from_bytes<F, U>(hdr: &[u8], f: F) -> Result<U, InvalidHeaderName>\n        where F: FnOnce(HdrName) -> U,\n    {\n        let mut buf = unsafe { mem::uninitialized() };\n        let hdr = parse_hdr(hdr, &mut buf, &HEADER_CHARS)?;\n        Ok(f(hdr))\n    }\n\n    #[allow(deprecated)]\n    pub fn from_static<F, U>(hdr: &'static str, f: F) -> U\n        where F: FnOnce(HdrName) -> U,\n    {\n        let mut buf = unsafe { mem::uninitialized() };\n        let hdr = parse_hdr(hdr.as_bytes(), &mut buf, &HEADER_CHARS)\n            .expect(\"static str is invalid name\");\n        f(hdr)\n    }\n}"],"header::name::HeaderName":["Clone","Eq","Hash","PartialEq","impl AsHeaderName for HeaderName {}","impl AsRef<[u8]> for HeaderName {\n    fn as_ref(&self) -> &[u8] {\n        self.as_str().as_bytes()\n    }\n}","impl AsRef<str> for HeaderName {\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}","impl Borrow<str> for HeaderName {\n    fn borrow(&self) -> &str {\n        self.as_str()\n    }\n}","impl From<Custom> for HeaderName {\n    fn from(src: Custom) -> HeaderName {\n        HeaderName { inner: Repr::Custom(src) }\n    }\n}","impl From<StandardHeader> for HeaderName {\n    fn from(src: StandardHeader) -> HeaderName {\n        HeaderName {\n            inner: Repr::Standard(src),\n        }\n    }\n}","impl FromStr for HeaderName {\n    type Err = InvalidHeaderName;\n\n    fn from_str(s: &str) -> Result<HeaderName, InvalidHeaderName> {\n        HeaderName::from_bytes(s.as_bytes())\n            .map_err(|_| InvalidHeaderName {\n                _priv: (),\n            })\n    }\n}","impl HeaderName {\n    /// Converts a slice of bytes to an HTTP header name.\n    ///\n    /// This function normalizes the input.\n    #[allow(deprecated)]\n    pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n        let mut buf = unsafe { mem::uninitialized() };\n        match parse_hdr(src, &mut buf, &HEADER_CHARS)?.inner {\n            Repr::Standard(std) => Ok(std.into()),\n            Repr::Custom(MaybeLower { buf, lower: true }) => {\n                let buf = Bytes::from(buf);\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n            Repr::Custom(MaybeLower { buf, lower: false }) => {\n                use bytes::{BufMut};\n                let mut dst = BytesMut::with_capacity(buf.len());\n\n                for b in buf.iter() {\n                    let b = HEADER_CHARS[*b as usize];\n\n                    if b == 0 {\n                        return Err(InvalidHeaderName::new());\n                    }\n\n                    dst.put(b);\n                }\n\n                let val = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };\n\n                Ok(Custom(val).into())\n            }\n        }\n    }\n\n    /// Converts a slice of bytes to an HTTP header name.\n    ///\n    /// This function expects the input to only contain lowercase characters.\n    /// This is useful when decoding HTTP/2.0 headers. The HTTP/2.0\n    /// specification requires that all headers be represented in lower case.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    ///\n    /// // Parsing a lower case header\n    /// let hdr = HeaderName::from_lowercase(b\"content-length\").unwrap();\n    /// assert_eq!(CONTENT_LENGTH, hdr);\n    ///\n    /// // Parsing a header that contains uppercase characters\n    /// assert!(HeaderName::from_lowercase(b\"Content-Length\").is_err());\n    /// ```\n    #[allow(deprecated)]\n    pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n        let mut buf = unsafe { mem::uninitialized() };\n        match parse_hdr(src, &mut buf, &HEADER_CHARS_H2)?.inner {\n            Repr::Standard(std) => Ok(std.into()),\n            Repr::Custom(MaybeLower { buf, lower: true }) => {\n                let buf = Bytes::from(buf);\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n            Repr::Custom(MaybeLower { buf, lower: false }) => {\n                for &b in buf.iter() {\n                    if b != HEADER_CHARS[b as usize] {\n                        return Err(InvalidHeaderName::new());\n                    }\n                }\n\n                let buf = Bytes::from(buf);\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n        }\n    }\n\n    /// Converts a static string to a HTTP header name.\n    ///\n    /// This function panics when the static string is a invalid header.\n    /// \n    /// This function requires the static string to only contain lowercase \n    /// characters, numerals and symbols, as per the HTTP/2.0 specification \n    /// and header names internal representation within this library.\n    /// \n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    /// // Parsing a standard header\n    /// let hdr = HeaderName::from_static(\"content-length\");\n    /// assert_eq!(CONTENT_LENGTH, hdr);\n    /// \n    /// // Parsing a custom header\n    /// let CUSTOM_HEADER: &'static str = \"custom-header\";\n    /// \n    /// let a = HeaderName::from_lowercase(b\"custom-header\").unwrap();\n    /// let b = HeaderName::from_static(CUSTOM_HEADER);\n    /// assert_eq!(a, b);\n    /// ```\n    /// \n    /// ```should_panic\n    /// # use http::header::*;\n    /// #\n    /// // Parsing a header that contains invalid symbols(s):\n    /// HeaderName::from_static(\"content{}{}length\"); // This line panics!\n    /// \n    /// // Parsing a header that contains invalid uppercase characters.\n    /// let a = HeaderName::from_static(\"foobar\");\n    /// let b = HeaderName::from_static(\"FOOBAR\"); // This line panics!\n    /// ```\n    #[allow(deprecated)]\n    pub fn from_static(src: &'static str) -> HeaderName {\n        let bytes = src.as_bytes();\n        let mut buf = unsafe { mem::uninitialized() };\n        match parse_hdr(bytes, &mut buf, &HEADER_CHARS_H2) {\n            Ok(hdr_name) => match hdr_name.inner {\n                Repr::Standard(std) => std.into(),\n                Repr::Custom(MaybeLower { buf: _, lower: true }) => {\n                    let val = ByteStr::from_static(src);\n                    Custom(val).into()\n                },\n                Repr::Custom(MaybeLower { buf: _, lower: false }) => {\n                    // With lower false, the string is left unchecked by\n                    // parse_hdr and must be validated manually.\n                    for &b in bytes.iter() {\n                        if HEADER_CHARS_H2[b as usize] == 0 {\n                            panic!(\"invalid header name\")\n                        }\n                    }\n\n                    let val = ByteStr::from_static(src);\n                    Custom(val).into()\n                }\n            },\n\n            Err(_) => panic!(\"invalid header name\")\n        }\n    }\n\n    /// Returns a `str` representation of the header.\n    ///\n    /// The returned string will always be lower case.\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        match self.inner {\n            Repr::Standard(v) => v.as_str(),\n            Repr::Custom(ref v) => &*v.0,\n        }\n    }\n}","impl HttpTryFrom<$t> for $t {\n            type Error = Error;\n\n            fn try_from(t: Self) -> Result<Self, Self::Error> {\n                Ok(t)\n            }\n        }","impl HttpTryFrom<Bytes> for HeaderName {\n    type Error = InvalidHeaderNameBytes;\n    #[inline]\n    fn try_from(bytes: Bytes) -> Result<Self, Self::Error> {\n        Self::from_bytes(bytes.as_ref()).map_err(InvalidHeaderNameBytes)\n    }\n}","impl IntoHeaderName for HeaderName {}","impl PartialEq<str> for HeaderName {\n    /// Performs a case-insensitive comparison of the string against the header\n    /// name\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use http::header::CONTENT_LENGTH;\n    ///\n    /// assert_eq!(CONTENT_LENGTH, \"content-length\");\n    /// assert_eq!(CONTENT_LENGTH, \"Content-Length\");\n    /// assert_ne!(CONTENT_LENGTH, \"content length\");\n    /// ```\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        eq_ignore_ascii_case(self.as_ref(), other.as_bytes())\n    }\n}","impl Sealed for $t {}","impl Sealed for HeaderName {\n        #[doc(hidden)]\n        #[inline]\n        fn entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<T>, InvalidHeaderName> {\n            Ok(map.entry2(self))\n        }\n\n        #[doc(hidden)]\n        #[inline]\n        fn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)> {\n            map.find(self)\n        }\n\n        #[doc(hidden)]\n        fn as_str(&self) -> &str {\n            <HeaderName>::as_str(self)\n        }\n    }","impl Sealed for HeaderName {\n        #[doc(hidden)]\n        #[inline]\n        fn insert<T>(self, map: &mut HeaderMap<T>, val: T) -> Option<T> {\n            map.insert2(self, val)\n        }\n\n        #[doc(hidden)]\n        #[inline]\n        fn append<T>(self, map: &mut HeaderMap<T>, val: T) -> bool {\n            map.append2(self, val)\n        }\n    }","impl fmt::Debug for HeaderName {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(self.as_str(), fmt)\n    }\n}","impl fmt::Display for HeaderName {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(self.as_str(), fmt)\n    }\n}","impl<'a> From<&'a HeaderName> for HeaderName {\n    fn from(src: &'a HeaderName) -> HeaderName {\n        src.clone()\n    }\n}","impl<'a> From<HdrName<'a>> for HeaderName {\n    fn from(src: HdrName<'a>) -> HeaderName {\n        match src.inner {\n            Repr::Standard(s) => {\n                HeaderName {\n                    inner: Repr::Standard(s),\n                }\n            }\n            Repr::Custom(maybe_lower) => {\n                if maybe_lower.lower {\n                    let buf = Bytes::from(&maybe_lower.buf[..]);\n                    let byte_str = unsafe { ByteStr::from_utf8_unchecked(buf) };\n\n                    HeaderName {\n                        inner: Repr::Custom(Custom(byte_str)),\n                    }\n                } else {\n                    use bytes::{BufMut};\n                    let mut dst = BytesMut::with_capacity(maybe_lower.buf.len());\n\n                    for b in maybe_lower.buf.iter() {\n                        dst.put(HEADER_CHARS[*b as usize]);\n                    }\n\n                    let buf = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };\n\n                    HeaderName {\n                        inner: Repr::Custom(Custom(buf)),\n                    }\n                }\n            }\n        }\n    }\n}","impl<'a> HttpTryFrom<&'a HeaderName> for HeaderName {\n    type Error = ::error::Never;\n\n    #[inline]\n    fn try_from(t: &'a HeaderName) -> Result<Self, Self::Error> {\n        Ok(t.clone())\n    }\n}","impl<'a> HttpTryFrom<&'a String> for HeaderName {\n    type Error = InvalidHeaderName;\n    #[inline]\n    fn try_from(s: &'a String) -> Result<Self, Self::Error> {\n        Self::from_bytes(s.as_bytes())\n    }\n}","impl<'a> HttpTryFrom<&'a [u8]> for HeaderName {\n    type Error = InvalidHeaderName;\n    #[inline]\n    fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {\n        Self::from_bytes(s)\n    }\n}","impl<'a> HttpTryFrom<&'a str> for HeaderName {\n    type Error = InvalidHeaderName;\n    #[inline]\n    fn try_from(s: &'a str) -> Result<Self, Self::Error> {\n        Self::from_bytes(s.as_bytes())\n    }\n}","impl<'a> PartialEq<&'a HeaderName> for HeaderName {\n    #[inline]\n    fn eq(&self, other: &&'a HeaderName) -> bool {\n        *self == **other\n    }\n}","impl<'a> PartialEq<&'a str> for HeaderName {\n    /// Performs a case-insensitive comparison of the string against the header\n    /// name\n    #[inline]\n    fn eq(&self, other: &&'a str) -> bool {\n        *self == **other\n    }\n}","impl<'a> PartialEq<HdrName<'a>> for HeaderName {\n    #[inline]\n    fn eq(&self, other: &HdrName<'a>) -> bool {\n        match self.inner {\n            Repr::Standard(a) => {\n                match other.inner {\n                    Repr::Standard(b) => a == b,\n                    _ => false,\n                }\n            }\n            Repr::Custom(Custom(ref a)) => {\n                match other.inner {\n                    Repr::Custom(ref b) => {\n                        if b.lower {\n                            a.as_bytes() == b.buf\n                        } else {\n                            eq_ignore_ascii_case(a.as_bytes(), b.buf)\n                        }\n                    }\n                    _ => false,\n                }\n            }\n        }\n    }\n}"],"header::name::InvalidHeaderName":["impl Error for InvalidHeaderName {\n    fn description(&self) -> &str {\n        \"invalid HTTP header name\"\n    }\n}","impl InvalidHeaderName {\n    fn new() -> InvalidHeaderName {\n        InvalidHeaderName { _priv: () }\n    }\n}","impl fmt::Debug for InvalidHeaderName {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"InvalidHeaderName\")\n            // skip _priv noise\n            .finish()\n    }\n}","impl fmt::Display for InvalidHeaderName {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.description().fmt(f)\n    }\n}"],"header::name::InvalidHeaderNameBytes":["Debug","impl Error for InvalidHeaderNameBytes {\n    fn description(&self) -> &str {\n        self.0.description()\n    }\n}","impl fmt::Display for InvalidHeaderNameBytes {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}"],"header::name::MaybeLower":["Clone","Debug","impl<'a> Hash for MaybeLower<'a> {\n    #[inline]\n    fn hash<H: Hasher>(&self, hasher: &mut H) {\n        if self.lower {\n            hasher.write(self.buf);\n        } else {\n            for &b in self.buf {\n                hasher.write(&[HEADER_CHARS[b as usize]]);\n            }\n        }\n    }\n}"],"header::name::Repr":["Clone","Debug","Eq","Hash","PartialEq"],"header::name::StandardHeader":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl StandardHeader {\n            #[inline]\n            fn as_str(&self) -> &'static str {\n                match *self {\n                    $(\n                    StandardHeader::$konst => $name,\n                    )+\n                }\n            }\n        }"],"header::value::HeaderValue":["Clone","Hash","impl AsRef<[u8]> for HeaderValue {\n    #[inline]\n    fn as_ref(&self) -> &[u8] {\n        self.inner.as_ref()\n    }\n}","impl Eq for HeaderValue {}","impl From<$t> for HeaderValue {\n            fn from(num: $t) -> HeaderValue {\n                let mut buf = if mem::size_of::<BytesMut>() - 1 < $max_len {\n                    // On 32bit platforms, BytesMut max inline size\n                    // is 15 bytes, but the $max_len could be bigger.\n                    //\n                    // The likelihood of the number *actually* being\n                    // that big is very small, so only allocate\n                    // if the number needs that space.\n                    //\n                    // The largest decimal number in 15 digits:\n                    // It wold be 10.pow(15) - 1, but this is a constant\n                    // version.\n                    if num as u64 > 999_999_999_999_999_999 {\n                        BytesMut::with_capacity($max_len)\n                    } else {\n                        // fits inline...\n                        BytesMut::new()\n                    }\n                } else {\n                    // full value fits inline, so don't allocate!\n                    BytesMut::new()\n                };\n                let _ = ::itoa::fmt(&mut buf, num);\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }\n        }","impl From<HeaderName> for HeaderValue {\n    #[inline]\n    fn from(h: HeaderName) -> HeaderValue {\n        HeaderValue {\n            inner: h.into(),\n            is_sensitive: false,\n        }\n    }\n}","impl FromStr for HeaderValue {\n    type Err = InvalidHeaderValue;\n\n    #[inline]\n    fn from_str(s: &str) -> Result<HeaderValue, Self::Err> {\n        HeaderValue::from_str(s)\n    }\n}","impl HeaderValue {\n    /// Convert a static string to a `HeaderValue`.\n    ///\n    /// This function will not perform any copying, however the string is\n    /// checked to ensure that no invalid characters are present. Only visible\n    /// ASCII characters (32-127) are permitted.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the argument contains invalid header value\n    /// characters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static(\"hello\");\n    /// assert_eq!(val, \"hello\");\n    /// ```\n    #[inline]\n    pub fn from_static(src: &'static str) -> HeaderValue {\n        let bytes = src.as_bytes();\n        for &b in bytes {\n            if !is_visible_ascii(b) {\n                panic!(\"invalid header value\");\n            }\n        }\n\n        HeaderValue {\n            inner: Bytes::from_static(bytes),\n            is_sensitive: false,\n        }\n    }\n\n    /// Attempt to convert a string to a `HeaderValue`.\n    ///\n    /// If the argument contains invalid header value characters, an error is\n    /// returned. Only visible ASCII characters (32-127) are permitted. Use\n    /// `from_bytes` to create a `HeaderValue` that includes opaque octets\n    /// (128-255).\n    ///\n    /// This function is intended to be replaced in the future by a `TryFrom`\n    /// implementation once the trait is stabilized in std.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_str(\"hello\").unwrap();\n    /// assert_eq!(val, \"hello\");\n    /// ```\n    ///\n    /// An invalid value\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_str(\"\\n\");\n    /// assert!(val.is_err());\n    /// ```\n    #[inline]\n    pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n        HeaderValue::try_from(src)\n    }\n\n    /// Converts a HeaderName into a HeaderValue\n    ///\n    /// Since every valid HeaderName is a valid HeaderValue this is done infallibly.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderValue, HeaderName};\n    /// # use http::header::ACCEPT;\n    /// let val = HeaderValue::from_name(ACCEPT);\n    /// assert_eq!(val, HeaderValue::from_bytes(b\"accept\").unwrap());\n    /// ```\n    #[inline]\n    pub fn from_name(name: HeaderName) -> HeaderValue {\n        name.into()\n    }\n\n    /// Attempt to convert a byte slice to a `HeaderValue`.\n    ///\n    /// If the argument contains invalid header value bytes, an error is\n    /// returned. Only byte values between 32 and 255 (inclusive) are permitted,\n    /// excluding byte 127 (DEL).\n    ///\n    /// This function is intended to be replaced in the future by a `TryFrom`\n    /// implementation once the trait is stabilized in std.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_bytes(b\"hello\\xfa\").unwrap();\n    /// assert_eq!(val, &b\"hello\\xfa\"[..]);\n    /// ```\n    ///\n    /// An invalid value\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_bytes(b\"\\n\");\n    /// assert!(val.is_err());\n    /// ```\n    #[inline]\n    pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n        HeaderValue::try_from(src)\n    }\n\n    /// Attempt to convert a `Bytes` buffer to a `HeaderValue`.\n    ///\n    /// If the argument contains invalid header value bytes, an error is\n    /// returned. Only byte values between 32 and 255 (inclusive) are permitted,\n    /// excluding byte 127 (DEL).\n    ///\n    /// This function is intended to be replaced in the future by a `TryFrom`\n    /// implementation once the trait is stabilized in std.\n    #[inline]\n    pub fn from_shared(src: Bytes) -> Result<HeaderValue, InvalidHeaderValueBytes> {\n        HeaderValue::try_from(src).map_err(InvalidHeaderValueBytes)\n    }\n\n    /// Convert a `Bytes` directly into a `HeaderValue` without validating.\n    ///\n    /// This function does NOT validate that illegal bytes are not contained\n    /// within the buffer.\n    #[inline]\n    pub unsafe fn from_shared_unchecked(src: Bytes) -> HeaderValue {\n        if cfg!(debug_assertions) {\n            match HeaderValue::from_shared(src) {\n                Ok(val) => val,\n                Err(_err) => {\n                    //TODO: if the Bytes were part of the InvalidHeaderValueBytes,\n                    //this message could include the invalid bytes.\n                    panic!(\"HeaderValue::from_shared_unchecked() with invalid bytes\");\n                },\n            }\n        } else {\n            HeaderValue {\n                inner: src,\n                is_sensitive: false,\n            }\n        }\n    }\n\n    fn try_from<T: AsRef<[u8]> + Into<Bytes>>(src: T) -> Result<HeaderValue, InvalidHeaderValue> {\n        for &b in src.as_ref() {\n            if !is_valid(b) {\n                return Err(InvalidHeaderValue {\n                    _priv: (),\n                });\n            }\n        }\n        Ok(HeaderValue {\n            inner: src.into(),\n            is_sensitive: false,\n        })\n    }\n\n    /// Yields a `&str` slice if the `HeaderValue` only contains visible ASCII\n    /// chars.\n    ///\n    /// This function will perform a scan of the header value, checking all the\n    /// characters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static(\"hello\");\n    /// assert_eq!(val.to_str().unwrap(), \"hello\");\n    /// ```\n    pub fn to_str(&self) -> Result<&str, ToStrError> {\n        let bytes = self.as_ref();\n\n        for &b in bytes {\n            if !is_visible_ascii(b) {\n                return Err(ToStrError { _priv: () });\n            }\n        }\n\n        unsafe { Ok(str::from_utf8_unchecked(bytes)) }\n    }\n\n    /// Returns the length of `self`.\n    ///\n    /// This length is in bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static(\"hello\");\n    /// assert_eq!(val.len(), 5);\n    /// ```\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.as_ref().len()\n    }\n\n    /// Returns true if the `HeaderValue` has a length of zero bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static(\"\");\n    /// assert!(val.is_empty());\n    ///\n    /// let val = HeaderValue::from_static(\"hello\");\n    /// assert!(!val.is_empty());\n    /// ```\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Converts a `HeaderValue` to a byte slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static(\"hello\");\n    /// assert_eq!(val.as_bytes(), b\"hello\");\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &[u8] {\n        self.as_ref()\n    }\n\n    /// Mark that the header value represents sensitive information.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let mut val = HeaderValue::from_static(\"my secret\");\n    ///\n    /// val.set_sensitive(true);\n    /// assert!(val.is_sensitive());\n    ///\n    /// val.set_sensitive(false);\n    /// assert!(!val.is_sensitive());\n    /// ```\n    #[inline]\n    pub fn set_sensitive(&mut self, val: bool) {\n        self.is_sensitive = val;\n    }\n\n    /// Returns `true` if the value represents sensitive data.\n    ///\n    /// Sensitive data could represent passwords or other data that should not\n    /// be stored on disk or in memory. This setting can be used by components\n    /// like caches to avoid storing the value. HPACK encoders must set the\n    /// header field to never index when `is_sensitive` returns true.\n    ///\n    /// Note that sensitivity is not factored into equality or ordering.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let mut val = HeaderValue::from_static(\"my secret\");\n    ///\n    /// val.set_sensitive(true);\n    /// assert!(val.is_sensitive());\n    ///\n    /// val.set_sensitive(false);\n    /// assert!(!val.is_sensitive());\n    /// ```\n    #[inline]\n    pub fn is_sensitive(&self) -> bool {\n        self.is_sensitive\n    }\n}","impl HttpTryFrom<$t> for $t {\n            type Error = Error;\n\n            fn try_from(t: Self) -> Result<Self, Self::Error> {\n                Ok(t)\n            }\n        }","impl HttpTryFrom<$t> for HeaderValue {\n            type Error = Never;\n\n            #[inline]\n            fn try_from(num: $t) -> Result<Self, Self::Error> {\n                Ok(num.into())\n            }\n        }","impl HttpTryFrom<Bytes> for HeaderValue {\n    type Error = InvalidHeaderValueBytes;\n\n    #[inline]\n    fn try_from(bytes: Bytes) -> Result<Self, Self::Error> {\n        HeaderValue::from_shared(bytes)\n    }\n}","impl HttpTryFrom<HeaderName> for HeaderValue {\n    type Error = InvalidHeaderValue;\n\n    #[inline]\n    fn try_from(name: HeaderName) -> Result<Self, Self::Error> {\n        // Infallable as header names have the same validations\n        Ok(name.into())\n    }\n}","impl HttpTryFrom<String> for HeaderValue {\n    type Error = InvalidHeaderValueBytes;\n\n    #[inline]\n    fn try_from(t: String) -> Result<Self, Self::Error> {\n        HeaderValue::from_shared(t.into())\n    }\n}","impl Ord for HeaderValue {\n    #[inline]\n    fn cmp(&self, other: &Self) -> cmp::Ordering {\n        self.inner.cmp(&other.inner)\n    }\n}","impl PartialEq for HeaderValue {\n    #[inline]\n    fn eq(&self, other: &HeaderValue) -> bool {\n        self.inner == other.inner\n    }\n}","impl PartialEq<String> for HeaderValue {\n    #[inline]\n    fn eq(&self, other: &String) -> bool {\n        *self == &other[..]\n    }\n}","impl PartialEq<[u8]> for HeaderValue {\n    #[inline]\n    fn eq(&self, other: &[u8]) -> bool {\n        self.inner == other\n    }\n}","impl PartialEq<str> for HeaderValue {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        self.inner == other.as_bytes()\n    }\n}","impl PartialOrd for HeaderValue {\n    #[inline]\n    fn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering> {\n        self.inner.partial_cmp(&other.inner)\n    }\n}","impl PartialOrd<String> for HeaderValue {\n    #[inline]\n    fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering> {\n        self.inner.partial_cmp(other.as_bytes())\n    }\n}","impl PartialOrd<[u8]> for HeaderValue {\n    #[inline]\n    fn partial_cmp(&self, other: &[u8]) -> Option<cmp::Ordering> {\n        (*self.inner).partial_cmp(other)\n    }\n}","impl PartialOrd<str> for HeaderValue {\n    #[inline]\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n        (*self.inner).partial_cmp(other.as_bytes())\n    }\n}","impl Sealed for $t {}","impl fmt::Debug for HeaderValue {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.is_sensitive {\n            f.write_str(\"Sensitive\")\n        } else {\n            f.write_str(\"\\\"\")?;\n            let mut from = 0;\n            let bytes = self.as_bytes();\n            for (i, &b) in bytes.iter().enumerate() {\n                if !is_visible_ascii(b) || b == b'\"' {\n                    if from != i {\n                        f.write_str(unsafe {\n                            str::from_utf8_unchecked(&bytes[from..i])\n                        })?;\n                    }\n                    if b == b'\"' {\n                        f.write_str(\"\\\\\\\"\")?;\n                    } else {\n                        write!(f, \"\\\\x{:x}\", b)?;\n                    }\n                    from = i + 1;\n                }\n            }\n\n            f.write_str(unsafe {\n                str::from_utf8_unchecked(&bytes[from..])\n            })?;\n            f.write_str(\"\\\"\")\n        }\n    }\n}","impl<'a, T: ?Sized> PartialEq<&'a T> for HeaderValue\n    where HeaderValue: PartialEq<T>\n{\n    #[inline]\n    fn eq(&self, other: &&'a T) -> bool {\n        *self == **other\n    }\n}","impl<'a, T: ?Sized> PartialOrd<&'a T> for HeaderValue\n    where HeaderValue: PartialOrd<T>\n{\n    #[inline]\n    fn partial_cmp(&self, other: &&'a T) -> Option<cmp::Ordering> {\n        self.partial_cmp(*other)\n    }\n}","impl<'a> From<&'a HeaderValue> for HeaderValue {\n    #[inline]\n    fn from(t: &'a HeaderValue) -> Self {\n        t.clone()\n    }\n}","impl<'a> HttpTryFrom<&'a HeaderValue> for HeaderValue {\n    type Error = ::error::Never;\n\n    #[inline]\n    fn try_from(t: &'a HeaderValue) -> Result<Self, Self::Error> {\n        Ok(t.clone())\n    }\n}","impl<'a> HttpTryFrom<&'a String> for HeaderValue {\n    type Error = InvalidHeaderValue;\n    #[inline]\n    fn try_from(s: &'a String) -> Result<Self, Self::Error> {\n        Self::from_bytes(s.as_bytes())\n    }\n}","impl<'a> HttpTryFrom<&'a [u8]> for HeaderValue {\n    type Error = InvalidHeaderValue;\n\n    #[inline]\n    fn try_from(t: &'a [u8]) -> Result<Self, Self::Error> {\n        HeaderValue::from_bytes(t)\n    }\n}","impl<'a> HttpTryFrom<&'a str> for HeaderValue {\n    type Error = InvalidHeaderValue;\n\n    #[inline]\n    fn try_from(t: &'a str) -> Result<Self, Self::Error> {\n        t.parse()\n    }\n}"],"header::value::InvalidHeaderValue":["impl Error for InvalidHeaderValue {\n    fn description(&self) -> &str {\n        \"failed to parse header value\"\n    }\n}","impl fmt::Debug for InvalidHeaderValue {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"InvalidHeaderValue\")\n            // skip _priv noise\n            .finish()\n    }\n}","impl fmt::Display for InvalidHeaderValue {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.description().fmt(f)\n    }\n}"],"header::value::InvalidHeaderValueBytes":["Debug","impl Error for InvalidHeaderValueBytes {\n    fn description(&self) -> &str {\n        self.0.description()\n    }\n}","impl fmt::Display for InvalidHeaderValueBytes {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}"],"header::value::ToStrError":["Debug","impl Error for ToStrError {\n    fn description(&self) -> &str {\n        \"failed to convert header to a str\"\n    }\n}","impl fmt::Display for ToStrError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.description().fmt(f)\n    }\n}"],"method::Inner":["Clone","Eq","Hash","PartialEq"],"method::InvalidMethod":["impl Error for InvalidMethod {\n    fn description(&self) -> &str {\n        \"invalid HTTP method\"\n    }\n}","impl InvalidMethod {\n    fn new() -> InvalidMethod {\n        InvalidMethod {\n            _priv: (),\n        }\n    }\n}","impl fmt::Debug for InvalidMethod {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"InvalidMethod\")\n            // skip _priv noise\n            .finish()\n    }\n}","impl fmt::Display for InvalidMethod {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.description())\n    }\n}"],"method::Method":["Clone","Eq","Hash","PartialEq","impl AsRef<str> for Method {\n    #[inline]\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}","impl Default for Method {\n    #[inline]\n    fn default() -> Method {\n        Method::GET\n    }\n}","impl FromStr for Method {\n    type Err = InvalidMethod;\n\n    #[inline]\n    fn from_str(t: &str) -> Result<Self, Self::Err> {\n        HttpTryFrom::try_from(t)\n    }\n}","impl HttpTryFrom<$t> for $t {\n            type Error = Error;\n\n            fn try_from(t: Self) -> Result<Self, Self::Error> {\n                Ok(t)\n            }\n        }","impl Method {\n    /// GET\n    pub const GET: Method = Method(Get);\n\n    /// POST\n    pub const POST: Method = Method(Post);\n\n    /// PUT\n    pub const PUT: Method = Method(Put);\n\n    /// DELETE\n    pub const DELETE: Method = Method(Delete);\n\n    /// HEAD\n    pub const HEAD: Method = Method(Head);\n\n    /// OPTIONS\n    pub const OPTIONS: Method = Method(Options);\n\n    /// CONNECT\n    pub const CONNECT: Method = Method(Connect);\n\n    /// PATCH\n    pub const PATCH: Method = Method(Patch);\n\n    /// TRACE\n    pub const TRACE: Method = Method(Trace);\n\n    /// Converts a slice of bytes to an HTTP method.\n    pub fn from_bytes(src: &[u8]) -> Result<Method, InvalidMethod> {\n        match src.len() {\n            0 => {\n                Err(InvalidMethod::new())\n            }\n            3 => {\n                match src {\n                    b\"GET\" => Ok(Method(Get)),\n                    b\"PUT\" => Ok(Method(Put)),\n                    _ => Method::extension_inline(src),\n                }\n            }\n            4 => {\n                match src {\n                    b\"POST\" => Ok(Method(Post)),\n                    b\"HEAD\" => Ok(Method(Head)),\n                    _ => Method::extension_inline(src),\n                }\n            }\n            5 => {\n                match src {\n                    b\"PATCH\" => Ok(Method(Patch)),\n                    b\"TRACE\" => Ok(Method(Trace)),\n                    _ => Method::extension_inline(src),\n                }\n            }\n            6 => {\n                match src {\n                    b\"DELETE\" => Ok(Method(Delete)),\n                    _ => Method::extension_inline(src),\n                }\n            }\n            7 => {\n                match src {\n                    b\"OPTIONS\" => Ok(Method(Options)),\n                    b\"CONNECT\" => Ok(Method(Connect)),\n                    _ => Method::extension_inline(src),\n                }\n            }\n            _ => {\n                if src.len() < MAX_INLINE {\n                    Method::extension_inline(src)\n                } else {\n                    let mut data: Vec<u8> = vec![0; src.len()];\n\n                    write_checked(src, &mut data)?;\n\n                    Ok(Method(ExtensionAllocated(data.into_boxed_slice())))\n                }\n            }\n        }\n    }\n\n    fn extension_inline(src: &[u8]) -> Result<Method, InvalidMethod> {\n        let mut data: [u8; MAX_INLINE] = Default::default();\n\n        write_checked(src, &mut data)?;\n\n        Ok(Method(ExtensionInline(data, src.len() as u8)))\n    }\n\n    /// Whether a method is considered \"safe\", meaning the request is\n    /// essentially read-only.\n    ///\n    /// See [the spec](https://tools.ietf.org/html/rfc7231#section-4.2.1)\n    /// for more words.\n    pub fn is_safe(&self) -> bool {\n        match self.0 {\n            Get | Head | Options | Trace => true,\n            _ => false\n        }\n    }\n\n    /// Whether a method is considered \"idempotent\", meaning the request has\n    /// the same result if executed multiple times.\n    ///\n    /// See [the spec](https://tools.ietf.org/html/rfc7231#section-4.2.2) for\n    /// more words.\n    pub fn is_idempotent(&self) -> bool {\n        if self.is_safe() {\n            true\n        } else {\n            match self.0 {\n                Put | Delete => true,\n                _ => false\n            }\n        }\n    }\n\n    /// Return a &str representation of the HTTP method\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        match self.0 {\n            Options => \"OPTIONS\",\n            Get => \"GET\",\n            Post => \"POST\",\n            Put => \"PUT\",\n            Delete => \"DELETE\",\n            Head => \"HEAD\",\n            Trace => \"TRACE\",\n            Connect => \"CONNECT\",\n            Patch => \"PATCH\",\n            ExtensionInline(ref data, len) => {\n                unsafe {\n                    str::from_utf8_unchecked(&data[..len as usize])\n                }\n            }\n            ExtensionAllocated(ref data) => {\n                unsafe {\n                    str::from_utf8_unchecked(data)\n                }\n            }\n        }\n    }\n}","impl PartialEq<str> for Method {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        self.as_ref() == other\n    }\n}","impl Sealed for $t {}","impl fmt::Debug for Method {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_str(self.as_ref())\n    }\n}","impl fmt::Display for Method {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.write_str(self.as_ref())\n    }\n}","impl<'a> From<&'a Method> for Method {\n    #[inline]\n    fn from(t: &'a Method) -> Self {\n        t.clone()\n    }\n}","impl<'a> HttpTryFrom<&'a Method> for Method {\n    type Error = ::error::Never;\n\n    #[inline]\n    fn try_from(t: &'a Method) -> Result<Self, Self::Error> {\n        Ok(t.clone())\n    }\n}","impl<'a> HttpTryFrom<&'a [u8]> for Method {\n    type Error = InvalidMethod;\n\n    #[inline]\n    fn try_from(t: &'a [u8]) -> Result<Self, Self::Error> {\n        Method::from_bytes(t)\n    }\n}","impl<'a> HttpTryFrom<&'a str> for Method {\n    type Error = InvalidMethod;\n\n    #[inline]\n    fn try_from(t: &'a str) -> Result<Self, Self::Error> {\n        HttpTryFrom::try_from(t.as_bytes())\n    }\n}","impl<'a> PartialEq<&'a Method> for Method {\n    #[inline]\n    fn eq(&self, other: & &'a Method) -> bool {\n        self == *other\n    }\n}","impl<'a> PartialEq<&'a str> for Method {\n    #[inline]\n    fn eq(&self, other: &&'a str) -> bool {\n        self.as_ref() == *other\n    }\n}"],"request::Builder":["Debug","impl Builder {\n    /// Creates a new default instance of `Builder` to construct a `Request`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = request::Builder::new()\n    ///     .method(\"POST\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn new() -> Builder {\n        Builder::default()\n    }\n\n    /// Set the HTTP method for this request.\n    ///\n    /// This function will configure the HTTP method of the `Request` that will\n    /// be returned from `Builder::build`.\n    ///\n    /// By default this is `GET`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = Request::builder()\n    ///     .method(\"POST\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn method<T>(&mut self, method: T) -> &mut Builder\n        where Method: HttpTryFrom<T>,\n    {\n        if let Some(head) = head(&mut self.head, &self.err) {\n            match HttpTryFrom::try_from(method) {\n                Ok(s) => head.method = s,\n                Err(e) => self.err = Some(e.into()),\n            }\n        }\n        self\n    }\n\n    /// Get the HTTP Method for this request.\n    /// \n    /// By default this is `GET`.\n    /// if builder has error, returns None.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// # use http::*;\n    /// \n    /// let mut req = Request::builder();\n    /// assert_eq!(req.method_ref(),Some(&Method::GET));\n    /// req.method(\"POST\");\n    /// assert_eq!(req.method_ref(),Some(&Method::POST));\n    /// req.method(\"DELETE\");\n    /// assert_eq!(req.method_ref(),Some(&Method::DELETE));\n    /// ```\n    pub fn method_ref(&self) -> Option<&Method>\n    {\n        if self.err.is_some() {\n            return None\n        }\n        match self.head {\n            Some(ref head) => Some(&head.method),\n            None => None\n        }\n    }\n\n    /// Set the URI for this request.\n    ///\n    /// This function will configure the URI of the `Request` that will\n    /// be returned from `Builder::build`.\n    ///\n    /// By default this is `/`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = Request::builder()\n    ///     .uri(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn uri<T>(&mut self, uri: T) -> &mut Builder\n        where Uri: HttpTryFrom<T>,\n    {\n        if let Some(head) = head(&mut self.head, &self.err) {\n            match HttpTryFrom::try_from(uri) {\n                Ok(s) => head.uri = s,\n                Err(e) => self.err = Some(e.into()),\n            }\n        }\n        self\n    }\n\n    /// Get the URI for this request\n    /// \n    /// By default this is `/`\n    /// # Examples\n    /// \n    /// ```\n    /// # use http::*;\n    /// \n    /// let mut req = Request::builder();\n    /// assert_eq!(req.uri_ref().unwrap().to_string(), \"/\" );\n    /// req.uri(\"https://www.rust-lang.org/\");\n    /// assert_eq!(req.uri_ref().unwrap().to_string(), \"https://www.rust-lang.org/\" );\n    /// ```\n    pub fn uri_ref(&self) -> Option<&Uri>\n    {\n        if self.err.is_some() {\n            return None;\n        }\n        match self.head\n        {\n            Some(ref head) => Some(&head.uri),\n            None => None\n        }\n    }\n\n    /// Set the HTTP version for this request.\n    ///\n    /// This function will configure the HTTP version of the `Request` that\n    /// will be returned from `Builder::build`.\n    ///\n    /// By default this is HTTP/1.1\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = Request::builder()\n    ///     .version(Version::HTTP_2)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn version(&mut self, version: Version) -> &mut Builder {\n        if let Some(head) = head(&mut self.head, &self.err) {\n            head.version = version;\n        }\n        self\n    }\n\n    /// Appends a header to this request builder.\n    ///\n    /// This function will append the provided key/value as a header to the\n    /// internal `HeaderMap` being constructed. Essentially this is equivalent\n    /// to calling `HeaderMap::append`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::HeaderValue;\n    ///\n    /// let req = Request::builder()\n    ///     .header(\"Accept\", \"text/html\")\n    ///     .header(\"X-Custom-Foo\", \"bar\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn header<K, V>(&mut self, key: K, value: V) -> &mut Builder\n        where HeaderName: HttpTryFrom<K>,\n              HeaderValue: HttpTryFrom<V>\n    {\n        if let Some(head) = head(&mut self.head, &self.err) {\n            match <HeaderName as HttpTryFrom<K>>::try_from(key) {\n                Ok(key) => {\n                    match <HeaderValue as HttpTryFrom<V>>::try_from(value) {\n                        Ok(value) => { head.headers.append(key, value); }\n                        Err(e) => self.err = Some(e.into()),\n                    }\n                },\n                Err(e) => self.err = Some(e.into()),\n            };\n        }\n        self\n    }\n\n    /// Get header on this request builder.\n    /// when builder has error returns None\n    /// \n    /// # Example\n    /// \n    /// ```\n    /// # use http::*;\n    /// # use http::header::HeaderValue;\n    /// # use http::request::Builder;\n    /// let mut req = Request::builder();\n    /// req.header(\"Accept\", \"text/html\")\n    ///    .header(\"X-Custom-Foo\", \"bar\");\n    /// let headers = req.headers_ref().unwrap();\n    /// assert_eq!( headers[\"Accept\"], \"text/html\" );\n    /// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n    /// ```\n    pub fn headers_ref(&self) -> Option<&HeaderMap<HeaderValue>> {\n        if self.err.is_some() {\n            return None;\n        }\n        match self.head\n        {\n            Some(ref head) => Some(&head.headers),\n            None => None\n        }\n    }\n\n    /// Get header on this request builder.\n    /// when builder has error returns None\n    /// \n    /// # Example\n    /// \n    /// ```\n    /// # use http::*;\n    /// # use http::header::HeaderValue;\n    /// # use http::request::Builder;\n    /// let mut req = Request::builder();\n    /// {\n    ///   let headers = req.headers_mut().unwrap();\n    ///   headers.insert(\"Accept\", HeaderValue::from_static(\"text/html\"));\n    ///   headers.insert(\"X-Custom-Foo\", HeaderValue::from_static(\"bar\"));\n    /// }\n    /// let headers = req.headers_ref().unwrap();\n    /// assert_eq!( headers[\"Accept\"], \"text/html\" );\n    /// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n    /// ```\n    pub fn headers_mut(&mut self) -> Option<&mut HeaderMap<HeaderValue>> {\n        if self.err.is_some() {\n            return None;\n        }\n        match self.head\n        {\n            Some(ref mut head) => Some(&mut head.headers),\n            None => None\n        }\n    }\n\n    /// Adds an extension to this builder\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = Request::builder()\n    ///     .extension(\"My Extension\")\n    ///     .body(())\n    ///     .unwrap();\n    ///\n    /// assert_eq!(req.extensions().get::<&'static str>(),\n    ///            Some(&\"My Extension\"));\n    /// ```\n    pub fn extension<T>(&mut self, extension: T) -> &mut Builder\n        where T: Any + Send + Sync + 'static,\n    {\n        if let Some(head) = head(&mut self.head, &self.err) {\n            head.extensions.insert(extension);\n        }\n        self\n    }\n\n    fn take_parts(&mut self) -> Result<Parts> {\n        let ret = self.head.take().expect(\"cannot reuse request builder\");\n        if let Some(e) = self.err.take() {\n            return Err(e)\n        }\n        Ok(ret)\n    }\n\n    /// \"Consumes\" this builder, using the provided `body` to return a\n    /// constructed `Request`.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if any previously configured argument\n    /// failed to parse or get converted to the internal representation. For\n    /// example if an invalid `head` was specified via `header(\"Foo\",\n    /// \"Bar\\r\\n\")` the error will be returned when this function is called\n    /// rather than when `header` was called.\n    ///\n    /// # Panics\n    ///\n    /// This method will panic if the builder is reused. The `body` function can\n    /// only be called once.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::builder()\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn body<T>(&mut self, body: T) -> Result<Request<T>> {\n        Ok(Request {\n            head: self.take_parts()?,\n            body: body,\n        })\n    }\n}","impl Default for Builder {\n    #[inline]\n    fn default() -> Builder {\n        Builder {\n            head: Some(Parts::new()),\n            err: None,\n        }\n    }\n}"],"request::Parts":["impl Parts {\n    /// Creates a new default instance of `Parts`\n    fn new() -> Parts {\n        Parts{\n            method: Method::default(),\n            uri: Uri::default(),\n            version: Version::default(),\n            headers: HeaderMap::default(),\n            extensions: Extensions::default(),\n            _priv: (),\n        }\n    }\n}","impl fmt::Debug for Parts {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Parts\")\n            .field(\"method\", &self.method)\n            .field(\"uri\", &self.uri)\n            .field(\"version\", &self.version)\n            .field(\"headers\", &self.headers)\n            // omits Extensions because not useful\n            // omits _priv because not useful\n            .finish()\n    }\n}"],"request::Request":["impl Request<()> {\n    /// Creates a new builder-style object to manufacture a `Request`\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::builder()\n    ///     .method(\"GET\")\n    ///     .uri(\"https://www.rust-lang.org/\")\n    ///     .header(\"X-Custom-Foo\", \"Bar\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn builder() -> Builder {\n        Builder::new()\n    }\n\n\n    /// Creates a new `Builder` initialized with a GET method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::get(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn get<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T> {\n        let mut b = Builder::new();\n        b.method(Method::GET).uri(uri);\n        b\n    }\n\n    /// Creates a new `Builder` initialized with a PUT method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::put(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn put<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T> {\n        let mut b = Builder::new();\n        b.method(Method::PUT).uri(uri);\n        b\n    }\n\n    /// Creates a new `Builder` initialized with a POST method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::post(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn post<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T> {\n        let mut b = Builder::new();\n        b.method(Method::POST).uri(uri);\n        b\n    }\n\n    /// Creates a new `Builder` initialized with a DELETE method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::delete(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn delete<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T> {\n        let mut b = Builder::new();\n        b.method(Method::DELETE).uri(uri);\n        b\n    }\n\n    /// Creates a new `Builder` initialized with an OPTIONS method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::options(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// # assert_eq!(*request.method(), Method::OPTIONS);\n    /// ```\n    pub fn options<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T> {\n        let mut b = Builder::new();\n        b.method(Method::OPTIONS).uri(uri);\n        b\n    }\n\n    /// Creates a new `Builder` initialized with a HEAD method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::head(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn head<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T> {\n        let mut b = Builder::new();\n        b.method(Method::HEAD).uri(uri);\n        b\n    }\n\n    /// Creates a new `Builder` initialized with a CONNECT method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::connect(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn connect<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T> {\n        let mut b = Builder::new();\n        b.method(Method::CONNECT).uri(uri);\n        b\n    }\n\n    /// Creates a new `Builder` initialized with a PATCH method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::patch(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn patch<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T> {\n        let mut b = Builder::new();\n        b.method(Method::PATCH).uri(uri);\n        b\n    }\n\n    /// Creates a new `Builder` initialized with a TRACE method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::trace(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn trace<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T> {\n        let mut b = Builder::new();\n        b.method(Method::TRACE).uri(uri);\n        b\n    }\n}","impl<T: Default> Default for Request<T> {\n    fn default() -> Request<T> {\n        Request::new(T::default())\n    }\n}","impl<T: fmt::Debug> fmt::Debug for Request<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Request\")\n            .field(\"method\", self.method())\n            .field(\"uri\", self.uri())\n            .field(\"version\", &self.version())\n            .field(\"headers\", self.headers())\n            // omits Extensions because not useful\n            .field(\"body\", self.body())\n            .finish()\n    }\n}","impl<T> Request<T> {\n    /// Creates a new blank `Request` with the body\n    ///\n    /// The component parts of this request will be set to their default, e.g.\n    /// the GET method, no headers, etc.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::new(\"hello world\");\n    ///\n    /// assert_eq!(*request.method(), Method::GET);\n    /// assert_eq!(*request.body(), \"hello world\");\n    /// ```\n    #[inline]\n    pub fn new(body: T) -> Request<T> {\n        Request {\n            head: Parts::new(),\n            body: body,\n        }\n    }\n\n    /// Creates a new `Request` with the given components parts and body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::new(\"hello world\");\n    /// let (mut parts, body) = request.into_parts();\n    /// parts.method = Method::POST;\n    ///\n    /// let request = Request::from_parts(parts, body);\n    /// ```\n    #[inline]\n    pub fn from_parts(parts: Parts, body: T) -> Request<T> {\n        Request {\n            head: parts,\n            body: body,\n        }\n    }\n\n    /// Returns a reference to the associated HTTP method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert_eq!(*request.method(), Method::GET);\n    /// ```\n    #[inline]\n    pub fn method(&self) -> &Method {\n        &self.head.method\n    }\n\n    /// Returns a mutable reference to the associated HTTP method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut request: Request<()> = Request::default();\n    /// *request.method_mut() = Method::PUT;\n    /// assert_eq!(*request.method(), Method::PUT);\n    /// ```\n    #[inline]\n    pub fn method_mut(&mut self) -> &mut Method {\n        &mut self.head.method\n    }\n\n    /// Returns a reference to the associated URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert_eq!(*request.uri(), *\"/\");\n    /// ```\n    #[inline]\n    pub fn uri(&self) -> &Uri {\n        &self.head.uri\n    }\n\n    /// Returns a mutable reference to the associated URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut request: Request<()> = Request::default();\n    /// *request.uri_mut() = \"/hello\".parse().unwrap();\n    /// assert_eq!(*request.uri(), *\"/hello\");\n    /// ```\n    #[inline]\n    pub fn uri_mut(&mut self) -> &mut Uri {\n        &mut self.head.uri\n    }\n\n    /// Returns the associated version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert_eq!(request.version(), Version::HTTP_11);\n    /// ```\n    #[inline]\n    pub fn version(&self) -> Version {\n        self.head.version\n    }\n\n    /// Returns a mutable reference to the associated version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut request: Request<()> = Request::default();\n    /// *request.version_mut() = Version::HTTP_2;\n    /// assert_eq!(request.version(), Version::HTTP_2);\n    /// ```\n    #[inline]\n    pub fn version_mut(&mut self) -> &mut Version {\n        &mut self.head.version\n    }\n\n    /// Returns a reference to the associated header field map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert!(request.headers().is_empty());\n    /// ```\n    #[inline]\n    pub fn headers(&self) -> &HeaderMap<HeaderValue> {\n        &self.head.headers\n    }\n\n    /// Returns a mutable reference to the associated header field map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::*;\n    /// let mut request: Request<()> = Request::default();\n    /// request.headers_mut().insert(HOST, HeaderValue::from_static(\"world\"));\n    /// assert!(!request.headers().is_empty());\n    /// ```\n    #[inline]\n    pub fn headers_mut(&mut self) -> &mut HeaderMap<HeaderValue> {\n        &mut self.head.headers\n    }\n\n    /// Returns a reference to the associated extensions.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert!(request.extensions().get::<i32>().is_none());\n    /// ```\n    #[inline]\n    pub fn extensions(&self) -> &Extensions {\n        &self.head.extensions\n    }\n\n    /// Returns a mutable reference to the associated extensions.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::*;\n    /// let mut request: Request<()> = Request::default();\n    /// request.extensions_mut().insert(\"hello\");\n    /// assert_eq!(request.extensions().get(), Some(&\"hello\"));\n    /// ```\n    #[inline]\n    pub fn extensions_mut(&mut self) -> &mut Extensions {\n        &mut self.head.extensions\n    }\n\n    /// Returns a reference to the associated HTTP body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<String> = Request::default();\n    /// assert!(request.body().is_empty());\n    /// ```\n    #[inline]\n    pub fn body(&self) -> &T {\n        &self.body\n    }\n\n    /// Returns a mutable reference to the associated HTTP body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut request: Request<String> = Request::default();\n    /// request.body_mut().push_str(\"hello world\");\n    /// assert!(!request.body().is_empty());\n    /// ```\n    #[inline]\n    pub fn body_mut(&mut self) -> &mut T {\n        &mut self.body\n    }\n\n\n    /// Consumes the request, returning just the body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::Request;\n    /// let request = Request::new(10);\n    /// let body = request.into_body();\n    /// assert_eq!(body, 10);\n    /// ```\n    #[inline]\n    pub fn into_body(self) -> T {\n        self.body\n    }\n\n    /// Consumes the request returning the head and body parts.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::new(());\n    /// let (parts, body) = request.into_parts();\n    /// assert_eq!(parts.method, Method::GET);\n    /// ```\n    #[inline]\n    pub fn into_parts(self) -> (Parts, T) {\n        (self.head, self.body)\n    }\n\n    /// Consumes the request returning a new request with body mapped to the\n    /// return type of the passed in function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::builder().body(\"some string\").unwrap();\n    /// let mapped_request: Request<&[u8]> = request.map(|b| {\n    ///   assert_eq!(b, \"some string\");\n    ///   b.as_bytes()\n    /// });\n    /// assert_eq!(mapped_request.body(), &\"some string\".as_bytes());\n    /// ```\n    #[inline]\n    pub fn map<F, U>(self, f: F) -> Request<U>\n        where F: FnOnce(T) -> U\n    {\n        Request { body: f(self.body), head: self.head }\n    }\n}"],"response::Builder":["Debug","impl Builder {\n    /// Creates a new default instance of `Builder` to construct either a\n    /// `Head` or a `Response`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = response::Builder::new()\n    ///     .status(200)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn new() -> Builder {\n        Builder::default()\n    }\n\n    /// Set the HTTP status for this response.\n    ///\n    /// This function will configure the HTTP status code of the `Response` that\n    /// will be returned from `Builder::build`.\n    ///\n    /// By default this is `200`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = Response::builder()\n    ///     .status(200)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn status<T>(&mut self, status: T) -> &mut Builder\n        where StatusCode: HttpTryFrom<T>,\n    {\n        if let Some(head) = head(&mut self.head, &self.err) {\n            match HttpTryFrom::try_from(status) {\n                Ok(s) => head.status = s,\n                Err(e) => self.err = Some(e.into()),\n            }\n        }\n        self\n    }\n\n    /// Set the HTTP version for this response.\n    ///\n    /// This function will configure the HTTP version of the `Response` that\n    /// will be returned from `Builder::build`.\n    ///\n    /// By default this is HTTP/1.1\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = Response::builder()\n    ///     .version(Version::HTTP_2)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn version(&mut self, version: Version) -> &mut Builder {\n        if let Some(head) = head(&mut self.head, &self.err) {\n            head.version = version;\n        }\n        self\n    }\n\n    /// Appends a header to this response builder.\n    ///\n    /// This function will append the provided key/value as a header to the\n    /// internal `HeaderMap` being constructed. Essentially this is equivalent\n    /// to calling `HeaderMap::append`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::HeaderValue;\n    ///\n    /// let response = Response::builder()\n    ///     .header(\"Content-Type\", \"text/html\")\n    ///     .header(\"X-Custom-Foo\", \"bar\")\n    ///     .header(\"content-length\", 0)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn header<K, V>(&mut self, key: K, value: V) -> &mut Builder\n        where HeaderName: HttpTryFrom<K>,\n              HeaderValue: HttpTryFrom<V>\n    {\n        if let Some(head) = head(&mut self.head, &self.err) {\n            match <HeaderName as HttpTryFrom<K>>::try_from(key) {\n                Ok(key) => {\n                    match <HeaderValue as HttpTryFrom<V>>::try_from(value) {\n                        Ok(value) => { head.headers.append(key, value); }\n                        Err(e) => self.err = Some(e.into()),\n                    }\n                },\n                Err(e) => self.err = Some(e.into()),\n            };\n        }\n        self\n    }\n\n    /// Get header on this response builder.\n    /// when builder has error returns None\n    /// \n    /// # Example\n    /// \n    /// ```\n    /// # use http::*;\n    /// # use http::header::HeaderValue;\n    /// # use http::response::Builder;\n    /// let mut res = Response::builder();\n    /// res.header(\"Accept\", \"text/html\")\n    ///    .header(\"X-Custom-Foo\", \"bar\");\n    /// let headers = res.headers_ref().unwrap();\n    /// assert_eq!( headers[\"Accept\"], \"text/html\" );\n    /// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n    /// ```\n    pub fn headers_ref(&self) -> Option<&HeaderMap<HeaderValue>> {\n        if self.err.is_some() {\n            return None;\n        }\n        match self.head\n        {\n            Some(ref head) => Some(&head.headers),\n            None => None\n        }\n    }\n\n    /// Get header on this response builder.\n    /// when builder has error returns None\n    /// \n    /// # Example\n    /// \n    /// ```\n    /// # use http::*;\n    /// # use http::header::HeaderValue;\n    /// # use http::response::Builder;\n    /// let mut res = Response::builder();\n    /// {\n    ///   let headers = res.headers_mut().unwrap();\n    ///   headers.insert(\"Accept\", HeaderValue::from_static(\"text/html\"));\n    ///   headers.insert(\"X-Custom-Foo\", HeaderValue::from_static(\"bar\"));\n    /// }\n    /// let headers = res.headers_ref().unwrap();\n    /// assert_eq!( headers[\"Accept\"], \"text/html\" );\n    /// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n    /// ```\n    pub fn headers_mut(&mut self) -> Option<&mut HeaderMap<HeaderValue>> {\n        if self.err.is_some() {\n            return None;\n        }\n        match self.head\n        {\n            Some(ref mut head) => Some(&mut head.headers),\n            None => None\n        }\n    }\n\n    /// Adds an extension to this builder\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = Response::builder()\n    ///     .extension(\"My Extension\")\n    ///     .body(())\n    ///     .unwrap();\n    ///\n    /// assert_eq!(response.extensions().get::<&'static str>(),\n    ///            Some(&\"My Extension\"));\n    /// ```\n    pub fn extension<T>(&mut self, extension: T) -> &mut Builder\n        where T: Any + Send + Sync + 'static,\n    {\n        if let Some(head) = head(&mut self.head, &self.err) {\n            head.extensions.insert(extension);\n        }\n        self\n    }\n\n    fn take_parts(&mut self) -> Result<Parts> {\n        let ret = self.head.take().expect(\"cannot reuse response builder\");\n        if let Some(e) = self.err.take() {\n            return Err(e)\n        }\n        Ok(ret)\n    }\n\n    /// \"Consumes\" this builder, using the provided `body` to return a\n    /// constructed `Response`.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if any previously configured argument\n    /// failed to parse or get converted to the internal representation. For\n    /// example if an invalid `head` was specified via `header(\"Foo\",\n    /// \"Bar\\r\\n\")` the error will be returned when this function is called\n    /// rather than when `header` was called.\n    ///\n    /// # Panics\n    ///\n    /// This method will panic if the builder is reused. The `body` function can\n    /// only be called once.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = Response::builder()\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn body<T>(&mut self, body: T) -> Result<Response<T>> {\n        Ok(Response {\n            head: self.take_parts()?,\n            body: body,\n        })\n    }\n}","impl Default for Builder {\n    #[inline]\n    fn default() -> Builder {\n        Builder {\n            head: Some(Parts::new()),\n            err: None,\n        }\n    }\n}"],"response::Parts":["impl Parts {\n    /// Creates a new default instance of `Parts`\n    fn new() -> Parts {\n        Parts{\n            status: StatusCode::default(),\n            version: Version::default(),\n            headers: HeaderMap::default(),\n            extensions: Extensions::default(),\n            _priv: (),\n        }\n    }\n}","impl fmt::Debug for Parts {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Parts\")\n            .field(\"status\", &self.status)\n            .field(\"version\", &self.version)\n            .field(\"headers\", &self.headers)\n            // omits Extensions because not useful\n            // omits _priv because not useful\n            .finish()\n    }\n}"],"response::Response":["impl Response<()> {\n    /// Creates a new builder-style object to manufacture a `Response`\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Response`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response = Response::builder()\n    ///     .status(200)\n    ///     .header(\"X-Custom-Foo\", \"Bar\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn builder() -> Builder {\n        Builder::new()\n    }\n}","impl<T: Default> Default for Response<T> {\n    #[inline]\n    fn default() -> Response<T> {\n        Response::new(T::default())\n    }\n}","impl<T: fmt::Debug> fmt::Debug for Response<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Response\")\n            .field(\"status\", &self.status())\n            .field(\"version\", &self.version())\n            .field(\"headers\", self.headers())\n            // omits Extensions because not useful\n            .field(\"body\", self.body())\n            .finish()\n    }\n}","impl<T> Response<T> {\n    /// Creates a new blank `Response` with the body\n    ///\n    /// The component ports of this response will be set to their default, e.g.\n    /// the ok status, no headers, etc.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response = Response::new(\"hello world\");\n    ///\n    /// assert_eq!(response.status(), StatusCode::OK);\n    /// assert_eq!(*response.body(), \"hello world\");\n    /// ```\n    #[inline]\n    pub fn new(body: T) -> Response<T> {\n        Response {\n            head: Parts::new(),\n            body: body,\n        }\n    }\n\n    /// Creates a new `Response` with the given head and body\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response = Response::new(\"hello world\");\n    /// let (mut parts, body) = response.into_parts();\n    ///\n    /// parts.status = StatusCode::BAD_REQUEST;\n    /// let response = Response::from_parts(parts, body);\n    ///\n    /// assert_eq!(response.status(), StatusCode::BAD_REQUEST);\n    /// assert_eq!(*response.body(), \"hello world\");\n    /// ```\n    #[inline]\n    pub fn from_parts(parts: Parts, body: T) -> Response<T> {\n        Response {\n            head: parts,\n            body: body,\n        }\n    }\n\n    /// Returns the `StatusCode`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// assert_eq!(response.status(), StatusCode::OK);\n    /// ```\n    #[inline]\n    pub fn status(&self) -> StatusCode {\n        self.head.status\n    }\n\n    /// Returns a mutable reference to the associated `StatusCode`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut response: Response<()> = Response::default();\n    /// *response.status_mut() = StatusCode::CREATED;\n    /// assert_eq!(response.status(), StatusCode::CREATED);\n    /// ```\n    #[inline]\n    pub fn status_mut(&mut self) -> &mut StatusCode {\n        &mut self.head.status\n    }\n\n    /// Returns a reference to the associated version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// assert_eq!(response.version(), Version::HTTP_11);\n    /// ```\n    #[inline]\n    pub fn version(&self) -> Version {\n        self.head.version\n    }\n\n    /// Returns a mutable reference to the associated version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut response: Response<()> = Response::default();\n    /// *response.version_mut() = Version::HTTP_2;\n    /// assert_eq!(response.version(), Version::HTTP_2);\n    /// ```\n    #[inline]\n    pub fn version_mut(&mut self) -> &mut Version {\n        &mut self.head.version\n    }\n\n    /// Returns a reference to the associated header field map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// assert!(response.headers().is_empty());\n    /// ```\n    #[inline]\n    pub fn headers(&self) -> &HeaderMap<HeaderValue> {\n        &self.head.headers\n    }\n\n    /// Returns a mutable reference to the associated header field map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::*;\n    /// let mut response: Response<()> = Response::default();\n    /// response.headers_mut().insert(HOST, HeaderValue::from_static(\"world\"));\n    /// assert!(!response.headers().is_empty());\n    /// ```\n    #[inline]\n    pub fn headers_mut(&mut self) -> &mut HeaderMap<HeaderValue> {\n        &mut self.head.headers\n    }\n\n    /// Returns a reference to the associated extensions.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// assert!(response.extensions().get::<i32>().is_none());\n    /// ```\n    #[inline]\n    pub fn extensions(&self) -> &Extensions {\n        &self.head.extensions\n    }\n\n    /// Returns a mutable reference to the associated extensions.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::*;\n    /// let mut response: Response<()> = Response::default();\n    /// response.extensions_mut().insert(\"hello\");\n    /// assert_eq!(response.extensions().get(), Some(&\"hello\"));\n    /// ```\n    #[inline]\n    pub fn extensions_mut(&mut self) -> &mut Extensions {\n        &mut self.head.extensions\n    }\n\n    /// Returns a reference to the associated HTTP body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<String> = Response::default();\n    /// assert!(response.body().is_empty());\n    /// ```\n    #[inline]\n    pub fn body(&self) -> &T {\n        &self.body\n    }\n\n    /// Returns a mutable reference to the associated HTTP body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut response: Response<String> = Response::default();\n    /// response.body_mut().push_str(\"hello world\");\n    /// assert!(!response.body().is_empty());\n    /// ```\n    #[inline]\n    pub fn body_mut(&mut self) -> &mut T {\n        &mut self.body\n    }\n\n    /// Consumes the response, returning just the body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::Response;\n    /// let response = Response::new(10);\n    /// let body = response.into_body();\n    /// assert_eq!(body, 10);\n    /// ```\n    #[inline]\n    pub fn into_body(self) -> T {\n        self.body\n    }\n\n    /// Consumes the response returning the head and body parts.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// let (parts, body) = response.into_parts();\n    /// assert_eq!(parts.status, StatusCode::OK);\n    /// ```\n    #[inline]\n    pub fn into_parts(self) -> (Parts, T) {\n        (self.head, self.body)\n    }\n\n    /// Consumes the response returning a new response with body mapped to the\n    /// return type of the passed in function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response = Response::builder().body(\"some string\").unwrap();\n    /// let mapped_response: Response<&[u8]> = response.map(|b| {\n    ///   assert_eq!(b, \"some string\");\n    ///   b.as_bytes()\n    /// });\n    /// assert_eq!(mapped_response.body(), &\"some string\".as_bytes());\n    /// ```\n    #[inline]\n    pub fn map<F, U>(self, f: F) -> Response<U>\n        where F: FnOnce(T) -> U\n    {\n        Response { body: f(self.body), head: self.head }\n    }\n}"],"status::InvalidStatusCode":["impl Error for InvalidStatusCode {\n    fn description(&self) -> &str {\n        \"invalid status code\"\n    }\n}","impl InvalidStatusCode {\n    fn new() -> InvalidStatusCode {\n        InvalidStatusCode {\n            _priv: (),\n        }\n    }\n}","impl fmt::Debug for InvalidStatusCode {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"InvalidStatusCode\")\n            // skip _priv noise\n            .finish()\n    }\n}","impl fmt::Display for InvalidStatusCode {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_str(self.description())\n    }\n}"],"status::StatusCode":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl Default for StatusCode {\n    #[inline]\n    fn default() -> StatusCode {\n        StatusCode::OK\n    }\n}","impl FromStr for StatusCode {\n    type Err = InvalidStatusCode;\n\n    fn from_str(s: &str) -> Result<StatusCode, InvalidStatusCode> {\n        StatusCode::from_bytes(s.as_ref())\n    }\n}","impl HttpTryFrom<$t> for $t {\n            type Error = Error;\n\n            fn try_from(t: Self) -> Result<Self, Self::Error> {\n                Ok(t)\n            }\n        }","impl HttpTryFrom<u16> for StatusCode {\n    type Error = InvalidStatusCode;\n\n    #[inline]\n    fn try_from(t: u16) -> Result<Self, Self::Error> {\n        StatusCode::from_u16(t)\n    }\n}","impl PartialEq<u16> for StatusCode {\n    #[inline]\n    fn eq(&self, other: &u16) -> bool {\n        self.as_u16() == *other\n    }\n}","impl Sealed for $t {}","impl StatusCode {\n        $(\n            $(#[$docs])*\n            pub const $konst: StatusCode = StatusCode($num);\n        )+\n\n        }","impl StatusCode {\n    /// Converts a u16 to a status code.\n    ///\n    /// The function validates the correctness of the supplied u16. It must be\n    /// greater or equal to 100 but less than 600.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use http::StatusCode;\n    ///\n    /// let ok = StatusCode::from_u16(200).unwrap();\n    /// assert_eq!(ok, StatusCode::OK);\n    ///\n    /// let err = StatusCode::from_u16(99);\n    /// assert!(err.is_err());\n    /// ```\n    #[inline]\n    pub fn from_u16(src: u16) -> Result<StatusCode, InvalidStatusCode> {\n        if src < 100 || src >= 600 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        Ok(StatusCode(src))\n    }\n\n    /// Converts a &[u8] to a status code\n    pub fn from_bytes(src: &[u8]) -> Result<StatusCode, InvalidStatusCode> {\n        if src.len() != 3 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        let a = src[0].wrapping_sub(b'0') as u16;\n        let b = src[1].wrapping_sub(b'0') as u16;\n        let c = src[2].wrapping_sub(b'0') as u16;\n\n        if a == 0 || a > 5 || b > 9 || c > 9 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        let status = (a * 100) + (b * 10) + c;\n        Ok(StatusCode(status))\n    }\n\n    /// Returns the `u16` corresponding to this `StatusCode`.\n    ///\n    /// # Note\n    ///\n    /// This is the same as the `From<StatusCode>` implementation, but\n    /// included as an inherent method because that implementation doesn't\n    /// appear in rustdocs, as well as a way to force the type instead of\n    /// relying on inference.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let status = http::StatusCode::OK;\n    /// assert_eq!(status.as_u16(), 200);\n    /// ```\n    #[inline]\n    pub fn as_u16(&self) -> u16 {\n        (*self).into()\n    }\n\n    /// Returns a &str representation of the `StatusCode`\n    ///\n    /// The return value only includes a numerical representation of the\n    /// status code. The canonical reason is not included.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let status = http::StatusCode::OK;\n    /// assert_eq!(status.as_str(), \"200\");\n    /// ```\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        CODES_AS_STR[(self.0 - 100) as usize]\n    }\n\n    /// Get the standardised `reason-phrase` for this status code.\n    ///\n    /// This is mostly here for servers writing responses, but could potentially have application\n    /// at other times.\n    ///\n    /// The reason phrase is defined as being exclusively for human readers. You should avoid\n    /// deriving any meaning from it at all costs.\n    ///\n    /// Bear in mind also that in HTTP/2.0 the reason phrase is abolished from transmission, and so\n    /// this canonical reason phrase really is the only reason phrase you’ll find.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let status = http::StatusCode::OK;\n    /// assert_eq!(status.canonical_reason(), Some(\"OK\"));\n    /// ```\n    pub fn canonical_reason(&self) -> Option<&'static str> {\n        canonical_reason(self.0)\n    }\n\n\n    /// Check if status is within 100-199.\n    #[inline]\n    pub fn is_informational(&self) -> bool {\n        200 > self.0 && self.0 >= 100\n    }\n\n    /// Check if status is within 200-299.\n    #[inline]\n    pub fn is_success(&self) -> bool {\n        300 > self.0 && self.0 >= 200\n    }\n\n    /// Check if status is within 300-399.\n    #[inline]\n    pub fn is_redirection(&self) -> bool {\n        400 > self.0 && self.0 >= 300\n    }\n\n    /// Check if status is within 400-499.\n    #[inline]\n    pub fn is_client_error(&self) -> bool {\n        500 > self.0 && self.0 >= 400\n    }\n\n    /// Check if status is within 500-599.\n    #[inline]\n    pub fn is_server_error(&self) -> bool {\n        600 > self.0 && self.0 >= 500\n    }\n}","impl fmt::Debug for StatusCode {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&self.0, f)\n    }\n}","impl fmt::Display for StatusCode {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{} {}\", u16::from(*self),\n               self.canonical_reason().unwrap_or(\"<unknown status code>\"))\n    }\n}","impl<'a> From<&'a StatusCode> for StatusCode {\n    #[inline]\n    fn from(t: &'a StatusCode) -> Self {\n        t.clone()\n    }\n}","impl<'a> HttpTryFrom<&'a StatusCode> for StatusCode {\n    type Error = ::error::Never;\n\n    #[inline]\n    fn try_from(t: &'a StatusCode) -> Result<Self, Self::Error> {\n        Ok(t.clone())\n    }\n}","impl<'a> HttpTryFrom<&'a [u8]> for StatusCode {\n    type Error = InvalidStatusCode;\n\n    #[inline]\n    fn try_from(t: &'a [u8]) -> Result<Self, Self::Error> {\n        StatusCode::from_bytes(t)\n    }\n}","impl<'a> HttpTryFrom<&'a str> for StatusCode {\n    type Error = InvalidStatusCode;\n\n    #[inline]\n    fn try_from(t: &'a str) -> Result<Self, Self::Error> {\n        t.parse()\n    }\n}"],"std::string::String":["impl AsHeaderName for String {}","impl PartialEq<Authority> for String {\n    fn eq(&self, other: &Authority) -> bool {\n        self.as_str().eq_ignore_ascii_case(other.as_str())\n    }\n}","impl PartialEq<HeaderValue> for String {\n    #[inline]\n    fn eq(&self, other: &HeaderValue) -> bool {\n        *other == *self\n    }\n}","impl PartialEq<PathAndQuery> for String {\n    #[inline]\n    fn eq(&self, other: &PathAndQuery) -> bool {\n        self.as_str() == other.as_str()\n    }\n}","impl PartialOrd<Authority> for String {\n    fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering> {\n        let left = self.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}","impl PartialOrd<HeaderValue> for String {\n    #[inline]\n    fn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering> {\n        self.as_bytes().partial_cmp(other.as_bytes())\n    }\n}","impl PartialOrd<PathAndQuery> for String {\n    #[inline]\n    fn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(other.as_str())\n    }\n}","impl Sealed for String {\n        #[doc(hidden)]\n        #[inline]\n        fn entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<T>, InvalidHeaderName> {\n            self.as_str().entry(map)\n        }\n\n        #[doc(hidden)]\n        #[inline]\n        fn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)> {\n            Sealed::find(&self.as_str(), map)\n        }\n\n        #[doc(hidden)]\n        fn as_str(&self) -> &str {\n            self\n        }\n    }"],"uri::ErrorKind":["Debug","Eq","PartialEq"],"uri::InvalidUri":["Debug","impl Error for InvalidUri {\n    fn description(&self) -> &str {\n        match self.0 {\n            ErrorKind::InvalidUriChar => \"invalid uri character\",\n            ErrorKind::InvalidScheme => \"invalid scheme\",\n            ErrorKind::InvalidAuthority => \"invalid authority\",\n            ErrorKind::InvalidPort => \"invalid port\",\n            ErrorKind::InvalidFormat => \"invalid format\",\n            ErrorKind::SchemeMissing => \"scheme missing\",\n            ErrorKind::AuthorityMissing => \"authority missing\",\n            ErrorKind::PathAndQueryMissing => \"path missing\",\n            ErrorKind::TooLong => \"uri too long\",\n            ErrorKind::Empty => \"empty string\",\n            ErrorKind::SchemeTooLong => \"scheme too long\",\n        }\n    }\n}","impl From<ErrorKind> for InvalidUri {\n    fn from(src: ErrorKind) -> InvalidUri {\n        InvalidUri(src)\n    }\n}","impl fmt::Display for InvalidUri {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.description().fmt(f)\n    }\n}"],"uri::InvalidUriBytes":["Debug","impl Error for InvalidUriBytes {\n    fn description(&self) -> &str {\n        self.0.description()\n    }\n}","impl From<ErrorKind> for InvalidUriBytes {\n    fn from(src: ErrorKind) -> InvalidUriBytes {\n        InvalidUriBytes(src.into())\n    }\n}","impl fmt::Display for InvalidUriBytes {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}"],"uri::InvalidUriParts":["Debug","impl Error for InvalidUriParts {\n    fn description(&self) -> &str {\n        self.0.description()\n    }\n}","impl From<ErrorKind> for InvalidUriParts {\n    fn from(src: ErrorKind) -> InvalidUriParts {\n        InvalidUriParts(src.into())\n    }\n}","impl fmt::Display for InvalidUriParts {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}"],"uri::Parts":["Debug","Default","impl From<Uri> for Parts {\n    fn from(src: Uri) -> Self {\n        let path_and_query = if src.has_path() {\n            Some(src.path_and_query)\n        } else {\n            None\n        };\n\n        let scheme = match src.scheme.inner {\n            Scheme2::None => None,\n            _ => Some(src.scheme),\n        };\n\n        let authority = if src.authority.data.is_empty() {\n            None\n        } else {\n            Some(src.authority)\n        };\n\n        Parts {\n            scheme: scheme,\n            authority: authority,\n            path_and_query: path_and_query,\n            _priv: (),\n        }\n    }\n}"],"uri::Uri":["Clone","impl Default for Uri {\n    #[inline]\n    fn default() -> Uri {\n        Uri {\n            scheme: Scheme::empty(),\n            authority: Authority::empty(),\n            path_and_query: PathAndQuery::slash(),\n        }\n    }\n}","impl Eq for Uri {}","impl FromStr for Uri {\n    type Err = InvalidUri;\n\n    #[inline]\n    fn from_str(s: &str) -> Result<Uri, InvalidUri> {\n        Uri::from_shared(s.into()).map_err(|e| e.0)\n    }\n}","impl Hash for Uri {\n    fn hash<H>(&self, state: &mut H) where H: Hasher {\n        if !self.scheme.inner.is_none() {\n            self.scheme.hash(state);\n            state.write_u8(0xff);\n        }\n\n        if let Some(auth) = self.authority_part() {\n            auth.hash(state);\n        }\n\n        Hash::hash_slice(self.path().as_bytes(), state);\n\n        if let Some(query) = self.query() {\n            b'?'.hash(state);\n            Hash::hash_slice(query.as_bytes(), state);\n        }\n    }\n}","impl HttpTryFrom<$t> for $t {\n            type Error = Error;\n\n            fn try_from(t: Self) -> Result<Self, Self::Error> {\n                Ok(t)\n            }\n        }","impl HttpTryFrom<Bytes> for Uri {\n    type Error = InvalidUriBytes;\n\n    #[inline]\n    fn try_from(t: Bytes) -> Result<Self, Self::Error> {\n        Uri::from_shared(t)\n    }\n}","impl HttpTryFrom<Parts> for Uri {\n    type Error = InvalidUriParts;\n\n    #[inline]\n    fn try_from(src: Parts) -> Result<Self, Self::Error> {\n        Uri::from_parts(src)\n    }\n}","impl HttpTryFrom<String> for Uri {\n    type Error = InvalidUriBytes;\n\n    #[inline]\n    fn try_from(t: String) -> Result<Self, Self::Error> {\n        Uri::from_shared(Bytes::from(t))\n    }\n}","impl PartialEq for Uri {\n    fn eq(&self, other: &Uri) -> bool {\n        if self.scheme_part() != other.scheme_part() {\n            return false;\n        }\n\n        if self.authority_part() != other.authority_part() {\n            return false;\n        }\n\n        if self.path() != other.path() {\n            return false;\n        }\n\n        if self.query() != other.query() {\n            return false;\n        }\n\n        true\n    }\n}","impl PartialEq<str> for Uri {\n    fn eq(&self, other: &str) -> bool {\n        let mut other = other.as_bytes();\n        let mut absolute = false;\n\n        if let Some(scheme) = self.scheme_part() {\n            let scheme = scheme.as_str().as_bytes();\n            absolute = true;\n\n            if other.len() < scheme.len() + 3 {\n                return false;\n            }\n\n            if !scheme.eq_ignore_ascii_case(&other[..scheme.len()]) {\n                return false;\n            }\n\n            other = &other[scheme.len()..];\n\n            if &other[..3] != b\"://\" {\n                return false;\n            }\n\n            other = &other[3..];\n        }\n\n        if let Some(auth) = self.authority_part() {\n            let len = auth.data.len();\n            absolute = true;\n\n            if other.len() < len {\n                return false;\n            }\n\n            if !auth.data.as_bytes().eq_ignore_ascii_case(&other[..len]) {\n                return false;\n            }\n\n            other = &other[len..];\n        }\n\n        let path = self.path();\n\n        if other.len() < path.len() || path.as_bytes() != &other[..path.len()] {\n            if absolute && path == \"/\" {\n                // PathAndQuery can be ommitted, fall through\n            } else {\n                return false;\n            }\n        } else {\n            other = &other[path.len()..];\n        }\n\n        if let Some(query) = self.query() {\n            if other.len() == 0 {\n                return query.len() == 0;\n            }\n\n            if other[0] != b'?' {\n                return false;\n            }\n\n            other = &other[1..];\n\n            if other.len() < query.len() {\n                return false;\n            }\n\n            if query.as_bytes() != &other[..query.len()] {\n                return false;\n            }\n\n            other = &other[query.len()..];\n        }\n\n        other.is_empty() || other[0] == b'#'\n    }\n}","impl Sealed for $t {}","impl Uri {\n    /// Creates a new builder-style object to manufacture a `Uri`.\n    ///\n    /// This method returns an instance of `Builder` which can be usd to\n    /// create a `Uri`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use http::Uri;\n    ///\n    /// let uri = Uri::builder()\n    ///     .scheme(\"https\")\n    ///     .authority(\"hyper.rs\")\n    ///     .path_and_query(\"/\")\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    pub fn builder() -> Builder {\n        Builder::new()\n    }\n\n    /// Attempt to convert a `Uri` from `Parts`\n    pub fn from_parts(src: Parts) -> Result<Uri, InvalidUriParts> {\n        if src.scheme.is_some() {\n            if src.authority.is_none() {\n                return Err(ErrorKind::AuthorityMissing.into());\n            }\n\n            if src.path_and_query.is_none() {\n                return Err(ErrorKind::PathAndQueryMissing.into());\n            }\n        } else {\n            if src.authority.is_some() && src.path_and_query.is_some() {\n                return Err(ErrorKind::SchemeMissing.into());\n            }\n        }\n\n        let scheme = match src.scheme {\n            Some(scheme) => scheme,\n            None => Scheme { inner: Scheme2::None },\n        };\n\n        let authority = match src.authority {\n            Some(authority) => authority,\n            None => Authority::empty(),\n        };\n\n        let path_and_query = match src.path_and_query {\n            Some(path_and_query) => path_and_query,\n            None => PathAndQuery::empty(),\n        };\n\n        Ok(Uri {\n            scheme: scheme,\n            authority: authority,\n            path_and_query: path_and_query,\n        })\n    }\n\n    /// Attempt to convert a `Uri` from `Bytes`\n    ///\n    /// This function will be replaced by a `TryFrom` implementation once the\n    /// trait lands in stable.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # extern crate http;\n    /// # use http::uri::*;\n    /// extern crate bytes;\n    ///\n    /// use bytes::Bytes;\n    ///\n    /// # pub fn main() {\n    /// let bytes = Bytes::from(\"http://example.com/foo\");\n    /// let uri = Uri::from_shared(bytes).unwrap();\n    ///\n    /// assert_eq!(uri.host().unwrap(), \"example.com\");\n    /// assert_eq!(uri.path(), \"/foo\");\n    /// # }\n    /// ```\n    pub fn from_shared(s: Bytes) -> Result<Uri, InvalidUriBytes> {\n        use self::ErrorKind::*;\n\n        if s.len() > MAX_LEN {\n            return Err(TooLong.into());\n        }\n\n        match s.len() {\n            0 => {\n                return Err(Empty.into());\n            }\n            1 => {\n                match s[0] {\n                    b'/' => {\n                        return Ok(Uri {\n                            scheme: Scheme::empty(),\n                            authority: Authority::empty(),\n                            path_and_query: PathAndQuery::slash(),\n                        });\n                    }\n                    b'*' => {\n                        return Ok(Uri {\n                            scheme: Scheme::empty(),\n                            authority: Authority::empty(),\n                            path_and_query: PathAndQuery::star(),\n                        });\n                    }\n                    _ => {\n                        let authority = Authority::from_shared(s)?;\n\n                        return Ok(Uri {\n                            scheme: Scheme::empty(),\n                            authority: authority,\n                            path_and_query: PathAndQuery::empty(),\n                        });\n                    }\n                }\n            }\n            _ => {}\n        }\n\n        if s[0] == b'/' {\n            return Ok(Uri {\n                scheme: Scheme::empty(),\n                authority: Authority::empty(),\n                path_and_query: PathAndQuery::from_shared(s)?,\n            });\n        }\n\n        parse_full(s)\n    }\n\n    /// Convert a `Uri` from a static string.\n    ///\n    /// This function will not perform any copying, however the string is\n    /// checked to ensure that it is valid.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the argument is an invalid URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::Uri;\n    /// let uri = Uri::from_static(\"http://example.com/foo\");\n    ///\n    /// assert_eq!(uri.host().unwrap(), \"example.com\");\n    /// assert_eq!(uri.path(), \"/foo\");\n    /// ```\n    pub fn from_static(src: &'static str) -> Self {\n        let s = Bytes::from_static(src.as_bytes());\n        match Uri::from_shared(s) {\n            Ok(uri) => uri,\n            Err(e) => panic!(\"static str is not valid URI: {}\", e),\n        }\n    }\n\n    /// Convert a `Uri` into `Parts`.\n    ///\n    /// # Note\n    ///\n    /// This is just an inherent method providing the same functionality as\n    /// `let parts: Parts = uri.into()`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let uri: Uri = \"/foo\".parse().unwrap();\n    ///\n    /// let parts = uri.into_parts();\n    ///\n    /// assert_eq!(parts.path_and_query.unwrap(), \"/foo\");\n    ///\n    /// assert!(parts.scheme.is_none());\n    /// assert!(parts.authority.is_none());\n    /// ```\n    #[inline]\n    pub fn into_parts(self) -> Parts {\n        self.into()\n    }\n\n    /// Returns the path & query components of the Uri\n    #[inline]\n    pub fn path_and_query(&self) -> Option<&PathAndQuery> {\n        if !self.scheme.inner.is_none() || self.authority.data.is_empty() {\n            Some(&self.path_and_query)\n        } else {\n            None\n        }\n    }\n\n    /// Get the path of this `Uri`.\n    ///\n    /// Both relative and absolute URIs contain a path component, though it\n    /// might be the empty string. The path component is **case sensitive**.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                        |--------|\n    ///                                             |\n    ///                                           path\n    /// ```\n    ///\n    /// If the URI is `*` then the path component is equal to `*`.\n    ///\n    /// # Examples\n    ///\n    /// A relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    ///\n    /// let uri: Uri = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.path(), \"/hello/world\");\n    /// ```\n    ///\n    /// An absolute URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.path(), \"/hello/world\");\n    /// ```\n    #[inline]\n    pub fn path(&self) -> &str {\n        if self.has_path() {\n            self.path_and_query.path()\n        } else {\n            \"\"\n        }\n    }\n\n    /// Get the scheme of this `Uri`.\n    ///\n    /// The URI scheme refers to a specification for assigning identifiers\n    /// within that scheme. Only absolute URIs contain a scheme component, but\n    /// not all absolute URIs will contain a scheme component.  Although scheme\n    /// names are case-insensitive, the canonical form is lowercase.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    /// |-|\n    ///  |\n    /// scheme\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// use http::uri::{Scheme, Uri};\n    ///\n    /// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.scheme_part(), Some(&Scheme::HTTP));\n    /// ```\n    ///\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert!(uri.scheme_part().is_none());\n    /// ```\n    #[inline]\n    pub fn scheme_part(&self) -> Option<&Scheme> {\n        if self.scheme.inner.is_none() {\n            None\n        } else {\n            Some(&self.scheme)\n        }\n    }\n\n    #[deprecated(since = \"0.1.2\", note = \"use scheme_part or scheme_str instead\")]\n    #[doc(hidden)]\n    #[inline]\n    pub fn scheme(&self) -> Option<&str> {\n        self.scheme_str()\n    }\n\n    /// Get the scheme of this `Uri` as a `&str`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.scheme_str(), Some(\"http\"));\n    /// ```\n    #[inline]\n    pub fn scheme_str(&self) -> Option<&str> {\n        if self.scheme.inner.is_none() {\n            None\n        } else {\n            Some(self.scheme.as_str())\n        }\n    }\n\n    /// Get the authority of this `Uri`.\n    ///\n    /// The authority is a hierarchical element for naming authority such that\n    /// the remainder of the URI is delegated to that authority. For HTTP, the\n    /// authority consists of the host and port. The host portion of the\n    /// authority is **case-insensitive**.\n    ///\n    /// The authority also includes a `username:password` component, however\n    /// the use of this is deprecated and should be avoided.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///       |-------------------------------|\n    ///                     |\n    ///                 authority\n    /// ```\n    ///\n    /// This function will be renamed to `authority` in the next semver release.\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.authority_part().map(|a| a.as_str()), Some(\"example.org:80\"));\n    /// ```\n    ///\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert!(uri.authority_part().is_none());\n    /// ```\n    #[inline]\n    pub fn authority_part(&self) -> Option<&Authority> {\n        if self.authority.data.is_empty() {\n            None\n        } else {\n            Some(&self.authority)\n        }\n    }\n\n    #[deprecated(since = \"0.1.1\", note = \"use authority_part instead\")]\n    #[doc(hidden)]\n    #[inline]\n    pub fn authority(&self) -> Option<&str> {\n        if self.authority.data.is_empty() {\n            None\n        } else {\n            Some(self.authority.as_str())\n        }\n    }\n\n    /// Get the host of this `Uri`.\n    ///\n    /// The host subcomponent of authority is identified by an IP literal\n    /// encapsulated within square brackets, an IPv4 address in dotted- decimal\n    /// form, or a registered name.  The host subcomponent is **case-insensitive**.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                         |---------|\n    ///                              |\n    ///                             host\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.host(), Some(\"example.org\"));\n    /// ```\n    ///\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert!(uri.host().is_none());\n    /// ```\n    #[inline]\n    pub fn host(&self) -> Option<&str> {\n        self.authority_part().map(|a| a.host())\n    }\n\n    #[deprecated(since=\"0.1.14\", note=\"use `port_part` or `port_u16` instead\")]\n    #[doc(hidden)]\n    pub fn port(&self) -> Option<u16> {\n        self.port_u16()\n    }\n\n    /// Get the port part of this `Uri`.\n    ///\n    /// The port subcomponent of authority is designated by an optional port\n    /// number following the host and delimited from it by a single colon (\":\")\n    /// character. It can be turned into a decimal port number with the `as_u16`\n    /// method or as a `str` with the `as_str` method.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                     |-|\n    ///                                      |\n    ///                                     port\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI with port\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n    ///\n    /// let port = uri.port_part().unwrap();\n    /// assert_eq!(port.as_u16(), 80);\n    /// ```\n    ///\n    /// Absolute URI without port\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n    ///\n    /// assert!(uri.port_part().is_none());\n    /// ```\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert!(uri.port_part().is_none());\n    /// ```\n    pub fn port_part(&self) -> Option<Port<&str>> {\n        self.authority_part()\n            .and_then(|a| a.port_part())\n    }\n\n    /// Get the port of this `Uri` as a `u16`.\n    ///\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::{Uri, uri::Port};\n    /// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.port_u16(), Some(80));\n    /// ```\n    pub fn port_u16(&self) -> Option<u16> {\n        self.port_part().and_then(|p| Some(p.as_u16()))\n    }\n\n    /// Get the query string of this `Uri`, starting after the `?`.\n    ///\n    /// The query component contains non-hierarchical data that, along with data\n    /// in the path component, serves to identify a resource within the scope of\n    /// the URI's scheme and naming authority (if any). The query component is\n    /// indicated by the first question mark (\"?\") character and terminated by a\n    /// number sign (\"#\") character or by the end of the URI.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                                   |-------------------|\n    ///                                                             |\n    ///                                                           query\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org/hello/world?key=value\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.query(), Some(\"key=value\"));\n    /// ```\n    ///\n    /// Relative URI with a query string component\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"/hello/world?key=value&foo=bar\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.query(), Some(\"key=value&foo=bar\"));\n    /// ```\n    ///\n    /// Relative URI without a query string component\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert!(uri.query().is_none());\n    /// ```\n    #[inline]\n    pub fn query(&self) -> Option<&str> {\n        self.path_and_query.query()\n    }\n\n    fn has_path(&self) -> bool {\n        !self.path_and_query.data.is_empty() || !self.scheme.inner.is_none()\n    }\n}","impl fmt::Debug for Uri {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}","impl fmt::Display for Uri {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if let Some(scheme) = self.scheme_part() {\n            write!(f, \"{}://\", scheme)?;\n        }\n\n        if let Some(authority) = self.authority_part() {\n            write!(f, \"{}\", authority)?;\n        }\n\n        write!(f, \"{}\", self.path())?;\n\n        if let Some(query) = self.query() {\n            write!(f, \"?{}\", query)?;\n        }\n\n        Ok(())\n    }\n}","impl<'a> HttpTryFrom<&'a String> for Uri {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(t: &'a String) -> Result<Self, Self::Error> {\n        t.parse()\n    }\n}","impl<'a> HttpTryFrom<&'a Uri> for Uri {\n    type Error = ::Error;\n\n    #[inline]\n    fn try_from(src: &'a Uri) -> Result<Self, Self::Error> {\n        Ok(src.clone())\n    }\n}","impl<'a> HttpTryFrom<&'a str> for Uri {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(t: &'a str) -> Result<Self, Self::Error> {\n        t.parse()\n    }\n}","impl<'a> PartialEq<&'a str> for Uri {\n    fn eq(&self, other: & &'a str) -> bool {\n        self == *other\n    }\n}"],"uri::authority::Authority":["Clone","impl AsRef<str> for Authority {\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}","impl Authority {\n    pub(super) fn empty() -> Self {\n        Authority { data: ByteStr::new() }\n    }\n\n    /// Attempt to convert an `Authority` from `Bytes`.\n    ///\n    /// This function will be replaced by a `TryFrom` implementation once the\n    /// trait lands in stable.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # extern crate http;\n    /// # use http::uri::*;\n    /// extern crate bytes;\n    ///\n    /// use bytes::Bytes;\n    ///\n    /// # pub fn main() {\n    /// let bytes = Bytes::from(\"example.com\");\n    /// let authority = Authority::from_shared(bytes).unwrap();\n    ///\n    /// assert_eq!(authority.host(), \"example.com\");\n    /// # }\n    /// ```\n    pub fn from_shared(s: Bytes) -> Result<Self, InvalidUriBytes> {\n        let authority_end = Authority::parse_non_empty(&s[..]).map_err(InvalidUriBytes)?;\n\n        if authority_end != s.len() {\n            return Err(ErrorKind::InvalidUriChar.into());\n        }\n\n        Ok(Authority {\n            data: unsafe { ByteStr::from_utf8_unchecked(s) },\n        })\n    }\n\n    /// Attempt to convert an `Authority` from a static string.\n    ///\n    /// This function will not perform any copying, and the string will be\n    /// checked if it is empty or contains an invalid character.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the argument contains invalid characters or\n    /// is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority = Authority::from_static(\"example.com\");\n    /// assert_eq!(authority.host(), \"example.com\");\n    /// ```\n    pub fn from_static(src: &'static str) -> Self {\n        let s = src.as_bytes();\n        let b = Bytes::from_static(s);\n        let authority_end = Authority::parse_non_empty(&b[..]).expect(\"static str is not valid authority\");\n\n        if authority_end != b.len() {\n            panic!(\"static str is not valid authority\");\n        }\n\n        Authority {\n            data: unsafe { ByteStr::from_utf8_unchecked(b) },\n        }\n    }\n\n    // Note: this may return an *empty* Authority. You might want `parse_non_empty`.\n    pub(super) fn parse(s: &[u8]) -> Result<usize, InvalidUri> {\n        let mut colon_cnt = 0;\n        let mut start_bracket = false;\n        let mut end_bracket = false;\n        let mut has_percent = false;\n        let mut end = s.len();\n        let mut at_sign_pos = None;\n\n        for (i, &b) in s.iter().enumerate() {\n            match URI_CHARS[b as usize] {\n                b'/' | b'?' | b'#' => {\n                    end = i;\n                    break;\n                }\n                b':' => {\n                    colon_cnt += 1;\n                }\n                b'[' => {\n                    start_bracket = true;\n                    if has_percent {\n                        // Something other than the userinfo has a `%`, so reject it.\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                }\n                b']' => {\n                    end_bracket = true;\n\n                    // Those were part of an IPv6 hostname, so forget them...\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                b'@' => {\n                    at_sign_pos = Some(i);\n\n                    // Those weren't a port colon, but part of the\n                    // userinfo, so it needs to be forgotten.\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                0 if b == b'%' => {\n                    // Per https://tools.ietf.org/html/rfc3986#section-3.2.1 and\n                    // https://url.spec.whatwg.org/#authority-state\n                    // the userinfo can have a percent-encoded username and password,\n                    // so record that a `%` was found. If this turns out to be\n                    // part of the userinfo, this flag will be cleared.\n                    // Also per https://tools.ietf.org/html/rfc6874, percent-encoding can\n                    // be used to indicate a zone identifier.\n                    // If the flag hasn't been cleared at the end, that means this\n                    // was part of the hostname (and not part of an IPv6 address), and\n                    // will fail with an error.\n                    has_percent = true;\n                }\n                0 => {\n                    return Err(ErrorKind::InvalidUriChar.into());\n                }\n                _ => {}\n            }\n        }\n\n        if start_bracket ^ end_bracket {\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if colon_cnt > 1 {\n            // Things like 'localhost:8080:3030' are rejected.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if end > 0 && at_sign_pos == Some(end - 1) {\n            // If there's nothing after an `@`, this is bonkers.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if has_percent {\n            // Something after the userinfo has a `%`, so reject it.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        Ok(end)\n    }\n\n    // Parse bytes as an Authority, not allowing an empty string.\n    //\n    // This should be used by functions that allow a user to parse\n    // an `Authority` by itself.\n    fn parse_non_empty(s: &[u8]) -> Result<usize, InvalidUri> {\n        if s.is_empty() {\n            return Err(ErrorKind::Empty.into());\n        }\n        Authority::parse(s)\n    }\n\n    /// Get the host of this `Authority`.\n    ///\n    /// The host subcomponent of authority is identified by an IP literal\n    /// encapsulated within square brackets, an IPv4 address in dotted- decimal\n    /// form, or a registered name.  The host subcomponent is **case-insensitive**.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                         |---------|\n    ///                              |\n    ///                             host\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let authority: Authority = \"example.org:80\".parse().unwrap();\n    ///\n    /// assert_eq!(authority.host(), \"example.org\");\n    /// ```\n    #[inline]\n    pub fn host(&self) -> &str {\n        host(self.as_str())\n    }\n\n    #[deprecated(since=\"0.1.14\", note=\"use `port_part` or `port_u16` instead\")]\n    #[doc(hidden)]\n    pub fn port(&self) -> Option<u16> {\n        self.port_u16()\n    }\n\n    /// Get the port part of this `Authority`.\n    ///\n    /// The port subcomponent of authority is designated by an optional port\n    /// number following the host and delimited from it by a single colon (\":\")\n    /// character. It can be turned into a decimal port number with the `as_u16`\n    /// method or as a `str` with the `as_str` method.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                     |-|\n    ///                                      |\n    ///                                     port\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Authority with port\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = \"example.org:80\".parse().unwrap();\n    ///\n    /// let port = authority.port_part().unwrap();\n    /// assert_eq!(port.as_u16(), 80);\n    /// assert_eq!(port.as_str(), \"80\");\n    /// ```\n    ///\n    /// Authority without port\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = \"example.org\".parse().unwrap();\n    ///\n    /// assert!(authority.port_part().is_none());\n    /// ```\n    pub fn port_part(&self) -> Option<Port<&str>> {\n        let bytes = self.as_str();\n        bytes\n            .rfind(\":\")\n            .and_then(|i| Port::from_str(&bytes[i + 1..]).ok())\n    }\n\n    /// Get the port of this `Authority` as a `u16`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = \"example.org:80\".parse().unwrap();\n    ///\n    /// assert_eq!(authority.port_u16(), Some(80));\n    /// ```\n    pub fn port_u16(&self) -> Option<u16> {\n        self.port_part().and_then(|p| Some(p.as_u16()))\n    }\n\n    /// Return a str representation of the authority\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        &self.data[..]\n    }\n\n    /// Converts this `Authority` back to a sequence of bytes\n    #[inline]\n    pub fn into_bytes(self) -> Bytes {\n        self.into()\n    }\n}","impl Eq for Authority {}","impl FromStr for Authority {\n    type Err = InvalidUri;\n\n    fn from_str(s: &str) -> Result<Self, InvalidUri> {\n        HttpTryFrom::try_from(s)\n    }\n}","impl Hash for Authority {\n    fn hash<H>(&self, state: &mut H) where H: Hasher {\n        self.data.len().hash(state);\n        for &b in self.data.as_bytes() {\n            state.write_u8(b.to_ascii_lowercase());\n        }\n    }\n}","impl HttpTryFrom<$t> for $t {\n            type Error = Error;\n\n            fn try_from(t: Self) -> Result<Self, Self::Error> {\n                Ok(t)\n            }\n        }","impl HttpTryFrom<Bytes> for Authority {\n    type Error = InvalidUriBytes;\n    #[inline]\n    fn try_from(bytes: Bytes) -> Result<Self, Self::Error> {\n        Authority::from_shared(bytes)\n    }\n}","impl PartialEq for Authority {\n    fn eq(&self, other: &Authority) -> bool {\n        self.data.eq_ignore_ascii_case(&other.data)\n    }\n}","impl PartialEq<String> for Authority {\n    fn eq(&self, other: &String) -> bool {\n        self.data.eq_ignore_ascii_case(other.as_str())\n    }\n}","impl PartialEq<str> for Authority {\n    fn eq(&self, other: &str) -> bool {\n        self.data.eq_ignore_ascii_case(other)\n    }\n}","impl PartialOrd for Authority {\n    fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering> {\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}","impl PartialOrd<String> for Authority {\n    fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering> {\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}","impl PartialOrd<str> for Authority {\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}","impl Sealed for $t {}","impl fmt::Debug for Authority {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_str(self.as_str())\n    }\n}","impl fmt::Display for Authority {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_str(self.as_str())\n    }\n}","impl<'a> HttpTryFrom<&'a [u8]> for Authority {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {\n        // parse first, and only turn into Bytes if valid\n        let end = Authority::parse_non_empty(s)?;\n\n        if end != s.len() {\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        Ok(Authority {\n            data: unsafe { ByteStr::from_utf8_unchecked(s.into()) },\n        })\n    }\n}","impl<'a> HttpTryFrom<&'a str> for Authority {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a str) -> Result<Self, Self::Error> {\n        HttpTryFrom::try_from(s.as_bytes())\n    }\n}","impl<'a> PartialEq<&'a str> for Authority {\n    fn eq(&self, other: &&'a str) -> bool {\n        self.data.eq_ignore_ascii_case(other)\n    }\n}","impl<'a> PartialOrd<&'a str> for Authority {\n    fn partial_cmp(&self, other: &&'a str) -> Option<cmp::Ordering> {\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}"],"uri::builder::Builder":["Debug","impl Builder {\n    /// Creates a new default instance of `Builder` to construct a `Uri`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let uri = uri::Builder::new()\n    ///     .scheme(\"https\")\n    ///     .authority(\"hyper.rs\")\n    ///     .path_and_query(\"/\")\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn new() -> Builder {\n        Builder::default()\n    }\n\n    /// Set the `Scheme` for this URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let mut builder = uri::Builder::new();\n    /// builder.scheme(\"https\");\n    /// ```\n    pub fn scheme<T>(&mut self, scheme: T) -> &mut Self\n    where\n        Scheme: HttpTryFrom<T>,\n    {\n        self.map(|parts| {\n            parts.scheme = Some(scheme.http_try_into()?);\n            Ok(())\n        })\n    }\n\n    /// Set the `Authority` for this URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let uri = uri::Builder::new()\n    ///     .authority(\"tokio.rs\")\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    pub fn authority<T>(&mut self, auth: T) -> &mut Self\n    where\n        Authority: HttpTryFrom<T>,\n    {\n        self.map(|parts| {\n            parts.authority = Some(auth.http_try_into()?);\n            Ok(())\n        })\n    }\n\n    /// Set the `PathAndQuery` for this URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let uri = uri::Builder::new()\n    ///     .path_and_query(\"/hello?foo=bar\")\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    pub fn path_and_query<T>(&mut self, p_and_q: T) -> &mut Self\n    where\n        PathAndQuery: HttpTryFrom<T>,\n    {\n        self.map(|parts| {\n            parts.path_and_query = Some(p_and_q.http_try_into()?);\n            Ok(())\n        })\n    }\n\n    /// Consumes this builder, and tries to construct a valid `Uri` from\n    /// the configured pieces.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if any previously configured argument\n    /// failed to parse or get converted to the internal representation. For\n    /// example if an invalid `scheme` was specified via `scheme(\"!@#%/^\")`\n    /// the error will be returned when this function is called rather than\n    /// when `scheme` was called.\n    ///\n    /// Additionally, the various forms of URI require certain combinations of\n    /// parts to be set to be valid. If the parts don't fit into any of the\n    /// valid forms of URI, a new error is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let uri = Uri::builder()\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    pub fn build(&mut self) -> Result<Uri> {\n        self\n            .parts\n            .take()\n            .expect(\"cannot reuse Uri builder\")\n            .and_then(|parts| parts.http_try_into())\n    }\n\n    fn map<F>(&mut self, f: F) -> &mut Self\n    where\n        F: FnOnce(&mut Parts) -> Result<()>,\n    {\n        let res = if let Some(Ok(ref mut parts)) = self.parts {\n            f(parts)\n        } else {\n            return self;\n        };\n\n        if let Err(err) = res {\n            self.parts = Some(Err(err));\n        }\n\n        self\n    }\n}","impl Default for Builder {\n    #[inline]\n    fn default() -> Builder {\n        Builder {\n            parts: Some(Ok(Parts::default())),\n        }\n    }\n}"],"uri::path::PathAndQuery":["Clone","impl Eq for PathAndQuery {}","impl FromStr for PathAndQuery {\n    type Err = InvalidUri;\n    #[inline]\n    fn from_str(s: &str) -> Result<Self, InvalidUri> {\n        HttpTryFrom::try_from(s)\n    }\n}","impl HttpTryFrom<$t> for $t {\n            type Error = Error;\n\n            fn try_from(t: Self) -> Result<Self, Self::Error> {\n                Ok(t)\n            }\n        }","impl HttpTryFrom<Bytes> for PathAndQuery {\n    type Error = InvalidUriBytes;\n    #[inline]\n    fn try_from(bytes: Bytes) -> Result<Self, Self::Error> {\n        PathAndQuery::from_shared(bytes)\n    }\n}","impl PartialEq for PathAndQuery {\n    #[inline]\n    fn eq(&self, other: &PathAndQuery) -> bool {\n        self.data == other.data\n    }\n}","impl PartialEq<String> for PathAndQuery {\n    #[inline]\n    fn eq(&self, other: &String) -> bool {\n        self.as_str() == other.as_str()\n    }\n}","impl PartialEq<str> for PathAndQuery {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        self.as_str() == other\n    }\n}","impl PartialOrd for PathAndQuery {\n    #[inline]\n    fn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(other.as_str())\n    }\n}","impl PartialOrd<String> for PathAndQuery {\n    #[inline]\n    fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(other.as_str())\n    }\n}","impl PartialOrd<str> for PathAndQuery {\n    #[inline]\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(other)\n    }\n}","impl PathAndQuery {\n    /// Attempt to convert a `PathAndQuery` from `Bytes`.\n    ///\n    /// This function will be replaced by a `TryFrom` implementation once the\n    /// trait lands in stable.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # extern crate http;\n    /// # use http::uri::*;\n    /// extern crate bytes;\n    ///\n    /// use bytes::Bytes;\n    ///\n    /// # pub fn main() {\n    /// let bytes = Bytes::from(\"/hello?world\");\n    /// let path_and_query = PathAndQuery::from_shared(bytes).unwrap();\n    ///\n    /// assert_eq!(path_and_query.path(), \"/hello\");\n    /// assert_eq!(path_and_query.query(), Some(\"world\"));\n    /// # }\n    /// ```\n    pub fn from_shared(mut src: Bytes) -> Result<Self, InvalidUriBytes> {\n        let mut query = NONE;\n        let mut fragment = None;\n\n        // block for iterator borrow\n        //\n        // allow: `...` pattersn are now `..=`, but we cannot update yet\n        // because of minimum Rust version\n        #[allow(warnings)]\n        {\n            let mut iter = src.as_ref().iter().enumerate();\n\n            // path ...\n            for (i, &b) in &mut iter {\n                // See https://url.spec.whatwg.org/#path-state\n                match b {\n                    b'?' => {\n                        debug_assert_eq!(query, NONE);\n                        query = i as u16;\n                        break;\n                    }\n                    b'#' => {\n                        fragment = Some(i);\n                        break;\n                    },\n\n                    // This is the range of bytes that don't need to be\n                    // percent-encoded in the path. If it should have been\n                    // percent-encoded, then error.\n                    0x21 |\n                    0x24...0x3B |\n                    0x3D |\n                    0x40...0x5F |\n                    0x61...0x7A |\n                    0x7C |\n                    0x7E => {},\n\n                    _ => return Err(ErrorKind::InvalidUriChar.into()),\n                }\n            }\n\n            // query ...\n            if query != NONE {\n\n                // allow: `...` pattersn are now `..=`, but we cannot update yet\n                // because of minimum Rust version\n                #[allow(warnings)]\n                for (i, &b) in iter {\n                    match b {\n                        // While queries *should* be percent-encoded, most\n                        // bytes are actually allowed...\n                        // See https://url.spec.whatwg.org/#query-state\n                        //\n                        // Allowed: 0x21 / 0x24 - 0x3B / 0x3D / 0x3F - 0x7E\n                        0x21 |\n                        0x24...0x3B |\n                        0x3D |\n                        0x3F...0x7E => {},\n\n                        b'#' => {\n                            fragment = Some(i);\n                            break;\n                        },\n\n                        _ => return Err(ErrorKind::InvalidUriChar.into()),\n                    }\n                }\n            }\n        }\n\n        if let Some(i) = fragment {\n            src.truncate(i);\n        }\n\n        Ok(PathAndQuery {\n            data: unsafe { ByteStr::from_utf8_unchecked(src) },\n            query: query,\n        })\n    }\n\n    /// Convert a `PathAndQuery` from a static string.\n    ///\n    /// This function will not perform any copying, however the string is\n    /// checked to ensure that it is valid.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the argument is an invalid path and query.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let v = PathAndQuery::from_static(\"/hello?world\");\n    ///\n    /// assert_eq!(v.path(), \"/hello\");\n    /// assert_eq!(v.query(), Some(\"world\"));\n    /// ```\n    #[inline]\n    pub fn from_static(src: &'static str) -> Self {\n        let src = Bytes::from_static(src.as_bytes());\n\n        PathAndQuery::from_shared(src)\n            .unwrap()\n    }\n\n    pub(super) fn empty() -> Self {\n        PathAndQuery {\n            data: ByteStr::new(),\n            query: NONE,\n        }\n    }\n\n    pub(super) fn slash() -> Self {\n        PathAndQuery {\n            data: ByteStr::from_static(\"/\"),\n            query: NONE,\n        }\n    }\n\n    pub(super) fn star() -> Self {\n        PathAndQuery {\n            data: ByteStr::from_static(\"*\"),\n            query: NONE,\n        }\n    }\n\n    /// Returns the path component\n    ///\n    /// The path component is **case sensitive**.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                        |--------|\n    ///                                             |\n    ///                                           path\n    /// ```\n    ///\n    /// If the URI is `*` then the path component is equal to `*`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    ///\n    /// let path_and_query: PathAndQuery = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(path_and_query.path(), \"/hello/world\");\n    /// ```\n    #[inline]\n    pub fn path(&self) -> &str {\n        let ret = if self.query == NONE {\n            &self.data[..]\n        } else {\n            &self.data[..self.query as usize]\n        };\n\n        if ret.is_empty() {\n            return \"/\";\n        }\n\n        ret\n    }\n\n    /// Returns the query string component\n    ///\n    /// The query component contains non-hierarchical data that, along with data\n    /// in the path component, serves to identify a resource within the scope of\n    /// the URI's scheme and naming authority (if any). The query component is\n    /// indicated by the first question mark (\"?\") character and terminated by a\n    /// number sign (\"#\") character or by the end of the URI.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                                   |-------------------|\n    ///                                                             |\n    ///                                                           query\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// With a query string component\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let path_and_query: PathAndQuery = \"/hello/world?key=value&foo=bar\".parse().unwrap();\n    ///\n    /// assert_eq!(path_and_query.query(), Some(\"key=value&foo=bar\"));\n    /// ```\n    ///\n    /// Without a query string component\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let path_and_query: PathAndQuery = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert!(path_and_query.query().is_none());\n    /// ```\n    #[inline]\n    pub fn query(&self) -> Option<&str> {\n        if self.query == NONE {\n            None\n        } else {\n            let i = self.query + 1;\n            Some(&self.data[i as usize..])\n        }\n    }\n\n    /// Returns the path and query as a string component.\n    ///\n    /// # Examples\n    ///\n    /// With a query string component\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let path_and_query: PathAndQuery = \"/hello/world?key=value&foo=bar\".parse().unwrap();\n    ///\n    /// assert_eq!(path_and_query.as_str(), \"/hello/world?key=value&foo=bar\");\n    /// ```\n    ///\n    /// Without a query string component\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let path_and_query: PathAndQuery = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(path_and_query.as_str(), \"/hello/world\");\n    /// ```\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        let ret = &self.data[..];\n        if ret.is_empty() {\n            return \"/\";\n        }\n        ret\n    }\n\n    /// Converts this `PathAndQuery` back to a sequence of bytes\n    #[inline]\n    pub fn into_bytes(self) -> Bytes {\n        self.into()\n    }\n}","impl Sealed for $t {}","impl fmt::Debug for PathAndQuery {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}","impl fmt::Display for PathAndQuery {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        if !self.data.is_empty() {\n            match self.data.as_bytes()[0] {\n                b'/' | b'*' => write!(fmt, \"{}\", &self.data[..]),\n                _ => write!(fmt, \"/{}\", &self.data[..]),\n            }\n        } else {\n            write!(fmt, \"/\")\n        }\n    }\n}","impl<'a> HttpTryFrom<&'a [u8]> for PathAndQuery {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {\n        PathAndQuery::from_shared(s.into()).map_err(|e| e.0)\n    }\n}","impl<'a> HttpTryFrom<&'a str> for PathAndQuery {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a str) -> Result<Self, Self::Error> {\n        HttpTryFrom::try_from(s.as_bytes())\n    }\n}","impl<'a> PartialEq<&'a str> for PathAndQuery {\n    #[inline]\n    fn eq(&self, other: &&'a str) -> bool {\n        self.as_str() == *other\n    }\n}","impl<'a> PartialOrd<&'a str> for PathAndQuery {\n    #[inline]\n    fn partial_cmp(&self, other: &&'a str) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(*other)\n    }\n}"],"uri::port::Port":["impl<T, U> PartialEq<Port<U>> for Port<T> {\n    fn eq(&self, other: &Port<U>) -> bool {\n        self.port == other.port\n    }\n}","impl<T> AsRef<str> for Port<T>\nwhere\n    T: AsRef<str>,\n{\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}","impl<T> PartialEq<u16> for Port<T> {\n    fn eq(&self, other: &u16) -> bool {\n        self.port == *other\n    }\n}","impl<T> Port<T>\nwhere\n    T: AsRef<str>,\n{\n    /// Converts a `str` to a port number.\n    ///\n    /// The supplied `str` must be a valid u16.\n    pub(crate) fn from_str(bytes: T) -> Result<Self, InvalidUri> {\n        bytes\n            .as_ref()\n            .parse::<u16>()\n            .map(|port| Port {\n                port,\n                repr: bytes,\n            })\n            .map_err(|_| {\n                ErrorKind::InvalidPort.into()\n            })\n    }\n\n    /// Returns the port number as a `str`.\n    ///\n    /// # Examples\n    ///\n    /// Port as `str`.\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = \"example.org:80\".parse().unwrap();\n    ///\n    /// let port = authority.port_part().unwrap();\n    /// assert_eq!(port.as_str(), \"80\");\n    /// ```\n    pub fn as_str(&self) -> &str {\n        self.repr.as_ref()\n    }\n}","impl<T> Port<T> {\n    /// Returns the port number as a `u16`.\n    ///\n    /// # Examples\n    ///\n    /// Port as `u16`.\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = \"example.org:80\".parse().unwrap();\n    ///\n    /// let port = authority.port_part().unwrap();\n    /// assert_eq!(port.as_u16(), 80);\n    /// ```\n    pub fn as_u16(&self) -> u16 {\n        self.port\n    }\n}","impl<T> fmt::Debug for Port<T>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"Port\")\n            .field(&self.port)\n            .finish()\n    }\n}","impl<T> fmt::Display for Port<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // Use `u16::fmt` so that it respects any formatting flags that\n        // may have been set (like padding, align, etc).\n        fmt::Display::fmt(&self.port, f)\n    }\n}"],"uri::scheme::Protocol":["Clone","Copy","Debug","impl Protocol {\n    pub(super) fn len(&self) -> usize {\n        match *self {\n            Protocol::Http => 4,\n            Protocol::Https => 5,\n        }\n    }\n}"],"uri::scheme::Scheme":["Clone","impl AsRef<str> for Scheme {\n    #[inline]\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}","impl Eq for Scheme {}","impl From<Scheme2> for Scheme {\n    fn from(src: Scheme2) -> Self {\n        Scheme { inner: src }\n    }\n}","impl FromStr for Scheme {\n    type Err = InvalidUri;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        HttpTryFrom::try_from(s)\n    }\n}","impl Hash for Scheme {\n    fn hash<H>(&self, state: &mut H) where H: Hasher {\n        match self.inner {\n            Scheme2::None => (),\n            Scheme2::Standard(Protocol::Http) => state.write_u8(1),\n            Scheme2::Standard(Protocol::Https) => state.write_u8(2),\n            Scheme2::Other(ref other) => {\n                other.len().hash(state);\n                for &b in other.as_bytes() {\n                    state.write_u8(b.to_ascii_lowercase());\n                }\n            }\n        }\n    }\n}","impl HttpTryFrom<$t> for $t {\n            type Error = Error;\n\n            fn try_from(t: Self) -> Result<Self, Self::Error> {\n                Ok(t)\n            }\n        }","impl HttpTryFrom<Bytes> for Scheme {\n    type Error = InvalidUriBytes;\n    #[inline]\n    fn try_from(bytes: Bytes) -> Result<Self, Self::Error> {\n        Scheme::from_shared(bytes)\n    }\n}","impl PartialEq for Scheme {\n    fn eq(&self, other: &Scheme) -> bool {\n        use self::Protocol::*;\n        use self::Scheme2::*;\n\n        match (&self.inner, &other.inner) {\n            (&Standard(Http), &Standard(Http)) => true,\n            (&Standard(Https), &Standard(Https)) => true,\n            (&Other(ref a), &Other(ref b)) => a.eq_ignore_ascii_case(b),\n            (&None, _) | (_, &None) => unreachable!(),\n            _ => false,\n        }\n    }\n}","impl PartialEq<str> for Scheme {\n    fn eq(&self, other: &str) -> bool {\n        self.as_str().eq_ignore_ascii_case(other)\n    }\n}","impl Scheme {\n    /// HTTP protocol scheme\n    pub const HTTP: Scheme = Scheme {\n        inner: Scheme2::Standard(Protocol::Http),\n    };\n\n    /// HTTP protocol over TLS.\n    pub const HTTPS: Scheme = Scheme {\n        inner: Scheme2::Standard(Protocol::Https),\n    };\n\n    /// Attempt to convert a `Scheme` from `Bytes`\n    ///\n    /// This function will be replaced by a `TryFrom` implementation once the\n    /// trait lands in stable.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # extern crate http;\n    /// # use http::uri::*;\n    /// extern crate bytes;\n    ///\n    /// use bytes::Bytes;\n    ///\n    /// # pub fn main() {\n    /// let bytes = Bytes::from(\"http\");\n    /// let scheme = Scheme::from_shared(bytes).unwrap();\n    ///\n    /// assert_eq!(scheme.as_str(), \"http\");\n    /// # }\n    /// ```\n    pub fn from_shared(s: Bytes) -> Result<Self, InvalidUriBytes> {\n        use self::Scheme2::*;\n\n        match Scheme2::parse_exact(&s[..]).map_err(InvalidUriBytes)? {\n            None => Err(ErrorKind::InvalidScheme.into()),\n            Standard(p) => Ok(Standard(p).into()),\n            Other(_) => {\n                let b = unsafe { ByteStr::from_utf8_unchecked(s) };\n                Ok(Other(Box::new(b)).into())\n            }\n        }\n    }\n\n    pub(super) fn empty() -> Self {\n        Scheme {\n            inner: Scheme2::None,\n        }\n    }\n\n    /// Return a str representation of the scheme\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let scheme: Scheme = \"http\".parse().unwrap();\n    /// assert_eq!(scheme.as_str(), \"http\");\n    /// ```\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        use self::Scheme2::*;\n        use self::Protocol::*;\n\n        match self.inner {\n            Standard(Http) => \"http\",\n            Standard(Https) => \"https\",\n            Other(ref v) => &v[..],\n            None => unreachable!(),\n        }\n    }\n\n    /// Converts this `Scheme` back to a sequence of bytes\n    #[inline]\n    pub fn into_bytes(self) -> Bytes {\n        self.into()\n    }\n}","impl Sealed for $t {}","impl fmt::Debug for Scheme {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(self.as_str(), f)\n    }\n}","impl fmt::Display for Scheme {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_str(self.as_str())\n    }\n}","impl<'a> HttpTryFrom<&'a [u8]> for Scheme {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {\n        use self::Scheme2::*;\n\n        match Scheme2::parse_exact(s)? {\n            None => Err(ErrorKind::InvalidScheme.into()),\n            Standard(p) => Ok(Standard(p).into()),\n            Other(_) => {\n                // Unsafe: parse_exact already checks for a strict subset of UTF-8\n                Ok(Other(Box::new(unsafe {\n                    ByteStr::from_utf8_unchecked(s.into())\n                })).into())\n            }\n        }\n    }\n}","impl<'a> HttpTryFrom<&'a str> for Scheme {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a str) -> Result<Self, Self::Error> {\n        HttpTryFrom::try_from(s.as_bytes())\n    }\n}"],"uri::scheme::Scheme2":["Clone","Debug","impl Scheme2<usize> {\n    fn parse_exact(s: &[u8]) -> Result<Scheme2<()>, InvalidUri> {\n        match s {\n            b\"http\" => Ok(Protocol::Http.into()),\n            b\"https\" => Ok(Protocol::Https.into()),\n            _ => {\n                if s.len() > MAX_SCHEME_LEN {\n                    return Err(ErrorKind::SchemeTooLong.into());\n                }\n\n                for &b in s {\n                    match SCHEME_CHARS[b as usize] {\n                        b':' => {\n                            // Don't want :// here\n                            return Err(ErrorKind::InvalidScheme.into());\n                        }\n                        0 => {\n                            return Err(ErrorKind::InvalidScheme.into());\n                        }\n                        _ => {}\n                    }\n                }\n\n                Ok(Scheme2::Other(()))\n            }\n        }\n    }\n\n    pub(super) fn parse(s: &[u8]) -> Result<Scheme2<usize>, InvalidUri> {\n        if s.len() >= 7 {\n            // Check for HTTP\n            if s[..7].eq_ignore_ascii_case(b\"http://\") {\n                // Prefix will be striped\n                return Ok(Protocol::Http.into());\n            }\n        }\n\n        if s.len() >= 8 {\n            // Check for HTTPs\n            if s[..8].eq_ignore_ascii_case(b\"https://\") {\n                return Ok(Protocol::Https.into());\n            }\n        }\n\n        if s.len() > 3 {\n            for i in 0..s.len() {\n                let b = s[i];\n\n                if i == MAX_SCHEME_LEN {\n                    return Err(ErrorKind::SchemeTooLong.into());\n                }\n\n                match SCHEME_CHARS[b as usize] {\n                    b':' => {\n                        // Not enough data remaining\n                        if s.len() < i + 3 {\n                            break;\n                        }\n\n                        // Not a scheme\n                        if &s[i+1..i+3] != b\"//\" {\n                            break;\n                        }\n\n                        // Return scheme\n                        return Ok(Scheme2::Other(i));\n                    }\n                    // Invald scheme character, abort\n                    0 => break,\n                    _ => {}\n                }\n            }\n        }\n\n        Ok(Scheme2::None)\n    }\n}","impl<T> From<Protocol> for Scheme2<T> {\n    fn from(src: Protocol) -> Self {\n        Scheme2::Standard(src)\n    }\n}","impl<T> Scheme2<T> {\n    pub(super) fn is_none(&self) -> bool {\n        match *self {\n            Scheme2::None => true,\n            _ => false,\n        }\n    }\n}"],"version::Http":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd"],"version::Version":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl Default for Version {\n    #[inline]\n    fn default() -> Version {\n        Version::HTTP_11\n    }\n}","impl Version {\n    /// `HTTP/0.9`\n    pub const HTTP_09: Version = Version(Http::Http09);\n\n    /// `HTTP/1.0`\n    pub const HTTP_10: Version = Version(Http::Http10);\n\n    /// `HTTP/1.1`\n    pub const HTTP_11: Version = Version(Http::Http11);\n\n    /// `HTTP/2.0`\n    pub const HTTP_2: Version = Version(Http::H2);\n}","impl fmt::Debug for Version {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::Http::*;\n\n        f.write_str(match self.0 {\n            Http09 => \"HTTP/0.9\",\n            Http10 => \"HTTP/1.0\",\n            Http11 => \"HTTP/1.1\",\n            H2     => \"HTTP/2.0\",\n        })\n    }\n}"]},"single_path_import":{"convert::HttpTryFrom":"HttpTryFrom","error::Error":"Error","error::Result":"Result","extensions::Extensions":"Extensions","header::map::Drain":"header::Drain","header::map::Entry":"header::Entry","header::map::GetAll":"header::GetAll","header::map::HeaderMap":"HeaderMap","header::map::IntoIter":"header::IntoIter","header::map::Iter":"header::Iter","header::map::IterMut":"header::IterMut","header::map::Keys":"header::Keys","header::map::OccupiedEntry":"header::OccupiedEntry","header::map::VacantEntry":"header::VacantEntry","header::map::ValueDrain":"header::ValueDrain","header::map::ValueIter":"header::ValueIter","header::map::ValueIterMut":"header::ValueIterMut","header::map::Values":"header::Values","header::map::ValuesMut":"header::ValuesMut","header::map::as_header_name::AsHeaderName":"header::AsHeaderName","header::map::into_header_name::IntoHeaderName":"header::IntoHeaderName","header::name::ACCEPT":"header::ACCEPT","header::name::ACCEPT_CHARSET":"header::ACCEPT_CHARSET","header::name::ACCEPT_ENCODING":"header::ACCEPT_ENCODING","header::name::ACCEPT_LANGUAGE":"header::ACCEPT_LANGUAGE","header::name::ACCEPT_RANGES":"header::ACCEPT_RANGES","header::name::ACCESS_CONTROL_ALLOW_CREDENTIALS":"header::ACCESS_CONTROL_ALLOW_CREDENTIALS","header::name::ACCESS_CONTROL_ALLOW_HEADERS":"header::ACCESS_CONTROL_ALLOW_HEADERS","header::name::ACCESS_CONTROL_ALLOW_METHODS":"header::ACCESS_CONTROL_ALLOW_METHODS","header::name::ACCESS_CONTROL_ALLOW_ORIGIN":"header::ACCESS_CONTROL_ALLOW_ORIGIN","header::name::ACCESS_CONTROL_EXPOSE_HEADERS":"header::ACCESS_CONTROL_EXPOSE_HEADERS","header::name::ACCESS_CONTROL_MAX_AGE":"header::ACCESS_CONTROL_MAX_AGE","header::name::ACCESS_CONTROL_REQUEST_HEADERS":"header::ACCESS_CONTROL_REQUEST_HEADERS","header::name::ACCESS_CONTROL_REQUEST_METHOD":"header::ACCESS_CONTROL_REQUEST_METHOD","header::name::AGE":"header::AGE","header::name::ALLOW":"header::ALLOW","header::name::ALT_SVC":"header::ALT_SVC","header::name::AUTHORIZATION":"header::AUTHORIZATION","header::name::CACHE_CONTROL":"header::CACHE_CONTROL","header::name::CONNECTION":"header::CONNECTION","header::name::CONTENT_DISPOSITION":"header::CONTENT_DISPOSITION","header::name::CONTENT_ENCODING":"header::CONTENT_ENCODING","header::name::CONTENT_LANGUAGE":"header::CONTENT_LANGUAGE","header::name::CONTENT_LENGTH":"header::CONTENT_LENGTH","header::name::CONTENT_LOCATION":"header::CONTENT_LOCATION","header::name::CONTENT_RANGE":"header::CONTENT_RANGE","header::name::CONTENT_SECURITY_POLICY":"header::CONTENT_SECURITY_POLICY","header::name::CONTENT_SECURITY_POLICY_REPORT_ONLY":"header::CONTENT_SECURITY_POLICY_REPORT_ONLY","header::name::CONTENT_TYPE":"header::CONTENT_TYPE","header::name::COOKIE":"header::COOKIE","header::name::DATE":"header::DATE","header::name::DNT":"header::DNT","header::name::ETAG":"header::ETAG","header::name::EXPECT":"header::EXPECT","header::name::EXPIRES":"header::EXPIRES","header::name::FORWARDED":"header::FORWARDED","header::name::FROM":"header::FROM","header::name::HOST":"header::HOST","header::name::HeaderName":"header::HeaderName","header::name::IF_MATCH":"header::IF_MATCH","header::name::IF_MODIFIED_SINCE":"header::IF_MODIFIED_SINCE","header::name::IF_NONE_MATCH":"header::IF_NONE_MATCH","header::name::IF_RANGE":"header::IF_RANGE","header::name::IF_UNMODIFIED_SINCE":"header::IF_UNMODIFIED_SINCE","header::name::InvalidHeaderName":"header::InvalidHeaderName","header::name::InvalidHeaderNameBytes":"header::InvalidHeaderNameBytes","header::name::LAST_MODIFIED":"header::LAST_MODIFIED","header::name::LINK":"header::LINK","header::name::LOCATION":"header::LOCATION","header::name::MAX_FORWARDS":"header::MAX_FORWARDS","header::name::ORIGIN":"header::ORIGIN","header::name::PRAGMA":"header::PRAGMA","header::name::PROXY_AUTHENTICATE":"header::PROXY_AUTHENTICATE","header::name::PROXY_AUTHORIZATION":"header::PROXY_AUTHORIZATION","header::name::PUBLIC_KEY_PINS":"header::PUBLIC_KEY_PINS","header::name::PUBLIC_KEY_PINS_REPORT_ONLY":"header::PUBLIC_KEY_PINS_REPORT_ONLY","header::name::RANGE":"header::RANGE","header::name::REFERER":"header::REFERER","header::name::REFERRER_POLICY":"header::REFERRER_POLICY","header::name::REFRESH":"header::REFRESH","header::name::RETRY_AFTER":"header::RETRY_AFTER","header::name::SEC_WEBSOCKET_ACCEPT":"header::SEC_WEBSOCKET_ACCEPT","header::name::SEC_WEBSOCKET_EXTENSIONS":"header::SEC_WEBSOCKET_EXTENSIONS","header::name::SEC_WEBSOCKET_KEY":"header::SEC_WEBSOCKET_KEY","header::name::SEC_WEBSOCKET_PROTOCOL":"header::SEC_WEBSOCKET_PROTOCOL","header::name::SEC_WEBSOCKET_VERSION":"header::SEC_WEBSOCKET_VERSION","header::name::SERVER":"header::SERVER","header::name::SET_COOKIE":"header::SET_COOKIE","header::name::STRICT_TRANSPORT_SECURITY":"header::STRICT_TRANSPORT_SECURITY","header::name::TE":"header::TE","header::name::TRAILER":"header::TRAILER","header::name::TRANSFER_ENCODING":"header::TRANSFER_ENCODING","header::name::UPGRADE":"header::UPGRADE","header::name::UPGRADE_INSECURE_REQUESTS":"header::UPGRADE_INSECURE_REQUESTS","header::name::USER_AGENT":"header::USER_AGENT","header::name::VARY":"header::VARY","header::name::VIA":"header::VIA","header::name::WARNING":"header::WARNING","header::name::WWW_AUTHENTICATE":"header::WWW_AUTHENTICATE","header::name::X_CONTENT_TYPE_OPTIONS":"header::X_CONTENT_TYPE_OPTIONS","header::name::X_DNS_PREFETCH_CONTROL":"header::X_DNS_PREFETCH_CONTROL","header::name::X_FRAME_OPTIONS":"header::X_FRAME_OPTIONS","header::name::X_XSS_PROTECTION":"header::X_XSS_PROTECTION","header::value::HeaderValue":"HeaderValue","header::value::InvalidHeaderValue":"header::InvalidHeaderValue","header::value::InvalidHeaderValueBytes":"header::InvalidHeaderValueBytes","header::value::ToStrError":"header::ToStrError","method::Method":"Method","request::Request":"Request","response::Response":"Response","status::StatusCode":"StatusCode","uri::Uri":"Uri","uri::authority::Authority":"uri::Authority","uri::builder::Builder":"uri::Builder","uri::path::PathAndQuery":"uri::PathAndQuery","uri::port::Port":"uri::Port","uri::scheme::Scheme":"uri::Scheme","version::Version":"Version"},"srcs":{"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Iter<'a, T>{\n        self.iter()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::as_str":["#[doc(hidden)]\nfn as_str(&self) -> &str{\n            <HeaderName>::as_str(*self)\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::entry":["#[doc(hidden)]\n#[inline]\nfn entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<T>, InvalidHeaderName>{\n            Ok(map.entry2(self))\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find":["#[doc(hidden)]\n#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            map.find(*self)\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::append":["#[doc(hidden)]\n#[inline]\nfn append<T>(self, map: &mut HeaderMap<T>, val: T) -> bool{\n            map.append2(self, val)\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::insert":["#[doc(hidden)]\n#[inline]\nfn insert<T>(self, map: &mut HeaderMap<T>, val: T) -> Option<T>{\n            map.insert2(self, val)\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'a header::name::HeaderName as std::cmp::PartialEq<header::name::HeaderName>>::eq":["#[inline]\nfn eq(&self, other: &HeaderName) -> bool{\n        *other == *self\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<&'a header::value::HeaderValue as std::cmp::PartialEq<header::value::HeaderValue>>::eq":["#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        **self == *other\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<&'a header::value::HeaderValue as std::cmp::PartialOrd<header::value::HeaderValue>>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        (**self).partial_cmp(other)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<&'a method::Method as std::cmp::PartialEq<method::Method>>::eq":["#[inline]\nfn eq(&self, other: &Method) -> bool{\n        *self == other\n    }","Real(LocalPath(\"src/method.rs\"))"],"<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> IterMut<'a, T>{\n        self.iter_mut()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'a std::string::String as header::map::as_header_name::Sealed>::as_str":["#[doc(hidden)]\nfn as_str(&self) -> &str{\n            *self\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'a std::string::String as header::map::as_header_name::Sealed>::entry":["#[doc(hidden)]\n#[inline]\nfn entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<T>, InvalidHeaderName>{\n            self.as_str().entry(map)\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'a std::string::String as header::map::as_header_name::Sealed>::find":["#[doc(hidden)]\n#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            Sealed::find(*self, map)\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'a str as header::map::as_header_name::Sealed>::as_str":["#[doc(hidden)]\nfn as_str(&self) -> &str{\n            self\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'a str as header::map::as_header_name::Sealed>::entry":["#[doc(hidden)]\n#[inline]\nfn entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<T>, InvalidHeaderName>{\n            HdrName::from_bytes(self.as_bytes(), move |hdr| map.entry2(hdr))\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'a str as header::map::as_header_name::Sealed>::find":["#[doc(hidden)]\n#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            HdrName::from_bytes(self.as_bytes(), move |hdr| map.find(&hdr)).unwrap_or(None)\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> ValueIter<'a, T>{\n        self.map.value_iter(self.index)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> ValueIter<'a, T>{\n        self.iter()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> ValueIterMut<'a, T>{\n        self.iter_mut()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'static str as header::map::into_header_name::Sealed>::append":["#[doc(hidden)]\n#[inline]\nfn append<T>(self, map: &mut HeaderMap<T>, val: T) -> bool{\n            HdrName::from_static(self, move |hdr| map.append2(hdr, val))\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<&'static str as header::map::into_header_name::Sealed>::insert":["#[doc(hidden)]\n#[inline]\nfn insert<T>(self, map: &mut HeaderMap<T>, val: T) -> Option<T>{\n            HdrName::from_static(self, move |hdr| map.insert2(hdr, val))\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<T as convert::HttpTryInto<U>>::http_try_into":["fn http_try_into(self) -> Result<U, Error>{\n        HttpTryFrom::try_from(self)\n            .map_err(|e: U::Error| e.into())\n    }","Real(LocalPath(\"src/convert.rs\"))"],"<byte_str::ByteStr as std::convert::From<&'a str>>::from":["#[inline]\nfn from(src: &'a str) -> ByteStr{\n        ByteStr { bytes: Bytes::from(src) }\n    }","Real(LocalPath(\"src/byte_str.rs\"))"],"<byte_str::ByteStr as std::convert::From<std::string::String>>::from":["#[inline]\nfn from(src: String) -> ByteStr{\n        ByteStr { bytes: Bytes::from(src) }\n    }","Real(LocalPath(\"src/byte_str.rs\"))"],"<byte_str::ByteStr as std::ops::Deref>::deref":["#[inline]\nfn deref(&self) -> &str{\n        let b: &[u8] = self.bytes.as_ref();\n        unsafe { str::from_utf8_unchecked(b) }\n    }","Real(LocalPath(\"src/byte_str.rs\"))"],"<error::Error as std::convert::From<error::Never>>::from":["fn from(never: Never) -> Error{\n        match never {}\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<header::name::InvalidHeaderName>>::from":["fn from(err: header::InvalidHeaderName) -> Error{\n        Error { inner: ErrorKind::HeaderName(err) }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<header::name::InvalidHeaderNameBytes>>::from":["fn from(err: header::InvalidHeaderNameBytes) -> Error{\n        Error { inner: ErrorKind::HeaderNameShared(err) }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<header::value::InvalidHeaderValue>>::from":["fn from(err: header::InvalidHeaderValue) -> Error{\n        Error { inner: ErrorKind::HeaderValue(err) }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<header::value::InvalidHeaderValueBytes>>::from":["fn from(err: header::InvalidHeaderValueBytes) -> Error{\n        Error { inner: ErrorKind::HeaderValueShared(err) }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<method::InvalidMethod>>::from":["fn from(err: method::InvalidMethod) -> Error{\n        Error { inner: ErrorKind::Method(err) }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<status::InvalidStatusCode>>::from":["fn from(err: status::InvalidStatusCode) -> Error{\n        Error { inner: ErrorKind::StatusCode(err) }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<uri::InvalidUri>>::from":["fn from(err: uri::InvalidUri) -> Error{\n        Error { inner: ErrorKind::Uri(err) }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<uri::InvalidUriBytes>>::from":["fn from(err: uri::InvalidUriBytes) -> Error{\n        Error { inner: ErrorKind::UriShared(err) }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<uri::InvalidUriParts>>::from":["fn from(err: uri::InvalidUriParts) -> Error{\n        Error { inner: ErrorKind::UriParts(err) }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::error::Error>::cause":["#[allow(warnings)]\nfn cause(&self) -> Option<&error::Error>{\n        self.get_ref().cause()\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::error::Error>::description":["fn description(&self) -> &str{\n        use self::ErrorKind::*;\n\n        match self.inner {\n            StatusCode(ref e) => e.description(),\n            Method(ref e) => e.description(),\n            Uri(ref e) => e.description(),\n            UriShared(ref e) => e.description(),\n            UriParts(ref e) => e.description(),\n            HeaderName(ref e) => e.description(),\n            HeaderNameShared(ref e) => e.description(),\n            HeaderValue(ref e) => e.description(),\n            HeaderValueShared(ref e) => e.description(),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_tuple(\"http::Error\")\n            // Skip the noise of the ErrorKind enum\n            .field(&self.get_ref())\n            .finish()\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Display::fmt(self.get_ref(), f)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Never as std::error::Error>::description":["fn description(&self) -> &str{\n        match *self {}\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Never as std::fmt::Debug>::fmt":["fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result{\n        match *self {}\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Never as std::fmt::Display>::fmt":["fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result{\n        match *self {}\n    }","Real(LocalPath(\"src/error.rs\"))"],"<extensions::Extensions as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"Extensions\")\n            .finish()\n    }","Real(LocalPath(\"src/extensions.rs\"))"],"<extensions::IdHasher as std::hash::Hasher>::finish":["#[inline]\nfn finish(&self) -> u64{\n        self.0\n    }","Real(LocalPath(\"src/extensions.rs\"))"],"<extensions::IdHasher as std::hash::Hasher>::write":["fn write(&mut self, _: &[u8]){\n        unreachable!(\"TypeId calls write_u64\");\n    }","Real(LocalPath(\"src/extensions.rs\"))"],"<extensions::IdHasher as std::hash::Hasher>::write_u64":["#[inline]\nfn write_u64(&mut self, id: u64){\n        self.0 = id;\n    }","Real(LocalPath(\"src/extensions.rs\"))"],"<header::map::Drain<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let idx = self.idx;\n\n        if idx == unsafe { (*self.map).entries.len() } {\n            return None;\n        }\n\n        self.idx += 1;\n\n        let key;\n        let value;\n        let next;\n\n        unsafe {\n            let entry = &(*self.map).entries[idx];\n\n            // Read the header name\n            key = ptr::read(&entry.key as *const _);\n            value = ptr::read(&entry.value as *const _);\n            next = entry.links.map(|l| l.next);\n        };\n\n        let values = ValueDrain {\n            map: self.map,\n            first: Some(value),\n            next: next,\n            lt: PhantomData,\n        };\n\n        Some((key, values))\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::Drain<'a, T> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let lower = unsafe { (*self.map).entries.len() } - self.idx;\n        (lower, Some(lower))\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::Drain<'a, T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        unsafe {\n            let map = &mut *self.map;\n            debug_assert!(map.extra_values.is_empty());\n            map.entries.set_len(0);\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Self) -> bool{\n        self.iter().eq(other.iter())\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> ValueIter<'a, T>{\n        self.map.value_iter(self.index)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::HeaderMap<T> as convert::HttpTryFrom<&'a std::collections::HashMap<K, V>>>::try_from":["fn try_from(c: &'a HashMap<K, V>) -> Result<Self, Self::Error>{\n        c.into_iter()\n            .map(|(k, v)| {\n                let name = k.http_try_into()?;\n                let value = v.http_try_into()?;\n                Ok((name, value))\n            })\n            .collect()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::HeaderMap<T> as convert::HttpTryFrom<header::map::HeaderMap<T>>>::try_from":["fn try_from(t: Self) -> Result<Self, Self::Error>{\n        Ok(t)\n    }","Real(LocalPath(\"src/convert.rs\"))"],"<header::map::HeaderMap<T> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &HeaderMap<T>) -> bool{\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.keys().all(|key| {\n            self.get_all(key) == other.get_all(key)\n        })\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::HeaderMap<T> as std::default::Default>::default":["fn default() -> Self{\n        HeaderMap::with_capacity(0)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::HeaderMap<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_map().entries(self.iter()).finish()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend":["fn extend<I: IntoIterator<Item = (HeaderName, T)>>(&mut self, iter: I){\n        // Keys may be already present or show multiple times in the iterator.\n        // Reserve the entire hint lower bound if the map is empty.\n        // Otherwise reserve half the hint (rounded up), so the map\n        // will only resize twice in the worst case.\n        let iter = iter.into_iter();\n\n        let reserve = if self.is_empty() {\n            iter.size_hint().0\n        } else {\n            (iter.size_hint().0 + 1) / 2\n        };\n\n        self.reserve(reserve);\n\n        for (k, v) in iter {\n            self.append(k, v);\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend":["/// Extend a `HeaderMap` with the contents of another `HeaderMap`.\n///\n/// This function expects the yielded items to follow the same structure as\n/// `IntoIter`.\n///\n/// # Panics\n///\n/// This panics if the first yielded item does not have a `HeaderName`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(ACCEPT, \"text/plain\".parse().unwrap());\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n///\n/// let mut extra = HeaderMap::new();\n///\n/// extra.insert(HOST, \"foo.bar\".parse().unwrap());\n/// extra.insert(COOKIE, \"hello\".parse().unwrap());\n/// extra.append(COOKIE, \"world\".parse().unwrap());\n///\n/// map.extend(extra);\n///\n/// assert_eq!(map[\"host\"], \"foo.bar\");\n/// assert_eq!(map[\"accept\"], \"text/plain\");\n/// assert_eq!(map[\"cookie\"], \"hello\");\n///\n/// let v = map.get_all(\"host\");\n/// assert_eq!(1, v.iter().count());\n///\n/// let v = map.get_all(\"cookie\");\n/// assert_eq!(2, v.iter().count());\n/// ```\nfn extend<I: IntoIterator<Item = (Option<HeaderName>, T)>>(&mut self, iter: I){\n        let mut iter = iter.into_iter();\n\n        // The structure of this is a bit weird, but it is mostly to make the\n        // borrow checker happy.\n        let (mut key, mut val) = match iter.next() {\n            Some((Some(key), val)) => (key, val),\n            Some((None, _)) => panic!(\"expected a header name, but got None\"),\n            None => return,\n        };\n\n        'outer:\n        loop {\n            let mut entry = match self.entry2(key) {\n                Entry::Occupied(mut e) => {\n                    // Replace all previous values while maintaining a handle to\n                    // the entry.\n                    e.insert(val);\n                    e\n                }\n                Entry::Vacant(e) => {\n                    e.insert_entry(val)\n                }\n            };\n\n            // As long as `HeaderName` is none, keep inserting the value into\n            // the current entry\n            'inner:\n            loop {\n                match iter.next() {\n                    Some((Some(k), v)) => {\n                        key = k;\n                        val = v;\n                        continue 'outer;\n                    }\n                    Some((None, v)) => {\n                        entry.append(v);\n                    }\n                    None => {\n                        return;\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter":["fn from_iter<I>(iter: I) -> Self\n        where I: IntoIterator<Item = (HeaderName, T)>{\n       let mut map = HeaderMap::default();\n       map.extend(iter);\n       map\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":["/// Creates a consuming iterator, that is, one that moves keys and values\n/// out of the map in arbitrary order. The map cannot be used after calling\n/// this.\n///\n/// For each yielded item that has `None` provided for the `HeaderName`,\n/// then the associated header name is the same as that of the previously\n/// yielded item. The first yielded item will have `HeaderName` set.\n///\n/// # Examples\n///\n/// Basic usage.\n///\n/// ```\n/// # use http::header;\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n/// map.insert(header::CONTENT_LENGTH, \"123\".parse().unwrap());\n/// map.insert(header::CONTENT_TYPE, \"json\".parse().unwrap());\n///\n/// let mut iter = map.into_iter();\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), \"123\".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), \"json\".parse().unwrap())));\n/// assert!(iter.next().is_none());\n/// ```\n///\n/// Multiple values per key.\n///\n/// ```\n/// # use http::header;\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n///\n/// map.append(header::CONTENT_LENGTH, \"123\".parse().unwrap());\n/// map.append(header::CONTENT_LENGTH, \"456\".parse().unwrap());\n///\n/// map.append(header::CONTENT_TYPE, \"json\".parse().unwrap());\n/// map.append(header::CONTENT_TYPE, \"html\".parse().unwrap());\n/// map.append(header::CONTENT_TYPE, \"xml\".parse().unwrap());\n///\n/// let mut iter = map.into_iter();\n///\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), \"123\".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((None, \"456\".parse().unwrap())));\n///\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), \"json\".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((None, \"html\".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((None, \"xml\".parse().unwrap())));\n/// assert!(iter.next().is_none());\n/// ```\nfn into_iter(self) -> IntoIter<T>{\n        IntoIter {\n            next: None,\n            entries: self.entries.into_iter(),\n            extra_values: self.extra_values,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::HeaderMap<T> as std::ops::Index<K>>::index":["/// # Panics\n/// Using the index operator will cause a panic if the header you're querying isn't set.\n#[inline]\nfn index(&self, index: K) -> &T{\n        match self.get2(&index) {\n            Some(val) => val,\n            None => panic!(\"no entry found for key {:?}\", index.as_str()),\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::IntoIter<T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        if let Some(next) = self.next {\n            self.next = match self.extra_values[next].next {\n                Link::Entry(_) => None,\n                Link::Extra(v) => Some(v),\n            };\n\n            let value = unsafe { ptr::read(&self.extra_values[next].value) };\n\n            return Some((None, value));\n        }\n\n        if let Some(bucket) = self.entries.next() {\n            self.next = bucket.links.map(|l| l.next);\n            let name = Some(bucket.key);\n            let value = bucket.value;\n\n            return Some((name, value));\n        }\n\n        None\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::IntoIter<T> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let (lower, _) = self.entries.size_hint();\n        // There could be more than just the entries upper, as there\n        // could be items in the `extra_values`. We could guess, saying\n        // `upper + extra_values.len()`, but that could overestimate by a lot.\n        (lower, None)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::IntoIter<T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        // Ensure the iterator is consumed\n        for _ in self.by_ref() { }\n\n        // All the values have already been yielded out.\n        unsafe { self.extra_values.set_len(0); }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::Iter<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.inner.next_unsafe().map(|(key, ptr)| {\n            (key, unsafe { &*ptr })\n        })\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::Iter<'a, T> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::IterMut<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.next_unsafe().map(|(key, ptr)| {\n            (key, unsafe { &mut *ptr })\n        })\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let map = unsafe { &*self.map };\n        debug_assert!(map.entries.len() >= self.entry);\n\n        let lower = map.entries.len() - self.entry;\n        // We could pessimistically guess at the upper bound, saying\n        // that its lower + map.extra_values.len(). That could be\n        // way over though, such as if we're near the end, and have\n        // already gone through several extra values...\n        (lower, None)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::Keys<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.inner.next().map(|b| &b.key)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::Keys<'a, T> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> ValueIterMut<'a, T>{\n        self.map.value_iter_mut(self.index)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::ValueDrain<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<T>{\n        if self.first.is_some() {\n            self.first.take()\n        } else if let Some(next) = self.next {\n            // Remove the extra value\n            let extra = unsafe { &mut (*self.map) }.remove_extra_value(next);\n\n            match extra.next {\n                Link::Extra(idx) => self.next = Some(idx),\n                Link::Entry(_) => self.next = None,\n            }\n\n            Some(extra.value)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        match (&self.first, self.next) {\n            // Exactly 1\n            (&Some(_), None) => (1, Some(1)),\n            // At least 1\n            (&_, Some(_)) => (1, None),\n            // No more\n            (&None, None) => (0, Some(0)),\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::ValueDrain<'a, T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        while let Some(_) = self.next() {\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n\n        match self.back {\n            Some(Head) => {\n                self.front = None;\n                self.back = None;\n                Some(&self.map.entries[self.index].value)\n            }\n            Some(Values(idx)) => {\n                let extra = &self.map.extra_values[idx];\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.prev {\n                        Link::Entry(_) => self.back = Some(Head),\n                        Link::Extra(idx) => self.back = Some(Values(idx)),\n                    }\n                }\n\n                Some(&extra.value)\n            }\n            None => None,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::ValueIter<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n\n        match self.front {\n            Some(Head) => {\n                let entry = &self.map.entries[self.index];\n\n                if self.back == Some(Head) {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    // Update the iterator state\n                    match entry.links {\n                        Some(links) => {\n                            self.front = Some(Values(links.next));\n                        }\n                        None => unreachable!(),\n                    }\n                }\n\n                Some(&entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = &self.map.extra_values[idx];\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.next {\n                        Link::Entry(_) => self.front = None,\n                        Link::Extra(i) => self.front = Some(Values(i)),\n                    }\n                }\n\n                Some(&extra.value)\n            }\n            None => None,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        match (self.front, self.back) {\n            // Exactly 1 value...\n            (Some(Cursor::Head), Some(Cursor::Head)) => (1, Some(1)),\n            // At least 1...\n            (Some(_), _) => (1, None),\n            // No more values...\n            (None, _) => (0, Some(0)),\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n        let entry = unsafe { &mut (*self.map).entries[self.index] };\n\n        match self.back {\n            Some(Head) => {\n                self.front = None;\n                self.back = None;\n                Some(&mut entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.prev {\n                        Link::Entry(_) => self.back = Some(Head),\n                        Link::Extra(idx) => self.back = Some(Values(idx)),\n                    }\n                }\n\n                Some(&mut extra.value)\n            }\n            None => None,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n        let entry = unsafe { &mut (*self.map).entries[self.index] };\n\n        match self.front {\n            Some(Head) => {\n                if self.back == Some(Head) {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    // Update the iterator state\n                    match entry.links {\n                        Some(links) => {\n                            self.front = Some(Values(links.next));\n                        }\n                        None => unreachable!(),\n                    }\n                }\n\n                Some(&mut entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.next {\n                        Link::Entry(_) => self.front = None,\n                        Link::Extra(i) => self.front = Some(Values(i)),\n                    }\n                }\n\n                Some(&mut extra.value)\n            }\n            None => None,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::Values<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.inner.next().map(|(_, v)| v)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::Values<'a, T> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::ValuesMut<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.inner.next().map(|(_, v)| v)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::name::Custom as std::hash::Hash>::hash":["#[inline]\nfn hash<H: Hasher>(&self, hasher: &mut H){\n        hasher.write(self.0.as_bytes())\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HdrName<'a> as std::convert::From<header::name::StandardHeader>>::from":["fn from(hdr: StandardHeader) -> HdrName<'a>{\n        HdrName { inner: Repr::Standard(hdr) }\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as convert::HttpTryFrom<&'a [u8]>>::try_from":["#[inline]\nfn try_from(s: &'a [u8]) -> Result<Self, Self::Error>{\n        Self::from_bytes(s)\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as convert::HttpTryFrom<&'a header::name::HeaderName>>::try_from":["#[inline]\nfn try_from(t: &'a HeaderName) -> Result<Self, Self::Error>{\n        Ok(t.clone())\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as convert::HttpTryFrom<&'a std::string::String>>::try_from":["#[inline]\nfn try_from(s: &'a String) -> Result<Self, Self::Error>{\n        Self::from_bytes(s.as_bytes())\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as convert::HttpTryFrom<&'a str>>::try_from":["#[inline]\nfn try_from(s: &'a str) -> Result<Self, Self::Error>{\n        Self::from_bytes(s.as_bytes())\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as convert::HttpTryFrom<bytes::Bytes>>::try_from":["#[inline]\nfn try_from(bytes: Bytes) -> Result<Self, Self::Error>{\n        Self::from_bytes(bytes.as_ref()).map_err(InvalidHeaderNameBytes)\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as convert::HttpTryFrom<header::name::HeaderName>>::try_from":["fn try_from(t: Self) -> Result<Self, Self::Error>{\n                Ok(t)\n            }","Real(LocalPath(\"src/convert.rs\"))"],"<header::name::HeaderName as header::map::as_header_name::Sealed>::as_str":["#[doc(hidden)]\nfn as_str(&self) -> &str{\n            <HeaderName>::as_str(self)\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::name::HeaderName as header::map::as_header_name::Sealed>::entry":["#[doc(hidden)]\n#[inline]\nfn entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<T>, InvalidHeaderName>{\n            Ok(map.entry2(self))\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::name::HeaderName as header::map::as_header_name::Sealed>::find":["#[doc(hidden)]\n#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            map.find(self)\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::name::HeaderName as header::map::into_header_name::Sealed>::append":["#[doc(hidden)]\n#[inline]\nfn append<T>(self, map: &mut HeaderMap<T>, val: T) -> bool{\n            map.append2(self, val)\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::name::HeaderName as header::map::into_header_name::Sealed>::insert":["#[doc(hidden)]\n#[inline]\nfn insert<T>(self, map: &mut HeaderMap<T>, val: T) -> Option<T>{\n            map.insert2(self, val)\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<header::name::HeaderName as std::borrow::Borrow<str>>::borrow":["fn borrow(&self) -> &str{\n        self.as_str()\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as std::cmp::PartialEq<&'a header::name::HeaderName>>::eq":["#[inline]\nfn eq(&self, other: &&'a HeaderName) -> bool{\n        *self == **other\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as std::cmp::PartialEq<&'a str>>::eq":["/// Performs a case-insensitive comparison of the string against the header\n/// name\n#[inline]\nfn eq(&self, other: &&'a str) -> bool{\n        *self == **other\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as std::cmp::PartialEq<header::name::HdrName<'a>>>::eq":["#[inline]\nfn eq(&self, other: &HdrName<'a>) -> bool{\n        match self.inner {\n            Repr::Standard(a) => {\n                match other.inner {\n                    Repr::Standard(b) => a == b,\n                    _ => false,\n                }\n            }\n            Repr::Custom(Custom(ref a)) => {\n                match other.inner {\n                    Repr::Custom(ref b) => {\n                        if b.lower {\n                            a.as_bytes() == b.buf\n                        } else {\n                            eq_ignore_ascii_case(a.as_bytes(), b.buf)\n                        }\n                    }\n                    _ => false,\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as std::cmp::PartialEq<str>>::eq":["/// Performs a case-insensitive comparison of the string against the header\n/// name\n///\n/// # Examples\n///\n/// ```\n/// use http::header::CONTENT_LENGTH;\n///\n/// assert_eq!(CONTENT_LENGTH, \"content-length\");\n/// assert_eq!(CONTENT_LENGTH, \"Content-Length\");\n/// assert_ne!(CONTENT_LENGTH, \"content length\");\n/// ```\n#[inline]\nfn eq(&self, other: &str) -> bool{\n        eq_ignore_ascii_case(self.as_ref(), other.as_bytes())\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as std::convert::AsRef<[u8]>>::as_ref":["fn as_ref(&self) -> &[u8]{\n        self.as_str().as_bytes()\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as std::convert::AsRef<str>>::as_ref":["fn as_ref(&self) -> &str{\n        self.as_str()\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as std::convert::From<&'a header::name::HeaderName>>::from":["fn from(src: &'a HeaderName) -> HeaderName{\n        src.clone()\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as std::convert::From<header::name::Custom>>::from":["fn from(src: Custom) -> HeaderName{\n        HeaderName { inner: Repr::Custom(src) }\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as std::convert::From<header::name::HdrName<'a>>>::from":["fn from(src: HdrName<'a>) -> HeaderName{\n        match src.inner {\n            Repr::Standard(s) => {\n                HeaderName {\n                    inner: Repr::Standard(s),\n                }\n            }\n            Repr::Custom(maybe_lower) => {\n                if maybe_lower.lower {\n                    let buf = Bytes::from(&maybe_lower.buf[..]);\n                    let byte_str = unsafe { ByteStr::from_utf8_unchecked(buf) };\n\n                    HeaderName {\n                        inner: Repr::Custom(Custom(byte_str)),\n                    }\n                } else {\n                    use bytes::{BufMut};\n                    let mut dst = BytesMut::with_capacity(maybe_lower.buf.len());\n\n                    for b in maybe_lower.buf.iter() {\n                        dst.put(HEADER_CHARS[*b as usize]);\n                    }\n\n                    let buf = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };\n\n                    HeaderName {\n                        inner: Repr::Custom(Custom(buf)),\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as std::convert::From<header::name::StandardHeader>>::from":["fn from(src: StandardHeader) -> HeaderName{\n        HeaderName {\n            inner: Repr::Standard(src),\n        }\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Debug::fmt(self.as_str(), fmt)\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as std::fmt::Display>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Display::fmt(self.as_str(), fmt)\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::HeaderName as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<HeaderName, InvalidHeaderName>{\n        HeaderName::from_bytes(s.as_bytes())\n            .map_err(|_| InvalidHeaderName {\n                _priv: (),\n            })\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::InvalidHeaderName as std::error::Error>::description":["fn description(&self) -> &str{\n        \"invalid HTTP header name\"\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::InvalidHeaderName as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"InvalidHeaderName\")\n            // skip _priv noise\n            .finish()\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::InvalidHeaderName as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.description().fmt(f)\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::InvalidHeaderNameBytes as std::error::Error>::description":["fn description(&self) -> &str{\n        self.0.description()\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::InvalidHeaderNameBytes as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::name::MaybeLower<'a> as std::hash::Hash>::hash":["#[inline]\nfn hash<H: Hasher>(&self, hasher: &mut H){\n        if self.lower {\n            hasher.write(self.buf);\n        } else {\n            for &b in self.buf {\n                hasher.write(&[HEADER_CHARS[b as usize]]);\n            }\n        }\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<&'a [u8]>>::try_from":["#[inline]\nfn try_from(t: &'a [u8]) -> Result<Self, Self::Error>{\n        HeaderValue::from_bytes(t)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<&'a header::value::HeaderValue>>::try_from":["#[inline]\nfn try_from(t: &'a HeaderValue) -> Result<Self, Self::Error>{\n        Ok(t.clone())\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<&'a std::string::String>>::try_from":["#[inline]\nfn try_from(s: &'a String) -> Result<Self, Self::Error>{\n        Self::from_bytes(s.as_bytes())\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<&'a str>>::try_from":["#[inline]\nfn try_from(t: &'a str) -> Result<Self, Self::Error>{\n        t.parse()\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<bytes::Bytes>>::try_from":["#[inline]\nfn try_from(bytes: Bytes) -> Result<Self, Self::Error>{\n        HeaderValue::from_shared(bytes)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<header::name::HeaderName>>::try_from":["#[inline]\nfn try_from(name: HeaderName) -> Result<Self, Self::Error>{\n        // Infallable as header names have the same validations\n        Ok(name.into())\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<header::value::HeaderValue>>::try_from":["fn try_from(t: Self) -> Result<Self, Self::Error>{\n                Ok(t)\n            }","Real(LocalPath(\"src/convert.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<i16>>::try_from":["#[inline]\nfn try_from(num: $t) -> Result<Self, Self::Error>{\n                Ok(num.into())\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<i32>>::try_from":["#[inline]\nfn try_from(num: $t) -> Result<Self, Self::Error>{\n                Ok(num.into())\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<i64>>::try_from":["#[inline]\nfn try_from(num: $t) -> Result<Self, Self::Error>{\n                Ok(num.into())\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<isize>>::try_from":["#[inline]\nfn try_from(num: $t) -> Result<Self, Self::Error>{\n                Ok(num.into())\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<std::string::String>>::try_from":["#[inline]\nfn try_from(t: String) -> Result<Self, Self::Error>{\n        HeaderValue::from_shared(t.into())\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<u16>>::try_from":["#[inline]\nfn try_from(num: $t) -> Result<Self, Self::Error>{\n                Ok(num.into())\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<u32>>::try_from":["#[inline]\nfn try_from(num: $t) -> Result<Self, Self::Error>{\n                Ok(num.into())\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<u64>>::try_from":["#[inline]\nfn try_from(num: $t) -> Result<Self, Self::Error>{\n                Ok(num.into())\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as convert::HttpTryFrom<usize>>::try_from":["#[inline]\nfn try_from(num: $t) -> Result<Self, Self::Error>{\n                Ok(num.into())\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::cmp::Ord>::cmp":["#[inline]\nfn cmp(&self, other: &Self) -> cmp::Ordering{\n        self.inner.cmp(&other.inner)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq":["#[inline]\nfn eq(&self, other: &&'a T) -> bool{\n        *self == **other\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::cmp::PartialEq<[u8]>>::eq":["#[inline]\nfn eq(&self, other: &[u8]) -> bool{\n        self.inner == other\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::cmp::PartialEq<std::string::String>>::eq":["#[inline]\nfn eq(&self, other: &String) -> bool{\n        *self == &other[..]\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::cmp::PartialEq<str>>::eq":["#[inline]\nfn eq(&self, other: &str) -> bool{\n        self.inner == other.as_bytes()\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::cmp::PartialEq>::eq":["#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        self.inner == other.inner\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &&'a T) -> Option<cmp::Ordering>{\n        self.partial_cmp(*other)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::cmp::PartialOrd<[u8]>>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &[u8]) -> Option<cmp::Ordering>{\n        (*self.inner).partial_cmp(other)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::cmp::PartialOrd<std::string::String>>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &String) -> Option<cmp::Ordering>{\n        self.inner.partial_cmp(other.as_bytes())\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::cmp::PartialOrd<str>>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &str) -> Option<cmp::Ordering>{\n        (*self.inner).partial_cmp(other.as_bytes())\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::cmp::PartialOrd>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        self.inner.partial_cmp(&other.inner)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::convert::AsRef<[u8]>>::as_ref":["#[inline]\nfn as_ref(&self) -> &[u8]{\n        self.inner.as_ref()\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::convert::From<&'a header::value::HeaderValue>>::from":["#[inline]\nfn from(t: &'a HeaderValue) -> Self{\n        t.clone()\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::convert::From<header::name::HeaderName>>::from":["#[inline]\nfn from(h: HeaderName) -> HeaderValue{\n        HeaderValue {\n            inner: h.into(),\n            is_sensitive: false,\n        }\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::convert::From<i16>>::from":["fn from(num: $t) -> HeaderValue{\n                let mut buf = if mem::size_of::<BytesMut>() - 1 < $max_len {\n                    // On 32bit platforms, BytesMut max inline size\n                    // is 15 bytes, but the $max_len could be bigger.\n                    //\n                    // The likelihood of the number *actually* being\n                    // that big is very small, so only allocate\n                    // if the number needs that space.\n                    //\n                    // The largest decimal number in 15 digits:\n                    // It wold be 10.pow(15) - 1, but this is a constant\n                    // version.\n                    if num as u64 > 999_999_999_999_999_999 {\n                        BytesMut::with_capacity($max_len)\n                    } else {\n                        // fits inline...\n                        BytesMut::new()\n                    }\n                } else {\n                    // full value fits inline, so don't allocate!\n                    BytesMut::new()\n                };\n                let _ = ::itoa::fmt(&mut buf, num);\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::convert::From<i32>>::from":["fn from(num: $t) -> HeaderValue{\n                let mut buf = if mem::size_of::<BytesMut>() - 1 < $max_len {\n                    // On 32bit platforms, BytesMut max inline size\n                    // is 15 bytes, but the $max_len could be bigger.\n                    //\n                    // The likelihood of the number *actually* being\n                    // that big is very small, so only allocate\n                    // if the number needs that space.\n                    //\n                    // The largest decimal number in 15 digits:\n                    // It wold be 10.pow(15) - 1, but this is a constant\n                    // version.\n                    if num as u64 > 999_999_999_999_999_999 {\n                        BytesMut::with_capacity($max_len)\n                    } else {\n                        // fits inline...\n                        BytesMut::new()\n                    }\n                } else {\n                    // full value fits inline, so don't allocate!\n                    BytesMut::new()\n                };\n                let _ = ::itoa::fmt(&mut buf, num);\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::convert::From<i64>>::from":["fn from(num: $t) -> HeaderValue{\n                let mut buf = if mem::size_of::<BytesMut>() - 1 < $max_len {\n                    // On 32bit platforms, BytesMut max inline size\n                    // is 15 bytes, but the $max_len could be bigger.\n                    //\n                    // The likelihood of the number *actually* being\n                    // that big is very small, so only allocate\n                    // if the number needs that space.\n                    //\n                    // The largest decimal number in 15 digits:\n                    // It wold be 10.pow(15) - 1, but this is a constant\n                    // version.\n                    if num as u64 > 999_999_999_999_999_999 {\n                        BytesMut::with_capacity($max_len)\n                    } else {\n                        // fits inline...\n                        BytesMut::new()\n                    }\n                } else {\n                    // full value fits inline, so don't allocate!\n                    BytesMut::new()\n                };\n                let _ = ::itoa::fmt(&mut buf, num);\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::convert::From<isize>>::from":["fn from(num: $t) -> HeaderValue{\n                let mut buf = if mem::size_of::<BytesMut>() - 1 < $max_len {\n                    // On 32bit platforms, BytesMut max inline size\n                    // is 15 bytes, but the $max_len could be bigger.\n                    //\n                    // The likelihood of the number *actually* being\n                    // that big is very small, so only allocate\n                    // if the number needs that space.\n                    //\n                    // The largest decimal number in 15 digits:\n                    // It wold be 10.pow(15) - 1, but this is a constant\n                    // version.\n                    if num as u64 > 999_999_999_999_999_999 {\n                        BytesMut::with_capacity($max_len)\n                    } else {\n                        // fits inline...\n                        BytesMut::new()\n                    }\n                } else {\n                    // full value fits inline, so don't allocate!\n                    BytesMut::new()\n                };\n                let _ = ::itoa::fmt(&mut buf, num);\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::convert::From<u16>>::from":["fn from(num: $t) -> HeaderValue{\n                let mut buf = if mem::size_of::<BytesMut>() - 1 < $max_len {\n                    // On 32bit platforms, BytesMut max inline size\n                    // is 15 bytes, but the $max_len could be bigger.\n                    //\n                    // The likelihood of the number *actually* being\n                    // that big is very small, so only allocate\n                    // if the number needs that space.\n                    //\n                    // The largest decimal number in 15 digits:\n                    // It wold be 10.pow(15) - 1, but this is a constant\n                    // version.\n                    if num as u64 > 999_999_999_999_999_999 {\n                        BytesMut::with_capacity($max_len)\n                    } else {\n                        // fits inline...\n                        BytesMut::new()\n                    }\n                } else {\n                    // full value fits inline, so don't allocate!\n                    BytesMut::new()\n                };\n                let _ = ::itoa::fmt(&mut buf, num);\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::convert::From<u32>>::from":["fn from(num: $t) -> HeaderValue{\n                let mut buf = if mem::size_of::<BytesMut>() - 1 < $max_len {\n                    // On 32bit platforms, BytesMut max inline size\n                    // is 15 bytes, but the $max_len could be bigger.\n                    //\n                    // The likelihood of the number *actually* being\n                    // that big is very small, so only allocate\n                    // if the number needs that space.\n                    //\n                    // The largest decimal number in 15 digits:\n                    // It wold be 10.pow(15) - 1, but this is a constant\n                    // version.\n                    if num as u64 > 999_999_999_999_999_999 {\n                        BytesMut::with_capacity($max_len)\n                    } else {\n                        // fits inline...\n                        BytesMut::new()\n                    }\n                } else {\n                    // full value fits inline, so don't allocate!\n                    BytesMut::new()\n                };\n                let _ = ::itoa::fmt(&mut buf, num);\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::convert::From<u64>>::from":["fn from(num: $t) -> HeaderValue{\n                let mut buf = if mem::size_of::<BytesMut>() - 1 < $max_len {\n                    // On 32bit platforms, BytesMut max inline size\n                    // is 15 bytes, but the $max_len could be bigger.\n                    //\n                    // The likelihood of the number *actually* being\n                    // that big is very small, so only allocate\n                    // if the number needs that space.\n                    //\n                    // The largest decimal number in 15 digits:\n                    // It wold be 10.pow(15) - 1, but this is a constant\n                    // version.\n                    if num as u64 > 999_999_999_999_999_999 {\n                        BytesMut::with_capacity($max_len)\n                    } else {\n                        // fits inline...\n                        BytesMut::new()\n                    }\n                } else {\n                    // full value fits inline, so don't allocate!\n                    BytesMut::new()\n                };\n                let _ = ::itoa::fmt(&mut buf, num);\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::convert::From<usize>>::from":["fn from(num: $t) -> HeaderValue{\n                let mut buf = if mem::size_of::<BytesMut>() - 1 < $max_len {\n                    // On 32bit platforms, BytesMut max inline size\n                    // is 15 bytes, but the $max_len could be bigger.\n                    //\n                    // The likelihood of the number *actually* being\n                    // that big is very small, so only allocate\n                    // if the number needs that space.\n                    //\n                    // The largest decimal number in 15 digits:\n                    // It wold be 10.pow(15) - 1, but this is a constant\n                    // version.\n                    if num as u64 > 999_999_999_999_999_999 {\n                        BytesMut::with_capacity($max_len)\n                    } else {\n                        // fits inline...\n                        BytesMut::new()\n                    }\n                } else {\n                    // full value fits inline, so don't allocate!\n                    BytesMut::new()\n                };\n                let _ = ::itoa::fmt(&mut buf, num);\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if self.is_sensitive {\n            f.write_str(\"Sensitive\")\n        } else {\n            f.write_str(\"\\\"\")?;\n            let mut from = 0;\n            let bytes = self.as_bytes();\n            for (i, &b) in bytes.iter().enumerate() {\n                if !is_visible_ascii(b) || b == b'\"' {\n                    if from != i {\n                        f.write_str(unsafe {\n                            str::from_utf8_unchecked(&bytes[from..i])\n                        })?;\n                    }\n                    if b == b'\"' {\n                        f.write_str(\"\\\\\\\"\")?;\n                    } else {\n                        write!(f, \"\\\\x{:x}\", b)?;\n                    }\n                    from = i + 1;\n                }\n            }\n\n            f.write_str(unsafe {\n                str::from_utf8_unchecked(&bytes[from..])\n            })?;\n            f.write_str(\"\\\"\")\n        }\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::HeaderValue as std::str::FromStr>::from_str":["#[inline]\nfn from_str(s: &str) -> Result<HeaderValue, Self::Err>{\n        HeaderValue::from_str(s)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::InvalidHeaderValue as std::error::Error>::description":["fn description(&self) -> &str{\n        \"failed to parse header value\"\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::InvalidHeaderValue as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"InvalidHeaderValue\")\n            // skip _priv noise\n            .finish()\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::InvalidHeaderValue as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.description().fmt(f)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::InvalidHeaderValueBytes as std::error::Error>::description":["fn description(&self) -> &str{\n        self.0.description()\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::InvalidHeaderValueBytes as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::ToStrError as std::error::Error>::description":["fn description(&self) -> &str{\n        \"failed to convert header to a str\"\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<header::value::ToStrError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.description().fmt(f)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"<method::InvalidMethod as std::error::Error>::description":["fn description(&self) -> &str{\n        \"invalid HTTP method\"\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::InvalidMethod as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"InvalidMethod\")\n            // skip _priv noise\n            .finish()\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::InvalidMethod as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"{}\", self.description())\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::Method as convert::HttpTryFrom<&'a [u8]>>::try_from":["#[inline]\nfn try_from(t: &'a [u8]) -> Result<Self, Self::Error>{\n        Method::from_bytes(t)\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::Method as convert::HttpTryFrom<&'a method::Method>>::try_from":["#[inline]\nfn try_from(t: &'a Method) -> Result<Self, Self::Error>{\n        Ok(t.clone())\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::Method as convert::HttpTryFrom<&'a str>>::try_from":["#[inline]\nfn try_from(t: &'a str) -> Result<Self, Self::Error>{\n        HttpTryFrom::try_from(t.as_bytes())\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::Method as convert::HttpTryFrom<method::Method>>::try_from":["fn try_from(t: Self) -> Result<Self, Self::Error>{\n                Ok(t)\n            }","Real(LocalPath(\"src/convert.rs\"))"],"<method::Method as std::cmp::PartialEq<&'a method::Method>>::eq":["#[inline]\nfn eq(&self, other: & &'a Method) -> bool{\n        self == *other\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::Method as std::cmp::PartialEq<&'a str>>::eq":["#[inline]\nfn eq(&self, other: &&'a str) -> bool{\n        self.as_ref() == *other\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::Method as std::cmp::PartialEq<str>>::eq":["#[inline]\nfn eq(&self, other: &str) -> bool{\n        self.as_ref() == other\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::Method as std::convert::AsRef<str>>::as_ref":["#[inline]\nfn as_ref(&self) -> &str{\n        self.as_str()\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::Method as std::convert::From<&'a method::Method>>::from":["#[inline]\nfn from(t: &'a Method) -> Self{\n        t.clone()\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::Method as std::default::Default>::default":["#[inline]\nfn default() -> Method{\n        Method::GET\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::Method as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.write_str(self.as_ref())\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::Method as std::fmt::Display>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        fmt.write_str(self.as_ref())\n    }","Real(LocalPath(\"src/method.rs\"))"],"<method::Method as std::str::FromStr>::from_str":["#[inline]\nfn from_str(t: &str) -> Result<Self, Self::Err>{\n        HttpTryFrom::try_from(t)\n    }","Real(LocalPath(\"src/method.rs\"))"],"<request::Builder as std::default::Default>::default":["#[inline]\nfn default() -> Builder{\n        Builder {\n            head: Some(Parts::new()),\n            err: None,\n        }\n    }","Real(LocalPath(\"src/request.rs\"))"],"<request::Parts as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"Parts\")\n            .field(\"method\", &self.method)\n            .field(\"uri\", &self.uri)\n            .field(\"version\", &self.version)\n            .field(\"headers\", &self.headers)\n            // omits Extensions because not useful\n            // omits _priv because not useful\n            .finish()\n    }","Real(LocalPath(\"src/request.rs\"))"],"<request::Request<T> as std::default::Default>::default":["fn default() -> Request<T>{\n        Request::new(T::default())\n    }","Real(LocalPath(\"src/request.rs\"))"],"<request::Request<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"Request\")\n            .field(\"method\", self.method())\n            .field(\"uri\", self.uri())\n            .field(\"version\", &self.version())\n            .field(\"headers\", self.headers())\n            // omits Extensions because not useful\n            .field(\"body\", self.body())\n            .finish()\n    }","Real(LocalPath(\"src/request.rs\"))"],"<response::Builder as std::default::Default>::default":["#[inline]\nfn default() -> Builder{\n        Builder {\n            head: Some(Parts::new()),\n            err: None,\n        }\n    }","Real(LocalPath(\"src/response.rs\"))"],"<response::Parts as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"Parts\")\n            .field(\"status\", &self.status)\n            .field(\"version\", &self.version)\n            .field(\"headers\", &self.headers)\n            // omits Extensions because not useful\n            // omits _priv because not useful\n            .finish()\n    }","Real(LocalPath(\"src/response.rs\"))"],"<response::Response<T> as std::default::Default>::default":["#[inline]\nfn default() -> Response<T>{\n        Response::new(T::default())\n    }","Real(LocalPath(\"src/response.rs\"))"],"<response::Response<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"Response\")\n            .field(\"status\", &self.status())\n            .field(\"version\", &self.version())\n            .field(\"headers\", self.headers())\n            // omits Extensions because not useful\n            .field(\"body\", self.body())\n            .finish()\n    }","Real(LocalPath(\"src/response.rs\"))"],"<status::InvalidStatusCode as std::error::Error>::description":["fn description(&self) -> &str{\n        \"invalid status code\"\n    }","Real(LocalPath(\"src/status.rs\"))"],"<status::InvalidStatusCode as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"InvalidStatusCode\")\n            // skip _priv noise\n            .finish()\n    }","Real(LocalPath(\"src/status.rs\"))"],"<status::InvalidStatusCode as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.write_str(self.description())\n    }","Real(LocalPath(\"src/status.rs\"))"],"<status::StatusCode as convert::HttpTryFrom<&'a [u8]>>::try_from":["#[inline]\nfn try_from(t: &'a [u8]) -> Result<Self, Self::Error>{\n        StatusCode::from_bytes(t)\n    }","Real(LocalPath(\"src/status.rs\"))"],"<status::StatusCode as convert::HttpTryFrom<&'a status::StatusCode>>::try_from":["#[inline]\nfn try_from(t: &'a StatusCode) -> Result<Self, Self::Error>{\n        Ok(t.clone())\n    }","Real(LocalPath(\"src/status.rs\"))"],"<status::StatusCode as convert::HttpTryFrom<&'a str>>::try_from":["#[inline]\nfn try_from(t: &'a str) -> Result<Self, Self::Error>{\n        t.parse()\n    }","Real(LocalPath(\"src/status.rs\"))"],"<status::StatusCode as convert::HttpTryFrom<status::StatusCode>>::try_from":["fn try_from(t: Self) -> Result<Self, Self::Error>{\n                Ok(t)\n            }","Real(LocalPath(\"src/convert.rs\"))"],"<status::StatusCode as convert::HttpTryFrom<u16>>::try_from":["#[inline]\nfn try_from(t: u16) -> Result<Self, Self::Error>{\n        StatusCode::from_u16(t)\n    }","Real(LocalPath(\"src/status.rs\"))"],"<status::StatusCode as std::cmp::PartialEq<u16>>::eq":["#[inline]\nfn eq(&self, other: &u16) -> bool{\n        self.as_u16() == *other\n    }","Real(LocalPath(\"src/status.rs\"))"],"<status::StatusCode as std::convert::From<&'a status::StatusCode>>::from":["#[inline]\nfn from(t: &'a StatusCode) -> Self{\n        t.clone()\n    }","Real(LocalPath(\"src/status.rs\"))"],"<status::StatusCode as std::default::Default>::default":["#[inline]\nfn default() -> StatusCode{\n        StatusCode::OK\n    }","Real(LocalPath(\"src/status.rs\"))"],"<status::StatusCode as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Debug::fmt(&self.0, f)\n    }","Real(LocalPath(\"src/status.rs\"))"],"<status::StatusCode as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"{} {}\", u16::from(*self),\n               self.canonical_reason().unwrap_or(\"<unknown status code>\"))\n    }","Real(LocalPath(\"src/status.rs\"))"],"<status::StatusCode as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<StatusCode, InvalidStatusCode>{\n        StatusCode::from_bytes(s.as_ref())\n    }","Real(LocalPath(\"src/status.rs\"))"],"<std::string::String as header::map::as_header_name::Sealed>::as_str":["#[doc(hidden)]\nfn as_str(&self) -> &str{\n            self\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<std::string::String as header::map::as_header_name::Sealed>::entry":["#[doc(hidden)]\n#[inline]\nfn entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<T>, InvalidHeaderName>{\n            self.as_str().entry(map)\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<std::string::String as header::map::as_header_name::Sealed>::find":["#[doc(hidden)]\n#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            Sealed::find(&self.as_str(), map)\n        }","Real(LocalPath(\"src/header/map.rs\"))"],"<uri::InvalidUri as std::convert::From<uri::ErrorKind>>::from":["fn from(src: ErrorKind) -> InvalidUri{\n        InvalidUri(src)\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::InvalidUri as std::error::Error>::description":["fn description(&self) -> &str{\n        match self.0 {\n            ErrorKind::InvalidUriChar => \"invalid uri character\",\n            ErrorKind::InvalidScheme => \"invalid scheme\",\n            ErrorKind::InvalidAuthority => \"invalid authority\",\n            ErrorKind::InvalidPort => \"invalid port\",\n            ErrorKind::InvalidFormat => \"invalid format\",\n            ErrorKind::SchemeMissing => \"scheme missing\",\n            ErrorKind::AuthorityMissing => \"authority missing\",\n            ErrorKind::PathAndQueryMissing => \"path missing\",\n            ErrorKind::TooLong => \"uri too long\",\n            ErrorKind::Empty => \"empty string\",\n            ErrorKind::SchemeTooLong => \"scheme too long\",\n        }\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::InvalidUri as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.description().fmt(f)\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::InvalidUriBytes as std::convert::From<uri::ErrorKind>>::from":["fn from(src: ErrorKind) -> InvalidUriBytes{\n        InvalidUriBytes(src.into())\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::InvalidUriBytes as std::error::Error>::description":["fn description(&self) -> &str{\n        self.0.description()\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::InvalidUriBytes as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::InvalidUriParts as std::convert::From<uri::ErrorKind>>::from":["fn from(src: ErrorKind) -> InvalidUriParts{\n        InvalidUriParts(src.into())\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::InvalidUriParts as std::error::Error>::description":["fn description(&self) -> &str{\n        self.0.description()\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::InvalidUriParts as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Parts as std::convert::From<uri::Uri>>::from":["fn from(src: Uri) -> Self{\n        let path_and_query = if src.has_path() {\n            Some(src.path_and_query)\n        } else {\n            None\n        };\n\n        let scheme = match src.scheme.inner {\n            Scheme2::None => None,\n            _ => Some(src.scheme),\n        };\n\n        let authority = if src.authority.data.is_empty() {\n            None\n        } else {\n            Some(src.authority)\n        };\n\n        Parts {\n            scheme: scheme,\n            authority: authority,\n            path_and_query: path_and_query,\n            _priv: (),\n        }\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as convert::HttpTryFrom<&'a std::string::String>>::try_from":["#[inline]\nfn try_from(t: &'a String) -> Result<Self, Self::Error>{\n        t.parse()\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as convert::HttpTryFrom<&'a str>>::try_from":["#[inline]\nfn try_from(t: &'a str) -> Result<Self, Self::Error>{\n        t.parse()\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as convert::HttpTryFrom<&'a uri::Uri>>::try_from":["#[inline]\nfn try_from(src: &'a Uri) -> Result<Self, Self::Error>{\n        Ok(src.clone())\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as convert::HttpTryFrom<bytes::Bytes>>::try_from":["#[inline]\nfn try_from(t: Bytes) -> Result<Self, Self::Error>{\n        Uri::from_shared(t)\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as convert::HttpTryFrom<std::string::String>>::try_from":["#[inline]\nfn try_from(t: String) -> Result<Self, Self::Error>{\n        Uri::from_shared(Bytes::from(t))\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as convert::HttpTryFrom<uri::Parts>>::try_from":["#[inline]\nfn try_from(src: Parts) -> Result<Self, Self::Error>{\n        Uri::from_parts(src)\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as convert::HttpTryFrom<uri::Uri>>::try_from":["fn try_from(t: Self) -> Result<Self, Self::Error>{\n                Ok(t)\n            }","Real(LocalPath(\"src/convert.rs\"))"],"<uri::Uri as std::cmp::PartialEq<&'a str>>::eq":["fn eq(&self, other: & &'a str) -> bool{\n        self == *other\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as std::cmp::PartialEq<str>>::eq":["fn eq(&self, other: &str) -> bool{\n        let mut other = other.as_bytes();\n        let mut absolute = false;\n\n        if let Some(scheme) = self.scheme_part() {\n            let scheme = scheme.as_str().as_bytes();\n            absolute = true;\n\n            if other.len() < scheme.len() + 3 {\n                return false;\n            }\n\n            if !scheme.eq_ignore_ascii_case(&other[..scheme.len()]) {\n                return false;\n            }\n\n            other = &other[scheme.len()..];\n\n            if &other[..3] != b\"://\" {\n                return false;\n            }\n\n            other = &other[3..];\n        }\n\n        if let Some(auth) = self.authority_part() {\n            let len = auth.data.len();\n            absolute = true;\n\n            if other.len() < len {\n                return false;\n            }\n\n            if !auth.data.as_bytes().eq_ignore_ascii_case(&other[..len]) {\n                return false;\n            }\n\n            other = &other[len..];\n        }\n\n        let path = self.path();\n\n        if other.len() < path.len() || path.as_bytes() != &other[..path.len()] {\n            if absolute && path == \"/\" {\n                // PathAndQuery can be ommitted, fall through\n            } else {\n                return false;\n            }\n        } else {\n            other = &other[path.len()..];\n        }\n\n        if let Some(query) = self.query() {\n            if other.len() == 0 {\n                return query.len() == 0;\n            }\n\n            if other[0] != b'?' {\n                return false;\n            }\n\n            other = &other[1..];\n\n            if other.len() < query.len() {\n                return false;\n            }\n\n            if query.as_bytes() != &other[..query.len()] {\n                return false;\n            }\n\n            other = &other[query.len()..];\n        }\n\n        other.is_empty() || other[0] == b'#'\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Uri) -> bool{\n        if self.scheme_part() != other.scheme_part() {\n            return false;\n        }\n\n        if self.authority_part() != other.authority_part() {\n            return false;\n        }\n\n        if self.path() != other.path() {\n            return false;\n        }\n\n        if self.query() != other.query() {\n            return false;\n        }\n\n        true\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as std::default::Default>::default":["#[inline]\nfn default() -> Uri{\n        Uri {\n            scheme: Scheme::empty(),\n            authority: Authority::empty(),\n            path_and_query: PathAndQuery::slash(),\n        }\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Display::fmt(self, f)\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if let Some(scheme) = self.scheme_part() {\n            write!(f, \"{}://\", scheme)?;\n        }\n\n        if let Some(authority) = self.authority_part() {\n            write!(f, \"{}\", authority)?;\n        }\n\n        write!(f, \"{}\", self.path())?;\n\n        if let Some(query) = self.query() {\n            write!(f, \"?{}\", query)?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as std::hash::Hash>::hash":["fn hash<H>(&self, state: &mut H) where H: Hasher{\n        if !self.scheme.inner.is_none() {\n            self.scheme.hash(state);\n            state.write_u8(0xff);\n        }\n\n        if let Some(auth) = self.authority_part() {\n            auth.hash(state);\n        }\n\n        Hash::hash_slice(self.path().as_bytes(), state);\n\n        if let Some(query) = self.query() {\n            b'?'.hash(state);\n            Hash::hash_slice(query.as_bytes(), state);\n        }\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::Uri as std::str::FromStr>::from_str":["#[inline]\nfn from_str(s: &str) -> Result<Uri, InvalidUri>{\n        Uri::from_shared(s.into()).map_err(|e| e.0)\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"<uri::authority::Authority as convert::HttpTryFrom<&'a [u8]>>::try_from":["#[inline]\nfn try_from(s: &'a [u8]) -> Result<Self, Self::Error>{\n        // parse first, and only turn into Bytes if valid\n        let end = Authority::parse_non_empty(s)?;\n\n        if end != s.len() {\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        Ok(Authority {\n            data: unsafe { ByteStr::from_utf8_unchecked(s.into()) },\n        })\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as convert::HttpTryFrom<&'a str>>::try_from":["#[inline]\nfn try_from(s: &'a str) -> Result<Self, Self::Error>{\n        HttpTryFrom::try_from(s.as_bytes())\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as convert::HttpTryFrom<bytes::Bytes>>::try_from":["#[inline]\nfn try_from(bytes: Bytes) -> Result<Self, Self::Error>{\n        Authority::from_shared(bytes)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as convert::HttpTryFrom<uri::authority::Authority>>::try_from":["fn try_from(t: Self) -> Result<Self, Self::Error>{\n                Ok(t)\n            }","Real(LocalPath(\"src/convert.rs\"))"],"<uri::authority::Authority as std::cmp::PartialEq<&'a str>>::eq":["fn eq(&self, other: &&'a str) -> bool{\n        self.data.eq_ignore_ascii_case(other)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as std::cmp::PartialEq<std::string::String>>::eq":["fn eq(&self, other: &String) -> bool{\n        self.data.eq_ignore_ascii_case(other.as_str())\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as std::cmp::PartialEq<str>>::eq":["fn eq(&self, other: &str) -> bool{\n        self.data.eq_ignore_ascii_case(other)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Authority) -> bool{\n        self.data.eq_ignore_ascii_case(&other.data)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as std::cmp::PartialOrd<&'a str>>::partial_cmp":["fn partial_cmp(&self, other: &&'a str) -> Option<cmp::Ordering>{\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as std::cmp::PartialOrd<std::string::String>>::partial_cmp":["fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering>{\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as std::cmp::PartialOrd<str>>::partial_cmp":["fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering>{\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering>{\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as std::convert::AsRef<str>>::as_ref":["fn as_ref(&self) -> &str{\n        self.as_str()\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.write_str(self.as_str())\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.write_str(self.as_str())\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as std::hash::Hash>::hash":["fn hash<H>(&self, state: &mut H) where H: Hasher{\n        self.data.len().hash(state);\n        for &b in self.data.as_bytes() {\n            state.write_u8(b.to_ascii_lowercase());\n        }\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::authority::Authority as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<Self, InvalidUri>{\n        HttpTryFrom::try_from(s)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"<uri::builder::Builder as std::default::Default>::default":["#[inline]\nfn default() -> Builder{\n        Builder {\n            parts: Some(Ok(Parts::default())),\n        }\n    }","Real(LocalPath(\"src/uri/builder.rs\"))"],"<uri::path::PathAndQuery as convert::HttpTryFrom<&'a [u8]>>::try_from":["#[inline]\nfn try_from(s: &'a [u8]) -> Result<Self, Self::Error>{\n        PathAndQuery::from_shared(s.into()).map_err(|e| e.0)\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::path::PathAndQuery as convert::HttpTryFrom<&'a str>>::try_from":["#[inline]\nfn try_from(s: &'a str) -> Result<Self, Self::Error>{\n        HttpTryFrom::try_from(s.as_bytes())\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::path::PathAndQuery as convert::HttpTryFrom<bytes::Bytes>>::try_from":["#[inline]\nfn try_from(bytes: Bytes) -> Result<Self, Self::Error>{\n        PathAndQuery::from_shared(bytes)\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::path::PathAndQuery as convert::HttpTryFrom<uri::path::PathAndQuery>>::try_from":["fn try_from(t: Self) -> Result<Self, Self::Error>{\n                Ok(t)\n            }","Real(LocalPath(\"src/convert.rs\"))"],"<uri::path::PathAndQuery as std::cmp::PartialEq<&'a str>>::eq":["#[inline]\nfn eq(&self, other: &&'a str) -> bool{\n        self.as_str() == *other\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::path::PathAndQuery as std::cmp::PartialEq<std::string::String>>::eq":["#[inline]\nfn eq(&self, other: &String) -> bool{\n        self.as_str() == other.as_str()\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::path::PathAndQuery as std::cmp::PartialEq<str>>::eq":["#[inline]\nfn eq(&self, other: &str) -> bool{\n        self.as_str() == other\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::path::PathAndQuery as std::cmp::PartialEq>::eq":["#[inline]\nfn eq(&self, other: &PathAndQuery) -> bool{\n        self.data == other.data\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::path::PathAndQuery as std::cmp::PartialOrd<&'a str>>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &&'a str) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(*other)\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::path::PathAndQuery as std::cmp::PartialOrd<std::string::String>>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &String) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(other.as_str())\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::path::PathAndQuery as std::cmp::PartialOrd<str>>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &str) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(other)\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::path::PathAndQuery as std::cmp::PartialOrd>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(other.as_str())\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::path::PathAndQuery as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Display::fmt(self, f)\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::path::PathAndQuery as std::fmt::Display>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        if !self.data.is_empty() {\n            match self.data.as_bytes()[0] {\n                b'/' | b'*' => write!(fmt, \"{}\", &self.data[..]),\n                _ => write!(fmt, \"/{}\", &self.data[..]),\n            }\n        } else {\n            write!(fmt, \"/\")\n        }\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::path::PathAndQuery as std::str::FromStr>::from_str":["#[inline]\nfn from_str(s: &str) -> Result<Self, InvalidUri>{\n        HttpTryFrom::try_from(s)\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"<uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq":["fn eq(&self, other: &u16) -> bool{\n        self.port == *other\n    }","Real(LocalPath(\"src/uri/port.rs\"))"],"<uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq":["fn eq(&self, other: &Port<U>) -> bool{\n        self.port == other.port\n    }","Real(LocalPath(\"src/uri/port.rs\"))"],"<uri::port::Port<T> as std::convert::AsRef<str>>::as_ref":["fn as_ref(&self) -> &str{\n        self.as_str()\n    }","Real(LocalPath(\"src/uri/port.rs\"))"],"<uri::port::Port<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_tuple(\"Port\")\n            .field(&self.port)\n            .finish()\n    }","Real(LocalPath(\"src/uri/port.rs\"))"],"<uri::port::Port<T> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        // Use `u16::fmt` so that it respects any formatting flags that\n        // may have been set (like padding, align, etc).\n        fmt::Display::fmt(&self.port, f)\n    }","Real(LocalPath(\"src/uri/port.rs\"))"],"<uri::scheme::Scheme as convert::HttpTryFrom<&'a [u8]>>::try_from":["#[inline]\nfn try_from(s: &'a [u8]) -> Result<Self, Self::Error>{\n        use self::Scheme2::*;\n\n        match Scheme2::parse_exact(s)? {\n            None => Err(ErrorKind::InvalidScheme.into()),\n            Standard(p) => Ok(Standard(p).into()),\n            Other(_) => {\n                // Unsafe: parse_exact already checks for a strict subset of UTF-8\n                Ok(Other(Box::new(unsafe {\n                    ByteStr::from_utf8_unchecked(s.into())\n                })).into())\n            }\n        }\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"<uri::scheme::Scheme as convert::HttpTryFrom<&'a str>>::try_from":["#[inline]\nfn try_from(s: &'a str) -> Result<Self, Self::Error>{\n        HttpTryFrom::try_from(s.as_bytes())\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"<uri::scheme::Scheme as convert::HttpTryFrom<bytes::Bytes>>::try_from":["#[inline]\nfn try_from(bytes: Bytes) -> Result<Self, Self::Error>{\n        Scheme::from_shared(bytes)\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"<uri::scheme::Scheme as convert::HttpTryFrom<uri::scheme::Scheme>>::try_from":["fn try_from(t: Self) -> Result<Self, Self::Error>{\n                Ok(t)\n            }","Real(LocalPath(\"src/convert.rs\"))"],"<uri::scheme::Scheme as std::cmp::PartialEq<str>>::eq":["fn eq(&self, other: &str) -> bool{\n        self.as_str().eq_ignore_ascii_case(other)\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"<uri::scheme::Scheme as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Scheme) -> bool{\n        use self::Protocol::*;\n        use self::Scheme2::*;\n\n        match (&self.inner, &other.inner) {\n            (&Standard(Http), &Standard(Http)) => true,\n            (&Standard(Https), &Standard(Https)) => true,\n            (&Other(ref a), &Other(ref b)) => a.eq_ignore_ascii_case(b),\n            (&None, _) | (_, &None) => unreachable!(),\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"<uri::scheme::Scheme as std::convert::AsRef<str>>::as_ref":["#[inline]\nfn as_ref(&self) -> &str{\n        self.as_str()\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"<uri::scheme::Scheme as std::convert::From<uri::scheme::Scheme2>>::from":["fn from(src: Scheme2) -> Self{\n        Scheme { inner: src }\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"<uri::scheme::Scheme as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Debug::fmt(self.as_str(), f)\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"<uri::scheme::Scheme as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.write_str(self.as_str())\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"<uri::scheme::Scheme as std::hash::Hash>::hash":["fn hash<H>(&self, state: &mut H) where H: Hasher{\n        match self.inner {\n            Scheme2::None => (),\n            Scheme2::Standard(Protocol::Http) => state.write_u8(1),\n            Scheme2::Standard(Protocol::Https) => state.write_u8(2),\n            Scheme2::Other(ref other) => {\n                other.len().hash(state);\n                for &b in other.as_bytes() {\n                    state.write_u8(b.to_ascii_lowercase());\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"<uri::scheme::Scheme as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<Self, Self::Err>{\n        HttpTryFrom::try_from(s)\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"<uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from":["fn from(src: Protocol) -> Self{\n        Scheme2::Standard(src)\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"<version::Version as std::default::Default>::default":["#[inline]\nfn default() -> Version{\n        Version::HTTP_11\n    }","Real(LocalPath(\"src/version.rs\"))"],"<version::Version as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        use self::Http::*;\n\n        f.write_str(match self.0 {\n            Http09 => \"HTTP/0.9\",\n            Http10 => \"HTTP/1.0\",\n            Http11 => \"HTTP/1.1\",\n            H2     => \"HTTP/2.0\",\n        })\n    }","Real(LocalPath(\"src/version.rs\"))"],"_assert_types":["fn _assert_types(){\n    fn assert_send<T: Send>() {}\n    fn assert_sync<T: Sync>() {}\n\n    assert_send::<Request<()>>();\n    assert_send::<Response<()>>();\n\n    assert_sync::<Request<()>>();\n    assert_sync::<Response<()>>();\n}","Real(LocalPath(\"src/lib.rs\"))"],"_assert_types::assert_send":["fn assert_send<T: Send>(){}","Real(LocalPath(\"src/lib.rs\"))"],"_assert_types::assert_sync":["fn assert_sync<T: Sync>(){}","Real(LocalPath(\"src/lib.rs\"))"],"byte_str::<impl std::convert::From<byte_str::ByteStr> for bytes::Bytes>::from":["fn from(src: ByteStr) -> Self{\n        src.bytes\n    }","Real(LocalPath(\"src/byte_str.rs\"))"],"byte_str::ByteStr":["pub(crate) struct ByteStr {\n    bytes: Bytes,\n}","Real(LocalPath(\"src/byte_str.rs\"))"],"byte_str::ByteStr::from_static":["#[inline]\npub fn from_static(val: &'static str) -> ByteStr{\n        ByteStr { bytes: Bytes::from_static(val.as_bytes()) }\n    }","Real(LocalPath(\"src/byte_str.rs\"))"],"byte_str::ByteStr::from_utf8_unchecked":["#[inline]\npub unsafe fn from_utf8_unchecked(bytes: Bytes) -> ByteStr{\n        if cfg!(debug_assertions) {\n            match str::from_utf8(&bytes) {\n                Ok(_) => (),\n                Err(err) => panic!(\"ByteStr::from_utf8_unchecked() with invalid bytes; error = {}, bytes = {:?}\", err, bytes),\n            }\n        }\n        ByteStr { bytes: bytes }\n    }","Real(LocalPath(\"src/byte_str.rs\"))"],"byte_str::ByteStr::new":["#[inline]\npub fn new() -> ByteStr{\n        ByteStr { bytes: Bytes::new() }\n    }","Real(LocalPath(\"src/byte_str.rs\"))"],"convert::HttpTryFrom":["/// Private trait for the `http` crate to have generic methods with fallible\n/// conversions.\n///\n/// This trait is similar to the `TryFrom` trait proposed in the standard\n/// library, except this is specialized for the `http` crate and isn't intended\n/// for general consumption.\n///\n/// This trait cannot be implemented types outside of the `http` crate, and is\n/// only intended for use as a generic bound on methods in the `http` crate.\npub trait HttpTryFrom<T>: Sized + Sealed {\n    /// Associated error with the conversion this implementation represents.\n    type Error: Into<Error>;\n\n    #[doc(hidden)]\n    fn try_from(t: T) -> Result<Self, Self::Error>;\n}","Real(LocalPath(\"src/convert.rs\"))"],"convert::HttpTryInto":["pub(crate) trait HttpTryInto<T>: Sized {\n    fn http_try_into(self) -> Result<T, Error>;\n}","Real(LocalPath(\"src/convert.rs\"))"],"error::Error":["/// A generic \"error\" for HTTP connections\n///\n/// This error type is less specific than the error returned from other\n/// functions in this crate, but all other errors can be converted to this\n/// error. Consumers of this crate can typically consume and work with this form\n/// of error for conversions with the `?` operator.\npub struct Error {\n    inner: ErrorKind,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Error::get_ref":["/// Return a reference to the lower level, inner error.\n#[allow(warnings)]\npub fn get_ref(&self) -> &(error::Error + 'static){\n        use self::ErrorKind::*;\n\n        match self.inner {\n            StatusCode(ref e) => e,\n            Method(ref e) => e,\n            Uri(ref e) => e,\n            UriShared(ref e) => e,\n            UriParts(ref e) => e,\n            HeaderName(ref e) => e,\n            HeaderNameShared(ref e) => e,\n            HeaderValue(ref e) => e,\n            HeaderValueShared(ref e) => e,\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::is":["/// Return true if the underlying error has the same type as T.\npub fn is<T: error::Error + 'static>(&self) -> bool{\n        self.get_ref().is::<T>()\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::ErrorKind":["enum ErrorKind {\n    StatusCode(status::InvalidStatusCode),\n    Method(method::InvalidMethod),\n    Uri(uri::InvalidUri),\n    UriShared(uri::InvalidUriBytes),\n    UriParts(uri::InvalidUriParts),\n    HeaderName(header::InvalidHeaderName),\n    HeaderNameShared(header::InvalidHeaderNameBytes),\n    HeaderValue(header::InvalidHeaderValue),\n    HeaderValueShared(header::InvalidHeaderValueBytes),\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Never":["pub enum Never {}","Real(LocalPath(\"src/error.rs\"))"],"extensions::Extensions":["/// A type map of protocol extensions.\n///\n/// `Extensions` can be used by `Request` and `Response` to store\n/// extra data derived from the underlying protocol.\npub struct Extensions {\n    // If extensions are never used, no need to carry around an empty HashMap.\n    // That's 3 words. Instead, this is only 1 word.\n    map: Option<Box<AnyMap>>,\n}","Real(LocalPath(\"src/extensions.rs\"))"],"extensions::Extensions::clear":["/// Clear the `Extensions` of all inserted extensions.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// ext.insert(5i32);\n/// ext.clear();\n///\n/// assert!(ext.get::<i32>().is_none());\n/// ```\n#[inline]\npub fn clear(&mut self){\n        if let Some(ref mut map) = self.map {\n            map.clear();\n        }\n    }","Real(LocalPath(\"src/extensions.rs\"))"],"extensions::Extensions::get":["/// Get a reference to a type previously inserted on this `Extensions`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// assert!(ext.get::<i32>().is_none());\n/// ext.insert(5i32);\n///\n/// assert_eq!(ext.get::<i32>(), Some(&5i32));\n/// ```\npub fn get<T: Send + Sync + 'static>(&self) -> Option<&T>{\n        self\n            .map\n            .as_ref()\n            .and_then(|map| map.get(&TypeId::of::<T>()))\n            .and_then(|boxed| {\n                #[allow(warnings)]\n                {\n                (&**boxed as &(Any + 'static)).downcast_ref()\n                }\n            })\n    }","Real(LocalPath(\"src/extensions.rs\"))"],"extensions::Extensions::get_mut":["/// Get a mutable reference to a type previously inserted on this `Extensions`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// ext.insert(String::from(\"Hello\"));\n/// ext.get_mut::<String>().unwrap().push_str(\" World\");\n///\n/// assert_eq!(ext.get::<String>().unwrap(), \"Hello World\");\n/// ```\npub fn get_mut<T: Send + Sync + 'static>(&mut self) -> Option<&mut T>{\n        self\n            .map\n            .as_mut()\n            .and_then(|map| map.get_mut(&TypeId::of::<T>()))\n            .and_then(|boxed| {\n                #[allow(warnings)]\n                {\n                (&mut **boxed as &mut (Any + 'static)).downcast_mut()\n                }\n            })\n    }","Real(LocalPath(\"src/extensions.rs\"))"],"extensions::Extensions::insert":["/// Insert a type into this `Extensions`.\n///\n/// If a extension of this type already existed, it will\n/// be returned.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// assert!(ext.insert(5i32).is_none());\n/// assert!(ext.insert(4u8).is_none());\n/// assert_eq!(ext.insert(9i32), Some(5i32));\n/// ```\npub fn insert<T: Send + Sync + 'static>(&mut self, val: T) -> Option<T>{\n        self\n            .map\n            .get_or_insert_with(|| Box::new(HashMap::default()))\n            .insert(TypeId::of::<T>(), Box::new(val))\n            .and_then(|boxed| {\n                #[allow(warnings)]\n                {\n                (boxed as Box<Any + 'static>)\n                    .downcast()\n                    .ok()\n                    .map(|boxed| *boxed)\n                }\n            })\n    }","Real(LocalPath(\"src/extensions.rs\"))"],"extensions::Extensions::new":["/// Create an empty `Extensions`.\n#[inline]\npub fn new() -> Extensions{\n        Extensions {\n            map: None,\n        }\n    }","Real(LocalPath(\"src/extensions.rs\"))"],"extensions::Extensions::remove":["/// Remove a type from this `Extensions`.\n///\n/// If a extension of this type existed, it will be returned.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// ext.insert(5i32);\n/// assert_eq!(ext.remove::<i32>(), Some(5i32));\n/// assert!(ext.get::<i32>().is_none());\n/// ```\npub fn remove<T: Send + Sync + 'static>(&mut self) -> Option<T>{\n        self\n            .map\n            .as_mut()\n            .and_then(|map| map.remove(&TypeId::of::<T>()))\n            .and_then(|boxed| {\n                #[allow(warnings)]\n                {\n                (boxed as Box<Any + 'static>)\n                    .downcast()\n                    .ok()\n                    .map(|boxed| *boxed)\n                }\n            })\n    }","Real(LocalPath(\"src/extensions.rs\"))"],"extensions::IdHasher":["struct IdHasher(u64);","Real(LocalPath(\"src/extensions.rs\"))"],"header::map::Bucket":["/// Stores the data associated with a `HeaderMap` entry. Only the first value is\n/// included in this struct. If a header name has more than one associated\n/// value, all extra values are stored in the `extra_values` vector. A doubly\n/// linked list of entries is maintained. The doubly linked list is used so that\n/// removing a value is constant time. This also has the nice property of\n/// enabling double ended iteration.\nstruct Bucket<T> {\n    hash: HashValue,\n    key: HeaderName,\n    value: T,\n    links: Option<Links>,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Cursor":["/// Tracks the value iterator state\nenum Cursor {\n    Head,\n    Values(usize),\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Danger":["/// Tracks the header map danger level! This relates to the adaptive hashing\n/// algorithm. A HeaderMap starts in the \"green\" state, when a large number of\n/// collisions are detected, it transitions to the yellow state. At this point,\n/// the header map will either grow and switch back to the green state OR it\n/// will transition to the red state.\n///\n/// When in the red state, a safe hashing algorithm is used and all values in\n/// the header map have to be rehashed.\nenum Danger {\n    Green,\n    Yellow,\n    Red(RandomState),\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Danger::is_red":["fn is_red(&self) -> bool{\n        match *self {\n            Danger::Red(_) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Danger::is_yellow":["fn is_yellow(&self) -> bool{\n        match *self {\n            Danger::Yellow => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Danger::to_green":["fn to_green(&mut self){\n        debug_assert!(self.is_yellow());\n        *self = Danger::Green;\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Danger::to_red":["fn to_red(&mut self){\n        debug_assert!(self.is_yellow());\n        *self = Danger::Red(RandomState::new());\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Danger::to_yellow":["fn to_yellow(&mut self){\n        match *self {\n            Danger::Green => {\n                *self = Danger::Yellow;\n            }\n            _ => {}\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Drain":["/// A drain iterator for `HeaderMap`.\npub struct Drain<'a, T: 'a> {\n    idx: usize,\n    map: *mut HeaderMap<T>,\n    lt: PhantomData<&'a mut HeaderMap<T>>,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Entry":["/// A view into a single location in a `HeaderMap`, which may be vacant or occupied.\npub enum Entry<'a, T: 'a> {\n    /// An occupied entry\n    Occupied(OccupiedEntry<'a, T>),\n\n    /// A vacant entry\n    Vacant(VacantEntry<'a, T>),\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Entry::<'a, T>::key":["/// Returns a reference to the entry's key\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(map.entry(\"x-hello\").unwrap().key(), \"x-hello\");\n/// ```\npub fn key(&self) -> &HeaderName{\n        use self::Entry::*;\n\n        match *self {\n            Vacant(ref e) => e.key(),\n            Occupied(ref e) => e.key(),\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Entry::<'a, T>::or_insert":["/// Ensures a value is in the entry by inserting the default if empty.\n///\n/// Returns a mutable reference to the **first** value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map: HeaderMap<u32> = HeaderMap::default();\n///\n/// let headers = &[\n///     \"content-length\",\n///     \"x-hello\",\n///     \"Content-Length\",\n///     \"x-world\",\n/// ];\n///\n/// for &header in headers {\n///     let counter = map.entry(header)\n///         .expect(\"valid header names\")\n///         .or_insert(0);\n///     *counter += 1;\n/// }\n///\n/// assert_eq!(map[\"content-length\"], 2);\n/// assert_eq!(map[\"x-hello\"], 1);\n/// ```\npub fn or_insert(self, default: T) -> &'a mut T{\n        use self::Entry::*;\n\n        match self {\n            Occupied(e) => e.into_mut(),\n            Vacant(e) => e.insert(default),\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Entry::<'a, T>::or_insert_with":["/// Ensures a value is in the entry by inserting the result of the default\n/// function if empty.\n///\n/// The default function is not called if the entry exists in the map.\n/// Returns a mutable reference to the **first** value in the entry.\n///\n/// # Examples\n///\n/// Basic usage.\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map = HeaderMap::new();\n///\n/// let res = map.entry(\"x-hello\").unwrap()\n///     .or_insert_with(|| \"world\".parse().unwrap());\n///\n/// assert_eq!(res, \"world\");\n/// ```\n///\n/// The default function is not called if the entry exists in the map.\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"world\".parse().unwrap());\n///\n/// let res = map.entry(\"host\")\n///     .expect(\"host is a valid string\")\n///     .or_insert_with(|| unreachable!());\n///\n///\n/// assert_eq!(res, \"world\");\n/// ```\npub fn or_insert_with<F: FnOnce() -> T>(self, default: F) -> &'a mut T{\n        use self::Entry::*;\n\n        match self {\n            Occupied(e) => e.into_mut(),\n            Vacant(e) => e.insert(default()),\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::ExtraValue":["/// Node in doubly-linked list of header value entries\nstruct ExtraValue<T> {\n    value: T,\n    prev: Link,\n    next: Link,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::GetAll":["/// A view to all values stored in a single entry.\n///\n/// This struct is returned by `HeaderMap::get_all`.\npub struct GetAll<'a, T: 'a> {\n    map: &'a HeaderMap<T>,\n    index: Option<usize>,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::GetAll::<'a, T>::iter":["/// Returns an iterator visiting all values associated with the entry.\n///\n/// Values are iterated in insertion order.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n/// map.append(HOST, \"hello.earth\".parse().unwrap());\n///\n/// let values = map.get_all(\"host\");\n/// let mut iter = values.iter();\n/// assert_eq!(&\"hello.world\", iter.next().unwrap());\n/// assert_eq!(&\"hello.earth\", iter.next().unwrap());\n/// assert!(iter.next().is_none());\n/// ```\npub fn iter(&self) -> ValueIter<'a, T>{\n        // This creates a new GetAll struct so that the lifetime\n        // isn't bound to &self.\n        GetAll {\n            map: self.map,\n            index: self.index,\n        }.into_iter()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HashValue":["/// Hash values are limited to u16 as well. While `fast_hash` and `Hasher`\n/// return `usize` hash codes, limiting the effective hash code to the lower 16\n/// bits is fine since we know that the `indices` vector will never grow beyond\n/// that size.\nstruct HashValue(usize);","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap":["/// A set of HTTP headers\n///\n/// `HeaderMap` is an multimap of [`HeaderName`] to values.\n///\n/// [`HeaderName`]: struct.HeaderName.html\n///\n/// # Examples\n///\n/// Basic usage\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST, LOCATION};\n/// let mut headers = HeaderMap::new();\n///\n/// headers.insert(HOST, \"example.com\".parse().unwrap());\n/// headers.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n///\n/// assert!(headers.contains_key(HOST));\n/// assert!(!headers.contains_key(LOCATION));\n///\n/// assert_eq!(headers[HOST], \"example.com\");\n///\n/// headers.remove(HOST);\n///\n/// assert!(!headers.contains_key(HOST));\n/// ```\npub struct HeaderMap<T = HeaderValue> {\n    // Used to mask values to get an index\n    mask: Size,\n    indices: Box<[Pos]>,\n    entries: Vec<Bucket<T>>,\n    extra_values: Vec<ExtraValue<T>>,\n    danger: Danger,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::append":["/// Inserts a key-value pair into the map.\n///\n/// If the map did not previously have this key present, then `false` is\n/// returned.\n///\n/// If the map did have this key present, the new value is pushed to the end\n/// of the list of values currently associated with the key. The key is not\n/// updated, though; this matters for types that can be `==` without being\n/// identical.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(map.insert(HOST, \"world\".parse().unwrap()).is_none());\n/// assert!(!map.is_empty());\n///\n/// map.append(HOST, \"earth\".parse().unwrap());\n///\n/// let values = map.get_all(\"host\");\n/// let mut i = values.iter();\n/// assert_eq!(\"world\", *i.next().unwrap());\n/// assert_eq!(\"earth\", *i.next().unwrap());\n/// ```\npub fn append<K>(&mut self, key: K, value: T) -> bool\n        where K: IntoHeaderName,{\n        key.append(self, value)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::append2":["#[inline]\nfn append2<K>(&mut self, key: K, value: T) -> bool\n        where K: Hash + Into<HeaderName>,\n              HeaderName: PartialEq<K>,{\n        self.reserve_one();\n\n        insert_phase_one!(\n            self, key, probe, pos, hash, danger,\n            // Vacant\n            {\n                drop(danger);\n                let index = self.entries.len();\n                self.insert_entry(hash, key.into(), value);\n                self.indices[probe] = Pos::new(index, hash);\n                false\n            },\n            // Occupied\n            {\n                append_value(pos, &mut self.entries[pos], &mut self.extra_values, value);\n                true\n            },\n            // Robinhood\n            {\n                self.insert_phase_two(\n                    key.into(),\n                    value,\n                    hash,\n                    probe,\n                    danger);\n\n                false\n            })\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::capacity":["/// Returns the number of headers the map can hold without reallocating.\n///\n/// This number is an approximation as certain usage patterns could cause\n/// additional allocations before the returned capacity is filled.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(0, map.capacity());\n///\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n/// assert_eq!(6, map.capacity());\n/// ```\npub fn capacity(&self) -> usize{\n        usable_capacity(self.indices.len())\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::clear":["/// Clears the map, removing all key-value pairs. Keeps the allocated memory\n/// for reuse.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n///\n/// map.clear();\n/// assert!(map.is_empty());\n/// assert!(map.capacity() > 0);\n/// ```\npub fn clear(&mut self){\n        self.entries.clear();\n        self.extra_values.clear();\n        self.danger = Danger::Green;\n\n        for e in self.indices.iter_mut() {\n            *e = Pos::none();\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::contains_key":["/// Returns true if the map contains a value for the specified key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(!map.contains_key(HOST));\n///\n/// map.insert(HOST, \"world\".parse().unwrap());\n/// assert!(map.contains_key(\"host\"));\n/// ```\npub fn contains_key<K>(&self, key: K) -> bool\n        where K: AsHeaderName{\n        key.find(self).is_some()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::drain":["/// Clears the map, returning all entries as an iterator.\n///\n/// The internal memory is kept for reuse.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, \"hello\".parse().unwrap());\n/// map.append(HOST, \"goodbye\".parse().unwrap());\n/// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n///\n/// let mut drain = map.drain();\n///\n/// let (key, mut vals) = drain.next().unwrap();\n///\n/// assert_eq!(\"host\", key);\n/// assert_eq!(\"hello\", vals.next().unwrap());\n/// assert_eq!(\"goodbye\", vals.next().unwrap());\n/// assert!(vals.next().is_none());\n///\n/// let (key, mut vals) = drain.next().unwrap();\n///\n/// assert_eq!(\"content-length\", key);\n/// assert_eq!(\"123\", vals.next().unwrap());\n/// assert!(vals.next().is_none());\n/// ```\npub fn drain(&mut self) -> Drain<T>{\n        for i in self.indices.iter_mut() {\n            *i = Pos::none();\n        }\n\n        Drain {\n            idx: 0,\n            map: self as *mut _,\n            lt: PhantomData,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::entry":["/// Gets the given key's corresponding entry in the map for in-place\n/// manipulation.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map: HeaderMap<u32> = HeaderMap::default();\n///\n/// let headers = &[\n///     \"content-length\",\n///     \"x-hello\",\n///     \"Content-Length\",\n///     \"x-world\",\n/// ];\n///\n/// for &header in headers {\n///     let counter = map.entry(header).unwrap().or_insert(0);\n///     *counter += 1;\n/// }\n///\n/// assert_eq!(map[\"content-length\"], 2);\n/// assert_eq!(map[\"x-hello\"], 1);\n/// ```\npub fn entry<K>(&mut self, key: K) -> Result<Entry<T>, InvalidHeaderName>\n        where K: AsHeaderName,{\n        key.entry(self)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::entry2":["fn entry2<K>(&mut self, key: K) -> Entry<T>\n        where K: Hash + Into<HeaderName>,\n              HeaderName: PartialEq<K>,{\n        // Ensure that there is space in the map\n        self.reserve_one();\n\n        insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash: hash,\n                key: key.into(),\n                probe: probe,\n                danger: danger,\n            }),\n            Entry::Occupied(OccupiedEntry {\n                map: self,\n                index: pos,\n                probe: probe,\n            }),\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash: hash,\n                key: key.into(),\n                probe: probe,\n                danger: danger,\n            }))\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::find":["#[inline]\nfn find<K: ?Sized>(&self, key: &K) -> Option<(usize, usize)>\n        where K: Hash + Into<HeaderName>,\n              HeaderName: PartialEq<K>,{\n        if self.entries.is_empty() {\n            return None;\n        }\n\n        let hash = hash_elem_using(&self.danger, key);\n        let mask = self.mask;\n        let mut probe = desired_pos(mask, hash);\n        let mut dist = 0;\n\n        probe_loop!(probe < self.indices.len(), {\n            if let Some((i, entry_hash)) = self.indices[probe].resolve() {\n                if dist > probe_distance(mask, entry_hash, probe) {\n                    // give up when probe distance is too long\n                    return None;\n                } else if entry_hash == hash && self.entries[i].key == *key {\n                    return Some((probe, i));\n                }\n            } else {\n                return None;\n            }\n\n            dist += 1;\n        });\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::get":["/// Returns a reference to the value associated with the key.\n///\n/// If there are multiple values associated with the key, then the first one\n/// is returned. Use `get_all` to get all values associated with a given\n/// key. Returns `None` if there are no values associated with the key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(map.get(\"host\").is_none());\n///\n/// map.insert(HOST, \"hello\".parse().unwrap());\n/// assert_eq!(map.get(HOST).unwrap(), &\"hello\");\n/// assert_eq!(map.get(\"host\").unwrap(), &\"hello\");\n///\n/// map.append(HOST, \"world\".parse().unwrap());\n/// assert_eq!(map.get(\"host\").unwrap(), &\"hello\");\n/// ```\npub fn get<K>(&self, key: K) -> Option<&T>\n        where K: AsHeaderName{\n        self.get2(&key)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::get2":["fn get2<K>(&self, key: &K) -> Option<&T>\n        where K: AsHeaderName{\n        match key.find(self) {\n            Some((_, found)) => {\n                let entry = &self.entries[found];\n                Some(&entry.value)\n            }\n            None => None,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::get_all":["/// Returns a view of all values associated with a key.\n///\n/// The returned view does not incur any allocations and allows iterating\n/// the values associated with the key.  See [`GetAll`] for more details.\n/// Returns `None` if there are no values associated with the key.\n///\n/// [`GetAll`]: struct.GetAll.html\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, \"hello\".parse().unwrap());\n/// map.append(HOST, \"goodbye\".parse().unwrap());\n///\n/// let view = map.get_all(\"host\");\n///\n/// let mut iter = view.iter();\n/// assert_eq!(&\"hello\", iter.next().unwrap());\n/// assert_eq!(&\"goodbye\", iter.next().unwrap());\n/// assert!(iter.next().is_none());\n/// ```\npub fn get_all<K>(&self, key: K) -> GetAll<T>\n        where K: AsHeaderName{\n        GetAll {\n            map: self,\n            index: key.find(self).map(|(_, i)| i),\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::get_mut":["/// Returns a mutable reference to the value associated with the key.\n///\n/// If there are multiple values associated with the key, then the first one\n/// is returned. Use `entry` to get all values associated with a given\n/// key. Returns `None` if there are no values associated with the key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::default();\n/// map.insert(HOST, \"hello\".to_string());\n/// map.get_mut(\"host\").unwrap().push_str(\"-world\");\n///\n/// assert_eq!(map.get(HOST).unwrap(), &\"hello-world\");\n/// ```\npub fn get_mut<K>(&mut self, key: K) -> Option<&mut T>\n        where K: AsHeaderName{\n        match key.find(self) {\n            Some((_, found)) => {\n                let entry = &mut self.entries[found];\n                Some(&mut entry.value)\n            }\n            None => None,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::grow":["#[inline]\nfn grow(&mut self, new_raw_cap: usize){\n        // This path can never be reached when handling the first allocation in\n        // the map.\n\n        // find first ideally placed element -- start of cluster\n        let mut first_ideal = 0;\n\n        for (i, pos) in self.indices.iter().enumerate() {\n            if let Some((_, entry_hash)) = pos.resolve() {\n                if 0 == probe_distance(self.mask, entry_hash, i) {\n                    first_ideal = i;\n                    break;\n                }\n            }\n        }\n\n        // visit the entries in an order where we can simply reinsert them\n        // into self.indices without any bucket stealing.\n        let old_indices = mem::replace(&mut self.indices, vec![Pos::none(); new_raw_cap].into_boxed_slice());\n        self.mask = new_raw_cap.wrapping_sub(1) as Size;\n\n        for &pos in &old_indices[first_ideal..] {\n            self.reinsert_entry_in_order(pos);\n        }\n\n        for &pos in &old_indices[..first_ideal] {\n            self.reinsert_entry_in_order(pos);\n        }\n\n        // Reserve additional entry slots\n        let more = self.capacity() - self.entries.len();\n        self.entries.reserve_exact(more);\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::insert":["/// Inserts a key-value pair into the map.\n///\n/// If the map did not previously have this key present, then `None` is\n/// returned.\n///\n/// If the map did have this key present, the new value is associated with\n/// the key and all previous values are removed. **Note** that only a single\n/// one of the previous values is returned. If there are multiple values\n/// that have been previously associated with the key, then the first one is\n/// returned. See `insert_mult` on `OccupiedEntry` for an API that returns\n/// all values.\n///\n/// The key is not updated, though; this matters for types that can be `==`\n/// without being identical.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(map.insert(HOST, \"world\".parse().unwrap()).is_none());\n/// assert!(!map.is_empty());\n///\n/// let mut prev = map.insert(HOST, \"earth\".parse().unwrap()).unwrap();\n/// assert_eq!(\"world\", prev);\n/// ```\npub fn insert<K>(&mut self, key: K, val: T) -> Option<T>\n        where K: IntoHeaderName,{\n        key.insert(self, val)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::insert2":["#[inline]\nfn insert2<K>(&mut self, key: K, value: T) -> Option<T>\n        where K: Hash + Into<HeaderName>,\n              HeaderName: PartialEq<K>,{\n        self.reserve_one();\n\n        insert_phase_one!(\n            self, key, probe, pos, hash, danger,\n            // Vacant\n            {\n                drop(danger); // Make lint happy\n                let index = self.entries.len();\n                self.insert_entry(hash, key.into(), value);\n                self.indices[probe] = Pos::new(index, hash);\n                None\n            },\n            // Occupied\n            Some(self.insert_occupied(pos, value)),\n            // Robinhood\n            {\n                self.insert_phase_two(\n                    key.into(),\n                    value,\n                    hash,\n                    probe,\n                    danger);\n                None\n            })\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::insert_entry":["#[inline]\nfn insert_entry(&mut self, hash: HashValue, key: HeaderName, value: T){\n        assert!(self.entries.len() < MAX_SIZE, \"header map at capacity\");\n\n        self.entries.push(Bucket {\n            hash: hash,\n            key: key,\n            value: value,\n            links: None,\n        });\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::insert_occupied":["/// Set an occupied bucket to the given value\n#[inline]\nfn insert_occupied(&mut self, index: usize, value: T) -> T{\n        if let Some(links) = self.entries[index].links {\n            self.remove_all_extra_values(links.next);\n        }\n\n        let entry = &mut self.entries[index];\n        mem::replace(&mut entry.value, value)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::insert_occupied_mult":["fn insert_occupied_mult(&mut self, index: usize, value: T) -> ValueDrain<T>{\n        let old;\n        let links;\n\n        {\n            let entry = &mut self.entries[index];\n\n            old = mem::replace(&mut entry.value, value);\n            links = entry.links.take();\n        }\n\n        ValueDrain {\n            map: self as *mut _,\n            first: Some(old),\n            next: links.map(|l| l.next),\n            lt: PhantomData,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::insert_phase_two":["/// phase 2 is post-insert where we forward-shift `Pos` in the indices.\n#[inline]\nfn insert_phase_two(&mut self,\n                        key: HeaderName,\n                        value: T,\n                        hash: HashValue,\n                        probe: usize,\n                        danger: bool) -> usize{\n        // Push the value and get the index\n        let index = self.entries.len();\n        self.insert_entry(hash, key, value);\n\n        let num_displaced = do_insert_phase_two(\n            &mut self.indices,\n            probe,\n            Pos::new(index, hash));\n\n        if danger || num_displaced >= DISPLACEMENT_THRESHOLD {\n            // Increase danger level\n            self.danger.to_yellow();\n        }\n\n        index\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::is_empty":["/// Returns true if the map contains no elements.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n///\n/// assert!(map.is_empty());\n///\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n///\n/// assert!(!map.is_empty());\n/// ```\npub fn is_empty(&self) -> bool{\n        self.entries.len() == 0\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::iter":["/// An iterator visiting all key-value pairs.\n///\n/// The iteration order is arbitrary, but consistent across platforms for\n/// the same crate version. Each key will be yielded once per associated\n/// value. So, if a key has 3 associated values, it will be yielded 3 times.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, \"hello\".parse().unwrap());\n/// map.append(HOST, \"goodbye\".parse().unwrap());\n/// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n///\n/// for (key, value) in map.iter() {\n///     println!(\"{:?}: {:?}\", key, value);\n/// }\n/// ```\npub fn iter(&self) -> Iter<T>{\n        Iter {\n            inner: IterMut {\n                map: self as *const _ as *mut _,\n                entry: 0,\n                cursor: self.entries.first().map(|_| Cursor::Head),\n                lt: PhantomData,\n            }\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::iter_mut":["/// An iterator visiting all key-value pairs, with mutable value references.\n///\n/// The iterator order is arbitrary, but consistent across platforms for the\n/// same crate version. Each key will be yielded once per associated value,\n/// so if a key has 3 associated values, it will be yielded 3 times.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::default();\n///\n/// map.insert(HOST, \"hello\".to_string());\n/// map.append(HOST, \"goodbye\".to_string());\n/// map.insert(CONTENT_LENGTH, \"123\".to_string());\n///\n/// for (key, value) in map.iter_mut() {\n///     value.push_str(\"-boop\");\n/// }\n/// ```\npub fn iter_mut(&mut self) -> IterMut<T>{\n        IterMut {\n            map: self as *mut _,\n            entry: 0,\n            cursor: self.entries.first().map(|_| Cursor::Head),\n            lt: PhantomData,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::keys":["/// An iterator visiting all keys.\n///\n/// The iteration order is arbitrary, but consistent across platforms for\n/// the same crate version. Each key will be yielded only once even if it\n/// has multiple associated values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, \"hello\".parse().unwrap());\n/// map.append(HOST, \"goodbye\".parse().unwrap());\n/// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n///\n/// for key in map.keys() {\n///     println!(\"{:?}\", key);\n/// }\n/// ```\npub fn keys(&self) -> Keys<T>{\n        Keys { inner: self.entries.iter() }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::keys_len":["/// Returns the number of keys stored in the map.\n///\n/// This number will be less than or equal to `len()` as each key may have\n/// more than one associated value.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{ACCEPT, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(0, map.keys_len());\n///\n/// map.insert(ACCEPT, \"text/plain\".parse().unwrap());\n/// map.insert(HOST, \"localhost\".parse().unwrap());\n///\n/// assert_eq!(2, map.keys_len());\n///\n/// map.insert(ACCEPT, \"text/html\".parse().unwrap());\n///\n/// assert_eq!(2, map.keys_len());\n/// ```\npub fn keys_len(&self) -> usize{\n        self.entries.len()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::len":["/// Returns the number of headers stored in the map.\n///\n/// This number represents the total number of **values** stored in the map.\n/// This number can be greater than or equal to the number of **keys**\n/// stored given that a single key may have more than one associated value.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{ACCEPT, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(0, map.len());\n///\n/// map.insert(ACCEPT, \"text/plain\".parse().unwrap());\n/// map.insert(HOST, \"localhost\".parse().unwrap());\n///\n/// assert_eq!(2, map.len());\n///\n/// map.append(ACCEPT, \"text/html\".parse().unwrap());\n///\n/// assert_eq!(3, map.len());\n/// ```\npub fn len(&self) -> usize{\n        self.entries.len() + self.extra_values.len()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::rebuild":["fn rebuild(&mut self){\n        // Loop over all entries and re-insert them into the map\n        'outer:\n        for (index, entry) in self.entries.iter_mut().enumerate() {\n            let hash = hash_elem_using(&self.danger, &entry.key);\n            let mut probe = desired_pos(self.mask, hash);\n            let mut dist = 0;\n\n            // Update the entry's hash code\n            entry.hash = hash;\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((_, entry_hash)) = self.indices[probe].resolve() {\n                    // if existing element probed less than us, swap\n                    let their_dist = probe_distance(self.mask, entry_hash, probe);\n\n                    if their_dist < dist {\n                        // Robinhood\n                        break;\n                    }\n                } else {\n                    // Vacant slot\n                    self.indices[probe] = Pos::new(index, hash);\n                    continue 'outer;\n                }\n\n                dist += 1;\n            });\n\n            do_insert_phase_two(\n                &mut self.indices,\n                probe,\n                Pos::new(index, hash));\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::reinsert_entry_in_order":["fn reinsert_entry_in_order(&mut self, pos: Pos){\n        if let Some((_, entry_hash)) = pos.resolve() {\n            // Find first empty bucket and insert there\n            let mut probe = desired_pos(self.mask, entry_hash);\n\n            probe_loop!(probe < self.indices.len(), {\n                if self.indices[probe].resolve().is_none() {\n                    // empty bucket, insert here\n                    self.indices[probe] = pos;\n                    return;\n                }\n            });\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::remove":["/// Removes a key from the map, returning the value associated with the key.\n///\n/// Returns `None` if the map does not contain the key. If there are\n/// multiple values associated with the key, then the first one is returned.\n/// See `remove_entry_mult` on `OccupiedEntry` for an API that yields all\n/// values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n///\n/// let prev = map.remove(HOST).unwrap();\n/// assert_eq!(\"hello.world\", prev);\n///\n/// assert!(map.remove(HOST).is_none());\n/// ```\npub fn remove<K>(&mut self, key: K) -> Option<T>\n        where K: AsHeaderName{\n        match key.find(self) {\n            Some((probe, idx)) => {\n                if let Some(links) = self.entries[idx].links {\n                    self.remove_all_extra_values(links.next);\n                }\n\n                let entry = self.remove_found(probe, idx);\n\n                Some(entry.value)\n            }\n            None => None,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::remove_all_extra_values":["fn remove_all_extra_values(&mut self, mut head: usize){\n        loop {\n            let extra = self.remove_extra_value(head);\n\n            if let Link::Extra(idx) = extra.next {\n                head = idx;\n            } else {\n                break;\n            }\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::remove_extra_value":["/// Removes the `ExtraValue` at the given index.\n#[inline]\nfn remove_extra_value(&mut self, idx: usize) -> ExtraValue<T>{\n        let prev;\n        let next;\n\n        {\n            debug_assert!(self.extra_values.len() > idx);\n            let extra = &self.extra_values[idx];\n            prev = extra.prev;\n            next = extra.next;\n        }\n\n        // First unlink the extra value\n        match (prev, next) {\n            (Link::Entry(prev), Link::Entry(next)) => {\n                debug_assert_eq!(prev, next);\n                debug_assert!(self.entries.len() > prev);\n\n                self.entries[prev].links = None;\n            }\n            (Link::Entry(prev), Link::Extra(next)) => {\n                debug_assert!(self.entries.len() > prev);\n                debug_assert!(self.entries[prev].links.is_some());\n\n                self.entries[prev].links.as_mut().unwrap()\n                    .next = next;\n\n                debug_assert!(self.extra_values.len() > next);\n                self.extra_values[next].prev = Link::Entry(prev);\n            }\n            (Link::Extra(prev), Link::Entry(next)) => {\n                debug_assert!(self.entries.len() > next);\n                debug_assert!(self.entries[next].links.is_some());\n\n                self.entries[next].links.as_mut().unwrap()\n                    .tail = prev;\n\n                debug_assert!(self.extra_values.len() > prev);\n                self.extra_values[prev].next = Link::Entry(next);\n            }\n            (Link::Extra(prev), Link::Extra(next)) => {\n                debug_assert!(self.extra_values.len() > next);\n                debug_assert!(self.extra_values.len() > prev);\n\n                self.extra_values[prev].next = Link::Extra(next);\n                self.extra_values[next].prev = Link::Extra(prev);\n            }\n        }\n\n        // Remove the extra value\n        let mut extra = self.extra_values.swap_remove(idx);\n\n        // This is the index of the value that was moved (possibly `extra`)\n        let old_idx = self.extra_values.len();\n\n        // Update the links\n        if extra.prev == Link::Extra(old_idx) {\n            extra.prev = Link::Extra(idx);\n        }\n\n        if extra.next == Link::Extra(old_idx) {\n            extra.next = Link::Extra(idx);\n        }\n\n        // Check if another entry was displaced. If it was, then the links\n        // need to be fixed.\n        if idx != old_idx {\n            let next;\n            let prev;\n\n            {\n                debug_assert!(self.extra_values.len() > idx);\n                let moved = &self.extra_values[idx];\n                next = moved.next;\n                prev = moved.prev;\n            }\n\n            // An entry was moved, we have to the links\n            match prev {\n                Link::Entry(entry_idx) => {\n                    // It is critical that we do not attempt to read the\n                    // header name or value as that memory may have been\n                    // \"released\" already.\n                    debug_assert!(self.entries.len() > entry_idx);\n                    debug_assert!(self.entries[entry_idx].links.is_some());\n\n                    let links = self.entries[entry_idx].links.as_mut().unwrap();\n                    links.next = idx;\n                }\n                Link::Extra(extra_idx) => {\n                    debug_assert!(self.extra_values.len() > extra_idx);\n                    self.extra_values[extra_idx].next = Link::Extra(idx);\n                }\n            }\n\n            match next {\n                Link::Entry(entry_idx) => {\n                    debug_assert!(self.entries.len() > entry_idx);\n                    debug_assert!(self.entries[entry_idx].links.is_some());\n\n                    let links = self.entries[entry_idx].links.as_mut().unwrap();\n                    links.tail = idx;\n                }\n                Link::Extra(extra_idx) => {\n                    debug_assert!(self.extra_values.len() > extra_idx);\n                    self.extra_values[extra_idx].prev = Link::Extra(idx);\n                }\n            }\n        }\n\n        debug_assert!({\n            for v in &self.extra_values {\n                assert!(v.next != Link::Extra(old_idx));\n                assert!(v.prev != Link::Extra(old_idx));\n            }\n\n            true\n        });\n\n        extra\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::remove_found":["/// Remove an entry from the map.\n#[inline]\nfn remove_found(&mut self, probe: usize, found: usize) -> Bucket<T>{\n        // index `probe` and entry `found` is to be removed\n        // use swap_remove, but then we need to update the index that points\n        // to the other entry that has to move\n        self.indices[probe] = Pos::none();\n        let entry = self.entries.swap_remove(found);\n\n        // correct index that points to the entry that had to swap places\n        if let Some(entry) = self.entries.get(found) {\n            // was not last element\n            // examine new element in `found` and find it in indices\n            let mut probe = desired_pos(self.mask, entry.hash);\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((i, _)) = self.indices[probe].resolve() {\n                    if i >= self.entries.len() {\n                        // found it\n                        self.indices[probe] = Pos::new(found, entry.hash);\n                        break;\n                    }\n                }\n            });\n\n            // Update links\n            if let Some(links) = entry.links {\n                self.extra_values[links.next].prev = Link::Entry(found);\n                self.extra_values[links.tail].next = Link::Entry(found);\n            }\n        }\n\n        // backward shift deletion in self.indices\n        // after probe, shift all non-ideally placed indices backward\n        if self.entries.len() > 0 {\n            let mut last_probe = probe;\n            let mut probe = probe + 1;\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((_, entry_hash)) = self.indices[probe].resolve() {\n                    if probe_distance(self.mask, entry_hash, probe) > 0 {\n                        self.indices[last_probe] = self.indices[probe];\n                        self.indices[probe] = Pos::none();\n                    } else {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n\n                last_probe = probe;\n            });\n        }\n\n        entry\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::reserve":["/// Reserves capacity for at least `additional` more headers to be inserted\n/// into the `HeaderMap`.\n///\n/// The header map may reserve more space to avoid frequent reallocations.\n/// Like with `with_capacity`, this will be a \"best effort\" to avoid\n/// allocations until `additional` more headers are inserted. Certain usage\n/// patterns could cause additional allocations before the number is\n/// reached.\n///\n/// # Panics\n///\n/// Panics if the new allocation size overflows `usize`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.reserve(10);\n/// # map.insert(HOST, \"bar\".parse().unwrap());\n/// ```\npub fn reserve(&mut self, additional: usize){\n        // TODO: This can't overflow if done properly... since the max # of\n        // elements is u16::MAX.\n        let cap = self.entries.len()\n            .checked_add(additional)\n            .expect(\"reserve overflow\");\n\n        if cap > self.indices.len() {\n            let cap = cap.next_power_of_two();\n\n            if self.entries.len() == 0 {\n                self.mask = cap - 1;\n                self.indices = vec![Pos::none(); cap].into_boxed_slice();\n                self.entries = Vec::with_capacity(usable_capacity(cap));\n            } else {\n                self.grow(cap);\n            }\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::reserve_one":["fn reserve_one(&mut self){\n        let len = self.entries.len();\n\n        if self.danger.is_yellow() {\n            let load_factor = self.entries.len() as f32 / self.indices.len() as f32;\n\n            if load_factor >= LOAD_FACTOR_THRESHOLD {\n                // Transition back to green danger level\n                self.danger.to_green();\n\n                // Double the capacity\n                let new_cap = self.indices.len() * 2;\n\n                // Grow the capacity\n                self.grow(new_cap);\n            } else {\n                self.danger.to_red();\n\n                // Rebuild hash table\n                for index in self.indices.iter_mut() {\n                    *index = Pos::none();\n                }\n\n                self.rebuild();\n            }\n        } else if len == self.capacity() {\n            if len == 0 {\n                let new_raw_cap = 8;\n                self.mask = 8 - 1;\n                self.indices = vec![Pos::none(); new_raw_cap].into_boxed_slice();\n                self.entries = Vec::with_capacity(usable_capacity(new_raw_cap));\n            } else {\n                let raw_cap = self.indices.len();\n                self.grow(raw_cap << 1);\n            }\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::value_iter":["fn value_iter(&self, idx: Option<usize>) -> ValueIter<T>{\n        use self::Cursor::*;\n\n        if let Some(idx) = idx {\n            let back = {\n                let entry = &self.entries[idx];\n\n                entry.links\n                    .map(|l| Values(l.tail))\n                    .unwrap_or(Head)\n            };\n\n            ValueIter {\n                map: self,\n                index: idx,\n                front: Some(Head),\n                back: Some(back),\n            }\n        } else {\n            ValueIter {\n                map: self,\n                index: ::std::usize::MAX,\n                front: None,\n                back: None,\n            }\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::value_iter_mut":["fn value_iter_mut(&mut self, idx: usize) -> ValueIterMut<T>{\n        use self::Cursor::*;\n\n        let back = {\n            let entry = &self.entries[idx];\n\n            entry.links\n                .map(|l| Values(l.tail))\n                .unwrap_or(Head)\n        };\n\n        ValueIterMut {\n            map: self as *mut _,\n            index: idx,\n            front: Some(Head),\n            back: Some(back),\n            lt: PhantomData,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::values":["/// An iterator visiting all values.\n///\n/// The iteration order is arbitrary, but consistent across platforms for\n/// the same crate version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, \"hello\".parse().unwrap());\n/// map.append(HOST, \"goodbye\".parse().unwrap());\n/// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n///\n/// for value in map.values() {\n///     println!(\"{:?}\", value);\n/// }\n/// ```\npub fn values(&self) -> Values<T>{\n        Values { inner: self.iter() }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::values_mut":["/// An iterator visiting all values mutably.\n///\n/// The iteration order is arbitrary, but consistent across platforms for\n/// the same crate version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::default();\n///\n/// map.insert(HOST, \"hello\".to_string());\n/// map.append(HOST, \"goodbye\".to_string());\n/// map.insert(CONTENT_LENGTH, \"123\".to_string());\n///\n/// for value in map.values_mut() {\n///     value.push_str(\"-boop\");\n/// }\n/// ```\npub fn values_mut(&mut self) -> ValuesMut<T>{\n        ValuesMut { inner: self.iter_mut() }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::<T>::with_capacity":["/// Create an empty `HeaderMap` with the specified capacity.\n///\n/// The returned map will allocate internal storage in order to hold about\n/// `capacity` elements without reallocating. However, this is a \"best\n/// effort\" as there are usage patterns that could cause additional\n/// allocations before `capacity` headers are stored in the map.\n///\n/// More capacity than requested may be allocated.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let map: HeaderMap<u32> = HeaderMap::with_capacity(10);\n///\n/// assert!(map.is_empty());\n/// assert_eq!(12, map.capacity());\n/// ```\npub fn with_capacity(capacity: usize) -> HeaderMap<T>{\n        assert!(capacity <= MAX_SIZE, \"requested capacity too large\");\n\n        if capacity == 0 {\n            HeaderMap {\n                mask: 0,\n                indices: Box::new([]), // as a ZST, this doesn't actually allocate anything\n                entries: Vec::new(),\n                extra_values: Vec::new(),\n                danger: Danger::Green,\n            }\n        } else {\n            let raw_cap = to_raw_capacity(capacity).next_power_of_two();\n            debug_assert!(raw_cap > 0);\n\n            HeaderMap {\n                mask: (raw_cap - 1) as Size,\n                indices: vec![Pos::none(); raw_cap].into_boxed_slice(),\n                entries: Vec::with_capacity(raw_cap),\n                extra_values: Vec::new(),\n                danger: Danger::Green,\n            }\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::HeaderMap::new":["/// Create an empty `HeaderMap`.\n///\n/// The map will be created without any capacity. This function will not\n/// allocate.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let map = HeaderMap::new();\n///\n/// assert!(map.is_empty());\n/// assert_eq!(0, map.capacity());\n/// ```\npub fn new() -> Self{\n        HeaderMap::with_capacity(0)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::IntoIter":["/// An owning iterator over the entries of a `HeaderMap`.\n///\n/// This struct is created by the `into_iter` method on `HeaderMap`.\npub struct IntoIter<T> {\n    // If None, pull from `entries`\n    next: Option<usize>,\n    entries: vec::IntoIter<Bucket<T>>,\n    extra_values: Vec<ExtraValue<T>>,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Iter":["/// `HeaderMap` entry iterator.\n///\n/// Yields `(&HeaderName, &value)` tuples. The same header name may be yielded\n/// more than once if it has more than one associated value.\npub struct Iter<'a, T: 'a> {\n    inner: IterMut<'a, T>,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::IterMut":["/// `HeaderMap` mutable entry iterator\n///\n/// Yields `(&HeaderName, &mut value)` tuples. The same header name may be\n/// yielded more than once if it has more than one associated value.\npub struct IterMut<'a, T: 'a> {\n    map: *mut HeaderMap<T>,\n    entry: usize,\n    cursor: Option<Cursor>,\n    lt: PhantomData<&'a mut HeaderMap<T>>,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::IterMut::<'a, T>::next_unsafe":["fn next_unsafe(&mut self) -> Option<(&'a HeaderName, *mut T)>{\n        use self::Cursor::*;\n\n        if self.cursor.is_none() {\n            if (self.entry + 1) >= unsafe { &*self.map }.entries.len() {\n                return None;\n            }\n\n            self.entry += 1;\n            self.cursor = Some(Cursor::Head);\n        }\n\n        let entry = unsafe { &(*self.map).entries[self.entry] };\n\n        match self.cursor.unwrap() {\n            Head => {\n                self.cursor = entry.links.map(|l| Values(l.next));\n                Some((&entry.key, &entry.value as *const _ as *mut _))\n            }\n            Values(idx) => {\n                let extra = unsafe { &(*self.map).extra_values[idx] };\n\n                match extra.next {\n                    Link::Entry(_) => self.cursor = None,\n                    Link::Extra(i) => self.cursor = Some(Values(i)),\n                }\n\n                Some((&entry.key, &extra.value as *const _ as *mut _))\n            }\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Keys":["/// An iterator over `HeaderMap` keys.\n///\n/// Each header name is yielded only once, even if it has more than one\n/// associated value.\npub struct Keys<'a, T: 'a> {\n    inner: ::std::slice::Iter<'a, Bucket<T>>,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Link":["/// A header value node is either linked to another node in the `extra_values`\n/// list or it points to an entry in `entries`. The entry in `entries` is the\n/// start of the list and holds the associated header name.\nenum Link {\n    Entry(usize),\n    Extra(usize),\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Links":["/// The head and tail of the value linked list.\nstruct Links {\n    next: usize,\n    tail: usize,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::OccupiedEntry":["/// A view into a single occupied location in a `HeaderMap`.\n///\n/// This struct is returned as part of the `Entry` enum.\npub struct OccupiedEntry<'a, T: 'a> {\n    map: &'a mut HeaderMap<T>,\n    probe: usize,\n    index: usize,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::OccupiedEntry::<'a, T>::append":["/// Insert the value into the entry.\n///\n/// The new value is appended to the end of the entry's value list. All\n/// previous values associated with the entry are retained.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"world\".parse().unwrap());\n///\n/// if let Entry::Occupied(mut e) = map.entry(\"host\").unwrap() {\n///     e.append(\"earth\".parse().unwrap());\n/// }\n///\n/// let values = map.get_all(\"host\");\n/// let mut i = values.iter();\n/// assert_eq!(\"world\", *i.next().unwrap());\n/// assert_eq!(\"earth\", *i.next().unwrap());\n/// ```\npub fn append(&mut self, value: T){\n        let idx = self.index;\n        let entry = &mut self.map.entries[idx];\n        append_value(idx, entry, &mut self.map.extra_values, value.into());\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::OccupiedEntry::<'a, T>::get":["/// Get a reference to the first value in the entry.\n///\n/// Values are stored in insertion order.\n///\n/// # Panics\n///\n/// `get` panics if there are no values associated with the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n///\n/// if let Entry::Occupied(mut e) = map.entry(\"host\").unwrap() {\n///     assert_eq!(e.get(), &\"hello.world\");\n///\n///     e.append(\"hello.earth\".parse().unwrap());\n///\n///     assert_eq!(e.get(), &\"hello.world\");\n/// }\n/// ```\npub fn get(&self) -> &T{\n        &self.map.entries[self.index].value\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::OccupiedEntry::<'a, T>::get_mut":["/// Get a mutable reference to the first value in the entry.\n///\n/// Values are stored in insertion order.\n///\n/// # Panics\n///\n/// `get_mut` panics if there are no values associated with the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::default();\n/// map.insert(HOST, \"hello.world\".to_string());\n///\n/// if let Entry::Occupied(mut e) = map.entry(\"host\").unwrap() {\n///     e.get_mut().push_str(\"-2\");\n///     assert_eq!(e.get(), &\"hello.world-2\");\n/// }\n/// ```\npub fn get_mut(&mut self) -> &mut T{\n        &mut self.map.entries[self.index].value\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::OccupiedEntry::<'a, T>::insert":["/// Sets the value of the entry.\n///\n/// All previous values associated with the entry are removed and the first\n/// one is returned. See `insert_mult` for an API that returns all values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n///\n/// if let Entry::Occupied(mut e) = map.entry(\"host\").unwrap() {\n///     let mut prev = e.insert(\"earth\".parse().unwrap());\n///     assert_eq!(\"hello.world\", prev);\n/// }\n///\n/// assert_eq!(\"earth\", map[\"host\"]);\n/// ```\npub fn insert(&mut self, value: T) -> T{\n        self.map.insert_occupied(self.index, value.into())\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::OccupiedEntry::<'a, T>::insert_mult":["/// Sets the value of the entry.\n///\n/// This function does the same as `insert` except it returns an iterator\n/// that yields all values previously associated with the key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"world\".parse().unwrap());\n/// map.append(HOST, \"world2\".parse().unwrap());\n///\n/// if let Entry::Occupied(mut e) = map.entry(\"host\").unwrap() {\n///     let mut prev = e.insert_mult(\"earth\".parse().unwrap());\n///     assert_eq!(\"world\", prev.next().unwrap());\n///     assert_eq!(\"world2\", prev.next().unwrap());\n///     assert!(prev.next().is_none());\n/// }\n///\n/// assert_eq!(\"earth\", map[\"host\"]);\n/// ```\npub fn insert_mult(&mut self, value: T) -> ValueDrain<T>{\n        self.map.insert_occupied_mult(self.index, value.into())\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::OccupiedEntry::<'a, T>::into_mut":["/// Converts the `OccupiedEntry` into a mutable reference to the **first**\n/// value.\n///\n/// The lifetime of the returned reference is bound to the original map.\n///\n/// # Panics\n///\n/// `into_mut` panics if there are no values associated with the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::default();\n/// map.insert(HOST, \"hello.world\".to_string());\n/// map.append(HOST, \"hello.earth\".to_string());\n///\n/// if let Entry::Occupied(e) = map.entry(\"host\").unwrap() {\n///     e.into_mut().push_str(\"-2\");\n/// }\n///\n/// assert_eq!(\"hello.world-2\", map[\"host\"]);\n/// ```\npub fn into_mut(self) -> &'a mut T{\n        &mut self.map.entries[self.index].value\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::OccupiedEntry::<'a, T>::iter":["/// Returns an iterator visiting all values associated with the entry.\n///\n/// Values are iterated in insertion order.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"world\".parse().unwrap());\n/// map.append(HOST, \"earth\".parse().unwrap());\n///\n/// if let Entry::Occupied(e) = map.entry(\"host\").unwrap() {\n///     let mut iter = e.iter();\n///     assert_eq!(&\"world\", iter.next().unwrap());\n///     assert_eq!(&\"earth\", iter.next().unwrap());\n///     assert!(iter.next().is_none());\n/// }\n/// ```\npub fn iter(&self) -> ValueIter<T>{\n        self.map.value_iter(Some(self.index))\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::OccupiedEntry::<'a, T>::iter_mut":["/// Returns an iterator mutably visiting all values associated with the\n/// entry.\n///\n/// Values are iterated in insertion order.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::default();\n/// map.insert(HOST, \"world\".to_string());\n/// map.append(HOST, \"earth\".to_string());\n///\n/// if let Entry::Occupied(mut e) = map.entry(\"host\").unwrap() {\n///     for e in e.iter_mut() {\n///         e.push_str(\"-boop\");\n///     }\n/// }\n///\n/// let mut values = map.get_all(\"host\");\n/// let mut i = values.iter();\n/// assert_eq!(&\"world-boop\", i.next().unwrap());\n/// assert_eq!(&\"earth-boop\", i.next().unwrap());\n/// ```\npub fn iter_mut(&mut self) -> ValueIterMut<T>{\n        self.map.value_iter_mut(self.index)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::OccupiedEntry::<'a, T>::key":["/// Returns a reference to the entry's key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"world\".parse().unwrap());\n///\n/// if let Entry::Occupied(e) = map.entry(\"host\").unwrap() {\n///     assert_eq!(\"host\", e.key());\n/// }\n/// ```\npub fn key(&self) -> &HeaderName{\n        &self.map.entries[self.index].key\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::OccupiedEntry::<'a, T>::remove":["/// Remove the entry from the map.\n///\n/// All values associated with the entry are removed and the first one is\n/// returned. See `remove_entry_mult` for an API that returns all values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"world\".parse().unwrap());\n///\n/// if let Entry::Occupied(e) = map.entry(\"host\").unwrap() {\n///     let mut prev = e.remove();\n///     assert_eq!(\"world\", prev);\n/// }\n///\n/// assert!(!map.contains_key(\"host\"));\n/// ```\npub fn remove(self) -> T{\n        self.remove_entry().1\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::OccupiedEntry::<'a, T>::remove_entry":["/// Remove the entry from the map.\n///\n/// The key and all values associated with the entry are removed and the\n/// first one is returned. See `remove_entry_mult` for an API that returns\n/// all values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"world\".parse().unwrap());\n///\n/// if let Entry::Occupied(e) = map.entry(\"host\").unwrap() {\n///     let (key, mut prev) = e.remove_entry();\n///     assert_eq!(\"host\", key.as_str());\n///     assert_eq!(\"world\", prev);\n/// }\n///\n/// assert!(!map.contains_key(\"host\"));\n/// ```\npub fn remove_entry(self) -> (HeaderName, T){\n        let entry = self.map.remove_found(self.probe, self.index);\n\n        if let Some(links) = entry.links {\n            self.map.remove_all_extra_values(links.next);\n        }\n\n        (entry.key, entry.value)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::OccupiedEntry::<'a, T>::remove_entry_mult":["/// Remove the entry from the map.\n///\n/// The key and all values associated with the entry are removed and\n/// returned.\npub fn remove_entry_mult(self) -> (HeaderName, ValueDrain<'a, T>){\n        let entry = self.map.remove_found(self.probe, self.index);\n        let drain = ValueDrain {\n            map: self.map as *mut _,\n            first: Some(entry.value),\n            next: entry.links.map(|l| l.next),\n            lt: PhantomData,\n        };\n        (entry.key, drain)\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Pos":["/// An entry in the hash table. This represents the full hash code for an entry\n/// as well as the position of the entry in the `entries` vector.\nstruct Pos {\n    // Index in the `entries` vec\n    index: Size,\n    // Full hash value for the entry.\n    hash: HashValue,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Pos::is_none":["#[inline]\nfn is_none(&self) -> bool{\n        self.index == !0\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Pos::is_some":["#[inline]\nfn is_some(&self) -> bool{\n        !self.is_none()\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Pos::new":["#[inline]\nfn new(index: usize, hash: HashValue) -> Self{\n        Pos {\n            index: index as Size,\n            hash: hash,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Pos::none":["#[inline]\nfn none() -> Self{\n        Pos {\n            index: !0,\n            hash: HashValue(0),\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Pos::resolve":["#[inline]\nfn resolve(&self) -> Option<(usize, HashValue)>{\n        if self.is_some() {\n            Some((self.index, self.hash))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::VacantEntry":["/// A view into a single empty location in a `HeaderMap`.\n///\n/// This struct is returned as part of the `Entry` enum.\npub struct VacantEntry<'a, T: 'a> {\n    map: &'a mut HeaderMap<T>,\n    key: HeaderName,\n    hash: HashValue,\n    probe: usize,\n    danger: bool,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::VacantEntry::<'a, T>::insert":["/// Insert the value into the entry.\n///\n/// The value will be associated with this entry's key. A mutable reference\n/// to the inserted value will be returned.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry};\n/// let mut map = HeaderMap::new();\n///\n/// if let Entry::Vacant(v) = map.entry(\"x-hello\").unwrap() {\n///     v.insert(\"world\".parse().unwrap());\n/// }\n///\n/// assert_eq!(map[\"x-hello\"], \"world\");\n/// ```\npub fn insert(self, value: T) -> &'a mut T{\n        // Ensure that there is space in the map\n        let index = self.map.insert_phase_two(\n            self.key,\n            value.into(),\n            self.hash,\n            self.probe,\n            self.danger);\n\n        &mut self.map.entries[index].value\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::VacantEntry::<'a, T>::insert_entry":["/// Insert the value into the entry.\n///\n/// The value will be associated with this entry's key. The new\n/// `OccupiedEntry` is returned, allowing for further manipulation.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n///\n/// if let Entry::Vacant(v) = map.entry(\"x-hello\").unwrap() {\n///     let mut e = v.insert_entry(\"world\".parse().unwrap());\n///     e.insert(\"world2\".parse().unwrap());\n/// }\n///\n/// assert_eq!(map[\"x-hello\"], \"world2\");\n/// ```\npub fn insert_entry(self, value: T) -> OccupiedEntry<'a, T>{\n        // Ensure that there is space in the map\n        let index = self.map.insert_phase_two(\n            self.key,\n            value.into(),\n            self.hash,\n            self.probe,\n            self.danger);\n\n        OccupiedEntry {\n            map: self.map,\n            index: index,\n            probe: self.probe,\n        }\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::VacantEntry::<'a, T>::into_key":["/// Take ownership of the key\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry};\n/// let mut map = HeaderMap::new();\n///\n/// if let Entry::Vacant(v) = map.entry(\"x-hello\").unwrap() {\n///     assert_eq!(v.into_key().as_str(), \"x-hello\");\n/// }\n/// ```\npub fn into_key(self) -> HeaderName{\n        self.key\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::VacantEntry::<'a, T>::key":["/// Returns a reference to the entry's key\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(map.entry(\"x-hello\").unwrap().key().as_str(), \"x-hello\");\n/// ```\npub fn key(&self) -> &HeaderName{\n        &self.key\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::ValueDrain":["/// An drain iterator of all values associated with a single header name.\npub struct ValueDrain<'a, T: 'a> {\n    map: *mut HeaderMap<T>,\n    first: Option<T>,\n    next: Option<usize>,\n    lt: PhantomData<&'a mut HeaderMap<T>>,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::ValueIter":["/// An iterator of all values associated with a single header name.\npub struct ValueIter<'a, T: 'a> {\n    map: &'a HeaderMap<T>,\n    index: usize,\n    front: Option<Cursor>,\n    back: Option<Cursor>,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::ValueIterMut":["/// A mutable iterator of all values associated with a single header name.\npub struct ValueIterMut<'a, T: 'a> {\n    map: *mut HeaderMap<T>,\n    index: usize,\n    front: Option<Cursor>,\n    back: Option<Cursor>,\n    lt: PhantomData<&'a mut HeaderMap<T>>,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::Values":["/// `HeaderMap` value iterator.\n///\n/// Each value contained in the `HeaderMap` will be yielded.\npub struct Values<'a, T: 'a> {\n    inner: Iter<'a, T>,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::ValuesMut":["/// `HeaderMap` mutable value iterator\npub struct ValuesMut<'a, T: 'a> {\n    inner: IterMut<'a, T>,\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::append_value":["#[inline]\nfn append_value<T>(entry_idx: usize,\n                   entry: &mut Bucket<T>,\n                   extra: &mut Vec<ExtraValue<T>>,\n                   value: T){\n    match entry.links {\n        Some(links) => {\n            let idx = extra.len();\n            extra.push(ExtraValue {\n                value: value,\n                prev: Link::Extra(links.tail),\n                next: Link::Entry(entry_idx),\n            });\n\n            extra[links.tail].next = Link::Extra(idx);\n\n            entry.links = Some(Links {\n                tail: idx,\n                .. links\n            });\n        }\n        None => {\n            let idx = extra.len();\n            extra.push(ExtraValue {\n                value: value,\n                prev: Link::Entry(entry_idx),\n                next: Link::Entry(entry_idx),\n            });\n\n            entry.links = Some(Links {\n                next: idx,\n                tail: idx,\n            });\n        }\n    }\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::as_header_name::AsHeaderName":["/// A marker trait used to identify values that can be used as search keys\n/// to a `HeaderMap`.\npub trait AsHeaderName: Sealed {}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::as_header_name::Sealed":["pub trait Sealed {\n        #[doc(hidden)]\n        fn entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<T>, InvalidHeaderName>;\n\n        #[doc(hidden)]\n        fn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>;\n\n        #[doc(hidden)]\n        fn as_str(&self) -> &str;\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::desired_pos":["#[inline]\nfn desired_pos(mask: Size, hash: HashValue) -> usize{\n    (hash.0 & mask)\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::do_insert_phase_two":["/// phase 2 is post-insert where we forward-shift `Pos` in the indices.\n///\n/// returns the number of displaced elements\n#[inline]\nfn do_insert_phase_two(indices: &mut [Pos],\n          mut probe: usize,\n          mut old_pos: Pos)\n    -> usize{\n    let mut num_displaced = 0;\n\n    probe_loop!(probe < indices.len(), {\n        let pos = &mut indices[probe];\n\n        if pos.is_none() {\n            *pos = old_pos;\n            break;\n        } else {\n            num_displaced += 1;\n            old_pos = mem::replace(pos, old_pos);\n        }\n    });\n\n    num_displaced\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::hash_elem_using":["fn hash_elem_using<K: ?Sized>(danger: &Danger, k: &K) -> HashValue\n    where K: Hash{\n    use fnv::FnvHasher;\n\n    const MASK: u64 = (MAX_SIZE as u64) - 1;\n\n    let hash = match *danger {\n        // Safe hash\n        Danger::Red(ref hasher) => {\n            let mut h = hasher.build_hasher();\n            k.hash(&mut h);\n            h.finish()\n        }\n        // Fast hash\n        _ => {\n            let mut h = FnvHasher::default();\n            k.hash(&mut h);\n            h.finish()\n        }\n    };\n\n    HashValue((hash & MASK) as usize)\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::into_header_name::IntoHeaderName":["/// A marker trait used to identify values that can be used as insert keys\n/// to a `HeaderMap`.\npub trait IntoHeaderName: Sealed {}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::into_header_name::Sealed":["pub trait Sealed {\n        #[doc(hidden)]\n        fn insert<T>(self, map: &mut HeaderMap<T>, val: T) -> Option<T>;\n\n        #[doc(hidden)]\n        fn append<T>(self, map: &mut HeaderMap<T>, val: T) -> bool;\n    }","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::probe_distance":["/// The number of steps that `current` is forward of the desired position for hash\n#[inline]\nfn probe_distance(mask: Size, hash: HashValue, current: usize) -> usize{\n    current.wrapping_sub(desired_pos(mask, hash)) & mask\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::to_raw_capacity":["#[inline]\nfn to_raw_capacity(n: usize) -> usize{\n    n + n / 3\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::map::usable_capacity":["#[inline]\nfn usable_capacity(cap: usize) -> usize{\n    cap - cap / 4\n}","Real(LocalPath(\"src/header/map.rs\"))"],"header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for &'a str>::eq":["/// Performs a case-insensitive comparison of the string against the header\n/// name\n#[inline]\nfn eq(&self, other: &HeaderName) -> bool{\n        *other == *self\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for str>::eq":["/// Performs a case-insensitive comparison of the string against the header\n/// name\n///\n/// # Examples\n///\n/// ```\n/// use http::header::CONTENT_LENGTH;\n///\n/// assert_eq!(CONTENT_LENGTH, \"content-length\");\n/// assert_eq!(CONTENT_LENGTH, \"Content-Length\");\n/// assert_ne!(CONTENT_LENGTH, \"content length\");\n/// ```\n#[inline]\nfn eq(&self, other: &HeaderName) -> bool{\n        *other == *self\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::<impl std::convert::From<header::name::Custom> for bytes::Bytes>::from":["#[inline]\nfn from(Custom(inner): Custom) -> Bytes{\n        Bytes::from(inner)\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::<impl std::convert::From<header::name::HeaderName> for bytes::Bytes>::from":["#[inline]\nfn from(name: HeaderName) -> Bytes{\n        name.inner.into()\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from":["fn from(repr: Repr<T>) -> Bytes{\n        match repr {\n            Repr::Standard(header) =>\n                Bytes::from_static(header.as_str().as_bytes()),\n            Repr::Custom(header) => header.into()\n        }\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::Custom":["struct Custom(ByteStr);","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::HdrName":["pub struct HdrName<'a> {\n    inner: Repr<MaybeLower<'a>>,\n}","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::HdrName::<'a>::custom":["fn custom(buf: &'a [u8], lower: bool) -> HdrName<'a>{\n        HdrName {\n            inner: Repr::Custom(MaybeLower {\n                buf: buf,\n                lower: lower,\n            }),\n        }\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::HdrName::<'a>::from_bytes":["#[allow(deprecated)]\npub fn from_bytes<F, U>(hdr: &[u8], f: F) -> Result<U, InvalidHeaderName>\n        where F: FnOnce(HdrName) -> U,{\n        let mut buf = unsafe { mem::uninitialized() };\n        let hdr = parse_hdr(hdr, &mut buf, &HEADER_CHARS)?;\n        Ok(f(hdr))\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::HdrName::<'a>::from_static":["#[allow(deprecated)]\npub fn from_static<F, U>(hdr: &'static str, f: F) -> U\n        where F: FnOnce(HdrName) -> U,{\n        let mut buf = unsafe { mem::uninitialized() };\n        let hdr = parse_hdr(hdr.as_bytes(), &mut buf, &HEADER_CHARS)\n            .expect(\"static str is invalid name\");\n        f(hdr)\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::HeaderName":["/// Represents an HTTP header field name\n///\n/// Header field names identify the header. Header sets may include multiple\n/// headers with the same name. The HTTP specification defines a number of\n/// standard headers, but HTTP messages may include non-standard header names as\n/// well as long as they adhere to the specification.\n///\n/// `HeaderName` is used as the [`HeaderMap`] key. Constants are available for\n/// all standard header names in the [`header`] module.\n///\n/// # Representation\n///\n/// `HeaderName` represents standard header names using an `enum`, as such they\n/// will not require an allocation for storage. All custom header names are\n/// lower cased upon conversion to a `HeaderName` value. This avoids the\n/// overhead of dynamically doing lower case conversion during the hash code\n/// computation and the comparison operation.\n///\n/// [`HeaderMap`]: struct.HeaderMap.html\n/// [`header`]: index.html\npub struct HeaderName {\n    inner: Repr<Custom>,\n}","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::HeaderName::as_str":["/// Returns a `str` representation of the header.\n///\n/// The returned string will always be lower case.\n#[inline]\npub fn as_str(&self) -> &str{\n        match self.inner {\n            Repr::Standard(v) => v.as_str(),\n            Repr::Custom(ref v) => &*v.0,\n        }\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::HeaderName::from_bytes":["/// Converts a slice of bytes to an HTTP header name.\n///\n/// This function normalizes the input.\n#[allow(deprecated)]\npub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName>{\n        let mut buf = unsafe { mem::uninitialized() };\n        match parse_hdr(src, &mut buf, &HEADER_CHARS)?.inner {\n            Repr::Standard(std) => Ok(std.into()),\n            Repr::Custom(MaybeLower { buf, lower: true }) => {\n                let buf = Bytes::from(buf);\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n            Repr::Custom(MaybeLower { buf, lower: false }) => {\n                use bytes::{BufMut};\n                let mut dst = BytesMut::with_capacity(buf.len());\n\n                for b in buf.iter() {\n                    let b = HEADER_CHARS[*b as usize];\n\n                    if b == 0 {\n                        return Err(InvalidHeaderName::new());\n                    }\n\n                    dst.put(b);\n                }\n\n                let val = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };\n\n                Ok(Custom(val).into())\n            }\n        }\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::HeaderName::from_lowercase":["/// Converts a slice of bytes to an HTTP header name.\n///\n/// This function expects the input to only contain lowercase characters.\n/// This is useful when decoding HTTP/2.0 headers. The HTTP/2.0\n/// specification requires that all headers be represented in lower case.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n///\n/// // Parsing a lower case header\n/// let hdr = HeaderName::from_lowercase(b\"content-length\").unwrap();\n/// assert_eq!(CONTENT_LENGTH, hdr);\n///\n/// // Parsing a header that contains uppercase characters\n/// assert!(HeaderName::from_lowercase(b\"Content-Length\").is_err());\n/// ```\n#[allow(deprecated)]\npub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName>{\n        let mut buf = unsafe { mem::uninitialized() };\n        match parse_hdr(src, &mut buf, &HEADER_CHARS_H2)?.inner {\n            Repr::Standard(std) => Ok(std.into()),\n            Repr::Custom(MaybeLower { buf, lower: true }) => {\n                let buf = Bytes::from(buf);\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n            Repr::Custom(MaybeLower { buf, lower: false }) => {\n                for &b in buf.iter() {\n                    if b != HEADER_CHARS[b as usize] {\n                        return Err(InvalidHeaderName::new());\n                    }\n                }\n\n                let buf = Bytes::from(buf);\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n        }\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::HeaderName::from_static":["/// Converts a static string to a HTTP header name.\n///\n/// This function panics when the static string is a invalid header.\n/// \n/// This function requires the static string to only contain lowercase \n/// characters, numerals and symbols, as per the HTTP/2.0 specification \n/// and header names internal representation within this library.\n/// \n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n/// // Parsing a standard header\n/// let hdr = HeaderName::from_static(\"content-length\");\n/// assert_eq!(CONTENT_LENGTH, hdr);\n/// \n/// // Parsing a custom header\n/// let CUSTOM_HEADER: &'static str = \"custom-header\";\n/// \n/// let a = HeaderName::from_lowercase(b\"custom-header\").unwrap();\n/// let b = HeaderName::from_static(CUSTOM_HEADER);\n/// assert_eq!(a, b);\n/// ```\n/// \n/// ```should_panic\n/// # use http::header::*;\n/// #\n/// // Parsing a header that contains invalid symbols(s):\n/// HeaderName::from_static(\"content{}{}length\"); // This line panics!\n/// \n/// // Parsing a header that contains invalid uppercase characters.\n/// let a = HeaderName::from_static(\"foobar\");\n/// let b = HeaderName::from_static(\"FOOBAR\"); // This line panics!\n/// ```\n#[allow(deprecated)]\npub fn from_static(src: &'static str) -> HeaderName{\n        let bytes = src.as_bytes();\n        let mut buf = unsafe { mem::uninitialized() };\n        match parse_hdr(bytes, &mut buf, &HEADER_CHARS_H2) {\n            Ok(hdr_name) => match hdr_name.inner {\n                Repr::Standard(std) => std.into(),\n                Repr::Custom(MaybeLower { buf: _, lower: true }) => {\n                    let val = ByteStr::from_static(src);\n                    Custom(val).into()\n                },\n                Repr::Custom(MaybeLower { buf: _, lower: false }) => {\n                    // With lower false, the string is left unchecked by\n                    // parse_hdr and must be validated manually.\n                    for &b in bytes.iter() {\n                        if HEADER_CHARS_H2[b as usize] == 0 {\n                            panic!(\"invalid header name\")\n                        }\n                    }\n\n                    let val = ByteStr::from_static(src);\n                    Custom(val).into()\n                }\n            },\n\n            Err(_) => panic!(\"invalid header name\")\n        }\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::InvalidHeaderName":["/// A possible error when converting a `HeaderName` from another type.\npub struct InvalidHeaderName {\n    _priv: (),\n}","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::InvalidHeaderName::new":["fn new() -> InvalidHeaderName{\n        InvalidHeaderName { _priv: () }\n    }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::InvalidHeaderNameBytes":["/// A possible error when converting a `HeaderName` from another type.\npub struct InvalidHeaderNameBytes(InvalidHeaderName) ;","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::MaybeLower":["struct MaybeLower<'a> {\n    buf: &'a [u8],\n    lower: bool,\n}","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::Repr":["enum Repr<T> {\n    Standard(StandardHeader),\n    Custom(T),\n}","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::StandardHeader":["enum StandardHeader {\n            $(\n                $konst,\n            )+\n        }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::StandardHeader::as_str":["#[inline]\nfn as_str(&self) -> &'static str{\n                match *self {\n                    $(\n                    StandardHeader::$konst => $name,\n                    )+\n                }\n            }","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::eq_ignore_ascii_case":["#[inline]\nfn eq_ignore_ascii_case(lower: &[u8], s: &[u8]) -> bool{\n    if lower.len() != s.len() {\n        return false;\n    }\n\n    lower.iter().zip(s).all(|(a, b)| {\n        *a == HEADER_CHARS[*b as usize]\n    })\n}","Real(LocalPath(\"src/header/name.rs\"))"],"header::name::parse_hdr":["#[cfg(any(not(debug_assertions), not(target_arch = \"wasm32\")))]\n/// This version is best under optimized mode, however in a wasm debug compile,\n/// the `eq` macro expands to 1 + 1 + 1 + 1... and wasm explodes when this chain gets too long\n/// See https://github.com/DenisKolodin/yew/issues/478\nfn parse_hdr<'a>(data: &'a [u8], b: &'a mut [u8; 64], table: &[u8; 256])\n    -> Result<HdrName<'a>, InvalidHeaderName>{\n    use self::StandardHeader::*;\n\n    let len = data.len();\n\n    let validate = |buf: &'a [u8], len: usize| {\n        let buf = &buf[..len];\n        if buf.iter().any(|&b| b == 0) {\n            Err(InvalidHeaderName::new())\n        } else {\n            Ok(HdrName::custom(buf, true))\n        }\n    };\n\n\n    macro_rules! to_lower {\n        ($d:ident, $src:ident, 1) => { $d[0] = table[$src[0] as usize]; };\n        ($d:ident, $src:ident, 2) => { to_lower!($d, $src, 1); $d[1] = table[$src[1] as usize]; };\n        ($d:ident, $src:ident, 3) => { to_lower!($d, $src, 2); $d[2] = table[$src[2] as usize]; };\n        ($d:ident, $src:ident, 4) => { to_lower!($d, $src, 3); $d[3] = table[$src[3] as usize]; };\n        ($d:ident, $src:ident, 5) => { to_lower!($d, $src, 4); $d[4] = table[$src[4] as usize]; };\n        ($d:ident, $src:ident, 6) => { to_lower!($d, $src, 5); $d[5] = table[$src[5] as usize]; };\n        ($d:ident, $src:ident, 7) => { to_lower!($d, $src, 6); $d[6] = table[$src[6] as usize]; };\n        ($d:ident, $src:ident, 8) => { to_lower!($d, $src, 7); $d[7] = table[$src[7] as usize]; };\n        ($d:ident, $src:ident, 9) => { to_lower!($d, $src, 8); $d[8] = table[$src[8] as usize]; };\n        ($d:ident, $src:ident, 10) => { to_lower!($d, $src, 9); $d[9] = table[$src[9] as usize]; };\n        ($d:ident, $src:ident, 11) => { to_lower!($d, $src, 10); $d[10] = table[$src[10] as usize]; };\n        ($d:ident, $src:ident, 12) => { to_lower!($d, $src, 11); $d[11] = table[$src[11] as usize]; };\n        ($d:ident, $src:ident, 13) => { to_lower!($d, $src, 12); $d[12] = table[$src[12] as usize]; };\n        ($d:ident, $src:ident, 14) => { to_lower!($d, $src, 13); $d[13] = table[$src[13] as usize]; };\n        ($d:ident, $src:ident, 15) => { to_lower!($d, $src, 14); $d[14] = table[$src[14] as usize]; };\n        ($d:ident, $src:ident, 16) => { to_lower!($d, $src, 15); $d[15] = table[$src[15] as usize]; };\n        ($d:ident, $src:ident, 17) => { to_lower!($d, $src, 16); $d[16] = table[$src[16] as usize]; };\n        ($d:ident, $src:ident, 18) => { to_lower!($d, $src, 17); $d[17] = table[$src[17] as usize]; };\n        ($d:ident, $src:ident, 19) => { to_lower!($d, $src, 18); $d[18] = table[$src[18] as usize]; };\n        ($d:ident, $src:ident, 20) => { to_lower!($d, $src, 19); $d[19] = table[$src[19] as usize]; };\n        ($d:ident, $src:ident, 21) => { to_lower!($d, $src, 20); $d[20] = table[$src[20] as usize]; };\n        ($d:ident, $src:ident, 22) => { to_lower!($d, $src, 21); $d[21] = table[$src[21] as usize]; };\n        ($d:ident, $src:ident, 23) => { to_lower!($d, $src, 22); $d[22] = table[$src[22] as usize]; };\n        ($d:ident, $src:ident, 24) => { to_lower!($d, $src, 23); $d[23] = table[$src[23] as usize]; };\n        ($d:ident, $src:ident, 25) => { to_lower!($d, $src, 24); $d[24] = table[$src[24] as usize]; };\n        ($d:ident, $src:ident, 26) => { to_lower!($d, $src, 25); $d[25] = table[$src[25] as usize]; };\n        ($d:ident, $src:ident, 27) => { to_lower!($d, $src, 26); $d[26] = table[$src[26] as usize]; };\n        ($d:ident, $src:ident, 28) => { to_lower!($d, $src, 27); $d[27] = table[$src[27] as usize]; };\n        ($d:ident, $src:ident, 29) => { to_lower!($d, $src, 28); $d[28] = table[$src[28] as usize]; };\n        ($d:ident, $src:ident, 30) => { to_lower!($d, $src, 29); $d[29] = table[$src[29] as usize]; };\n        ($d:ident, $src:ident, 31) => { to_lower!($d, $src, 30); $d[30] = table[$src[30] as usize]; };\n        ($d:ident, $src:ident, 32) => { to_lower!($d, $src, 31); $d[31] = table[$src[31] as usize]; };\n        ($d:ident, $src:ident, 33) => { to_lower!($d, $src, 32); $d[32] = table[$src[32] as usize]; };\n        ($d:ident, $src:ident, 34) => { to_lower!($d, $src, 33); $d[33] = table[$src[33] as usize]; };\n        ($d:ident, $src:ident, 35) => { to_lower!($d, $src, 34); $d[34] = table[$src[34] as usize]; };\n    }\n\n    assert!(len < super::MAX_HEADER_NAME_LEN,\n            \"header name too long -- max length is {}\",\n            super::MAX_HEADER_NAME_LEN);\n\n    match len {\n        0 => {\n            Err(InvalidHeaderName::new())\n        }\n        2 => {\n            to_lower!(b, data, 2);\n\n            if eq!(b == b't' b'e') {\n                Ok(Te.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        3 => {\n            to_lower!(b, data, 3);\n\n            if eq!(b == b'a' b'g' b'e') {\n                Ok(Age.into())\n            } else if eq!(b == b'v' b'i' b'a') {\n                Ok(Via.into())\n            } else if eq!(b == b'd' b'n' b't') {\n                Ok(Dnt.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        4 => {\n            to_lower!(b, data, 4);\n\n            if eq!(b == b'd' b'a' b't' b'e') {\n                Ok(Date.into())\n            } else if eq!(b == b'e' b't' b'a' b'g') {\n                Ok(Etag.into())\n            } else if eq!(b == b'f' b'r' b'o' b'm') {\n                Ok(From.into())\n            } else if eq!(b == b'h' b'o' b's' b't') {\n                Ok(Host.into())\n            } else if eq!(b == b'l' b'i' b'n' b'k') {\n                Ok(Link.into())\n            } else if eq!(b == b'v' b'a' b'r' b'y') {\n                Ok(Vary.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        5 => {\n            to_lower!(b, data, 5);\n\n            if eq!(b == b'a' b'l' b'l' b'o' b'w') {\n                Ok(Allow.into())\n            } else if eq!(b == b'r' b'a' b'n' b'g' b'e') {\n                Ok(Range.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        6 => {\n            to_lower!(b, data, 6);\n\n            if eq!(b == b'a' b'c' b'c' b'e' b'p' b't') {\n                return Ok(Accept.into())\n            } else if eq!(b == b'c' b'o' b'o' b'k' b'i' b'e') {\n                return Ok(Cookie.into())\n            } else if eq!(b == b'e' b'x' b'p' b'e' b'c' b't') {\n                return Ok(Expect.into())\n            } else if eq!(b == b'o' b'r' b'i' b'g' b'i' b'n') {\n                return Ok(Origin.into())\n            } else if eq!(b == b'p' b'r' b'a' b'g' b'm' b'a') {\n                return Ok(Pragma.into())\n            } else if b[0] == b's' {\n                if eq!(b[1] == b'e' b'r' b'v' b'e' b'r') {\n                    return Ok(Server.into())\n                }\n            }\n\n            validate(b, len)\n        }\n        7 => {\n            to_lower!(b, data, 7);\n\n            if eq!(b == b'a' b'l' b't' b'-' b's' b'v' b'c') {\n                Ok(AltSvc.into())\n            } else if eq!(b == b'e' b'x' b'p' b'i' b'r' b'e' b's') {\n                Ok(Expires.into())\n            } else if eq!(b == b'r' b'e' b'f' b'e' b'r' b'e' b'r') {\n                Ok(Referer.into())\n            } else if eq!(b == b'r' b'e' b'f' b'r' b'e' b's' b'h') {\n                Ok(Refresh.into())\n            } else if eq!(b == b't' b'r' b'a' b'i' b'l' b'e' b'r') {\n                Ok(Trailer.into())\n            } else if eq!(b == b'u' b'p' b'g' b'r' b'a' b'd' b'e') {\n                Ok(Upgrade.into())\n            } else if eq!(b == b'w' b'a' b'r' b'n' b'i' b'n' b'g') {\n                Ok(Warning.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        8 => {\n            to_lower!(b, data, 8);\n\n            if eq!(b == b'i' b'f' b'-') {\n                if eq!(b[3] == b'm' b'a' b't' b'c' b'h') {\n                    return Ok(IfMatch.into())\n                } else if eq!(b[3] == b'r' b'a' b'n' b'g' b'e') {\n                    return Ok(IfRange.into())\n                }\n            } else if eq!(b == b'l' b'o' b'c' b'a' b't' b'i' b'o' b'n') {\n                return Ok(Location.into())\n            }\n\n            validate(b, len)\n        }\n        9 => {\n            to_lower!(b, data, 9);\n\n            if eq!(b == b'f' b'o' b'r' b'w' b'a' b'r' b'd' b'e' b'd') {\n                Ok(Forwarded.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        10 => {\n            to_lower!(b, data, 10);\n\n            if eq!(b == b'c' b'o' b'n' b'n' b'e' b'c' b't' b'i' b'o' b'n') {\n                Ok(Connection.into())\n            } else if eq!(b == b's' b'e' b't' b'-' b'c' b'o' b'o' b'k' b'i' b'e') {\n                Ok(SetCookie.into())\n            } else if eq!(b == b'u' b's' b'e' b'r' b'-' b'a' b'g' b'e' b'n' b't') {\n                Ok(UserAgent.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        11 => {\n            to_lower!(b, data, 11);\n\n            if eq!(b == b'r' b'e' b't' b'r' b'y' b'-' b'a' b'f' b't' b'e' b'r') {\n                Ok(RetryAfter.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        12 => {\n            to_lower!(b, data, 12);\n\n            if eq!(b == b'c' b'o' b'n' b't' b'e' b'n' b't' b'-' b't' b'y' b'p' b'e') {\n                Ok(ContentType.into())\n            } else if eq!(b == b'm' b'a' b'x' b'-' b'f' b'o' b'r' b'w' b'a' b'r' b'd' b's') {\n                Ok(MaxForwards.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        13 => {\n            to_lower!(b, data, 13);\n\n            if b[0] == b'a' {\n                if eq!(b[1] == b'c' b'c' b'e' b'p' b't' b'-' b'r' b'a' b'n' b'g' b'e' b's') {\n                    return Ok(AcceptRanges.into())\n                } else if eq!(b[1] == b'u' b't' b'h' b'o' b'r' b'i' b'z' b'a' b't' b'i' b'o' b'n') {\n                    return Ok(Authorization.into())\n                }\n            } else if b[0] == b'c' {\n                if eq!(b[1] == b'a' b'c' b'h' b'e' b'-' b'c' b'o' b'n' b't' b'r' b'o' b'l') {\n                    return Ok(CacheControl.into())\n                } else if eq!(b[1] == b'o' b'n' b't' b'e' b'n' b't' b'-' b'r' b'a' b'n' b'g' b'e' ) {\n                    return Ok(ContentRange.into())\n                }\n            } else if eq!(b == b'i' b'f' b'-' b'n' b'o' b'n' b'e' b'-' b'm' b'a' b't' b'c' b'h') {\n                return Ok(IfNoneMatch.into())\n            } else if eq!(b == b'l' b'a' b's' b't' b'-' b'm' b'o' b'd' b'i' b'f' b'i' b'e' b'd') {\n                return Ok(LastModified.into())\n            }\n\n            validate(b, len)\n        }\n        14 => {\n            to_lower!(b, data, 14);\n\n            if eq!(b == b'a' b'c' b'c' b'e' b'p' b't' b'-' b'c' b'h' b'a' b'r' b's' b'e' b't') {\n                Ok(AcceptCharset.into())\n            } else if eq!(b == b'c' b'o' b'n' b't' b'e' b'n' b't' b'-' b'l' b'e' b'n' b'g' b't' b'h') {\n                Ok(ContentLength.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        15 => {\n            to_lower!(b, data, 15);\n\n            if eq!(b == b'a' b'c' b'c' b'e' b'p' b't' b'-') { // accept-\n                if eq!(b[7] == b'e' b'n' b'c' b'o' b'd' b'i' b'n' b'g') {\n                    return Ok(AcceptEncoding.into())\n                } else if eq!(b[7] == b'l' b'a' b'n' b'g' b'u' b'a' b'g' b'e') {\n                    return Ok(AcceptLanguage.into())\n                }\n            } else if eq!(b == b'p' b'u' b'b' b'l' b'i' b'c' b'-' b'k' b'e' b'y' b'-' b'p' b'i' b'n' b's') {\n                return Ok(PublicKeyPins.into())\n            } else if eq!(b == b'x' b'-' b'f' b'r' b'a' b'm' b'e' b'-' b'o' b'p' b't' b'i' b'o' b'n' b's') {\n                return Ok(XFrameOptions.into())\n            }\n            else if eq!(b == b'r' b'e' b'f' b'e' b'r' b'r' b'e' b'r' b'-' b'p' b'o' b'l' b'i' b'c' b'y') {\n                return Ok(ReferrerPolicy.into())\n            }\n\n            validate(b, len)\n        }\n        16 => {\n            to_lower!(b, data, 16);\n\n            if eq!(b == b'c' b'o' b'n' b't' b'e' b'n' b't' b'-') {\n                if eq!(b[8] == b'l' b'a' b'n' b'g' b'u' b'a' b'g' b'e') {\n                    return Ok(ContentLanguage.into())\n                } else if eq!(b[8] == b'l' b'o' b'c' b'a' b't' b'i' b'o' b'n') {\n                    return Ok(ContentLocation.into())\n                } else if eq!(b[8] == b'e' b'n' b'c' b'o' b'd' b'i' b'n' b'g') {\n                    return Ok(ContentEncoding.into())\n                }\n            } else if eq!(b == b'w' b'w' b'w' b'-' b'a' b'u' b't' b'h' b'e' b'n' b't' b'i' b'c' b'a' b't' b'e') {\n                return Ok(WwwAuthenticate.into())\n            } else if eq!(b == b'x' b'-' b'x' b's' b's' b'-' b'p' b'r' b'o' b't' b'e' b'c' b't' b'i' b'o' b'n') {\n                return Ok(XXssProtection.into())\n            }\n\n            validate(b, len)\n        }\n        17 => {\n            to_lower!(b, data, 17);\n\n            if eq!(b == b't' b'r' b'a' b'n' b's' b'f' b'e' b'r' b'-' b'e' b'n' b'c' b'o' b'd' b'i' b'n' b'g') {\n                Ok(TransferEncoding.into())\n            } else if eq!(b == b'i' b'f' b'-' b'm' b'o' b'd' b'i' b'f' b'i' b'e' b'd' b'-' b's' b'i' b'n' b'c' b'e') {\n                Ok(IfModifiedSince.into())\n            } else if eq!(b == b's' b'e' b'c' b'-' b'w' b'e' b'b' b's' b'o' b'c' b'k' b'e' b't' b'-' b'k' b'e' b'y') {\n                Ok(SecWebSocketKey.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        18 => {\n            to_lower!(b, data, 18);\n\n            if eq!(b == b'p' b'r' b'o' b'x' b'y' b'-' b'a' b'u' b't' b'h' b'e' b'n' b't' b'i' b'c' b'a' b't' b'e') {\n                Ok(ProxyAuthenticate.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        19 => {\n            to_lower!(b, data, 19);\n\n            if eq!(b == b'c' b'o' b'n' b't' b'e' b'n' b't' b'-' b'd' b'i' b's' b'p' b'o' b's' b'i' b't' b'i' b'o' b'n') {\n                Ok(ContentDisposition.into())\n            } else if eq!(b == b'i' b'f' b'-' b'u' b'n' b'm' b'o' b'd' b'i' b'f' b'i' b'e' b'd' b'-' b's' b'i' b'n' b'c' b'e') {\n                Ok(IfUnmodifiedSince.into())\n            } else if eq!(b == b'p' b'r' b'o' b'x' b'y' b'-' b'a' b'u' b't' b'h' b'o' b'r' b'i' b'z' b'a' b't' b'i' b'o' b'n') {\n                Ok(ProxyAuthorization.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        20 => {\n            to_lower!(b, data, 20);\n\n            if eq!(b == b's' b'e' b'c' b'-' b'w' b'e' b'b' b's' b'o' b'c' b'k' b'e' b't' b'-' b'a' b'c' b'c' b'e' b'p' b't') {\n                Ok(SecWebSocketAccept.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        21 => {\n            to_lower!(b, data, 21);\n\n            if eq!(b == b's' b'e' b'c' b'-' b'w' b'e' b'b' b's' b'o' b'c' b'k' b'e' b't' b'-' b'v' b'e' b'r' b's' b'i' b'o' b'n') {\n                Ok(SecWebSocketVersion.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        22 => {\n            to_lower!(b, data, 22);\n\n            if eq!(b == b'a' b'c' b'c' b'e' b's' b's' b'-' b'c' b'o' b'n' b't' b'r' b'o' b'l' b'-' b'm' b'a' b'x' b'-' b'a' b'g' b'e') {\n                Ok(AccessControlMaxAge.into())\n            } else if eq!(b == b'x' b'-' b'c' b'o' b'n' b't' b'e' b'n' b't' b'-' b't' b'y' b'p' b'e' b'-' b'o' b'p' b't' b'i' b'o' b'n' b's') {\n                Ok(XContentTypeOptions.into())\n            } else if eq!(b == b'x' b'-' b'd' b'n' b's' b'-' b'p' b'r' b'e' b'f' b'e' b't' b'c' b'h' b'-' b'c' b'o' b'n' b't' b'r' b'o' b'l') {\n                Ok(XDnsPrefetchControl.into())\n            } else if eq!(b == b's' b'e' b'c' b'-' b'w' b'e' b'b' b's' b'o' b'c' b'k' b'e' b't' b'-' b'p' b'r' b'o' b't' b'o' b'c' b'o' b'l') {\n                Ok(SecWebSocketProtocol.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        23 => {\n            to_lower!(b, data, 23);\n\n            if eq!(b == b'c' b'o' b'n' b't' b'e' b'n' b't' b'-' b's' b'e' b'c' b'u' b'r' b'i' b't' b'y' b'-' b'p' b'o' b'l' b'i' b'c' b'y') {\n                Ok(ContentSecurityPolicy.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        24 => {\n            to_lower!(b, data, 24);\n\n            if eq!(b == b's' b'e' b'c' b'-' b'w' b'e' b'b' b's' b'o' b'c' b'k' b'e' b't' b'-' b'e' b'x' b't' b'e' b'n' b's' b'i' b'o' b'n' b's') {\n                Ok(SecWebSocketExtensions.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        25 => {\n            to_lower!(b, data, 25);\n\n            if eq!(b == b's' b't' b'r' b'i' b'c' b't' b'-' b't' b'r' b'a' b'n' b's' b'p' b'o' b'r' b't' b'-' b's' b'e' b'c' b'u' b'r' b'i' b't' b'y') {\n                Ok(StrictTransportSecurity.into())\n            } else if eq!(b == b'u' b'p' b'g' b'r' b'a' b'd' b'e' b'-' b'i' b'n' b's' b'e' b'c' b'u' b'r' b'e' b'-' b'r' b'e' b'q' b'u' b'e' b's' b't' b's') {\n                Ok(UpgradeInsecureRequests.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        27 => {\n            to_lower!(b, data, 27);\n\n            if eq!(b == b'a' b'c' b'c' b'e' b's' b's' b'-' b'c' b'o' b'n' b't' b'r' b'o' b'l' b'-' b'a' b'l' b'l' b'o' b'w' b'-' b'o' b'r' b'i' b'g' b'i' b'n') {\n                Ok(AccessControlAllowOrigin.into())\n            } else if eq!(b == b'p' b'u' b'b' b'l' b'i' b'c' b'-' b'k' b'e' b'y' b'-' b'p' b'i' b'n' b's' b'-' b'r' b'e' b'p' b'o' b'r' b't' b'-' b'o' b'n' b'l' b'y') {\n                Ok(PublicKeyPinsReportOnly.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        28 => {\n            to_lower!(b, data, 28);\n\n            if eq!(b == b'a' b'c' b'c' b'e' b's' b's' b'-' b'c' b'o' b'n' b't' b'r' b'o' b'l' b'-' b'a' b'l' b'l' b'o' b'w' b'-') {\n                if eq!(b[21] == b'h' b'e' b'a' b'd' b'e' b'r' b's') {\n                    return Ok(AccessControlAllowHeaders.into())\n                } else if eq!(b[21] == b'm' b'e' b't' b'h' b'o' b'd' b's') {\n                    return Ok(AccessControlAllowMethods.into())\n                }\n            }\n\n            validate(b, len)\n        }\n        29 => {\n            to_lower!(b, data, 29);\n\n            if eq!(b == b'a' b'c' b'c' b'e' b's' b's' b'-' b'c' b'o' b'n' b't' b'r' b'o' b'l' b'-') {\n                if eq!(b[15] == b'e' b'x' b'p' b'o' b's' b'e' b'-' b'h' b'e' b'a' b'd' b'e' b'r' b's') {\n                    return Ok(AccessControlExposeHeaders.into())\n                } else if eq!(b[15] == b'r' b'e' b'q' b'u' b'e' b's' b't' b'-' b'm' b'e' b't' b'h' b'o' b'd') {\n                    return Ok(AccessControlRequestMethod.into())\n                }\n            }\n\n            validate(b, len)\n        }\n        30 => {\n            to_lower!(b, data, 30);\n\n            if eq!(b == b'a' b'c' b'c' b'e' b's' b's' b'-' b'c' b'o' b'n' b't' b'r' b'o' b'l' b'-' b'r' b'e' b'q' b'u' b'e' b's' b't' b'-' b'h' b'e' b'a' b'd' b'e' b'r' b's') {\n                Ok(AccessControlRequestHeaders.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        32 => {\n            to_lower!(b, data, 32);\n\n            if eq!(b == b'a' b'c' b'c' b'e' b's' b's' b'-' b'c' b'o' b'n' b't' b'r' b'o' b'l' b'-' b'a' b'l' b'l' b'o' b'w' b'-' b'c' b'r' b'e' b'd' b'e' b'n' b't' b'i' b'a' b'l' b's') {\n                Ok(AccessControlAllowCredentials.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        35 => {\n            to_lower!(b, data, 35);\n\n            if eq!(b == b'c' b'o' b'n' b't' b'e' b'n' b't' b'-' b's' b'e' b'c' b'u' b'r' b'i' b't' b'y' b'-' b'p' b'o' b'l' b'i' b'c' b'y' b'-' b'r' b'e' b'p' b'o' b'r' b't' b'-' b'o' b'n' b'l' b'y') {\n                Ok(ContentSecurityPolicyReportOnly.into())\n            } else {\n                validate(b, len)\n            }\n        }\n        _ => {\n            if len < 64 {\n                for i in 0..len {\n                    b[i] = table[data[i] as usize];\n                }\n\n                validate(b, len)\n            } else {\n                Ok(HdrName::custom(data, false))\n            }\n        }\n    }\n}","Real(LocalPath(\"src/header/name.rs\"))"],"header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for &'a str>::eq":["#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        *other == *self\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for [u8]>::eq":["#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        *other == *self\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for std::string::String>::eq":["#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        *other == *self\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for str>::eq":["#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        *other == *self\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for &'a str>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        self.as_bytes().partial_cmp(other.as_bytes())\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for [u8]>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        self.partial_cmp(other.as_bytes())\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for std::string::String>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        self.as_bytes().partial_cmp(other.as_bytes())\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for str>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        self.as_bytes().partial_cmp(other.as_bytes())\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::<impl std::convert::From<header::value::HeaderValue> for bytes::Bytes>::from":["#[inline]\nfn from(value: HeaderValue) -> Bytes{\n        value.inner\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue":["/// Represents an HTTP header field value.\n///\n/// In practice, HTTP header field values are usually valid ASCII. However, the\n/// HTTP spec allows for a header value to contain opaque bytes as well. In this\n/// case, the header field value is not able to be represented as a string.\n///\n/// To handle this, the `HeaderValue` is useable as a type and can be compared\n/// with strings and implements `Debug`. A `to_str` fn is provided that returns\n/// an `Err` if the header value contains non visible ascii characters.\npub struct HeaderValue {\n    inner: Bytes,\n    is_sensitive: bool,\n}","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue::as_bytes":["/// Converts a `HeaderValue` to a byte slice.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static(\"hello\");\n/// assert_eq!(val.as_bytes(), b\"hello\");\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &[u8]{\n        self.as_ref()\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue::from_bytes":["/// Attempt to convert a byte slice to a `HeaderValue`.\n///\n/// If the argument contains invalid header value bytes, an error is\n/// returned. Only byte values between 32 and 255 (inclusive) are permitted,\n/// excluding byte 127 (DEL).\n///\n/// This function is intended to be replaced in the future by a `TryFrom`\n/// implementation once the trait is stabilized in std.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_bytes(b\"hello\\xfa\").unwrap();\n/// assert_eq!(val, &b\"hello\\xfa\"[..]);\n/// ```\n///\n/// An invalid value\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_bytes(b\"\\n\");\n/// assert!(val.is_err());\n/// ```\n#[inline]\npub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue>{\n        HeaderValue::try_from(src)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue::from_name":["/// Converts a HeaderName into a HeaderValue\n///\n/// Since every valid HeaderName is a valid HeaderValue this is done infallibly.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderValue, HeaderName};\n/// # use http::header::ACCEPT;\n/// let val = HeaderValue::from_name(ACCEPT);\n/// assert_eq!(val, HeaderValue::from_bytes(b\"accept\").unwrap());\n/// ```\n#[inline]\npub fn from_name(name: HeaderName) -> HeaderValue{\n        name.into()\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue::from_shared":["/// Attempt to convert a `Bytes` buffer to a `HeaderValue`.\n///\n/// If the argument contains invalid header value bytes, an error is\n/// returned. Only byte values between 32 and 255 (inclusive) are permitted,\n/// excluding byte 127 (DEL).\n///\n/// This function is intended to be replaced in the future by a `TryFrom`\n/// implementation once the trait is stabilized in std.\n#[inline]\npub fn from_shared(src: Bytes) -> Result<HeaderValue, InvalidHeaderValueBytes>{\n        HeaderValue::try_from(src).map_err(InvalidHeaderValueBytes)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue::from_shared_unchecked":["/// Convert a `Bytes` directly into a `HeaderValue` without validating.\n///\n/// This function does NOT validate that illegal bytes are not contained\n/// within the buffer.\n#[inline]\npub unsafe fn from_shared_unchecked(src: Bytes) -> HeaderValue{\n        if cfg!(debug_assertions) {\n            match HeaderValue::from_shared(src) {\n                Ok(val) => val,\n                Err(_err) => {\n                    //TODO: if the Bytes were part of the InvalidHeaderValueBytes,\n                    //this message could include the invalid bytes.\n                    panic!(\"HeaderValue::from_shared_unchecked() with invalid bytes\");\n                },\n            }\n        } else {\n            HeaderValue {\n                inner: src,\n                is_sensitive: false,\n            }\n        }\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue::from_static":["/// Convert a static string to a `HeaderValue`.\n///\n/// This function will not perform any copying, however the string is\n/// checked to ensure that no invalid characters are present. Only visible\n/// ASCII characters (32-127) are permitted.\n///\n/// # Panics\n///\n/// This function panics if the argument contains invalid header value\n/// characters.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static(\"hello\");\n/// assert_eq!(val, \"hello\");\n/// ```\n#[inline]\npub fn from_static(src: &'static str) -> HeaderValue{\n        let bytes = src.as_bytes();\n        for &b in bytes {\n            if !is_visible_ascii(b) {\n                panic!(\"invalid header value\");\n            }\n        }\n\n        HeaderValue {\n            inner: Bytes::from_static(bytes),\n            is_sensitive: false,\n        }\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue::from_str":["/// Attempt to convert a string to a `HeaderValue`.\n///\n/// If the argument contains invalid header value characters, an error is\n/// returned. Only visible ASCII characters (32-127) are permitted. Use\n/// `from_bytes` to create a `HeaderValue` that includes opaque octets\n/// (128-255).\n///\n/// This function is intended to be replaced in the future by a `TryFrom`\n/// implementation once the trait is stabilized in std.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_str(\"hello\").unwrap();\n/// assert_eq!(val, \"hello\");\n/// ```\n///\n/// An invalid value\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_str(\"\\n\");\n/// assert!(val.is_err());\n/// ```\n#[inline]\npub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue>{\n        HeaderValue::try_from(src)\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue::is_empty":["/// Returns true if the `HeaderValue` has a length of zero bytes.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static(\"\");\n/// assert!(val.is_empty());\n///\n/// let val = HeaderValue::from_static(\"hello\");\n/// assert!(!val.is_empty());\n/// ```\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue::is_sensitive":["/// Returns `true` if the value represents sensitive data.\n///\n/// Sensitive data could represent passwords or other data that should not\n/// be stored on disk or in memory. This setting can be used by components\n/// like caches to avoid storing the value. HPACK encoders must set the\n/// header field to never index when `is_sensitive` returns true.\n///\n/// Note that sensitivity is not factored into equality or ordering.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let mut val = HeaderValue::from_static(\"my secret\");\n///\n/// val.set_sensitive(true);\n/// assert!(val.is_sensitive());\n///\n/// val.set_sensitive(false);\n/// assert!(!val.is_sensitive());\n/// ```\n#[inline]\npub fn is_sensitive(&self) -> bool{\n        self.is_sensitive\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue::len":["/// Returns the length of `self`.\n///\n/// This length is in bytes.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static(\"hello\");\n/// assert_eq!(val.len(), 5);\n/// ```\n#[inline]\npub fn len(&self) -> usize{\n        self.as_ref().len()\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue::set_sensitive":["/// Mark that the header value represents sensitive information.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let mut val = HeaderValue::from_static(\"my secret\");\n///\n/// val.set_sensitive(true);\n/// assert!(val.is_sensitive());\n///\n/// val.set_sensitive(false);\n/// assert!(!val.is_sensitive());\n/// ```\n#[inline]\npub fn set_sensitive(&mut self, val: bool){\n        self.is_sensitive = val;\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue::to_str":["/// Yields a `&str` slice if the `HeaderValue` only contains visible ASCII\n/// chars.\n///\n/// This function will perform a scan of the header value, checking all the\n/// characters.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static(\"hello\");\n/// assert_eq!(val.to_str().unwrap(), \"hello\");\n/// ```\npub fn to_str(&self) -> Result<&str, ToStrError>{\n        let bytes = self.as_ref();\n\n        for &b in bytes {\n            if !is_visible_ascii(b) {\n                return Err(ToStrError { _priv: () });\n            }\n        }\n\n        unsafe { Ok(str::from_utf8_unchecked(bytes)) }\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::HeaderValue::try_from":["fn try_from<T: AsRef<[u8]> + Into<Bytes>>(src: T) -> Result<HeaderValue, InvalidHeaderValue>{\n        for &b in src.as_ref() {\n            if !is_valid(b) {\n                return Err(InvalidHeaderValue {\n                    _priv: (),\n                });\n            }\n        }\n        Ok(HeaderValue {\n            inner: src.into(),\n            is_sensitive: false,\n        })\n    }","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::InvalidHeaderValue":["/// A possible error when converting a `HeaderValue` from a string or byte\n/// slice.\npub struct InvalidHeaderValue {\n    _priv: (),\n}","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::InvalidHeaderValueBytes":["/// A possible error when converting a `HeaderValue` from a string or byte\n/// slice.\npub struct InvalidHeaderValueBytes(InvalidHeaderValue);","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::ToStrError":["/// A possible error when converting a `HeaderValue` to a string representation.\n///\n/// Header field values may contain opaque bytes, in which case it is not\n/// possible to represent the value as a string.\npub struct ToStrError {\n    _priv: (),\n}","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::is_valid":["#[inline]\nfn is_valid(b: u8) -> bool{\n    b >= 32 && b != 127 || b == b'\\t'\n}","Real(LocalPath(\"src/header/value.rs\"))"],"header::value::is_visible_ascii":["fn is_visible_ascii(b: u8) -> bool{\n    b >= 32 && b < 127 || b == b'\\t'\n}","Real(LocalPath(\"src/header/value.rs\"))"],"method::<impl std::cmp::PartialEq<method::Method> for &'a str>::eq":["#[inline]\nfn eq(&self, other: &Method) -> bool{\n        *self == other.as_ref()\n    }","Real(LocalPath(\"src/method.rs\"))"],"method::<impl std::cmp::PartialEq<method::Method> for str>::eq":["#[inline]\nfn eq(&self, other: &Method) -> bool{\n        self == other.as_ref()\n    }","Real(LocalPath(\"src/method.rs\"))"],"method::Inner":["enum Inner {\n    Options,\n    Get,\n    Post,\n    Put,\n    Delete,\n    Head,\n    Trace,\n    Connect,\n    Patch,\n    // If the extension is short enough, store it inline\n    ExtensionInline([u8; MAX_INLINE], u8),\n    // Otherwise, allocate it\n    ExtensionAllocated(Box<[u8]>),\n}","Real(LocalPath(\"src/method.rs\"))"],"method::InvalidMethod":["/// A possible error value when converting `Method` from bytes.\npub struct InvalidMethod {\n    _priv: (),\n}","Real(LocalPath(\"src/method.rs\"))"],"method::InvalidMethod::new":["fn new() -> InvalidMethod{\n        InvalidMethod {\n            _priv: (),\n        }\n    }","Real(LocalPath(\"src/method.rs\"))"],"method::Method":["/// The Request Method (VERB)\n///\n/// This type also contains constants for a number of common HTTP methods such\n/// as GET, POST, etc.\n///\n/// Currently includes 8 variants representing the 8 methods defined in\n/// [RFC 7230](https://tools.ietf.org/html/rfc7231#section-4.1), plus PATCH,\n/// and an Extension variant for all extensions.\n///\n/// # Examples\n///\n/// ```\n/// use http::Method;\n///\n/// assert_eq!(Method::GET, Method::from_bytes(b\"GET\").unwrap());\n/// assert!(Method::GET.is_idempotent());\n/// assert_eq!(Method::POST.as_str(), \"POST\");\n/// ```\npub struct Method(Inner);","Real(LocalPath(\"src/method.rs\"))"],"method::Method::as_str":["/// Return a &str representation of the HTTP method\n#[inline]\npub fn as_str(&self) -> &str{\n        match self.0 {\n            Options => \"OPTIONS\",\n            Get => \"GET\",\n            Post => \"POST\",\n            Put => \"PUT\",\n            Delete => \"DELETE\",\n            Head => \"HEAD\",\n            Trace => \"TRACE\",\n            Connect => \"CONNECT\",\n            Patch => \"PATCH\",\n            ExtensionInline(ref data, len) => {\n                unsafe {\n                    str::from_utf8_unchecked(&data[..len as usize])\n                }\n            }\n            ExtensionAllocated(ref data) => {\n                unsafe {\n                    str::from_utf8_unchecked(data)\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/method.rs\"))"],"method::Method::extension_inline":["fn extension_inline(src: &[u8]) -> Result<Method, InvalidMethod>{\n        let mut data: [u8; MAX_INLINE] = Default::default();\n\n        write_checked(src, &mut data)?;\n\n        Ok(Method(ExtensionInline(data, src.len() as u8)))\n    }","Real(LocalPath(\"src/method.rs\"))"],"method::Method::from_bytes":["/// Converts a slice of bytes to an HTTP method.\npub fn from_bytes(src: &[u8]) -> Result<Method, InvalidMethod>{\n        match src.len() {\n            0 => {\n                Err(InvalidMethod::new())\n            }\n            3 => {\n                match src {\n                    b\"GET\" => Ok(Method(Get)),\n                    b\"PUT\" => Ok(Method(Put)),\n                    _ => Method::extension_inline(src),\n                }\n            }\n            4 => {\n                match src {\n                    b\"POST\" => Ok(Method(Post)),\n                    b\"HEAD\" => Ok(Method(Head)),\n                    _ => Method::extension_inline(src),\n                }\n            }\n            5 => {\n                match src {\n                    b\"PATCH\" => Ok(Method(Patch)),\n                    b\"TRACE\" => Ok(Method(Trace)),\n                    _ => Method::extension_inline(src),\n                }\n            }\n            6 => {\n                match src {\n                    b\"DELETE\" => Ok(Method(Delete)),\n                    _ => Method::extension_inline(src),\n                }\n            }\n            7 => {\n                match src {\n                    b\"OPTIONS\" => Ok(Method(Options)),\n                    b\"CONNECT\" => Ok(Method(Connect)),\n                    _ => Method::extension_inline(src),\n                }\n            }\n            _ => {\n                if src.len() < MAX_INLINE {\n                    Method::extension_inline(src)\n                } else {\n                    let mut data: Vec<u8> = vec![0; src.len()];\n\n                    write_checked(src, &mut data)?;\n\n                    Ok(Method(ExtensionAllocated(data.into_boxed_slice())))\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/method.rs\"))"],"method::Method::is_idempotent":["/// Whether a method is considered \"idempotent\", meaning the request has\n/// the same result if executed multiple times.\n///\n/// See [the spec](https://tools.ietf.org/html/rfc7231#section-4.2.2) for\n/// more words.\npub fn is_idempotent(&self) -> bool{\n        if self.is_safe() {\n            true\n        } else {\n            match self.0 {\n                Put | Delete => true,\n                _ => false\n            }\n        }\n    }","Real(LocalPath(\"src/method.rs\"))"],"method::Method::is_safe":["/// Whether a method is considered \"safe\", meaning the request is\n/// essentially read-only.\n///\n/// See [the spec](https://tools.ietf.org/html/rfc7231#section-4.2.1)\n/// for more words.\npub fn is_safe(&self) -> bool{\n        match self.0 {\n            Get | Head | Options | Trace => true,\n            _ => false\n        }\n    }","Real(LocalPath(\"src/method.rs\"))"],"method::write_checked":["fn write_checked(src: &[u8], dst: &mut [u8]) -> Result<(), InvalidMethod>{\n    for (i, &b) in src.iter().enumerate() {\n        let b = METHOD_CHARS[b as usize];\n\n        if b == 0 {\n            return Err(InvalidMethod::new());\n        }\n\n        dst[i] = b;\n    }\n\n    Ok(())\n}","Real(LocalPath(\"src/method.rs\"))"],"request::Builder":["/// An HTTP request builder\n///\n/// This type can be used to construct an instance or `Request`\n/// through a builder-like pattern.\npub struct Builder {\n    head: Option<Parts>,\n    err: Option<Error>,\n}","Real(LocalPath(\"src/request.rs\"))"],"request::Builder::body":["/// \"Consumes\" this builder, using the provided `body` to return a\n/// constructed `Request`.\n///\n/// # Errors\n///\n/// This function may return an error if any previously configured argument\n/// failed to parse or get converted to the internal representation. For\n/// example if an invalid `head` was specified via `header(\"Foo\",\n/// \"Bar\\r\\n\")` the error will be returned when this function is called\n/// rather than when `header` was called.\n///\n/// # Panics\n///\n/// This method will panic if the builder is reused. The `body` function can\n/// only be called once.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::builder()\n///     .body(())\n///     .unwrap();\n/// ```\npub fn body<T>(&mut self, body: T) -> Result<Request<T>>{\n        Ok(Request {\n            head: self.take_parts()?,\n            body: body,\n        })\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Builder::extension":["/// Adds an extension to this builder\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = Request::builder()\n///     .extension(\"My Extension\")\n///     .body(())\n///     .unwrap();\n///\n/// assert_eq!(req.extensions().get::<&'static str>(),\n///            Some(&\"My Extension\"));\n/// ```\npub fn extension<T>(&mut self, extension: T) -> &mut Builder\n        where T: Any + Send + Sync + 'static,{\n        if let Some(head) = head(&mut self.head, &self.err) {\n            head.extensions.insert(extension);\n        }\n        self\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Builder::header":["/// Appends a header to this request builder.\n///\n/// This function will append the provided key/value as a header to the\n/// internal `HeaderMap` being constructed. Essentially this is equivalent\n/// to calling `HeaderMap::append`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::HeaderValue;\n///\n/// let req = Request::builder()\n///     .header(\"Accept\", \"text/html\")\n///     .header(\"X-Custom-Foo\", \"bar\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn header<K, V>(&mut self, key: K, value: V) -> &mut Builder\n        where HeaderName: HttpTryFrom<K>,\n              HeaderValue: HttpTryFrom<V>{\n        if let Some(head) = head(&mut self.head, &self.err) {\n            match <HeaderName as HttpTryFrom<K>>::try_from(key) {\n                Ok(key) => {\n                    match <HeaderValue as HttpTryFrom<V>>::try_from(value) {\n                        Ok(value) => { head.headers.append(key, value); }\n                        Err(e) => self.err = Some(e.into()),\n                    }\n                },\n                Err(e) => self.err = Some(e.into()),\n            };\n        }\n        self\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Builder::headers_mut":["/// Get header on this request builder.\n/// when builder has error returns None\n/// \n/// # Example\n/// \n/// ```\n/// # use http::*;\n/// # use http::header::HeaderValue;\n/// # use http::request::Builder;\n/// let mut req = Request::builder();\n/// {\n///   let headers = req.headers_mut().unwrap();\n///   headers.insert(\"Accept\", HeaderValue::from_static(\"text/html\"));\n///   headers.insert(\"X-Custom-Foo\", HeaderValue::from_static(\"bar\"));\n/// }\n/// let headers = req.headers_ref().unwrap();\n/// assert_eq!( headers[\"Accept\"], \"text/html\" );\n/// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n/// ```\npub fn headers_mut(&mut self) -> Option<&mut HeaderMap<HeaderValue>>{\n        if self.err.is_some() {\n            return None;\n        }\n        match self.head\n        {\n            Some(ref mut head) => Some(&mut head.headers),\n            None => None\n        }\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Builder::headers_ref":["/// Get header on this request builder.\n/// when builder has error returns None\n/// \n/// # Example\n/// \n/// ```\n/// # use http::*;\n/// # use http::header::HeaderValue;\n/// # use http::request::Builder;\n/// let mut req = Request::builder();\n/// req.header(\"Accept\", \"text/html\")\n///    .header(\"X-Custom-Foo\", \"bar\");\n/// let headers = req.headers_ref().unwrap();\n/// assert_eq!( headers[\"Accept\"], \"text/html\" );\n/// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n/// ```\npub fn headers_ref(&self) -> Option<&HeaderMap<HeaderValue>>{\n        if self.err.is_some() {\n            return None;\n        }\n        match self.head\n        {\n            Some(ref head) => Some(&head.headers),\n            None => None\n        }\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Builder::method":["/// Set the HTTP method for this request.\n///\n/// This function will configure the HTTP method of the `Request` that will\n/// be returned from `Builder::build`.\n///\n/// By default this is `GET`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = Request::builder()\n///     .method(\"POST\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn method<T>(&mut self, method: T) -> &mut Builder\n        where Method: HttpTryFrom<T>,{\n        if let Some(head) = head(&mut self.head, &self.err) {\n            match HttpTryFrom::try_from(method) {\n                Ok(s) => head.method = s,\n                Err(e) => self.err = Some(e.into()),\n            }\n        }\n        self\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Builder::method_ref":["/// Get the HTTP Method for this request.\n/// \n/// By default this is `GET`.\n/// if builder has error, returns None.\n/// \n/// # Examples\n/// \n/// ```\n/// # use http::*;\n/// \n/// let mut req = Request::builder();\n/// assert_eq!(req.method_ref(),Some(&Method::GET));\n/// req.method(\"POST\");\n/// assert_eq!(req.method_ref(),Some(&Method::POST));\n/// req.method(\"DELETE\");\n/// assert_eq!(req.method_ref(),Some(&Method::DELETE));\n/// ```\npub fn method_ref(&self) -> Option<&Method>{\n        if self.err.is_some() {\n            return None\n        }\n        match self.head {\n            Some(ref head) => Some(&head.method),\n            None => None\n        }\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Builder::new":["/// Creates a new default instance of `Builder` to construct a `Request`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = request::Builder::new()\n///     .method(\"POST\")\n///     .body(())\n///     .unwrap();\n/// ```\n#[inline]\npub fn new() -> Builder{\n        Builder::default()\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Builder::take_parts":["fn take_parts(&mut self) -> Result<Parts>{\n        let ret = self.head.take().expect(\"cannot reuse request builder\");\n        if let Some(e) = self.err.take() {\n            return Err(e)\n        }\n        Ok(ret)\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Builder::uri":["/// Set the URI for this request.\n///\n/// This function will configure the URI of the `Request` that will\n/// be returned from `Builder::build`.\n///\n/// By default this is `/`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = Request::builder()\n///     .uri(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn uri<T>(&mut self, uri: T) -> &mut Builder\n        where Uri: HttpTryFrom<T>,{\n        if let Some(head) = head(&mut self.head, &self.err) {\n            match HttpTryFrom::try_from(uri) {\n                Ok(s) => head.uri = s,\n                Err(e) => self.err = Some(e.into()),\n            }\n        }\n        self\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Builder::uri_ref":["/// Get the URI for this request\n/// \n/// By default this is `/`\n/// # Examples\n/// \n/// ```\n/// # use http::*;\n/// \n/// let mut req = Request::builder();\n/// assert_eq!(req.uri_ref().unwrap().to_string(), \"/\" );\n/// req.uri(\"https://www.rust-lang.org/\");\n/// assert_eq!(req.uri_ref().unwrap().to_string(), \"https://www.rust-lang.org/\" );\n/// ```\npub fn uri_ref(&self) -> Option<&Uri>{\n        if self.err.is_some() {\n            return None;\n        }\n        match self.head\n        {\n            Some(ref head) => Some(&head.uri),\n            None => None\n        }\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Builder::version":["/// Set the HTTP version for this request.\n///\n/// This function will configure the HTTP version of the `Request` that\n/// will be returned from `Builder::build`.\n///\n/// By default this is HTTP/1.1\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = Request::builder()\n///     .version(Version::HTTP_2)\n///     .body(())\n///     .unwrap();\n/// ```\npub fn version(&mut self, version: Version) -> &mut Builder{\n        if let Some(head) = head(&mut self.head, &self.err) {\n            head.version = version;\n        }\n        self\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Parts":["/// Component parts of an HTTP `Request`\n///\n/// The HTTP request head consists of a method, uri, version, and a set of\n/// header fields.\npub struct Parts {\n    /// The request's method\n    pub method: Method,\n\n    /// The request's URI\n    pub uri: Uri,\n\n    /// The request's version\n    pub version: Version,\n\n    /// The request's headers\n    pub headers: HeaderMap<HeaderValue>,\n\n    /// The request's extensions\n    pub extensions: Extensions,\n\n    _priv: (),\n}","Real(LocalPath(\"src/request.rs\"))"],"request::Parts::new":["/// Creates a new default instance of `Parts`\nfn new() -> Parts{\n        Parts{\n            method: Method::default(),\n            uri: Uri::default(),\n            version: Version::default(),\n            headers: HeaderMap::default(),\n            extensions: Extensions::default(),\n            _priv: (),\n        }\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request":["/// Represents an HTTP request.\n///\n/// An HTTP request consists of a head and a potentially optional body. The body\n/// component is generic, enabling arbitrary types to represent the HTTP body.\n/// For example, the body could be `Vec<u8>`, a `Stream` of byte chunks, or a\n/// value that has been deserialized.\n///\n/// # Examples\n///\n/// Creating a `Request` to send\n///\n/// ```no_run\n/// use http::{Request, Response};\n///\n/// let mut request = Request::builder();\n/// request.uri(\"https://www.rust-lang.org/\")\n///        .header(\"User-Agent\", \"my-awesome-agent/1.0\");\n///\n/// if needs_awesome_header() {\n///     request.header(\"Awesome\", \"yes\");\n/// }\n///\n/// let response = send(request.body(()).unwrap());\n///\n/// # fn needs_awesome_header() -> bool {\n/// #     true\n/// # }\n/// #\n/// fn send(req: Request<()>) -> Response<()> {\n///     // ...\n/// # panic!()\n/// }\n/// ```\n///\n/// Inspecting a request to see what was sent.\n///\n/// ```\n/// use http::{Request, Response, StatusCode};\n///\n/// fn respond_to(req: Request<()>) -> http::Result<Response<()>> {\n///     if req.uri() != \"/awesome-url\" {\n///         return Response::builder()\n///             .status(StatusCode::NOT_FOUND)\n///             .body(())\n///     }\n///\n///     let has_awesome_header = req.headers().contains_key(\"Awesome\");\n///     let body = req.body();\n///\n///     // ...\n/// # panic!()\n/// }\n/// ```\n///\n/// Deserialize a request of bytes via json:\n///\n/// ```\n/// # extern crate serde;\n/// # extern crate serde_json;\n/// # extern crate http;\n/// use http::Request;\n/// use serde::de;\n///\n/// fn deserialize<T>(req: Request<Vec<u8>>) -> serde_json::Result<Request<T>>\n///     where for<'de> T: de::Deserialize<'de>,\n/// {\n///     let (parts, body) = req.into_parts();\n///     let body = serde_json::from_slice(&body)?;\n///     Ok(Request::from_parts(parts, body))\n/// }\n/// #\n/// # fn main() {}\n/// ```\n///\n/// Or alternatively, serialize the body of a request to json\n///\n/// ```\n/// # extern crate serde;\n/// # extern crate serde_json;\n/// # extern crate http;\n/// use http::Request;\n/// use serde::ser;\n///\n/// fn serialize<T>(req: Request<T>) -> serde_json::Result<Request<Vec<u8>>>\n///     where T: ser::Serialize,\n/// {\n///     let (parts, body) = req.into_parts();\n///     let body = serde_json::to_vec(&body)?;\n///     Ok(Request::from_parts(parts, body))\n/// }\n/// #\n/// # fn main() {}\n/// ```\npub struct Request<T> {\n    head: Parts,\n    body: T,\n}","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<()>::builder":["/// Creates a new builder-style object to manufacture a `Request`\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::builder()\n///     .method(\"GET\")\n///     .uri(\"https://www.rust-lang.org/\")\n///     .header(\"X-Custom-Foo\", \"Bar\")\n///     .body(())\n///     .unwrap();\n/// ```\n#[inline]\npub fn builder() -> Builder{\n        Builder::new()\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<()>::connect":["/// Creates a new `Builder` initialized with a CONNECT method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::connect(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn connect<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T>{\n        let mut b = Builder::new();\n        b.method(Method::CONNECT).uri(uri);\n        b\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<()>::delete":["/// Creates a new `Builder` initialized with a DELETE method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::delete(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn delete<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T>{\n        let mut b = Builder::new();\n        b.method(Method::DELETE).uri(uri);\n        b\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<()>::get":["/// Creates a new `Builder` initialized with a GET method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::get(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn get<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T>{\n        let mut b = Builder::new();\n        b.method(Method::GET).uri(uri);\n        b\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<()>::head":["/// Creates a new `Builder` initialized with a HEAD method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::head(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn head<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T>{\n        let mut b = Builder::new();\n        b.method(Method::HEAD).uri(uri);\n        b\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<()>::options":["/// Creates a new `Builder` initialized with an OPTIONS method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::options(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// # assert_eq!(*request.method(), Method::OPTIONS);\n/// ```\npub fn options<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T>{\n        let mut b = Builder::new();\n        b.method(Method::OPTIONS).uri(uri);\n        b\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<()>::patch":["/// Creates a new `Builder` initialized with a PATCH method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::patch(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn patch<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T>{\n        let mut b = Builder::new();\n        b.method(Method::PATCH).uri(uri);\n        b\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<()>::post":["/// Creates a new `Builder` initialized with a POST method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::post(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn post<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T>{\n        let mut b = Builder::new();\n        b.method(Method::POST).uri(uri);\n        b\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<()>::put":["/// Creates a new `Builder` initialized with a PUT method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::put(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn put<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T>{\n        let mut b = Builder::new();\n        b.method(Method::PUT).uri(uri);\n        b\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<()>::trace":["/// Creates a new `Builder` initialized with a TRACE method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::trace(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn trace<T>(uri: T) -> Builder\n        where Uri: HttpTryFrom<T>{\n        let mut b = Builder::new();\n        b.method(Method::TRACE).uri(uri);\n        b\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::body":["/// Returns a reference to the associated HTTP body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<String> = Request::default();\n/// assert!(request.body().is_empty());\n/// ```\n#[inline]\npub fn body(&self) -> &T{\n        &self.body\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::body_mut":["/// Returns a mutable reference to the associated HTTP body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut request: Request<String> = Request::default();\n/// request.body_mut().push_str(\"hello world\");\n/// assert!(!request.body().is_empty());\n/// ```\n#[inline]\npub fn body_mut(&mut self) -> &mut T{\n        &mut self.body\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::extensions":["/// Returns a reference to the associated extensions.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert!(request.extensions().get::<i32>().is_none());\n/// ```\n#[inline]\npub fn extensions(&self) -> &Extensions{\n        &self.head.extensions\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::extensions_mut":["/// Returns a mutable reference to the associated extensions.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::*;\n/// let mut request: Request<()> = Request::default();\n/// request.extensions_mut().insert(\"hello\");\n/// assert_eq!(request.extensions().get(), Some(&\"hello\"));\n/// ```\n#[inline]\npub fn extensions_mut(&mut self) -> &mut Extensions{\n        &mut self.head.extensions\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::from_parts":["/// Creates a new `Request` with the given components parts and body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::new(\"hello world\");\n/// let (mut parts, body) = request.into_parts();\n/// parts.method = Method::POST;\n///\n/// let request = Request::from_parts(parts, body);\n/// ```\n#[inline]\npub fn from_parts(parts: Parts, body: T) -> Request<T>{\n        Request {\n            head: parts,\n            body: body,\n        }\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::headers":["/// Returns a reference to the associated header field map.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert!(request.headers().is_empty());\n/// ```\n#[inline]\npub fn headers(&self) -> &HeaderMap<HeaderValue>{\n        &self.head.headers\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::headers_mut":["/// Returns a mutable reference to the associated header field map.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::*;\n/// let mut request: Request<()> = Request::default();\n/// request.headers_mut().insert(HOST, HeaderValue::from_static(\"world\"));\n/// assert!(!request.headers().is_empty());\n/// ```\n#[inline]\npub fn headers_mut(&mut self) -> &mut HeaderMap<HeaderValue>{\n        &mut self.head.headers\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::into_body":["/// Consumes the request, returning just the body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::Request;\n/// let request = Request::new(10);\n/// let body = request.into_body();\n/// assert_eq!(body, 10);\n/// ```\n#[inline]\npub fn into_body(self) -> T{\n        self.body\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::into_parts":["/// Consumes the request returning the head and body parts.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::new(());\n/// let (parts, body) = request.into_parts();\n/// assert_eq!(parts.method, Method::GET);\n/// ```\n#[inline]\npub fn into_parts(self) -> (Parts, T){\n        (self.head, self.body)\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::map":["/// Consumes the request returning a new request with body mapped to the\n/// return type of the passed in function.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::builder().body(\"some string\").unwrap();\n/// let mapped_request: Request<&[u8]> = request.map(|b| {\n///   assert_eq!(b, \"some string\");\n///   b.as_bytes()\n/// });\n/// assert_eq!(mapped_request.body(), &\"some string\".as_bytes());\n/// ```\n#[inline]\npub fn map<F, U>(self, f: F) -> Request<U>\n        where F: FnOnce(T) -> U{\n        Request { body: f(self.body), head: self.head }\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::method":["/// Returns a reference to the associated HTTP method.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert_eq!(*request.method(), Method::GET);\n/// ```\n#[inline]\npub fn method(&self) -> &Method{\n        &self.head.method\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::method_mut":["/// Returns a mutable reference to the associated HTTP method.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut request: Request<()> = Request::default();\n/// *request.method_mut() = Method::PUT;\n/// assert_eq!(*request.method(), Method::PUT);\n/// ```\n#[inline]\npub fn method_mut(&mut self) -> &mut Method{\n        &mut self.head.method\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::new":["/// Creates a new blank `Request` with the body\n///\n/// The component parts of this request will be set to their default, e.g.\n/// the GET method, no headers, etc.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::new(\"hello world\");\n///\n/// assert_eq!(*request.method(), Method::GET);\n/// assert_eq!(*request.body(), \"hello world\");\n/// ```\n#[inline]\npub fn new(body: T) -> Request<T>{\n        Request {\n            head: Parts::new(),\n            body: body,\n        }\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::uri":["/// Returns a reference to the associated URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert_eq!(*request.uri(), *\"/\");\n/// ```\n#[inline]\npub fn uri(&self) -> &Uri{\n        &self.head.uri\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::uri_mut":["/// Returns a mutable reference to the associated URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut request: Request<()> = Request::default();\n/// *request.uri_mut() = \"/hello\".parse().unwrap();\n/// assert_eq!(*request.uri(), *\"/hello\");\n/// ```\n#[inline]\npub fn uri_mut(&mut self) -> &mut Uri{\n        &mut self.head.uri\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::version":["/// Returns the associated version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert_eq!(request.version(), Version::HTTP_11);\n/// ```\n#[inline]\npub fn version(&self) -> Version{\n        self.head.version\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::Request::<T>::version_mut":["/// Returns a mutable reference to the associated version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut request: Request<()> = Request::default();\n/// *request.version_mut() = Version::HTTP_2;\n/// assert_eq!(request.version(), Version::HTTP_2);\n/// ```\n#[inline]\npub fn version_mut(&mut self) -> &mut Version{\n        &mut self.head.version\n    }","Real(LocalPath(\"src/request.rs\"))"],"request::head":["fn head<'a>(head: &'a mut Option<Parts>, err: &Option<Error>)\n    -> Option<&'a mut Parts>{\n    if err.is_some() {\n        return None\n    }\n    head.as_mut()\n}","Real(LocalPath(\"src/request.rs\"))"],"response::Builder":["/// An HTTP response builder\n///\n/// This type can be used to construct an instance of `Response` through a\n/// builder-like pattern.\npub struct Builder {\n    head: Option<Parts>,\n    err: Option<Error>,\n}","Real(LocalPath(\"src/response.rs\"))"],"response::Builder::body":["/// \"Consumes\" this builder, using the provided `body` to return a\n/// constructed `Response`.\n///\n/// # Errors\n///\n/// This function may return an error if any previously configured argument\n/// failed to parse or get converted to the internal representation. For\n/// example if an invalid `head` was specified via `header(\"Foo\",\n/// \"Bar\\r\\n\")` the error will be returned when this function is called\n/// rather than when `header` was called.\n///\n/// # Panics\n///\n/// This method will panic if the builder is reused. The `body` function can\n/// only be called once.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = Response::builder()\n///     .body(())\n///     .unwrap();\n/// ```\npub fn body<T>(&mut self, body: T) -> Result<Response<T>>{\n        Ok(Response {\n            head: self.take_parts()?,\n            body: body,\n        })\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Builder::extension":["/// Adds an extension to this builder\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = Response::builder()\n///     .extension(\"My Extension\")\n///     .body(())\n///     .unwrap();\n///\n/// assert_eq!(response.extensions().get::<&'static str>(),\n///            Some(&\"My Extension\"));\n/// ```\npub fn extension<T>(&mut self, extension: T) -> &mut Builder\n        where T: Any + Send + Sync + 'static,{\n        if let Some(head) = head(&mut self.head, &self.err) {\n            head.extensions.insert(extension);\n        }\n        self\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Builder::header":["/// Appends a header to this response builder.\n///\n/// This function will append the provided key/value as a header to the\n/// internal `HeaderMap` being constructed. Essentially this is equivalent\n/// to calling `HeaderMap::append`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::HeaderValue;\n///\n/// let response = Response::builder()\n///     .header(\"Content-Type\", \"text/html\")\n///     .header(\"X-Custom-Foo\", \"bar\")\n///     .header(\"content-length\", 0)\n///     .body(())\n///     .unwrap();\n/// ```\npub fn header<K, V>(&mut self, key: K, value: V) -> &mut Builder\n        where HeaderName: HttpTryFrom<K>,\n              HeaderValue: HttpTryFrom<V>{\n        if let Some(head) = head(&mut self.head, &self.err) {\n            match <HeaderName as HttpTryFrom<K>>::try_from(key) {\n                Ok(key) => {\n                    match <HeaderValue as HttpTryFrom<V>>::try_from(value) {\n                        Ok(value) => { head.headers.append(key, value); }\n                        Err(e) => self.err = Some(e.into()),\n                    }\n                },\n                Err(e) => self.err = Some(e.into()),\n            };\n        }\n        self\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Builder::headers_mut":["/// Get header on this response builder.\n/// when builder has error returns None\n/// \n/// # Example\n/// \n/// ```\n/// # use http::*;\n/// # use http::header::HeaderValue;\n/// # use http::response::Builder;\n/// let mut res = Response::builder();\n/// {\n///   let headers = res.headers_mut().unwrap();\n///   headers.insert(\"Accept\", HeaderValue::from_static(\"text/html\"));\n///   headers.insert(\"X-Custom-Foo\", HeaderValue::from_static(\"bar\"));\n/// }\n/// let headers = res.headers_ref().unwrap();\n/// assert_eq!( headers[\"Accept\"], \"text/html\" );\n/// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n/// ```\npub fn headers_mut(&mut self) -> Option<&mut HeaderMap<HeaderValue>>{\n        if self.err.is_some() {\n            return None;\n        }\n        match self.head\n        {\n            Some(ref mut head) => Some(&mut head.headers),\n            None => None\n        }\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Builder::headers_ref":["/// Get header on this response builder.\n/// when builder has error returns None\n/// \n/// # Example\n/// \n/// ```\n/// # use http::*;\n/// # use http::header::HeaderValue;\n/// # use http::response::Builder;\n/// let mut res = Response::builder();\n/// res.header(\"Accept\", \"text/html\")\n///    .header(\"X-Custom-Foo\", \"bar\");\n/// let headers = res.headers_ref().unwrap();\n/// assert_eq!( headers[\"Accept\"], \"text/html\" );\n/// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n/// ```\npub fn headers_ref(&self) -> Option<&HeaderMap<HeaderValue>>{\n        if self.err.is_some() {\n            return None;\n        }\n        match self.head\n        {\n            Some(ref head) => Some(&head.headers),\n            None => None\n        }\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Builder::new":["/// Creates a new default instance of `Builder` to construct either a\n/// `Head` or a `Response`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = response::Builder::new()\n///     .status(200)\n///     .body(())\n///     .unwrap();\n/// ```\n#[inline]\npub fn new() -> Builder{\n        Builder::default()\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Builder::status":["/// Set the HTTP status for this response.\n///\n/// This function will configure the HTTP status code of the `Response` that\n/// will be returned from `Builder::build`.\n///\n/// By default this is `200`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = Response::builder()\n///     .status(200)\n///     .body(())\n///     .unwrap();\n/// ```\npub fn status<T>(&mut self, status: T) -> &mut Builder\n        where StatusCode: HttpTryFrom<T>,{\n        if let Some(head) = head(&mut self.head, &self.err) {\n            match HttpTryFrom::try_from(status) {\n                Ok(s) => head.status = s,\n                Err(e) => self.err = Some(e.into()),\n            }\n        }\n        self\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Builder::take_parts":["fn take_parts(&mut self) -> Result<Parts>{\n        let ret = self.head.take().expect(\"cannot reuse response builder\");\n        if let Some(e) = self.err.take() {\n            return Err(e)\n        }\n        Ok(ret)\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Builder::version":["/// Set the HTTP version for this response.\n///\n/// This function will configure the HTTP version of the `Response` that\n/// will be returned from `Builder::build`.\n///\n/// By default this is HTTP/1.1\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = Response::builder()\n///     .version(Version::HTTP_2)\n///     .body(())\n///     .unwrap();\n/// ```\npub fn version(&mut self, version: Version) -> &mut Builder{\n        if let Some(head) = head(&mut self.head, &self.err) {\n            head.version = version;\n        }\n        self\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Parts":["/// Component parts of an HTTP `Response`\n///\n/// The HTTP response head consists of a status, version, and a set of\n/// header fields.\npub struct Parts {\n    /// The response's status\n    pub status: StatusCode,\n\n    /// The response's version\n    pub version: Version,\n\n    /// The response's headers\n    pub headers: HeaderMap<HeaderValue>,\n\n    /// The response's extensions\n    pub extensions: Extensions,\n\n    _priv: (),\n}","Real(LocalPath(\"src/response.rs\"))"],"response::Parts::new":["/// Creates a new default instance of `Parts`\nfn new() -> Parts{\n        Parts{\n            status: StatusCode::default(),\n            version: Version::default(),\n            headers: HeaderMap::default(),\n            extensions: Extensions::default(),\n            _priv: (),\n        }\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response":["/// Represents an HTTP response\n///\n/// An HTTP response consists of a head and a potentially optional body. The body\n/// component is generic, enabling arbitrary types to represent the HTTP body.\n/// For example, the body could be `Vec<u8>`, a `Stream` of byte chunks, or a\n/// value that has been deserialized.\n///\n/// Typically you'll work with responses on the client side as the result of\n/// sending a `Request` and on the server you'll be generating a `Request` to\n/// send back to the client.\n///\n/// # Examples\n///\n/// Creating a `Response` to return\n///\n/// ```\n/// use http::{Request, Response, StatusCode};\n///\n/// fn respond_to(req: Request<()>) -> http::Result<Response<()>> {\n///     let mut response = Response::builder();\n///     response.header(\"Foo\", \"Bar\")\n///             .status(StatusCode::OK);\n///\n///     if req.headers().contains_key(\"Another-Header\") {\n///         response.header(\"Another-Header\", \"Ack\");\n///     }\n///\n///     response.body(())\n/// }\n/// ```\n///\n/// A simple 404 handler\n///\n/// ```\n/// use http::{Request, Response, StatusCode};\n///\n/// fn not_found(_req: Request<()>) -> http::Result<Response<()>> {\n///     Response::builder()\n///         .status(StatusCode::NOT_FOUND)\n///         .body(())\n/// }\n/// ```\n///\n/// Or otherwise inspecting the result of a request:\n///\n/// ```no_run\n/// use http::{Request, Response};\n///\n/// fn get(url: &str) -> http::Result<Response<()>> {\n///     // ...\n/// # panic!()\n/// }\n///\n/// let response = get(\"https://www.rust-lang.org/\").unwrap();\n///\n/// if !response.status().is_success() {\n///     panic!(\"failed to get a successful response status!\");\n/// }\n///\n/// if let Some(date) = response.headers().get(\"Date\") {\n///     // we've got a `Date` header!\n/// }\n///\n/// let body = response.body();\n/// // ...\n/// ```\n///\n/// Deserialize a response of bytes via json:\n///\n/// ```\n/// # extern crate serde;\n/// # extern crate serde_json;\n/// # extern crate http;\n/// use http::Response;\n/// use serde::de;\n///\n/// fn deserialize<T>(req: Response<Vec<u8>>) -> serde_json::Result<Response<T>>\n///     where for<'de> T: de::Deserialize<'de>,\n/// {\n///     let (parts, body) = req.into_parts();\n///     let body = serde_json::from_slice(&body)?;\n///     Ok(Response::from_parts(parts, body))\n/// }\n/// #\n/// # fn main() {}\n/// ```\n///\n/// Or alternatively, serialize the body of a response to json\n///\n/// ```\n/// # extern crate serde;\n/// # extern crate serde_json;\n/// # extern crate http;\n/// use http::Response;\n/// use serde::ser;\n///\n/// fn serialize<T>(req: Response<T>) -> serde_json::Result<Response<Vec<u8>>>\n///     where T: ser::Serialize,\n/// {\n///     let (parts, body) = req.into_parts();\n///     let body = serde_json::to_vec(&body)?;\n///     Ok(Response::from_parts(parts, body))\n/// }\n/// #\n/// # fn main() {}\n/// ```\npub struct Response<T> {\n    head: Parts,\n    body: T,\n}","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<()>::builder":["/// Creates a new builder-style object to manufacture a `Response`\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Response`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response = Response::builder()\n///     .status(200)\n///     .header(\"X-Custom-Foo\", \"Bar\")\n///     .body(())\n///     .unwrap();\n/// ```\n#[inline]\npub fn builder() -> Builder{\n        Builder::new()\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::body":["/// Returns a reference to the associated HTTP body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<String> = Response::default();\n/// assert!(response.body().is_empty());\n/// ```\n#[inline]\npub fn body(&self) -> &T{\n        &self.body\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::body_mut":["/// Returns a mutable reference to the associated HTTP body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut response: Response<String> = Response::default();\n/// response.body_mut().push_str(\"hello world\");\n/// assert!(!response.body().is_empty());\n/// ```\n#[inline]\npub fn body_mut(&mut self) -> &mut T{\n        &mut self.body\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::extensions":["/// Returns a reference to the associated extensions.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// assert!(response.extensions().get::<i32>().is_none());\n/// ```\n#[inline]\npub fn extensions(&self) -> &Extensions{\n        &self.head.extensions\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::extensions_mut":["/// Returns a mutable reference to the associated extensions.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::*;\n/// let mut response: Response<()> = Response::default();\n/// response.extensions_mut().insert(\"hello\");\n/// assert_eq!(response.extensions().get(), Some(&\"hello\"));\n/// ```\n#[inline]\npub fn extensions_mut(&mut self) -> &mut Extensions{\n        &mut self.head.extensions\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::from_parts":["/// Creates a new `Response` with the given head and body\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response = Response::new(\"hello world\");\n/// let (mut parts, body) = response.into_parts();\n///\n/// parts.status = StatusCode::BAD_REQUEST;\n/// let response = Response::from_parts(parts, body);\n///\n/// assert_eq!(response.status(), StatusCode::BAD_REQUEST);\n/// assert_eq!(*response.body(), \"hello world\");\n/// ```\n#[inline]\npub fn from_parts(parts: Parts, body: T) -> Response<T>{\n        Response {\n            head: parts,\n            body: body,\n        }\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::headers":["/// Returns a reference to the associated header field map.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// assert!(response.headers().is_empty());\n/// ```\n#[inline]\npub fn headers(&self) -> &HeaderMap<HeaderValue>{\n        &self.head.headers\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::headers_mut":["/// Returns a mutable reference to the associated header field map.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::*;\n/// let mut response: Response<()> = Response::default();\n/// response.headers_mut().insert(HOST, HeaderValue::from_static(\"world\"));\n/// assert!(!response.headers().is_empty());\n/// ```\n#[inline]\npub fn headers_mut(&mut self) -> &mut HeaderMap<HeaderValue>{\n        &mut self.head.headers\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::into_body":["/// Consumes the response, returning just the body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::Response;\n/// let response = Response::new(10);\n/// let body = response.into_body();\n/// assert_eq!(body, 10);\n/// ```\n#[inline]\npub fn into_body(self) -> T{\n        self.body\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::into_parts":["/// Consumes the response returning the head and body parts.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// let (parts, body) = response.into_parts();\n/// assert_eq!(parts.status, StatusCode::OK);\n/// ```\n#[inline]\npub fn into_parts(self) -> (Parts, T){\n        (self.head, self.body)\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::map":["/// Consumes the response returning a new response with body mapped to the\n/// return type of the passed in function.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response = Response::builder().body(\"some string\").unwrap();\n/// let mapped_response: Response<&[u8]> = response.map(|b| {\n///   assert_eq!(b, \"some string\");\n///   b.as_bytes()\n/// });\n/// assert_eq!(mapped_response.body(), &\"some string\".as_bytes());\n/// ```\n#[inline]\npub fn map<F, U>(self, f: F) -> Response<U>\n        where F: FnOnce(T) -> U{\n        Response { body: f(self.body), head: self.head }\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::new":["/// Creates a new blank `Response` with the body\n///\n/// The component ports of this response will be set to their default, e.g.\n/// the ok status, no headers, etc.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response = Response::new(\"hello world\");\n///\n/// assert_eq!(response.status(), StatusCode::OK);\n/// assert_eq!(*response.body(), \"hello world\");\n/// ```\n#[inline]\npub fn new(body: T) -> Response<T>{\n        Response {\n            head: Parts::new(),\n            body: body,\n        }\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::status":["/// Returns the `StatusCode`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// assert_eq!(response.status(), StatusCode::OK);\n/// ```\n#[inline]\npub fn status(&self) -> StatusCode{\n        self.head.status\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::status_mut":["/// Returns a mutable reference to the associated `StatusCode`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut response: Response<()> = Response::default();\n/// *response.status_mut() = StatusCode::CREATED;\n/// assert_eq!(response.status(), StatusCode::CREATED);\n/// ```\n#[inline]\npub fn status_mut(&mut self) -> &mut StatusCode{\n        &mut self.head.status\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::version":["/// Returns a reference to the associated version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// assert_eq!(response.version(), Version::HTTP_11);\n/// ```\n#[inline]\npub fn version(&self) -> Version{\n        self.head.version\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::Response::<T>::version_mut":["/// Returns a mutable reference to the associated version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut response: Response<()> = Response::default();\n/// *response.version_mut() = Version::HTTP_2;\n/// assert_eq!(response.version(), Version::HTTP_2);\n/// ```\n#[inline]\npub fn version_mut(&mut self) -> &mut Version{\n        &mut self.head.version\n    }","Real(LocalPath(\"src/response.rs\"))"],"response::head":["fn head<'a>(head: &'a mut Option<Parts>, err: &Option<Error>)\n    -> Option<&'a mut Parts>{\n    if err.is_some() {\n        return None\n    }\n    head.as_mut()\n}","Real(LocalPath(\"src/response.rs\"))"],"sealed::Sealed":["/// Private trait to this crate to prevent traits from being implemented in\n/// downstream crates.\npub trait Sealed {}","Real(LocalPath(\"src/lib.rs\"))"],"status::<impl std::cmp::PartialEq<status::StatusCode> for u16>::eq":["#[inline]\nfn eq(&self, other: &StatusCode) -> bool{\n        *self == other.as_u16()\n    }","Real(LocalPath(\"src/status.rs\"))"],"status::<impl std::convert::From<status::StatusCode> for u16>::from":["#[inline]\nfn from(status: StatusCode) -> u16{\n        status.0\n    }","Real(LocalPath(\"src/status.rs\"))"],"status::InvalidStatusCode":["/// A possible error value when converting a `StatusCode` from a `u16` or `&str`\n///\n/// This error indicates that the supplied input was not a valid number, was less\n/// than 100, or was greater than 599.\npub struct InvalidStatusCode {\n    _priv: (),\n}","Real(LocalPath(\"src/status.rs\"))"],"status::InvalidStatusCode::new":["fn new() -> InvalidStatusCode{\n        InvalidStatusCode {\n            _priv: (),\n        }\n    }","Real(LocalPath(\"src/status.rs\"))"],"status::StatusCode":["/// An HTTP status code (`status-code` in RFC 7230 et al.).\n///\n/// This type contains constants for all common status codes.\n/// It allows status codes in the range [100, 599].\n///\n/// IANA maintain the [Hypertext Transfer Protocol (HTTP) Status Code\n/// Registry](http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) which is\n/// the source for this enum (with one exception, 418 I'm a teapot, which is\n/// inexplicably not in the register).\n///\n/// # Examples\n///\n/// ```\n/// use http::StatusCode;\n///\n/// assert_eq!(StatusCode::from_u16(200).unwrap(), StatusCode::OK);\n/// assert_eq!(StatusCode::NOT_FOUND.as_u16(), 404);\n/// assert!(StatusCode::OK.is_success());\n/// ```\npub struct StatusCode(u16);","Real(LocalPath(\"src/status.rs\"))"],"status::StatusCode::as_str":["/// Returns a &str representation of the `StatusCode`\n///\n/// The return value only includes a numerical representation of the\n/// status code. The canonical reason is not included.\n///\n/// # Example\n///\n/// ```\n/// let status = http::StatusCode::OK;\n/// assert_eq!(status.as_str(), \"200\");\n/// ```\n#[inline]\npub fn as_str(&self) -> &str{\n        CODES_AS_STR[(self.0 - 100) as usize]\n    }","Real(LocalPath(\"src/status.rs\"))"],"status::StatusCode::as_u16":["/// Returns the `u16` corresponding to this `StatusCode`.\n///\n/// # Note\n///\n/// This is the same as the `From<StatusCode>` implementation, but\n/// included as an inherent method because that implementation doesn't\n/// appear in rustdocs, as well as a way to force the type instead of\n/// relying on inference.\n///\n/// # Example\n///\n/// ```\n/// let status = http::StatusCode::OK;\n/// assert_eq!(status.as_u16(), 200);\n/// ```\n#[inline]\npub fn as_u16(&self) -> u16{\n        (*self).into()\n    }","Real(LocalPath(\"src/status.rs\"))"],"status::StatusCode::canonical_reason":["/// Get the standardised `reason-phrase` for this status code.\n///\n/// This is mostly here for servers writing responses, but could potentially have application\n/// at other times.\n///\n/// The reason phrase is defined as being exclusively for human readers. You should avoid\n/// deriving any meaning from it at all costs.\n///\n/// Bear in mind also that in HTTP/2.0 the reason phrase is abolished from transmission, and so\n/// this canonical reason phrase really is the only reason phrase you’ll find.\n///\n/// # Example\n///\n/// ```\n/// let status = http::StatusCode::OK;\n/// assert_eq!(status.canonical_reason(), Some(\"OK\"));\n/// ```\npub fn canonical_reason(&self) -> Option<&'static str>{\n        canonical_reason(self.0)\n    }","Real(LocalPath(\"src/status.rs\"))"],"status::StatusCode::from_bytes":["/// Converts a &[u8] to a status code\npub fn from_bytes(src: &[u8]) -> Result<StatusCode, InvalidStatusCode>{\n        if src.len() != 3 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        let a = src[0].wrapping_sub(b'0') as u16;\n        let b = src[1].wrapping_sub(b'0') as u16;\n        let c = src[2].wrapping_sub(b'0') as u16;\n\n        if a == 0 || a > 5 || b > 9 || c > 9 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        let status = (a * 100) + (b * 10) + c;\n        Ok(StatusCode(status))\n    }","Real(LocalPath(\"src/status.rs\"))"],"status::StatusCode::from_u16":["/// Converts a u16 to a status code.\n///\n/// The function validates the correctness of the supplied u16. It must be\n/// greater or equal to 100 but less than 600.\n///\n/// # Example\n///\n/// ```\n/// use http::StatusCode;\n///\n/// let ok = StatusCode::from_u16(200).unwrap();\n/// assert_eq!(ok, StatusCode::OK);\n///\n/// let err = StatusCode::from_u16(99);\n/// assert!(err.is_err());\n/// ```\n#[inline]\npub fn from_u16(src: u16) -> Result<StatusCode, InvalidStatusCode>{\n        if src < 100 || src >= 600 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        Ok(StatusCode(src))\n    }","Real(LocalPath(\"src/status.rs\"))"],"status::StatusCode::is_client_error":["/// Check if status is within 400-499.\n#[inline]\npub fn is_client_error(&self) -> bool{\n        500 > self.0 && self.0 >= 400\n    }","Real(LocalPath(\"src/status.rs\"))"],"status::StatusCode::is_informational":["/// Check if status is within 100-199.\n#[inline]\npub fn is_informational(&self) -> bool{\n        200 > self.0 && self.0 >= 100\n    }","Real(LocalPath(\"src/status.rs\"))"],"status::StatusCode::is_redirection":["/// Check if status is within 300-399.\n#[inline]\npub fn is_redirection(&self) -> bool{\n        400 > self.0 && self.0 >= 300\n    }","Real(LocalPath(\"src/status.rs\"))"],"status::StatusCode::is_server_error":["/// Check if status is within 500-599.\n#[inline]\npub fn is_server_error(&self) -> bool{\n        600 > self.0 && self.0 >= 500\n    }","Real(LocalPath(\"src/status.rs\"))"],"status::StatusCode::is_success":["/// Check if status is within 200-299.\n#[inline]\npub fn is_success(&self) -> bool{\n        300 > self.0 && self.0 >= 200\n    }","Real(LocalPath(\"src/status.rs\"))"],"status::canonical_reason":["fn canonical_reason(num: u16) -> Option<&'static str>{\n            match num {\n                $(\n                $num => Some($phrase),\n                )+\n                _ => None\n            }\n        }","Real(LocalPath(\"src/status.rs\"))"],"uri::<impl std::cmp::PartialEq<uri::Uri> for &'a str>::eq":["fn eq(&self, uri: &Uri) -> bool{\n        uri == *self\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::<impl std::cmp::PartialEq<uri::Uri> for str>::eq":["fn eq(&self, uri: &Uri) -> bool{\n        uri == self\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::ErrorKind":["enum ErrorKind {\n    InvalidUriChar,\n    InvalidScheme,\n    InvalidAuthority,\n    InvalidPort,\n    InvalidFormat,\n    SchemeMissing,\n    AuthorityMissing,\n    PathAndQueryMissing,\n    TooLong,\n    Empty,\n    SchemeTooLong,\n}","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::InvalidUri":["/// An error resulting from a failed attempt to construct a URI.\npub struct InvalidUri(ErrorKind);","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::InvalidUriBytes":["/// An error resulting from a failed attempt to construct a URI.\npub struct InvalidUriBytes(InvalidUri);","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::InvalidUriParts":["/// An error resulting from a failed attempt to construct a URI.\npub struct InvalidUriParts(InvalidUri);","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Parts":["/// The various parts of a URI.\n///\n/// This struct is used to provide to and retrieve from a URI.\npub struct Parts {\n    /// The scheme component of a URI\n    pub scheme: Option<Scheme>,\n\n    /// The authority component of a URI\n    pub authority: Option<Authority>,\n\n    /// The origin-form component of a URI\n    pub path_and_query: Option<PathAndQuery>,\n\n    /// Allow extending in the future\n    _priv: (),\n}","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri":["/// The URI component of a request.\n///\n/// For HTTP 1, this is included as part of the request line. From Section 5.3,\n/// Request Target:\n///\n/// > Once an inbound connection is obtained, the client sends an HTTP\n/// > request message (Section 3) with a request-target derived from the\n/// > target URI.  There are four distinct formats for the request-target,\n/// > depending on both the method being requested and whether the request\n/// > is to a proxy.\n/// >\n/// > ```notrust\n/// > request-target = origin-form\n/// >                / absolute-form\n/// >                / authority-form\n/// >                / asterisk-form\n/// > ```\n///\n/// The URI is structured as follows:\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n/// |-|   |-------------------------------||--------| |-------------------| |-----|\n///  |                  |                       |               |              |\n/// scheme          authority                 path            query         fragment\n/// ```\n///\n/// For HTTP 2.0, the URI is encoded using pseudoheaders.\n///\n/// # Examples\n///\n/// ```\n/// use http::Uri;\n///\n/// let uri = \"/foo/bar?baz\".parse::<Uri>().unwrap();\n/// assert_eq!(uri.path(), \"/foo/bar\");\n/// assert_eq!(uri.query(), Some(\"baz\"));\n/// assert_eq!(uri.host(), None);\n///\n/// let uri = \"https://www.rust-lang.org/install.html\".parse::<Uri>().unwrap();\n/// assert_eq!(uri.scheme_part().map(|s| s.as_str()), Some(\"https\"));\n/// assert_eq!(uri.host(), Some(\"www.rust-lang.org\"));\n/// assert_eq!(uri.path(), \"/install.html\");\n/// ```\npub struct Uri {\n    scheme: Scheme,\n    authority: Authority,\n    path_and_query: PathAndQuery,\n}","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::authority":["#[deprecated(since = \"0.1.1\", note = \"use authority_part instead\")]\n#[doc(hidden)]\n#[inline]\npub fn authority(&self) -> Option<&str>{\n        if self.authority.data.is_empty() {\n            None\n        } else {\n            Some(self.authority.as_str())\n        }\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::authority_part":["/// Get the authority of this `Uri`.\n///\n/// The authority is a hierarchical element for naming authority such that\n/// the remainder of the URI is delegated to that authority. For HTTP, the\n/// authority consists of the host and port. The host portion of the\n/// authority is **case-insensitive**.\n///\n/// The authority also includes a `username:password` component, however\n/// the use of this is deprecated and should be avoided.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///       |-------------------------------|\n///                     |\n///                 authority\n/// ```\n///\n/// This function will be renamed to `authority` in the next semver release.\n///\n/// # Examples\n///\n/// Absolute URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.authority_part().map(|a| a.as_str()), Some(\"example.org:80\"));\n/// ```\n///\n///\n/// Relative URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"/hello/world\".parse().unwrap();\n///\n/// assert!(uri.authority_part().is_none());\n/// ```\n#[inline]\npub fn authority_part(&self) -> Option<&Authority>{\n        if self.authority.data.is_empty() {\n            None\n        } else {\n            Some(&self.authority)\n        }\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::builder":["/// Creates a new builder-style object to manufacture a `Uri`.\n///\n/// This method returns an instance of `Builder` which can be usd to\n/// create a `Uri`.\n///\n/// # Examples\n///\n/// ```\n/// use http::Uri;\n///\n/// let uri = Uri::builder()\n///     .scheme(\"https\")\n///     .authority(\"hyper.rs\")\n///     .path_and_query(\"/\")\n///     .build()\n///     .unwrap();\n/// ```\npub fn builder() -> Builder{\n        Builder::new()\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::from_parts":["/// Attempt to convert a `Uri` from `Parts`\npub fn from_parts(src: Parts) -> Result<Uri, InvalidUriParts>{\n        if src.scheme.is_some() {\n            if src.authority.is_none() {\n                return Err(ErrorKind::AuthorityMissing.into());\n            }\n\n            if src.path_and_query.is_none() {\n                return Err(ErrorKind::PathAndQueryMissing.into());\n            }\n        } else {\n            if src.authority.is_some() && src.path_and_query.is_some() {\n                return Err(ErrorKind::SchemeMissing.into());\n            }\n        }\n\n        let scheme = match src.scheme {\n            Some(scheme) => scheme,\n            None => Scheme { inner: Scheme2::None },\n        };\n\n        let authority = match src.authority {\n            Some(authority) => authority,\n            None => Authority::empty(),\n        };\n\n        let path_and_query = match src.path_and_query {\n            Some(path_and_query) => path_and_query,\n            None => PathAndQuery::empty(),\n        };\n\n        Ok(Uri {\n            scheme: scheme,\n            authority: authority,\n            path_and_query: path_and_query,\n        })\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::from_shared":["/// Attempt to convert a `Uri` from `Bytes`\n///\n/// This function will be replaced by a `TryFrom` implementation once the\n/// trait lands in stable.\n///\n/// # Examples\n///\n/// ```\n/// # extern crate http;\n/// # use http::uri::*;\n/// extern crate bytes;\n///\n/// use bytes::Bytes;\n///\n/// # pub fn main() {\n/// let bytes = Bytes::from(\"http://example.com/foo\");\n/// let uri = Uri::from_shared(bytes).unwrap();\n///\n/// assert_eq!(uri.host().unwrap(), \"example.com\");\n/// assert_eq!(uri.path(), \"/foo\");\n/// # }\n/// ```\npub fn from_shared(s: Bytes) -> Result<Uri, InvalidUriBytes>{\n        use self::ErrorKind::*;\n\n        if s.len() > MAX_LEN {\n            return Err(TooLong.into());\n        }\n\n        match s.len() {\n            0 => {\n                return Err(Empty.into());\n            }\n            1 => {\n                match s[0] {\n                    b'/' => {\n                        return Ok(Uri {\n                            scheme: Scheme::empty(),\n                            authority: Authority::empty(),\n                            path_and_query: PathAndQuery::slash(),\n                        });\n                    }\n                    b'*' => {\n                        return Ok(Uri {\n                            scheme: Scheme::empty(),\n                            authority: Authority::empty(),\n                            path_and_query: PathAndQuery::star(),\n                        });\n                    }\n                    _ => {\n                        let authority = Authority::from_shared(s)?;\n\n                        return Ok(Uri {\n                            scheme: Scheme::empty(),\n                            authority: authority,\n                            path_and_query: PathAndQuery::empty(),\n                        });\n                    }\n                }\n            }\n            _ => {}\n        }\n\n        if s[0] == b'/' {\n            return Ok(Uri {\n                scheme: Scheme::empty(),\n                authority: Authority::empty(),\n                path_and_query: PathAndQuery::from_shared(s)?,\n            });\n        }\n\n        parse_full(s)\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::from_static":["/// Convert a `Uri` from a static string.\n///\n/// This function will not perform any copying, however the string is\n/// checked to ensure that it is valid.\n///\n/// # Panics\n///\n/// This function panics if the argument is an invalid URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::Uri;\n/// let uri = Uri::from_static(\"http://example.com/foo\");\n///\n/// assert_eq!(uri.host().unwrap(), \"example.com\");\n/// assert_eq!(uri.path(), \"/foo\");\n/// ```\npub fn from_static(src: &'static str) -> Self{\n        let s = Bytes::from_static(src.as_bytes());\n        match Uri::from_shared(s) {\n            Ok(uri) => uri,\n            Err(e) => panic!(\"static str is not valid URI: {}\", e),\n        }\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::has_path":["fn has_path(&self) -> bool{\n        !self.path_and_query.data.is_empty() || !self.scheme.inner.is_none()\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::host":["/// Get the host of this `Uri`.\n///\n/// The host subcomponent of authority is identified by an IP literal\n/// encapsulated within square brackets, an IPv4 address in dotted- decimal\n/// form, or a registered name.  The host subcomponent is **case-insensitive**.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                         |---------|\n///                              |\n///                             host\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.host(), Some(\"example.org\"));\n/// ```\n///\n///\n/// Relative URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"/hello/world\".parse().unwrap();\n///\n/// assert!(uri.host().is_none());\n/// ```\n#[inline]\npub fn host(&self) -> Option<&str>{\n        self.authority_part().map(|a| a.host())\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::into_parts":["/// Convert a `Uri` into `Parts`.\n///\n/// # Note\n///\n/// This is just an inherent method providing the same functionality as\n/// `let parts: Parts = uri.into()`\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n/// let uri: Uri = \"/foo\".parse().unwrap();\n///\n/// let parts = uri.into_parts();\n///\n/// assert_eq!(parts.path_and_query.unwrap(), \"/foo\");\n///\n/// assert!(parts.scheme.is_none());\n/// assert!(parts.authority.is_none());\n/// ```\n#[inline]\npub fn into_parts(self) -> Parts{\n        self.into()\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::path":["/// Get the path of this `Uri`.\n///\n/// Both relative and absolute URIs contain a path component, though it\n/// might be the empty string. The path component is **case sensitive**.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                        |--------|\n///                                             |\n///                                           path\n/// ```\n///\n/// If the URI is `*` then the path component is equal to `*`.\n///\n/// # Examples\n///\n/// A relative URI\n///\n/// ```\n/// # use http::Uri;\n///\n/// let uri: Uri = \"/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.path(), \"/hello/world\");\n/// ```\n///\n/// An absolute URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.path(), \"/hello/world\");\n/// ```\n#[inline]\npub fn path(&self) -> &str{\n        if self.has_path() {\n            self.path_and_query.path()\n        } else {\n            \"\"\n        }\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::path_and_query":["/// Returns the path & query components of the Uri\n#[inline]\npub fn path_and_query(&self) -> Option<&PathAndQuery>{\n        if !self.scheme.inner.is_none() || self.authority.data.is_empty() {\n            Some(&self.path_and_query)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::port":["#[deprecated(since=\"0.1.14\", note=\"use `port_part` or `port_u16` instead\")]\n#[doc(hidden)]\npub fn port(&self) -> Option<u16>{\n        self.port_u16()\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::port_part":["/// Get the port part of this `Uri`.\n///\n/// The port subcomponent of authority is designated by an optional port\n/// number following the host and delimited from it by a single colon (\":\")\n/// character. It can be turned into a decimal port number with the `as_u16`\n/// method or as a `str` with the `as_str` method.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                     |-|\n///                                      |\n///                                     port\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI with port\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n///\n/// let port = uri.port_part().unwrap();\n/// assert_eq!(port.as_u16(), 80);\n/// ```\n///\n/// Absolute URI without port\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n///\n/// assert!(uri.port_part().is_none());\n/// ```\n///\n/// Relative URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"/hello/world\".parse().unwrap();\n///\n/// assert!(uri.port_part().is_none());\n/// ```\npub fn port_part(&self) -> Option<Port<&str>>{\n        self.authority_part()\n            .and_then(|a| a.port_part())\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::port_u16":["/// Get the port of this `Uri` as a `u16`.\n///\n///\n/// # Example\n///\n/// ```\n/// # use http::{Uri, uri::Port};\n/// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.port_u16(), Some(80));\n/// ```\npub fn port_u16(&self) -> Option<u16>{\n        self.port_part().and_then(|p| Some(p.as_u16()))\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::query":["/// Get the query string of this `Uri`, starting after the `?`.\n///\n/// The query component contains non-hierarchical data that, along with data\n/// in the path component, serves to identify a resource within the scope of\n/// the URI's scheme and naming authority (if any). The query component is\n/// indicated by the first question mark (\"?\") character and terminated by a\n/// number sign (\"#\") character or by the end of the URI.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                                   |-------------------|\n///                                                             |\n///                                                           query\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org/hello/world?key=value\".parse().unwrap();\n///\n/// assert_eq!(uri.query(), Some(\"key=value\"));\n/// ```\n///\n/// Relative URI with a query string component\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"/hello/world?key=value&foo=bar\".parse().unwrap();\n///\n/// assert_eq!(uri.query(), Some(\"key=value&foo=bar\"));\n/// ```\n///\n/// Relative URI without a query string component\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"/hello/world\".parse().unwrap();\n///\n/// assert!(uri.query().is_none());\n/// ```\n#[inline]\npub fn query(&self) -> Option<&str>{\n        self.path_and_query.query()\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::scheme":["#[deprecated(since = \"0.1.2\", note = \"use scheme_part or scheme_str instead\")]\n#[doc(hidden)]\n#[inline]\npub fn scheme(&self) -> Option<&str>{\n        self.scheme_str()\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::scheme_part":["/// Get the scheme of this `Uri`.\n///\n/// The URI scheme refers to a specification for assigning identifiers\n/// within that scheme. Only absolute URIs contain a scheme component, but\n/// not all absolute URIs will contain a scheme component.  Although scheme\n/// names are case-insensitive, the canonical form is lowercase.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n/// |-|\n///  |\n/// scheme\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI\n///\n/// ```\n/// use http::uri::{Scheme, Uri};\n///\n/// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.scheme_part(), Some(&Scheme::HTTP));\n/// ```\n///\n///\n/// Relative URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"/hello/world\".parse().unwrap();\n///\n/// assert!(uri.scheme_part().is_none());\n/// ```\n#[inline]\npub fn scheme_part(&self) -> Option<&Scheme>{\n        if self.scheme.inner.is_none() {\n            None\n        } else {\n            Some(&self.scheme)\n        }\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::Uri::scheme_str":["/// Get the scheme of this `Uri` as a `&str`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.scheme_str(), Some(\"http\"));\n/// ```\n#[inline]\npub fn scheme_str(&self) -> Option<&str>{\n        if self.scheme.inner.is_none() {\n            None\n        } else {\n            Some(self.scheme.as_str())\n        }\n    }","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for &'a str>::eq":["fn eq(&self, other: &Authority) -> bool{\n        self.eq_ignore_ascii_case(other.as_str())\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for std::string::String>::eq":["fn eq(&self, other: &Authority) -> bool{\n        self.as_str().eq_ignore_ascii_case(other.as_str())\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for str>::eq":["fn eq(&self, other: &Authority) -> bool{\n        self.eq_ignore_ascii_case(other.as_str())\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for &'a str>::partial_cmp":["fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering>{\n        let left = self.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for std::string::String>::partial_cmp":["fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering>{\n        let left = self.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for str>::partial_cmp":["fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering>{\n        let left = self.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::<impl std::convert::From<uri::authority::Authority> for bytes::Bytes>::from":["#[inline]\nfn from(src: Authority) -> Bytes{\n        src.data.into()\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::Authority":["/// Represents the authority component of a URI.\npub struct Authority {\n    pub(super) data: ByteStr,\n}","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::Authority::as_str":["/// Return a str representation of the authority\n#[inline]\npub fn as_str(&self) -> &str{\n        &self.data[..]\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::Authority::empty":["pub(super) fn empty() -> Self{\n        Authority { data: ByteStr::new() }\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::Authority::from_shared":["/// Attempt to convert an `Authority` from `Bytes`.\n///\n/// This function will be replaced by a `TryFrom` implementation once the\n/// trait lands in stable.\n///\n/// # Examples\n///\n/// ```\n/// # extern crate http;\n/// # use http::uri::*;\n/// extern crate bytes;\n///\n/// use bytes::Bytes;\n///\n/// # pub fn main() {\n/// let bytes = Bytes::from(\"example.com\");\n/// let authority = Authority::from_shared(bytes).unwrap();\n///\n/// assert_eq!(authority.host(), \"example.com\");\n/// # }\n/// ```\npub fn from_shared(s: Bytes) -> Result<Self, InvalidUriBytes>{\n        let authority_end = Authority::parse_non_empty(&s[..]).map_err(InvalidUriBytes)?;\n\n        if authority_end != s.len() {\n            return Err(ErrorKind::InvalidUriChar.into());\n        }\n\n        Ok(Authority {\n            data: unsafe { ByteStr::from_utf8_unchecked(s) },\n        })\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::Authority::from_static":["/// Attempt to convert an `Authority` from a static string.\n///\n/// This function will not perform any copying, and the string will be\n/// checked if it is empty or contains an invalid character.\n///\n/// # Panics\n///\n/// This function panics if the argument contains invalid characters or\n/// is empty.\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority = Authority::from_static(\"example.com\");\n/// assert_eq!(authority.host(), \"example.com\");\n/// ```\npub fn from_static(src: &'static str) -> Self{\n        let s = src.as_bytes();\n        let b = Bytes::from_static(s);\n        let authority_end = Authority::parse_non_empty(&b[..]).expect(\"static str is not valid authority\");\n\n        if authority_end != b.len() {\n            panic!(\"static str is not valid authority\");\n        }\n\n        Authority {\n            data: unsafe { ByteStr::from_utf8_unchecked(b) },\n        }\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::Authority::host":["/// Get the host of this `Authority`.\n///\n/// The host subcomponent of authority is identified by an IP literal\n/// encapsulated within square brackets, an IPv4 address in dotted- decimal\n/// form, or a registered name.  The host subcomponent is **case-insensitive**.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                         |---------|\n///                              |\n///                             host\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n/// let authority: Authority = \"example.org:80\".parse().unwrap();\n///\n/// assert_eq!(authority.host(), \"example.org\");\n/// ```\n#[inline]\npub fn host(&self) -> &str{\n        host(self.as_str())\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::Authority::into_bytes":["/// Converts this `Authority` back to a sequence of bytes\n#[inline]\npub fn into_bytes(self) -> Bytes{\n        self.into()\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::Authority::parse":["pub(super) fn parse(s: &[u8]) -> Result<usize, InvalidUri>{\n        let mut colon_cnt = 0;\n        let mut start_bracket = false;\n        let mut end_bracket = false;\n        let mut has_percent = false;\n        let mut end = s.len();\n        let mut at_sign_pos = None;\n\n        for (i, &b) in s.iter().enumerate() {\n            match URI_CHARS[b as usize] {\n                b'/' | b'?' | b'#' => {\n                    end = i;\n                    break;\n                }\n                b':' => {\n                    colon_cnt += 1;\n                }\n                b'[' => {\n                    start_bracket = true;\n                    if has_percent {\n                        // Something other than the userinfo has a `%`, so reject it.\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                }\n                b']' => {\n                    end_bracket = true;\n\n                    // Those were part of an IPv6 hostname, so forget them...\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                b'@' => {\n                    at_sign_pos = Some(i);\n\n                    // Those weren't a port colon, but part of the\n                    // userinfo, so it needs to be forgotten.\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                0 if b == b'%' => {\n                    // Per https://tools.ietf.org/html/rfc3986#section-3.2.1 and\n                    // https://url.spec.whatwg.org/#authority-state\n                    // the userinfo can have a percent-encoded username and password,\n                    // so record that a `%` was found. If this turns out to be\n                    // part of the userinfo, this flag will be cleared.\n                    // Also per https://tools.ietf.org/html/rfc6874, percent-encoding can\n                    // be used to indicate a zone identifier.\n                    // If the flag hasn't been cleared at the end, that means this\n                    // was part of the hostname (and not part of an IPv6 address), and\n                    // will fail with an error.\n                    has_percent = true;\n                }\n                0 => {\n                    return Err(ErrorKind::InvalidUriChar.into());\n                }\n                _ => {}\n            }\n        }\n\n        if start_bracket ^ end_bracket {\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if colon_cnt > 1 {\n            // Things like 'localhost:8080:3030' are rejected.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if end > 0 && at_sign_pos == Some(end - 1) {\n            // If there's nothing after an `@`, this is bonkers.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if has_percent {\n            // Something after the userinfo has a `%`, so reject it.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        Ok(end)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::Authority::parse_non_empty":["fn parse_non_empty(s: &[u8]) -> Result<usize, InvalidUri>{\n        if s.is_empty() {\n            return Err(ErrorKind::Empty.into());\n        }\n        Authority::parse(s)\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::Authority::port":["#[deprecated(since=\"0.1.14\", note=\"use `port_part` or `port_u16` instead\")]\n#[doc(hidden)]\npub fn port(&self) -> Option<u16>{\n        self.port_u16()\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::Authority::port_part":["/// Get the port part of this `Authority`.\n///\n/// The port subcomponent of authority is designated by an optional port\n/// number following the host and delimited from it by a single colon (\":\")\n/// character. It can be turned into a decimal port number with the `as_u16`\n/// method or as a `str` with the `as_str` method.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                     |-|\n///                                      |\n///                                     port\n/// ```\n///\n/// # Examples\n///\n/// Authority with port\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = \"example.org:80\".parse().unwrap();\n///\n/// let port = authority.port_part().unwrap();\n/// assert_eq!(port.as_u16(), 80);\n/// assert_eq!(port.as_str(), \"80\");\n/// ```\n///\n/// Authority without port\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = \"example.org\".parse().unwrap();\n///\n/// assert!(authority.port_part().is_none());\n/// ```\npub fn port_part(&self) -> Option<Port<&str>>{\n        let bytes = self.as_str();\n        bytes\n            .rfind(\":\")\n            .and_then(|i| Port::from_str(&bytes[i + 1..]).ok())\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::Authority::port_u16":["/// Get the port of this `Authority` as a `u16`.\n///\n/// # Example\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = \"example.org:80\".parse().unwrap();\n///\n/// assert_eq!(authority.port_u16(), Some(80));\n/// ```\npub fn port_u16(&self) -> Option<u16>{\n        self.port_part().and_then(|p| Some(p.as_u16()))\n    }","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::authority::host":["fn host(auth: &str) -> &str{\n    let host_port = auth.rsplitn(2, '@')\n        .next()\n        .expect(\"split always has at least 1 item\");\n\n    if host_port.as_bytes()[0] == b'[' {\n        let i = host_port.find(']')\n            .expect(\"parsing should validate brackets\");\n        // ..= ranges aren't available in 1.20, our minimum Rust version...\n        &host_port[0 .. i + 1]\n    } else {\n        host_port.split(':')\n            .next()\n            .expect(\"split always has at least 1 item\")\n    }\n}","Real(LocalPath(\"src/uri/authority.rs\"))"],"uri::builder::Builder":["/// A builder for `Uri`s.\n///\n/// This type can be used to construct an instance of `Uri`\n/// through a builder pattern.\npub struct Builder {\n    parts: Option<Result<Parts>>,\n}","Real(LocalPath(\"src/uri/builder.rs\"))"],"uri::builder::Builder::authority":["/// Set the `Authority` for this URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let uri = uri::Builder::new()\n///     .authority(\"tokio.rs\")\n///     .build()\n///     .unwrap();\n/// ```\npub fn authority<T>(&mut self, auth: T) -> &mut Self\n    where\n        Authority: HttpTryFrom<T>,{\n        self.map(|parts| {\n            parts.authority = Some(auth.http_try_into()?);\n            Ok(())\n        })\n    }","Real(LocalPath(\"src/uri/builder.rs\"))"],"uri::builder::Builder::build":["/// Consumes this builder, and tries to construct a valid `Uri` from\n/// the configured pieces.\n///\n/// # Errors\n///\n/// This function may return an error if any previously configured argument\n/// failed to parse or get converted to the internal representation. For\n/// example if an invalid `scheme` was specified via `scheme(\"!@#%/^\")`\n/// the error will be returned when this function is called rather than\n/// when `scheme` was called.\n///\n/// Additionally, the various forms of URI require certain combinations of\n/// parts to be set to be valid. If the parts don't fit into any of the\n/// valid forms of URI, a new error is returned.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let uri = Uri::builder()\n///     .build()\n///     .unwrap();\n/// ```\npub fn build(&mut self) -> Result<Uri>{\n        self\n            .parts\n            .take()\n            .expect(\"cannot reuse Uri builder\")\n            .and_then(|parts| parts.http_try_into())\n    }","Real(LocalPath(\"src/uri/builder.rs\"))"],"uri::builder::Builder::map":["fn map<F>(&mut self, f: F) -> &mut Self\n    where\n        F: FnOnce(&mut Parts) -> Result<()>,{\n        let res = if let Some(Ok(ref mut parts)) = self.parts {\n            f(parts)\n        } else {\n            return self;\n        };\n\n        if let Err(err) = res {\n            self.parts = Some(Err(err));\n        }\n\n        self\n    }","Real(LocalPath(\"src/uri/builder.rs\"))"],"uri::builder::Builder::new":["/// Creates a new default instance of `Builder` to construct a `Uri`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let uri = uri::Builder::new()\n///     .scheme(\"https\")\n///     .authority(\"hyper.rs\")\n///     .path_and_query(\"/\")\n///     .build()\n///     .unwrap();\n/// ```\n#[inline]\npub fn new() -> Builder{\n        Builder::default()\n    }","Real(LocalPath(\"src/uri/builder.rs\"))"],"uri::builder::Builder::path_and_query":["/// Set the `PathAndQuery` for this URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let uri = uri::Builder::new()\n///     .path_and_query(\"/hello?foo=bar\")\n///     .build()\n///     .unwrap();\n/// ```\npub fn path_and_query<T>(&mut self, p_and_q: T) -> &mut Self\n    where\n        PathAndQuery: HttpTryFrom<T>,{\n        self.map(|parts| {\n            parts.path_and_query = Some(p_and_q.http_try_into()?);\n            Ok(())\n        })\n    }","Real(LocalPath(\"src/uri/builder.rs\"))"],"uri::builder::Builder::scheme":["/// Set the `Scheme` for this URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let mut builder = uri::Builder::new();\n/// builder.scheme(\"https\");\n/// ```\npub fn scheme<T>(&mut self, scheme: T) -> &mut Self\n    where\n        Scheme: HttpTryFrom<T>,{\n        self.map(|parts| {\n            parts.scheme = Some(scheme.http_try_into()?);\n            Ok(())\n        })\n    }","Real(LocalPath(\"src/uri/builder.rs\"))"],"uri::parse_full":["fn parse_full(mut s: Bytes) -> Result<Uri, InvalidUriBytes>{\n    // Parse the scheme\n    let scheme = match Scheme2::parse(&s[..]).map_err(InvalidUriBytes)? {\n        Scheme2::None => Scheme2::None,\n        Scheme2::Standard(p) => {\n            // TODO: use truncate\n            let _ = s.split_to(p.len() + 3);\n            Scheme2::Standard(p)\n        }\n        Scheme2::Other(n) => {\n            // Grab the protocol\n            let mut scheme = s.split_to(n + 3);\n\n            // Strip ://, TODO: truncate\n            let _ = scheme.split_off(n);\n\n            // Allocate the ByteStr\n            let val = unsafe { ByteStr::from_utf8_unchecked(scheme) };\n\n            Scheme2::Other(Box::new(val))\n        }\n    };\n\n    // Find the end of the authority. The scheme will already have been\n    // extracted.\n    let authority_end = Authority::parse(&s[..]).map_err(InvalidUriBytes)?;\n\n    if scheme.is_none() {\n        if authority_end != s.len() {\n            return Err(ErrorKind::InvalidFormat.into());\n        }\n\n        let authority = Authority {\n            data: unsafe { ByteStr::from_utf8_unchecked(s) },\n        };\n\n        return Ok(Uri {\n            scheme: scheme.into(),\n            authority: authority,\n            path_and_query: PathAndQuery::empty(),\n        });\n    }\n\n    // Authority is required when absolute\n    if authority_end == 0 {\n        return Err(ErrorKind::InvalidFormat.into());\n    }\n\n    let authority = s.split_to(authority_end);\n    let authority = Authority {\n        data: unsafe { ByteStr::from_utf8_unchecked(authority) },\n    };\n\n    Ok(Uri {\n        scheme: scheme.into(),\n        authority: authority,\n        path_and_query: PathAndQuery::from_shared(s)?,\n    })\n}","Real(LocalPath(\"src/uri/mod.rs\"))"],"uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for &'a str>::eq":["#[inline]\nfn eq(&self, other: &PathAndQuery) -> bool{\n        self == &other.as_str()\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for std::string::String>::eq":["#[inline]\nfn eq(&self, other: &PathAndQuery) -> bool{\n        self.as_str() == other.as_str()\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for str>::eq":["#[inline]\nfn eq(&self, other: &PathAndQuery) -> bool{\n        self == other.as_str()\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for &'a str>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering>{\n        self.partial_cmp(&other.as_str())\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for std::string::String>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(other.as_str())\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for str>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering>{\n        self.partial_cmp(other.as_str())\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::<impl std::convert::From<uri::path::PathAndQuery> for bytes::Bytes>::from":["fn from(src: PathAndQuery) -> Bytes{\n        src.data.into()\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::PathAndQuery":["/// Represents the path component of a URI\npub struct PathAndQuery {\n    pub(super) data: ByteStr,\n    pub(super) query: u16,\n}","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::PathAndQuery::as_str":["/// Returns the path and query as a string component.\n///\n/// # Examples\n///\n/// With a query string component\n///\n/// ```\n/// # use http::uri::*;\n/// let path_and_query: PathAndQuery = \"/hello/world?key=value&foo=bar\".parse().unwrap();\n///\n/// assert_eq!(path_and_query.as_str(), \"/hello/world?key=value&foo=bar\");\n/// ```\n///\n/// Without a query string component\n///\n/// ```\n/// # use http::uri::*;\n/// let path_and_query: PathAndQuery = \"/hello/world\".parse().unwrap();\n///\n/// assert_eq!(path_and_query.as_str(), \"/hello/world\");\n/// ```\n#[inline]\npub fn as_str(&self) -> &str{\n        let ret = &self.data[..];\n        if ret.is_empty() {\n            return \"/\";\n        }\n        ret\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::PathAndQuery::empty":["pub(super) fn empty() -> Self{\n        PathAndQuery {\n            data: ByteStr::new(),\n            query: NONE,\n        }\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::PathAndQuery::from_shared":["/// Attempt to convert a `PathAndQuery` from `Bytes`.\n///\n/// This function will be replaced by a `TryFrom` implementation once the\n/// trait lands in stable.\n///\n/// # Examples\n///\n/// ```\n/// # extern crate http;\n/// # use http::uri::*;\n/// extern crate bytes;\n///\n/// use bytes::Bytes;\n///\n/// # pub fn main() {\n/// let bytes = Bytes::from(\"/hello?world\");\n/// let path_and_query = PathAndQuery::from_shared(bytes).unwrap();\n///\n/// assert_eq!(path_and_query.path(), \"/hello\");\n/// assert_eq!(path_and_query.query(), Some(\"world\"));\n/// # }\n/// ```\npub fn from_shared(mut src: Bytes) -> Result<Self, InvalidUriBytes>{\n        let mut query = NONE;\n        let mut fragment = None;\n\n        // block for iterator borrow\n        //\n        // allow: `...` pattersn are now `..=`, but we cannot update yet\n        // because of minimum Rust version\n        #[allow(warnings)]\n        {\n            let mut iter = src.as_ref().iter().enumerate();\n\n            // path ...\n            for (i, &b) in &mut iter {\n                // See https://url.spec.whatwg.org/#path-state\n                match b {\n                    b'?' => {\n                        debug_assert_eq!(query, NONE);\n                        query = i as u16;\n                        break;\n                    }\n                    b'#' => {\n                        fragment = Some(i);\n                        break;\n                    },\n\n                    // This is the range of bytes that don't need to be\n                    // percent-encoded in the path. If it should have been\n                    // percent-encoded, then error.\n                    0x21 |\n                    0x24...0x3B |\n                    0x3D |\n                    0x40...0x5F |\n                    0x61...0x7A |\n                    0x7C |\n                    0x7E => {},\n\n                    _ => return Err(ErrorKind::InvalidUriChar.into()),\n                }\n            }\n\n            // query ...\n            if query != NONE {\n\n                // allow: `...` pattersn are now `..=`, but we cannot update yet\n                // because of minimum Rust version\n                #[allow(warnings)]\n                for (i, &b) in iter {\n                    match b {\n                        // While queries *should* be percent-encoded, most\n                        // bytes are actually allowed...\n                        // See https://url.spec.whatwg.org/#query-state\n                        //\n                        // Allowed: 0x21 / 0x24 - 0x3B / 0x3D / 0x3F - 0x7E\n                        0x21 |\n                        0x24...0x3B |\n                        0x3D |\n                        0x3F...0x7E => {},\n\n                        b'#' => {\n                            fragment = Some(i);\n                            break;\n                        },\n\n                        _ => return Err(ErrorKind::InvalidUriChar.into()),\n                    }\n                }\n            }\n        }\n\n        if let Some(i) = fragment {\n            src.truncate(i);\n        }\n\n        Ok(PathAndQuery {\n            data: unsafe { ByteStr::from_utf8_unchecked(src) },\n            query: query,\n        })\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::PathAndQuery::from_static":["/// Convert a `PathAndQuery` from a static string.\n///\n/// This function will not perform any copying, however the string is\n/// checked to ensure that it is valid.\n///\n/// # Panics\n///\n/// This function panics if the argument is an invalid path and query.\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n/// let v = PathAndQuery::from_static(\"/hello?world\");\n///\n/// assert_eq!(v.path(), \"/hello\");\n/// assert_eq!(v.query(), Some(\"world\"));\n/// ```\n#[inline]\npub fn from_static(src: &'static str) -> Self{\n        let src = Bytes::from_static(src.as_bytes());\n\n        PathAndQuery::from_shared(src)\n            .unwrap()\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::PathAndQuery::into_bytes":["/// Converts this `PathAndQuery` back to a sequence of bytes\n#[inline]\npub fn into_bytes(self) -> Bytes{\n        self.into()\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::PathAndQuery::path":["/// Returns the path component\n///\n/// The path component is **case sensitive**.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                        |--------|\n///                                             |\n///                                           path\n/// ```\n///\n/// If the URI is `*` then the path component is equal to `*`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n///\n/// let path_and_query: PathAndQuery = \"/hello/world\".parse().unwrap();\n///\n/// assert_eq!(path_and_query.path(), \"/hello/world\");\n/// ```\n#[inline]\npub fn path(&self) -> &str{\n        let ret = if self.query == NONE {\n            &self.data[..]\n        } else {\n            &self.data[..self.query as usize]\n        };\n\n        if ret.is_empty() {\n            return \"/\";\n        }\n\n        ret\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::PathAndQuery::query":["/// Returns the query string component\n///\n/// The query component contains non-hierarchical data that, along with data\n/// in the path component, serves to identify a resource within the scope of\n/// the URI's scheme and naming authority (if any). The query component is\n/// indicated by the first question mark (\"?\") character and terminated by a\n/// number sign (\"#\") character or by the end of the URI.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                                   |-------------------|\n///                                                             |\n///                                                           query\n/// ```\n///\n/// # Examples\n///\n/// With a query string component\n///\n/// ```\n/// # use http::uri::*;\n/// let path_and_query: PathAndQuery = \"/hello/world?key=value&foo=bar\".parse().unwrap();\n///\n/// assert_eq!(path_and_query.query(), Some(\"key=value&foo=bar\"));\n/// ```\n///\n/// Without a query string component\n///\n/// ```\n/// # use http::uri::*;\n/// let path_and_query: PathAndQuery = \"/hello/world\".parse().unwrap();\n///\n/// assert!(path_and_query.query().is_none());\n/// ```\n#[inline]\npub fn query(&self) -> Option<&str>{\n        if self.query == NONE {\n            None\n        } else {\n            let i = self.query + 1;\n            Some(&self.data[i as usize..])\n        }\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::PathAndQuery::slash":["pub(super) fn slash() -> Self{\n        PathAndQuery {\n            data: ByteStr::from_static(\"/\"),\n            query: NONE,\n        }\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::path::PathAndQuery::star":["pub(super) fn star() -> Self{\n        PathAndQuery {\n            data: ByteStr::from_static(\"*\"),\n            query: NONE,\n        }\n    }","Real(LocalPath(\"src/uri/path.rs\"))"],"uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq":["fn eq(&self, other: &Port<T>) -> bool{\n        other.port == *self\n    }","Real(LocalPath(\"src/uri/port.rs\"))"],"uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from":["fn from(port: Port<T>) -> Self{\n        port.as_u16()\n    }","Real(LocalPath(\"src/uri/port.rs\"))"],"uri::port::Port":["/// The port component of a URI.\npub struct Port<T> {\n    port: u16,\n    repr: T,\n}","Real(LocalPath(\"src/uri/port.rs\"))"],"uri::port::Port::<T>::as_str":["/// Returns the port number as a `str`.\n///\n/// # Examples\n///\n/// Port as `str`.\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = \"example.org:80\".parse().unwrap();\n///\n/// let port = authority.port_part().unwrap();\n/// assert_eq!(port.as_str(), \"80\");\n/// ```\npub fn as_str(&self) -> &str{\n        self.repr.as_ref()\n    }","Real(LocalPath(\"src/uri/port.rs\"))"],"uri::port::Port::<T>::as_u16":["/// Returns the port number as a `u16`.\n///\n/// # Examples\n///\n/// Port as `u16`.\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = \"example.org:80\".parse().unwrap();\n///\n/// let port = authority.port_part().unwrap();\n/// assert_eq!(port.as_u16(), 80);\n/// ```\npub fn as_u16(&self) -> u16{\n        self.port\n    }","Real(LocalPath(\"src/uri/port.rs\"))"],"uri::port::Port::<T>::from_str":["/// Converts a `str` to a port number.\n///\n/// The supplied `str` must be a valid u16.\npub(crate) fn from_str(bytes: T) -> Result<Self, InvalidUri>{\n        bytes\n            .as_ref()\n            .parse::<u16>()\n            .map(|port| Port {\n                port,\n                repr: bytes,\n            })\n            .map_err(|_| {\n                ErrorKind::InvalidPort.into()\n            })\n    }","Real(LocalPath(\"src/uri/port.rs\"))"],"uri::scheme::<impl std::cmp::PartialEq<uri::scheme::Scheme> for str>::eq":["fn eq(&self, other: &Scheme) -> bool{\n        other == self\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"uri::scheme::<impl std::convert::From<uri::scheme::Scheme> for bytes::Bytes>::from":["#[inline]\nfn from(src: Scheme) -> Self{\n        use self::Scheme2::*;\n        use self::Protocol::*;\n\n        match src.inner {\n            None => Bytes::new(),\n            Standard(Http) => Bytes::from_static(b\"http\"),\n            Standard(Https) => Bytes::from_static(b\"https\"),\n            Other(v) => (*v).into(),\n        }\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"uri::scheme::Protocol":["pub(super) enum Protocol {\n    Http,\n    Https,\n}","Real(LocalPath(\"src/uri/scheme.rs\"))"],"uri::scheme::Protocol::len":["pub(super) fn len(&self) -> usize{\n        match *self {\n            Protocol::Http => 4,\n            Protocol::Https => 5,\n        }\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"uri::scheme::Scheme":["/// Represents the scheme component of a URI\npub struct Scheme {\n    pub(super) inner: Scheme2,\n}","Real(LocalPath(\"src/uri/scheme.rs\"))"],"uri::scheme::Scheme2":["pub(super) enum Scheme2<T = Box<ByteStr>> {\n    None,\n    Standard(Protocol),\n    Other(T),\n}","Real(LocalPath(\"src/uri/scheme.rs\"))"],"uri::scheme::Scheme2::<T>::is_none":["pub(super) fn is_none(&self) -> bool{\n        match *self {\n            Scheme2::None => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"uri::scheme::Scheme2::<usize>::parse":["pub(super) fn parse(s: &[u8]) -> Result<Scheme2<usize>, InvalidUri>{\n        if s.len() >= 7 {\n            // Check for HTTP\n            if s[..7].eq_ignore_ascii_case(b\"http://\") {\n                // Prefix will be striped\n                return Ok(Protocol::Http.into());\n            }\n        }\n\n        if s.len() >= 8 {\n            // Check for HTTPs\n            if s[..8].eq_ignore_ascii_case(b\"https://\") {\n                return Ok(Protocol::Https.into());\n            }\n        }\n\n        if s.len() > 3 {\n            for i in 0..s.len() {\n                let b = s[i];\n\n                if i == MAX_SCHEME_LEN {\n                    return Err(ErrorKind::SchemeTooLong.into());\n                }\n\n                match SCHEME_CHARS[b as usize] {\n                    b':' => {\n                        // Not enough data remaining\n                        if s.len() < i + 3 {\n                            break;\n                        }\n\n                        // Not a scheme\n                        if &s[i+1..i+3] != b\"//\" {\n                            break;\n                        }\n\n                        // Return scheme\n                        return Ok(Scheme2::Other(i));\n                    }\n                    // Invald scheme character, abort\n                    0 => break,\n                    _ => {}\n                }\n            }\n        }\n\n        Ok(Scheme2::None)\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"uri::scheme::Scheme2::<usize>::parse_exact":["fn parse_exact(s: &[u8]) -> Result<Scheme2<()>, InvalidUri>{\n        match s {\n            b\"http\" => Ok(Protocol::Http.into()),\n            b\"https\" => Ok(Protocol::Https.into()),\n            _ => {\n                if s.len() > MAX_SCHEME_LEN {\n                    return Err(ErrorKind::SchemeTooLong.into());\n                }\n\n                for &b in s {\n                    match SCHEME_CHARS[b as usize] {\n                        b':' => {\n                            // Don't want :// here\n                            return Err(ErrorKind::InvalidScheme.into());\n                        }\n                        0 => {\n                            return Err(ErrorKind::InvalidScheme.into());\n                        }\n                        _ => {}\n                    }\n                }\n\n                Ok(Scheme2::Other(()))\n            }\n        }\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"uri::scheme::Scheme::as_str":["/// Return a str representation of the scheme\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n/// let scheme: Scheme = \"http\".parse().unwrap();\n/// assert_eq!(scheme.as_str(), \"http\");\n/// ```\n#[inline]\npub fn as_str(&self) -> &str{\n        use self::Scheme2::*;\n        use self::Protocol::*;\n\n        match self.inner {\n            Standard(Http) => \"http\",\n            Standard(Https) => \"https\",\n            Other(ref v) => &v[..],\n            None => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"uri::scheme::Scheme::empty":["pub(super) fn empty() -> Self{\n        Scheme {\n            inner: Scheme2::None,\n        }\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"uri::scheme::Scheme::from_shared":["/// Attempt to convert a `Scheme` from `Bytes`\n///\n/// This function will be replaced by a `TryFrom` implementation once the\n/// trait lands in stable.\n///\n/// # Examples\n///\n/// ```\n/// # extern crate http;\n/// # use http::uri::*;\n/// extern crate bytes;\n///\n/// use bytes::Bytes;\n///\n/// # pub fn main() {\n/// let bytes = Bytes::from(\"http\");\n/// let scheme = Scheme::from_shared(bytes).unwrap();\n///\n/// assert_eq!(scheme.as_str(), \"http\");\n/// # }\n/// ```\npub fn from_shared(s: Bytes) -> Result<Self, InvalidUriBytes>{\n        use self::Scheme2::*;\n\n        match Scheme2::parse_exact(&s[..]).map_err(InvalidUriBytes)? {\n            None => Err(ErrorKind::InvalidScheme.into()),\n            Standard(p) => Ok(Standard(p).into()),\n            Other(_) => {\n                let b = unsafe { ByteStr::from_utf8_unchecked(s) };\n                Ok(Other(Box::new(b)).into())\n            }\n        }\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"uri::scheme::Scheme::into_bytes":["/// Converts this `Scheme` back to a sequence of bytes\n#[inline]\npub fn into_bytes(self) -> Bytes{\n        self.into()\n    }","Real(LocalPath(\"src/uri/scheme.rs\"))"],"version::Http":["enum Http {\n    Http09,\n    Http10,\n    Http11,\n    H2,\n}","Real(LocalPath(\"src/version.rs\"))"],"version::Version":["/// Represents a version of the HTTP spec.\npub struct Version(Http);","Real(LocalPath(\"src/version.rs\"))"]},"struct_constructor":{"&'a mut request::Parts":["head"],"&'a mut response::Parts":["head"],"&'static str":["as_str","canonical_reason"],"&(dyn std::error::Error + 'static)":["get_ref"],"&[u8]":["as_bytes","as_ref"],"&dyn std::error::Error":["cause"],"&extensions::Extensions":["extensions"],"&header::name::HeaderName":["key"],"&method::Method":["method","method_ref"],"&mut extensions::Extensions":["extensions_mut"],"&mut method::Method":["method_mut"],"&mut status::StatusCode":["status_mut"],"&mut uri::Uri":["uri_mut"],"&mut version::Version":["version_mut"],"&str":["as_ref","as_str","authority","borrow","deref","description","host","path","query","scheme","scheme_str","to_str"],"&uri::Uri":["uri","uri_ref"],"&uri::authority::Authority":["authority_part"],"&uri::path::PathAndQuery":["path_and_query"],"&uri::scheme::Scheme":["scheme_part"],"(&'a header::name::HeaderName, *mut T)":["next_unsafe"],"(header::name::HeaderName, T)":["remove_entry"],"(header::name::HeaderName, header::map::ValueDrain<'a, T>)":["remove_entry_mult"],"(request::Parts, T)":["into_parts"],"(response::Parts, T)":["into_parts"],"(usize, header::map::HashValue)":["resolve"],"(usize, std::option::Option<usize>)":["size_hint"],"(usize, usize)":["find"],"<header::map::Drain<'a, T> as std::iter::Iterator>::Item":["next"],"<header::map::IntoIter<T> as std::iter::Iterator>::Item":["next"],"<header::map::Iter<'a, T> as std::iter::Iterator>::Item":["next"],"<header::map::IterMut<'a, T> as std::iter::Iterator>::Item":["next"],"<header::map::Keys<'a, T> as std::iter::Iterator>::Item":["next"],"<header::map::ValueIter<'a, T> as std::iter::Iterator>::Item":["next","next_back"],"<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::Item":["next","next_back"],"<header::map::Values<'a, T> as std::iter::Iterator>::Item":["next"],"<header::map::ValuesMut<'a, T> as std::iter::Iterator>::Item":["next"],"bool":["append","append2","contains_key","eq","eq_ignore_ascii_case","has_path","is","is_client_error","is_empty","is_idempotent","is_informational","is_none","is_red","is_redirection","is_safe","is_sensitive","is_server_error","is_some","is_success","is_valid","is_visible_ascii","is_yellow"],"byte_str::ByteStr":["clone","from","from_static","from_utf8_unchecked","new"],"bytes::Bytes":["from","into_bytes"],"error::Error":["from"],"extensions::Extensions":["default","new"],"extensions::IdHasher":["default"],"header::map::Bucket":["clone","remove_found"],"header::map::Cursor":["clone"],"header::map::Danger":["clone"],"header::map::Drain":["drain"],"header::map::Entry":["entry","entry2"],"header::map::ExtraValue":["clone","remove_extra_value"],"header::map::GetAll":["get_all"],"header::map::HashValue":["clone","hash_elem_using"],"header::map::HeaderMap":["clone","default","from_iter","new","try_from","with_capacity"],"header::map::IntoIter":["into_iter"],"header::map::Iter":["into_iter","iter"],"header::map::IterMut":["into_iter","iter_mut"],"header::map::Keys":["keys"],"header::map::Link":["clone"],"header::map::Links":["clone"],"header::map::OccupiedEntry":["insert_entry"],"header::map::Pos":["clone","new","none"],"header::map::ValueDrain":["insert_mult","insert_occupied_mult"],"header::map::ValueIter":["into_iter","iter","value_iter"],"header::map::ValueIterMut":["into_iter","iter_mut","value_iter_mut"],"header::map::Values":["values"],"header::map::ValuesMut":["values_mut"],"header::name::Custom":["clone"],"header::name::HdrName":["custom","from","parse_hdr"],"header::name::HeaderName":["clone","from","from_bytes","from_lowercase","from_static","from_str","into_key","try_from"],"header::name::InvalidHeaderName":["new"],"header::name::MaybeLower":["clone"],"header::name::Repr":["clone"],"header::name::StandardHeader":["clone"],"header::value::HeaderValue":["clone","from","from_bytes","from_name","from_shared","from_shared_unchecked","from_static","from_str","try_from"],"method::Inner":["clone"],"method::InvalidMethod":["new"],"method::Method":["clone","default","extension_inline","from","from_bytes","from_str","try_from"],"request::Builder":["builder","connect","default","delete","get","head","new","options","patch","post","put","trace"],"request::Parts":["new","take_parts"],"request::Request":["body","default","from_parts","new"],"response::Builder":["builder","default","new"],"response::Parts":["new","take_parts"],"response::Response":["body","default","from_parts","new"],"status::InvalidStatusCode":["new"],"status::StatusCode":["clone","default","from","from_bytes","from_str","from_u16","status","try_from"],"std::cmp::Ordering":["cmp","partial_cmp"],"u16":["as_u16","from","port","port_u16"],"u64":["finish"],"uri::InvalidUri":["from"],"uri::InvalidUriBytes":["from"],"uri::InvalidUriParts":["from"],"uri::Parts":["default","from","into_parts"],"uri::Uri":["build","clone","default","from_parts","from_shared","from_static","from_str","parse_full","try_from"],"uri::authority::Authority":["clone","empty","from_shared","from_static","from_str","try_from"],"uri::builder::Builder":["builder","default","new"],"uri::path::PathAndQuery":["clone","empty","from_shared","from_static","from_str","slash","star","try_from"],"uri::port::Port":["from_str","port_part"],"uri::scheme::Protocol":["clone"],"uri::scheme::Scheme":["clone","empty","from","from_shared","from_str","try_from"],"uri::scheme::Scheme2":["clone","from","parse","parse_exact"],"usize":["capacity","keys_len","len","parse","parse_non_empty"],"version::Http":["clone"],"version::Version":["clone","default","version"]},"struct_to_trait":{"<T as convert::HttpTryInto<U>>::T":["convert::HttpTryInto"],"byte_str::ByteStr":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref"],"bytes::Bytes":["std::convert::From"],"error::Error":["std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display"],"error::Never":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"extensions::Extensions":["std::default::Default","std::fmt::Debug"],"extensions::IdHasher":["std::default::Default","std::hash::Hasher"],"header::map::Bucket":["std::clone::Clone","std::fmt::Debug"],"header::map::Cursor":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"header::map::Danger":["std::clone::Clone"],"header::map::Drain":["std::fmt::Debug","std::iter::Iterator","std::marker::Send","std::marker::Sync","std::ops::Drop"],"header::map::Entry":["std::fmt::Debug"],"header::map::ExtraValue":["std::clone::Clone","std::fmt::Debug"],"header::map::GetAll":["std::cmp::PartialEq","std::fmt::Debug","std::iter::IntoIterator"],"header::map::HashValue":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"header::map::HeaderMap":["convert::HttpTryFrom","sealed::Sealed","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::ops::Index"],"header::map::IntoIter":["std::fmt::Debug","std::iter::Iterator","std::ops::Drop"],"header::map::Iter":["std::fmt::Debug","std::iter::Iterator","std::marker::Send","std::marker::Sync"],"header::map::IterMut":["std::fmt::Debug","std::iter::Iterator","std::marker::Send","std::marker::Sync"],"header::map::Keys":["std::fmt::Debug","std::iter::ExactSizeIterator","std::iter::Iterator"],"header::map::Link":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"header::map::Links":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"header::map::OccupiedEntry":["std::fmt::Debug","std::iter::IntoIterator"],"header::map::Pos":["std::clone::Clone","std::marker::Copy"],"header::map::VacantEntry":["std::fmt::Debug"],"header::map::ValueDrain":["std::fmt::Debug","std::iter::Iterator","std::marker::Send","std::marker::Sync","std::ops::Drop"],"header::map::ValueIter":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"header::map::ValueIterMut":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync"],"header::map::Values":["std::fmt::Debug","std::iter::Iterator"],"header::map::ValuesMut":["std::fmt::Debug","std::iter::Iterator"],"header::name::Custom":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"header::name::HdrName":["std::convert::From","std::fmt::Debug","std::hash::Hash"],"header::name::HeaderName":["convert::HttpTryFrom","header::map::as_header_name::AsHeaderName","header::map::as_header_name::Sealed","header::map::into_header_name::IntoHeaderName","header::map::into_header_name::Sealed","sealed::Sealed","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::AsRef","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"],"header::name::InvalidHeaderName":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"header::name::InvalidHeaderNameBytes":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"header::name::MaybeLower":["std::clone::Clone","std::fmt::Debug","std::hash::Hash"],"header::name::Repr":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"header::name::StandardHeader":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"header::value::HeaderValue":["convert::HttpTryFrom","sealed::Sealed","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::fmt::Debug","std::hash::Hash","std::str::FromStr"],"header::value::InvalidHeaderValue":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"header::value::InvalidHeaderValueBytes":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"header::value::ToStrError":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"method::Inner":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"method::InvalidMethod":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"method::Method":["convert::HttpTryFrom","sealed::Sealed","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"],"request::Builder":["std::default::Default","std::fmt::Debug"],"request::Parts":["std::fmt::Debug"],"request::Request":["std::default::Default","std::fmt::Debug"],"response::Builder":["std::default::Default","std::fmt::Debug"],"response::Parts":["std::fmt::Debug"],"response::Response":["std::default::Default","std::fmt::Debug"],"status::InvalidStatusCode":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"status::StatusCode":["convert::HttpTryFrom","sealed::Sealed","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"],"std::string::String":["header::map::as_header_name::AsHeaderName","header::map::as_header_name::Sealed","std::cmp::PartialEq","std::cmp::PartialOrd"],"uri::ErrorKind":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"uri::InvalidUri":["std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display"],"uri::InvalidUriBytes":["std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display"],"uri::InvalidUriParts":["std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display"],"uri::Parts":["std::convert::From","std::default::Default","std::fmt::Debug"],"uri::Uri":["convert::HttpTryFrom","sealed::Sealed","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::str::FromStr"],"uri::authority::Authority":["convert::HttpTryFrom","sealed::Sealed","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::str::FromStr"],"uri::builder::Builder":["std::default::Default","std::fmt::Debug"],"uri::path::PathAndQuery":["convert::HttpTryFrom","sealed::Sealed","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::str::FromStr"],"uri::port::Port":["std::cmp::PartialEq","std::convert::AsRef","std::fmt::Debug","std::fmt::Display"],"uri::scheme::Protocol":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"uri::scheme::Scheme":["convert::HttpTryFrom","sealed::Sealed","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::AsRef","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::str::FromStr"],"uri::scheme::Scheme2":["std::clone::Clone","std::convert::From","std::fmt::Debug"],"version::Http":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"version::Version":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"]},"targets":{"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/header/map.rs\"))","std::iter::IntoIterator"],"<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::as_str":["as_str","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::entry":["entry","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find":["find","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::append":["append","Real(LocalPath(\"src/header/map.rs\"))","header::map::into_header_name::Sealed"],"<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::insert":["insert","Real(LocalPath(\"src/header/map.rs\"))","header::map::into_header_name::Sealed"],"<&'a header::name::HeaderName as std::cmp::PartialEq<header::name::HeaderName>>::eq":["eq","Real(LocalPath(\"src/header/name.rs\"))","std::cmp::PartialEq"],"<&'a header::value::HeaderValue as std::cmp::PartialEq<header::value::HeaderValue>>::eq":["eq","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialEq"],"<&'a header::value::HeaderValue as std::cmp::PartialOrd<header::value::HeaderValue>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialOrd"],"<&'a method::Method as std::cmp::PartialEq<method::Method>>::eq":["eq","Real(LocalPath(\"src/method.rs\"))","std::cmp::PartialEq"],"<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/header/map.rs\"))","std::iter::IntoIterator"],"<&'a std::string::String as header::map::as_header_name::Sealed>::as_str":["as_str","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<&'a std::string::String as header::map::as_header_name::Sealed>::entry":["entry","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<&'a std::string::String as header::map::as_header_name::Sealed>::find":["find","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<&'a str as header::map::as_header_name::Sealed>::as_str":["as_str","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<&'a str as header::map::as_header_name::Sealed>::entry":["entry","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<&'a str as header::map::as_header_name::Sealed>::find":["find","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/header/map.rs\"))","std::iter::IntoIterator"],"<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/header/map.rs\"))","std::iter::IntoIterator"],"<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/header/map.rs\"))","std::iter::IntoIterator"],"<&'static str as header::map::into_header_name::Sealed>::append":["append","Real(LocalPath(\"src/header/map.rs\"))","header::map::into_header_name::Sealed"],"<&'static str as header::map::into_header_name::Sealed>::insert":["insert","Real(LocalPath(\"src/header/map.rs\"))","header::map::into_header_name::Sealed"],"<T as convert::HttpTryInto<U>>::http_try_into":["http_try_into","Real(LocalPath(\"src/convert.rs\"))","convert::HttpTryInto"],"<byte_str::ByteStr as std::convert::From<&'a str>>::from":["from","Real(LocalPath(\"src/byte_str.rs\"))","std::convert::From"],"<byte_str::ByteStr as std::convert::From<std::string::String>>::from":["from","Real(LocalPath(\"src/byte_str.rs\"))","std::convert::From"],"<byte_str::ByteStr as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/byte_str.rs\"))","std::ops::Deref"],"<error::Error as std::convert::From<error::Never>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<header::name::InvalidHeaderName>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<header::name::InvalidHeaderNameBytes>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<header::value::InvalidHeaderValue>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<header::value::InvalidHeaderValueBytes>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<method::InvalidMethod>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<status::InvalidStatusCode>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<uri::InvalidUri>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<uri::InvalidUriBytes>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<uri::InvalidUriParts>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::error::Error>::cause":["cause","Real(LocalPath(\"src/error.rs\"))","std::error::Error"],"<error::Error as std::error::Error>::description":["description","Real(LocalPath(\"src/error.rs\"))","std::error::Error"],"<error::Error as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Debug"],"<error::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::Never as std::error::Error>::description":["description","Real(LocalPath(\"src/error.rs\"))","std::error::Error"],"<error::Never as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Debug"],"<error::Never as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<extensions::Extensions as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/extensions.rs\"))","std::fmt::Debug"],"<extensions::IdHasher as std::hash::Hasher>::finish":["finish","Real(LocalPath(\"src/extensions.rs\"))","std::hash::Hasher"],"<extensions::IdHasher as std::hash::Hasher>::write":["write","Real(LocalPath(\"src/extensions.rs\"))","std::hash::Hasher"],"<extensions::IdHasher as std::hash::Hasher>::write_u64":["write_u64","Real(LocalPath(\"src/extensions.rs\"))","std::hash::Hasher"],"<header::map::Drain<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::Drain<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::Drain<'a, T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/header/map.rs\"))","std::ops::Drop"],"<header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/header/map.rs\"))","std::cmp::PartialEq"],"<header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/header/map.rs\"))","std::iter::IntoIterator"],"<header::map::HeaderMap<T> as convert::HttpTryFrom<&'a std::collections::HashMap<K, V>>>::try_from":["try_from","Real(LocalPath(\"src/header/map.rs\"))","convert::HttpTryFrom"],"<header::map::HeaderMap<T> as convert::HttpTryFrom<header::map::HeaderMap<T>>>::try_from":["try_from","Real(LocalPath(\"src/convert.rs\"))","convert::HttpTryFrom"],"<header::map::HeaderMap<T> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/header/map.rs\"))","std::cmp::PartialEq"],"<header::map::HeaderMap<T> as std::default::Default>::default":["default","Real(LocalPath(\"src/header/map.rs\"))","std::default::Default"],"<header::map::HeaderMap<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/header/map.rs\"))","std::fmt::Debug"],"<header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend":["extend","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Extend"],"<header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend":["extend","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Extend"],"<header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter":["from_iter","Real(LocalPath(\"src/header/map.rs\"))","std::iter::FromIterator"],"<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/header/map.rs\"))","std::iter::IntoIterator"],"<header::map::HeaderMap<T> as std::ops::Index<K>>::index":["index","Real(LocalPath(\"src/header/map.rs\"))","std::ops::Index"],"<header::map::IntoIter<T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::IntoIter<T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::IntoIter<T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/header/map.rs\"))","std::ops::Drop"],"<header::map::Iter<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::Iter<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::IterMut<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::Keys<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::Keys<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/header/map.rs\"))","std::iter::IntoIterator"],"<header::map::ValueDrain<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::ValueDrain<'a, T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/header/map.rs\"))","std::ops::Drop"],"<header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/header/map.rs\"))","std::iter::DoubleEndedIterator"],"<header::map::ValueIter<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/header/map.rs\"))","std::iter::DoubleEndedIterator"],"<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::Values<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::Values<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::ValuesMut<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/header/map.rs\"))","std::iter::Iterator"],"<header::name::Custom as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/header/name.rs\"))","std::hash::Hash"],"<header::name::HdrName<'a> as std::convert::From<header::name::StandardHeader>>::from":["from","Real(LocalPath(\"src/header/name.rs\"))","std::convert::From"],"<header::name::HeaderName as convert::HttpTryFrom<&'a [u8]>>::try_from":["try_from","Real(LocalPath(\"src/header/name.rs\"))","convert::HttpTryFrom"],"<header::name::HeaderName as convert::HttpTryFrom<&'a header::name::HeaderName>>::try_from":["try_from","Real(LocalPath(\"src/header/name.rs\"))","convert::HttpTryFrom"],"<header::name::HeaderName as convert::HttpTryFrom<&'a std::string::String>>::try_from":["try_from","Real(LocalPath(\"src/header/name.rs\"))","convert::HttpTryFrom"],"<header::name::HeaderName as convert::HttpTryFrom<&'a str>>::try_from":["try_from","Real(LocalPath(\"src/header/name.rs\"))","convert::HttpTryFrom"],"<header::name::HeaderName as convert::HttpTryFrom<bytes::Bytes>>::try_from":["try_from","Real(LocalPath(\"src/header/name.rs\"))","convert::HttpTryFrom"],"<header::name::HeaderName as convert::HttpTryFrom<header::name::HeaderName>>::try_from":["try_from","Real(LocalPath(\"src/convert.rs\"))","convert::HttpTryFrom"],"<header::name::HeaderName as header::map::as_header_name::Sealed>::as_str":["as_str","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<header::name::HeaderName as header::map::as_header_name::Sealed>::entry":["entry","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<header::name::HeaderName as header::map::as_header_name::Sealed>::find":["find","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<header::name::HeaderName as header::map::into_header_name::Sealed>::append":["append","Real(LocalPath(\"src/header/map.rs\"))","header::map::into_header_name::Sealed"],"<header::name::HeaderName as header::map::into_header_name::Sealed>::insert":["insert","Real(LocalPath(\"src/header/map.rs\"))","header::map::into_header_name::Sealed"],"<header::name::HeaderName as std::borrow::Borrow<str>>::borrow":["borrow","Real(LocalPath(\"src/header/name.rs\"))","std::borrow::Borrow"],"<header::name::HeaderName as std::cmp::PartialEq<&'a header::name::HeaderName>>::eq":["eq","Real(LocalPath(\"src/header/name.rs\"))","std::cmp::PartialEq"],"<header::name::HeaderName as std::cmp::PartialEq<&'a str>>::eq":["eq","Real(LocalPath(\"src/header/name.rs\"))","std::cmp::PartialEq"],"<header::name::HeaderName as std::cmp::PartialEq<header::name::HdrName<'a>>>::eq":["eq","Real(LocalPath(\"src/header/name.rs\"))","std::cmp::PartialEq"],"<header::name::HeaderName as std::cmp::PartialEq<str>>::eq":["eq","Real(LocalPath(\"src/header/name.rs\"))","std::cmp::PartialEq"],"<header::name::HeaderName as std::convert::AsRef<[u8]>>::as_ref":["as_ref","Real(LocalPath(\"src/header/name.rs\"))","std::convert::AsRef"],"<header::name::HeaderName as std::convert::AsRef<str>>::as_ref":["as_ref","Real(LocalPath(\"src/header/name.rs\"))","std::convert::AsRef"],"<header::name::HeaderName as std::convert::From<&'a header::name::HeaderName>>::from":["from","Real(LocalPath(\"src/header/name.rs\"))","std::convert::From"],"<header::name::HeaderName as std::convert::From<header::name::Custom>>::from":["from","Real(LocalPath(\"src/header/name.rs\"))","std::convert::From"],"<header::name::HeaderName as std::convert::From<header::name::HdrName<'a>>>::from":["from","Real(LocalPath(\"src/header/name.rs\"))","std::convert::From"],"<header::name::HeaderName as std::convert::From<header::name::StandardHeader>>::from":["from","Real(LocalPath(\"src/header/name.rs\"))","std::convert::From"],"<header::name::HeaderName as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/header/name.rs\"))","std::fmt::Debug"],"<header::name::HeaderName as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/header/name.rs\"))","std::fmt::Display"],"<header::name::HeaderName as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/header/name.rs\"))","std::str::FromStr"],"<header::name::InvalidHeaderName as std::error::Error>::description":["description","Real(LocalPath(\"src/header/name.rs\"))","std::error::Error"],"<header::name::InvalidHeaderName as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/header/name.rs\"))","std::fmt::Debug"],"<header::name::InvalidHeaderName as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/header/name.rs\"))","std::fmt::Display"],"<header::name::InvalidHeaderNameBytes as std::error::Error>::description":["description","Real(LocalPath(\"src/header/name.rs\"))","std::error::Error"],"<header::name::InvalidHeaderNameBytes as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/header/name.rs\"))","std::fmt::Display"],"<header::name::MaybeLower<'a> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/header/name.rs\"))","std::hash::Hash"],"<header::value::HeaderValue as convert::HttpTryFrom<&'a [u8]>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<&'a header::value::HeaderValue>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<&'a std::string::String>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<&'a str>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<bytes::Bytes>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<header::name::HeaderName>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<header::value::HeaderValue>>::try_from":["try_from","Real(LocalPath(\"src/convert.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<i16>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<i32>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<i64>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<isize>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<std::string::String>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<u16>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<u32>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<u64>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as convert::HttpTryFrom<usize>>::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))","convert::HttpTryFrom"],"<header::value::HeaderValue as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::Ord"],"<header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq":["eq","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialEq"],"<header::value::HeaderValue as std::cmp::PartialEq<[u8]>>::eq":["eq","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialEq"],"<header::value::HeaderValue as std::cmp::PartialEq<std::string::String>>::eq":["eq","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialEq"],"<header::value::HeaderValue as std::cmp::PartialEq<str>>::eq":["eq","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialEq"],"<header::value::HeaderValue as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialEq"],"<header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialOrd"],"<header::value::HeaderValue as std::cmp::PartialOrd<[u8]>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialOrd"],"<header::value::HeaderValue as std::cmp::PartialOrd<std::string::String>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialOrd"],"<header::value::HeaderValue as std::cmp::PartialOrd<str>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialOrd"],"<header::value::HeaderValue as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialOrd"],"<header::value::HeaderValue as std::convert::AsRef<[u8]>>::as_ref":["as_ref","Real(LocalPath(\"src/header/value.rs\"))","std::convert::AsRef"],"<header::value::HeaderValue as std::convert::From<&'a header::value::HeaderValue>>::from":["from","Real(LocalPath(\"src/header/value.rs\"))","std::convert::From"],"<header::value::HeaderValue as std::convert::From<header::name::HeaderName>>::from":["from","Real(LocalPath(\"src/header/value.rs\"))","std::convert::From"],"<header::value::HeaderValue as std::convert::From<i16>>::from":["from","Real(LocalPath(\"src/header/value.rs\"))","std::convert::From"],"<header::value::HeaderValue as std::convert::From<i32>>::from":["from","Real(LocalPath(\"src/header/value.rs\"))","std::convert::From"],"<header::value::HeaderValue as std::convert::From<i64>>::from":["from","Real(LocalPath(\"src/header/value.rs\"))","std::convert::From"],"<header::value::HeaderValue as std::convert::From<isize>>::from":["from","Real(LocalPath(\"src/header/value.rs\"))","std::convert::From"],"<header::value::HeaderValue as std::convert::From<u16>>::from":["from","Real(LocalPath(\"src/header/value.rs\"))","std::convert::From"],"<header::value::HeaderValue as std::convert::From<u32>>::from":["from","Real(LocalPath(\"src/header/value.rs\"))","std::convert::From"],"<header::value::HeaderValue as std::convert::From<u64>>::from":["from","Real(LocalPath(\"src/header/value.rs\"))","std::convert::From"],"<header::value::HeaderValue as std::convert::From<usize>>::from":["from","Real(LocalPath(\"src/header/value.rs\"))","std::convert::From"],"<header::value::HeaderValue as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/header/value.rs\"))","std::fmt::Debug"],"<header::value::HeaderValue as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/header/value.rs\"))","std::str::FromStr"],"<header::value::InvalidHeaderValue as std::error::Error>::description":["description","Real(LocalPath(\"src/header/value.rs\"))","std::error::Error"],"<header::value::InvalidHeaderValue as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/header/value.rs\"))","std::fmt::Debug"],"<header::value::InvalidHeaderValue as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/header/value.rs\"))","std::fmt::Display"],"<header::value::InvalidHeaderValueBytes as std::error::Error>::description":["description","Real(LocalPath(\"src/header/value.rs\"))","std::error::Error"],"<header::value::InvalidHeaderValueBytes as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/header/value.rs\"))","std::fmt::Display"],"<header::value::ToStrError as std::error::Error>::description":["description","Real(LocalPath(\"src/header/value.rs\"))","std::error::Error"],"<header::value::ToStrError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/header/value.rs\"))","std::fmt::Display"],"<method::InvalidMethod as std::error::Error>::description":["description","Real(LocalPath(\"src/method.rs\"))","std::error::Error"],"<method::InvalidMethod as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/method.rs\"))","std::fmt::Debug"],"<method::InvalidMethod as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/method.rs\"))","std::fmt::Display"],"<method::Method as convert::HttpTryFrom<&'a [u8]>>::try_from":["try_from","Real(LocalPath(\"src/method.rs\"))","convert::HttpTryFrom"],"<method::Method as convert::HttpTryFrom<&'a method::Method>>::try_from":["try_from","Real(LocalPath(\"src/method.rs\"))","convert::HttpTryFrom"],"<method::Method as convert::HttpTryFrom<&'a str>>::try_from":["try_from","Real(LocalPath(\"src/method.rs\"))","convert::HttpTryFrom"],"<method::Method as convert::HttpTryFrom<method::Method>>::try_from":["try_from","Real(LocalPath(\"src/convert.rs\"))","convert::HttpTryFrom"],"<method::Method as std::cmp::PartialEq<&'a method::Method>>::eq":["eq","Real(LocalPath(\"src/method.rs\"))","std::cmp::PartialEq"],"<method::Method as std::cmp::PartialEq<&'a str>>::eq":["eq","Real(LocalPath(\"src/method.rs\"))","std::cmp::PartialEq"],"<method::Method as std::cmp::PartialEq<str>>::eq":["eq","Real(LocalPath(\"src/method.rs\"))","std::cmp::PartialEq"],"<method::Method as std::convert::AsRef<str>>::as_ref":["as_ref","Real(LocalPath(\"src/method.rs\"))","std::convert::AsRef"],"<method::Method as std::convert::From<&'a method::Method>>::from":["from","Real(LocalPath(\"src/method.rs\"))","std::convert::From"],"<method::Method as std::default::Default>::default":["default","Real(LocalPath(\"src/method.rs\"))","std::default::Default"],"<method::Method as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/method.rs\"))","std::fmt::Debug"],"<method::Method as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/method.rs\"))","std::fmt::Display"],"<method::Method as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/method.rs\"))","std::str::FromStr"],"<request::Builder as std::default::Default>::default":["default","Real(LocalPath(\"src/request.rs\"))","std::default::Default"],"<request::Parts as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/request.rs\"))","std::fmt::Debug"],"<request::Request<T> as std::default::Default>::default":["default","Real(LocalPath(\"src/request.rs\"))","std::default::Default"],"<request::Request<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/request.rs\"))","std::fmt::Debug"],"<response::Builder as std::default::Default>::default":["default","Real(LocalPath(\"src/response.rs\"))","std::default::Default"],"<response::Parts as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/response.rs\"))","std::fmt::Debug"],"<response::Response<T> as std::default::Default>::default":["default","Real(LocalPath(\"src/response.rs\"))","std::default::Default"],"<response::Response<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/response.rs\"))","std::fmt::Debug"],"<status::InvalidStatusCode as std::error::Error>::description":["description","Real(LocalPath(\"src/status.rs\"))","std::error::Error"],"<status::InvalidStatusCode as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/status.rs\"))","std::fmt::Debug"],"<status::InvalidStatusCode as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/status.rs\"))","std::fmt::Display"],"<status::StatusCode as convert::HttpTryFrom<&'a [u8]>>::try_from":["try_from","Real(LocalPath(\"src/status.rs\"))","convert::HttpTryFrom"],"<status::StatusCode as convert::HttpTryFrom<&'a status::StatusCode>>::try_from":["try_from","Real(LocalPath(\"src/status.rs\"))","convert::HttpTryFrom"],"<status::StatusCode as convert::HttpTryFrom<&'a str>>::try_from":["try_from","Real(LocalPath(\"src/status.rs\"))","convert::HttpTryFrom"],"<status::StatusCode as convert::HttpTryFrom<status::StatusCode>>::try_from":["try_from","Real(LocalPath(\"src/convert.rs\"))","convert::HttpTryFrom"],"<status::StatusCode as convert::HttpTryFrom<u16>>::try_from":["try_from","Real(LocalPath(\"src/status.rs\"))","convert::HttpTryFrom"],"<status::StatusCode as std::cmp::PartialEq<u16>>::eq":["eq","Real(LocalPath(\"src/status.rs\"))","std::cmp::PartialEq"],"<status::StatusCode as std::convert::From<&'a status::StatusCode>>::from":["from","Real(LocalPath(\"src/status.rs\"))","std::convert::From"],"<status::StatusCode as std::default::Default>::default":["default","Real(LocalPath(\"src/status.rs\"))","std::default::Default"],"<status::StatusCode as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/status.rs\"))","std::fmt::Debug"],"<status::StatusCode as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/status.rs\"))","std::fmt::Display"],"<status::StatusCode as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/status.rs\"))","std::str::FromStr"],"<std::string::String as header::map::as_header_name::Sealed>::as_str":["as_str","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<std::string::String as header::map::as_header_name::Sealed>::entry":["entry","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<std::string::String as header::map::as_header_name::Sealed>::find":["find","Real(LocalPath(\"src/header/map.rs\"))","header::map::as_header_name::Sealed"],"<uri::InvalidUri as std::convert::From<uri::ErrorKind>>::from":["from","Real(LocalPath(\"src/uri/mod.rs\"))","std::convert::From"],"<uri::InvalidUri as std::error::Error>::description":["description","Real(LocalPath(\"src/uri/mod.rs\"))","std::error::Error"],"<uri::InvalidUri as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/uri/mod.rs\"))","std::fmt::Display"],"<uri::InvalidUriBytes as std::convert::From<uri::ErrorKind>>::from":["from","Real(LocalPath(\"src/uri/mod.rs\"))","std::convert::From"],"<uri::InvalidUriBytes as std::error::Error>::description":["description","Real(LocalPath(\"src/uri/mod.rs\"))","std::error::Error"],"<uri::InvalidUriBytes as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/uri/mod.rs\"))","std::fmt::Display"],"<uri::InvalidUriParts as std::convert::From<uri::ErrorKind>>::from":["from","Real(LocalPath(\"src/uri/mod.rs\"))","std::convert::From"],"<uri::InvalidUriParts as std::error::Error>::description":["description","Real(LocalPath(\"src/uri/mod.rs\"))","std::error::Error"],"<uri::InvalidUriParts as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/uri/mod.rs\"))","std::fmt::Display"],"<uri::Parts as std::convert::From<uri::Uri>>::from":["from","Real(LocalPath(\"src/uri/mod.rs\"))","std::convert::From"],"<uri::Uri as convert::HttpTryFrom<&'a std::string::String>>::try_from":["try_from","Real(LocalPath(\"src/uri/mod.rs\"))","convert::HttpTryFrom"],"<uri::Uri as convert::HttpTryFrom<&'a str>>::try_from":["try_from","Real(LocalPath(\"src/uri/mod.rs\"))","convert::HttpTryFrom"],"<uri::Uri as convert::HttpTryFrom<&'a uri::Uri>>::try_from":["try_from","Real(LocalPath(\"src/uri/mod.rs\"))","convert::HttpTryFrom"],"<uri::Uri as convert::HttpTryFrom<bytes::Bytes>>::try_from":["try_from","Real(LocalPath(\"src/uri/mod.rs\"))","convert::HttpTryFrom"],"<uri::Uri as convert::HttpTryFrom<std::string::String>>::try_from":["try_from","Real(LocalPath(\"src/uri/mod.rs\"))","convert::HttpTryFrom"],"<uri::Uri as convert::HttpTryFrom<uri::Parts>>::try_from":["try_from","Real(LocalPath(\"src/uri/mod.rs\"))","convert::HttpTryFrom"],"<uri::Uri as convert::HttpTryFrom<uri::Uri>>::try_from":["try_from","Real(LocalPath(\"src/convert.rs\"))","convert::HttpTryFrom"],"<uri::Uri as std::cmp::PartialEq<&'a str>>::eq":["eq","Real(LocalPath(\"src/uri/mod.rs\"))","std::cmp::PartialEq"],"<uri::Uri as std::cmp::PartialEq<str>>::eq":["eq","Real(LocalPath(\"src/uri/mod.rs\"))","std::cmp::PartialEq"],"<uri::Uri as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/uri/mod.rs\"))","std::cmp::PartialEq"],"<uri::Uri as std::default::Default>::default":["default","Real(LocalPath(\"src/uri/mod.rs\"))","std::default::Default"],"<uri::Uri as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/uri/mod.rs\"))","std::fmt::Debug"],"<uri::Uri as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/uri/mod.rs\"))","std::fmt::Display"],"<uri::Uri as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/uri/mod.rs\"))","std::hash::Hash"],"<uri::Uri as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/uri/mod.rs\"))","std::str::FromStr"],"<uri::authority::Authority as convert::HttpTryFrom<&'a [u8]>>::try_from":["try_from","Real(LocalPath(\"src/uri/authority.rs\"))","convert::HttpTryFrom"],"<uri::authority::Authority as convert::HttpTryFrom<&'a str>>::try_from":["try_from","Real(LocalPath(\"src/uri/authority.rs\"))","convert::HttpTryFrom"],"<uri::authority::Authority as convert::HttpTryFrom<bytes::Bytes>>::try_from":["try_from","Real(LocalPath(\"src/uri/authority.rs\"))","convert::HttpTryFrom"],"<uri::authority::Authority as convert::HttpTryFrom<uri::authority::Authority>>::try_from":["try_from","Real(LocalPath(\"src/convert.rs\"))","convert::HttpTryFrom"],"<uri::authority::Authority as std::cmp::PartialEq<&'a str>>::eq":["eq","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialEq"],"<uri::authority::Authority as std::cmp::PartialEq<std::string::String>>::eq":["eq","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialEq"],"<uri::authority::Authority as std::cmp::PartialEq<str>>::eq":["eq","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialEq"],"<uri::authority::Authority as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialEq"],"<uri::authority::Authority as std::cmp::PartialOrd<&'a str>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialOrd"],"<uri::authority::Authority as std::cmp::PartialOrd<std::string::String>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialOrd"],"<uri::authority::Authority as std::cmp::PartialOrd<str>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialOrd"],"<uri::authority::Authority as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialOrd"],"<uri::authority::Authority as std::convert::AsRef<str>>::as_ref":["as_ref","Real(LocalPath(\"src/uri/authority.rs\"))","std::convert::AsRef"],"<uri::authority::Authority as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/uri/authority.rs\"))","std::fmt::Debug"],"<uri::authority::Authority as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/uri/authority.rs\"))","std::fmt::Display"],"<uri::authority::Authority as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/uri/authority.rs\"))","std::hash::Hash"],"<uri::authority::Authority as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/uri/authority.rs\"))","std::str::FromStr"],"<uri::builder::Builder as std::default::Default>::default":["default","Real(LocalPath(\"src/uri/builder.rs\"))","std::default::Default"],"<uri::path::PathAndQuery as convert::HttpTryFrom<&'a [u8]>>::try_from":["try_from","Real(LocalPath(\"src/uri/path.rs\"))","convert::HttpTryFrom"],"<uri::path::PathAndQuery as convert::HttpTryFrom<&'a str>>::try_from":["try_from","Real(LocalPath(\"src/uri/path.rs\"))","convert::HttpTryFrom"],"<uri::path::PathAndQuery as convert::HttpTryFrom<bytes::Bytes>>::try_from":["try_from","Real(LocalPath(\"src/uri/path.rs\"))","convert::HttpTryFrom"],"<uri::path::PathAndQuery as convert::HttpTryFrom<uri::path::PathAndQuery>>::try_from":["try_from","Real(LocalPath(\"src/convert.rs\"))","convert::HttpTryFrom"],"<uri::path::PathAndQuery as std::cmp::PartialEq<&'a str>>::eq":["eq","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialEq"],"<uri::path::PathAndQuery as std::cmp::PartialEq<std::string::String>>::eq":["eq","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialEq"],"<uri::path::PathAndQuery as std::cmp::PartialEq<str>>::eq":["eq","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialEq"],"<uri::path::PathAndQuery as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialEq"],"<uri::path::PathAndQuery as std::cmp::PartialOrd<&'a str>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialOrd"],"<uri::path::PathAndQuery as std::cmp::PartialOrd<std::string::String>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialOrd"],"<uri::path::PathAndQuery as std::cmp::PartialOrd<str>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialOrd"],"<uri::path::PathAndQuery as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialOrd"],"<uri::path::PathAndQuery as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/uri/path.rs\"))","std::fmt::Debug"],"<uri::path::PathAndQuery as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/uri/path.rs\"))","std::fmt::Display"],"<uri::path::PathAndQuery as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/uri/path.rs\"))","std::str::FromStr"],"<uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq":["eq","Real(LocalPath(\"src/uri/port.rs\"))","std::cmp::PartialEq"],"<uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq":["eq","Real(LocalPath(\"src/uri/port.rs\"))","std::cmp::PartialEq"],"<uri::port::Port<T> as std::convert::AsRef<str>>::as_ref":["as_ref","Real(LocalPath(\"src/uri/port.rs\"))","std::convert::AsRef"],"<uri::port::Port<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/uri/port.rs\"))","std::fmt::Debug"],"<uri::port::Port<T> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/uri/port.rs\"))","std::fmt::Display"],"<uri::scheme::Scheme as convert::HttpTryFrom<&'a [u8]>>::try_from":["try_from","Real(LocalPath(\"src/uri/scheme.rs\"))","convert::HttpTryFrom"],"<uri::scheme::Scheme as convert::HttpTryFrom<&'a str>>::try_from":["try_from","Real(LocalPath(\"src/uri/scheme.rs\"))","convert::HttpTryFrom"],"<uri::scheme::Scheme as convert::HttpTryFrom<bytes::Bytes>>::try_from":["try_from","Real(LocalPath(\"src/uri/scheme.rs\"))","convert::HttpTryFrom"],"<uri::scheme::Scheme as convert::HttpTryFrom<uri::scheme::Scheme>>::try_from":["try_from","Real(LocalPath(\"src/convert.rs\"))","convert::HttpTryFrom"],"<uri::scheme::Scheme as std::cmp::PartialEq<str>>::eq":["eq","Real(LocalPath(\"src/uri/scheme.rs\"))","std::cmp::PartialEq"],"<uri::scheme::Scheme as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/uri/scheme.rs\"))","std::cmp::PartialEq"],"<uri::scheme::Scheme as std::convert::AsRef<str>>::as_ref":["as_ref","Real(LocalPath(\"src/uri/scheme.rs\"))","std::convert::AsRef"],"<uri::scheme::Scheme as std::convert::From<uri::scheme::Scheme2>>::from":["from","Real(LocalPath(\"src/uri/scheme.rs\"))","std::convert::From"],"<uri::scheme::Scheme as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/uri/scheme.rs\"))","std::fmt::Debug"],"<uri::scheme::Scheme as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/uri/scheme.rs\"))","std::fmt::Display"],"<uri::scheme::Scheme as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/uri/scheme.rs\"))","std::hash::Hash"],"<uri::scheme::Scheme as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/uri/scheme.rs\"))","std::str::FromStr"],"<uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from":["from","Real(LocalPath(\"src/uri/scheme.rs\"))","std::convert::From"],"<version::Version as std::default::Default>::default":["default","Real(LocalPath(\"src/version.rs\"))","std::default::Default"],"<version::Version as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/version.rs\"))","std::fmt::Debug"],"_assert_types":["_assert_types","Real(LocalPath(\"src/lib.rs\"))",""],"_assert_types::assert_send":["assert_send","Real(LocalPath(\"src/lib.rs\"))",""],"_assert_types::assert_sync":["assert_sync","Real(LocalPath(\"src/lib.rs\"))",""],"byte_str::<impl std::convert::From<byte_str::ByteStr> for bytes::Bytes>::from":["from","Real(LocalPath(\"src/byte_str.rs\"))","std::convert::From"],"byte_str::ByteStr::from_static":["from_static","Real(LocalPath(\"src/byte_str.rs\"))",""],"byte_str::ByteStr::from_utf8_unchecked":["from_utf8_unchecked","Real(LocalPath(\"src/byte_str.rs\"))",""],"byte_str::ByteStr::new":["new","Real(LocalPath(\"src/byte_str.rs\"))",""],"error::Error::get_ref":["get_ref","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::is":["is","Real(LocalPath(\"src/error.rs\"))",""],"extensions::Extensions::clear":["clear","Real(LocalPath(\"src/extensions.rs\"))",""],"extensions::Extensions::get":["get","Real(LocalPath(\"src/extensions.rs\"))",""],"extensions::Extensions::get_mut":["get_mut","Real(LocalPath(\"src/extensions.rs\"))",""],"extensions::Extensions::insert":["insert","Real(LocalPath(\"src/extensions.rs\"))",""],"extensions::Extensions::new":["new","Real(LocalPath(\"src/extensions.rs\"))",""],"extensions::Extensions::remove":["remove","Real(LocalPath(\"src/extensions.rs\"))",""],"header::map::Danger::is_red":["is_red","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::Danger::is_yellow":["is_yellow","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::Danger::to_green":["to_green","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::Danger::to_red":["to_red","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::Danger::to_yellow":["to_yellow","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::Entry::<'a, T>::key":["key","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::Entry::<'a, T>::or_insert":["or_insert","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::Entry::<'a, T>::or_insert_with":["or_insert_with","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::GetAll::<'a, T>::iter":["iter","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::append":["append","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::append2":["append2","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::capacity":["capacity","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::clear":["clear","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::contains_key":["contains_key","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::drain":["drain","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::entry":["entry","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::entry2":["entry2","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::find":["find","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::get":["get","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::get2":["get2","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::get_all":["get_all","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::get_mut":["get_mut","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::grow":["grow","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::insert":["insert","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::insert2":["insert2","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::insert_entry":["insert_entry","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::insert_occupied":["insert_occupied","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::insert_occupied_mult":["insert_occupied_mult","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::insert_phase_two":["insert_phase_two","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::is_empty":["is_empty","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::iter":["iter","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::iter_mut":["iter_mut","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::keys":["keys","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::keys_len":["keys_len","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::len":["len","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::rebuild":["rebuild","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::reinsert_entry_in_order":["reinsert_entry_in_order","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::remove":["remove","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::remove_all_extra_values":["remove_all_extra_values","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::remove_extra_value":["remove_extra_value","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::remove_found":["remove_found","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::reserve":["reserve","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::reserve_one":["reserve_one","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::value_iter":["value_iter","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::value_iter_mut":["value_iter_mut","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::values":["values","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::values_mut":["values_mut","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::<T>::with_capacity":["with_capacity","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::HeaderMap::new":["new","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::IterMut::<'a, T>::next_unsafe":["next_unsafe","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::OccupiedEntry::<'a, T>::append":["append","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::OccupiedEntry::<'a, T>::get":["get","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::OccupiedEntry::<'a, T>::get_mut":["get_mut","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::OccupiedEntry::<'a, T>::insert":["insert","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::OccupiedEntry::<'a, T>::insert_mult":["insert_mult","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::OccupiedEntry::<'a, T>::into_mut":["into_mut","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::OccupiedEntry::<'a, T>::iter":["iter","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::OccupiedEntry::<'a, T>::iter_mut":["iter_mut","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::OccupiedEntry::<'a, T>::key":["key","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::OccupiedEntry::<'a, T>::remove":["remove","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::OccupiedEntry::<'a, T>::remove_entry":["remove_entry","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::OccupiedEntry::<'a, T>::remove_entry_mult":["remove_entry_mult","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::Pos::is_none":["is_none","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::Pos::is_some":["is_some","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::Pos::new":["new","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::Pos::none":["none","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::Pos::resolve":["resolve","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::VacantEntry::<'a, T>::insert":["insert","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::VacantEntry::<'a, T>::insert_entry":["insert_entry","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::VacantEntry::<'a, T>::into_key":["into_key","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::VacantEntry::<'a, T>::key":["key","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::append_value":["append_value","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::desired_pos":["desired_pos","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::do_insert_phase_two":["do_insert_phase_two","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::hash_elem_using":["hash_elem_using","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::probe_distance":["probe_distance","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::to_raw_capacity":["to_raw_capacity","Real(LocalPath(\"src/header/map.rs\"))",""],"header::map::usable_capacity":["usable_capacity","Real(LocalPath(\"src/header/map.rs\"))",""],"header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for &'a str>::eq":["eq","Real(LocalPath(\"src/header/name.rs\"))","std::cmp::PartialEq"],"header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for str>::eq":["eq","Real(LocalPath(\"src/header/name.rs\"))","std::cmp::PartialEq"],"header::name::<impl std::convert::From<header::name::Custom> for bytes::Bytes>::from":["from","Real(LocalPath(\"src/header/name.rs\"))","std::convert::From"],"header::name::<impl std::convert::From<header::name::HeaderName> for bytes::Bytes>::from":["from","Real(LocalPath(\"src/header/name.rs\"))","std::convert::From"],"header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from":["from","Real(LocalPath(\"src/header/name.rs\"))","std::convert::From"],"header::name::HdrName::<'a>::custom":["custom","Real(LocalPath(\"src/header/name.rs\"))",""],"header::name::HdrName::<'a>::from_bytes":["from_bytes","Real(LocalPath(\"src/header/name.rs\"))",""],"header::name::HdrName::<'a>::from_static":["from_static","Real(LocalPath(\"src/header/name.rs\"))",""],"header::name::HeaderName::as_str":["as_str","Real(LocalPath(\"src/header/name.rs\"))",""],"header::name::HeaderName::from_bytes":["from_bytes","Real(LocalPath(\"src/header/name.rs\"))",""],"header::name::HeaderName::from_lowercase":["from_lowercase","Real(LocalPath(\"src/header/name.rs\"))",""],"header::name::HeaderName::from_static":["from_static","Real(LocalPath(\"src/header/name.rs\"))",""],"header::name::InvalidHeaderName::new":["new","Real(LocalPath(\"src/header/name.rs\"))",""],"header::name::StandardHeader::as_str":["as_str","Real(LocalPath(\"src/header/name.rs\"))",""],"header::name::eq_ignore_ascii_case":["eq_ignore_ascii_case","Real(LocalPath(\"src/header/name.rs\"))",""],"header::name::parse_hdr":["parse_hdr","Real(LocalPath(\"src/header/name.rs\"))",""],"header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for &'a str>::eq":["eq","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialEq"],"header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for [u8]>::eq":["eq","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialEq"],"header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for std::string::String>::eq":["eq","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialEq"],"header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for str>::eq":["eq","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialEq"],"header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for &'a str>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialOrd"],"header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for [u8]>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialOrd"],"header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for std::string::String>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialOrd"],"header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for str>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/header/value.rs\"))","std::cmp::PartialOrd"],"header::value::<impl std::convert::From<header::value::HeaderValue> for bytes::Bytes>::from":["from","Real(LocalPath(\"src/header/value.rs\"))","std::convert::From"],"header::value::HeaderValue::as_bytes":["as_bytes","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::HeaderValue::from_bytes":["from_bytes","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::HeaderValue::from_name":["from_name","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::HeaderValue::from_shared":["from_shared","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::HeaderValue::from_shared_unchecked":["from_shared_unchecked","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::HeaderValue::from_static":["from_static","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::HeaderValue::from_str":["from_str","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::HeaderValue::is_empty":["is_empty","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::HeaderValue::is_sensitive":["is_sensitive","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::HeaderValue::len":["len","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::HeaderValue::set_sensitive":["set_sensitive","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::HeaderValue::to_str":["to_str","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::HeaderValue::try_from":["try_from","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::is_valid":["is_valid","Real(LocalPath(\"src/header/value.rs\"))",""],"header::value::is_visible_ascii":["is_visible_ascii","Real(LocalPath(\"src/header/value.rs\"))",""],"method::<impl std::cmp::PartialEq<method::Method> for &'a str>::eq":["eq","Real(LocalPath(\"src/method.rs\"))","std::cmp::PartialEq"],"method::<impl std::cmp::PartialEq<method::Method> for str>::eq":["eq","Real(LocalPath(\"src/method.rs\"))","std::cmp::PartialEq"],"method::InvalidMethod::new":["new","Real(LocalPath(\"src/method.rs\"))",""],"method::Method::as_str":["as_str","Real(LocalPath(\"src/method.rs\"))",""],"method::Method::extension_inline":["extension_inline","Real(LocalPath(\"src/method.rs\"))",""],"method::Method::from_bytes":["from_bytes","Real(LocalPath(\"src/method.rs\"))",""],"method::Method::is_idempotent":["is_idempotent","Real(LocalPath(\"src/method.rs\"))",""],"method::Method::is_safe":["is_safe","Real(LocalPath(\"src/method.rs\"))",""],"method::write_checked":["write_checked","Real(LocalPath(\"src/method.rs\"))",""],"request::Builder::body":["body","Real(LocalPath(\"src/request.rs\"))",""],"request::Builder::extension":["extension","Real(LocalPath(\"src/request.rs\"))",""],"request::Builder::header":["header","Real(LocalPath(\"src/request.rs\"))",""],"request::Builder::headers_mut":["headers_mut","Real(LocalPath(\"src/request.rs\"))",""],"request::Builder::headers_ref":["headers_ref","Real(LocalPath(\"src/request.rs\"))",""],"request::Builder::method":["method","Real(LocalPath(\"src/request.rs\"))",""],"request::Builder::method_ref":["method_ref","Real(LocalPath(\"src/request.rs\"))",""],"request::Builder::new":["new","Real(LocalPath(\"src/request.rs\"))",""],"request::Builder::take_parts":["take_parts","Real(LocalPath(\"src/request.rs\"))",""],"request::Builder::uri":["uri","Real(LocalPath(\"src/request.rs\"))",""],"request::Builder::uri_ref":["uri_ref","Real(LocalPath(\"src/request.rs\"))",""],"request::Builder::version":["version","Real(LocalPath(\"src/request.rs\"))",""],"request::Parts::new":["new","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<()>::builder":["builder","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<()>::connect":["connect","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<()>::delete":["delete","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<()>::get":["get","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<()>::head":["head","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<()>::options":["options","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<()>::patch":["patch","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<()>::post":["post","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<()>::put":["put","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<()>::trace":["trace","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::body":["body","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::body_mut":["body_mut","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::extensions":["extensions","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::extensions_mut":["extensions_mut","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::from_parts":["from_parts","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::headers":["headers","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::headers_mut":["headers_mut","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::into_body":["into_body","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::into_parts":["into_parts","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::map":["map","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::method":["method","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::method_mut":["method_mut","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::new":["new","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::uri":["uri","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::uri_mut":["uri_mut","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::version":["version","Real(LocalPath(\"src/request.rs\"))",""],"request::Request::<T>::version_mut":["version_mut","Real(LocalPath(\"src/request.rs\"))",""],"request::head":["head","Real(LocalPath(\"src/request.rs\"))",""],"response::Builder::body":["body","Real(LocalPath(\"src/response.rs\"))",""],"response::Builder::extension":["extension","Real(LocalPath(\"src/response.rs\"))",""],"response::Builder::header":["header","Real(LocalPath(\"src/response.rs\"))",""],"response::Builder::headers_mut":["headers_mut","Real(LocalPath(\"src/response.rs\"))",""],"response::Builder::headers_ref":["headers_ref","Real(LocalPath(\"src/response.rs\"))",""],"response::Builder::new":["new","Real(LocalPath(\"src/response.rs\"))",""],"response::Builder::status":["status","Real(LocalPath(\"src/response.rs\"))",""],"response::Builder::take_parts":["take_parts","Real(LocalPath(\"src/response.rs\"))",""],"response::Builder::version":["version","Real(LocalPath(\"src/response.rs\"))",""],"response::Parts::new":["new","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<()>::builder":["builder","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::body":["body","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::body_mut":["body_mut","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::extensions":["extensions","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::extensions_mut":["extensions_mut","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::from_parts":["from_parts","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::headers":["headers","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::headers_mut":["headers_mut","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::into_body":["into_body","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::into_parts":["into_parts","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::map":["map","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::new":["new","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::status":["status","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::status_mut":["status_mut","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::version":["version","Real(LocalPath(\"src/response.rs\"))",""],"response::Response::<T>::version_mut":["version_mut","Real(LocalPath(\"src/response.rs\"))",""],"response::head":["head","Real(LocalPath(\"src/response.rs\"))",""],"status::<impl std::cmp::PartialEq<status::StatusCode> for u16>::eq":["eq","Real(LocalPath(\"src/status.rs\"))","std::cmp::PartialEq"],"status::<impl std::convert::From<status::StatusCode> for u16>::from":["from","Real(LocalPath(\"src/status.rs\"))","std::convert::From"],"status::InvalidStatusCode::new":["new","Real(LocalPath(\"src/status.rs\"))",""],"status::StatusCode::as_str":["as_str","Real(LocalPath(\"src/status.rs\"))",""],"status::StatusCode::as_u16":["as_u16","Real(LocalPath(\"src/status.rs\"))",""],"status::StatusCode::canonical_reason":["canonical_reason","Real(LocalPath(\"src/status.rs\"))",""],"status::StatusCode::from_bytes":["from_bytes","Real(LocalPath(\"src/status.rs\"))",""],"status::StatusCode::from_u16":["from_u16","Real(LocalPath(\"src/status.rs\"))",""],"status::StatusCode::is_client_error":["is_client_error","Real(LocalPath(\"src/status.rs\"))",""],"status::StatusCode::is_informational":["is_informational","Real(LocalPath(\"src/status.rs\"))",""],"status::StatusCode::is_redirection":["is_redirection","Real(LocalPath(\"src/status.rs\"))",""],"status::StatusCode::is_server_error":["is_server_error","Real(LocalPath(\"src/status.rs\"))",""],"status::StatusCode::is_success":["is_success","Real(LocalPath(\"src/status.rs\"))",""],"status::canonical_reason":["canonical_reason","Real(LocalPath(\"src/status.rs\"))",""],"uri::<impl std::cmp::PartialEq<uri::Uri> for &'a str>::eq":["eq","Real(LocalPath(\"src/uri/mod.rs\"))","std::cmp::PartialEq"],"uri::<impl std::cmp::PartialEq<uri::Uri> for str>::eq":["eq","Real(LocalPath(\"src/uri/mod.rs\"))","std::cmp::PartialEq"],"uri::Uri::authority":["authority","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::authority_part":["authority_part","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::builder":["builder","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::from_parts":["from_parts","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::from_shared":["from_shared","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::from_static":["from_static","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::has_path":["has_path","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::host":["host","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::into_parts":["into_parts","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::path":["path","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::path_and_query":["path_and_query","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::port":["port","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::port_part":["port_part","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::port_u16":["port_u16","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::query":["query","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::scheme":["scheme","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::scheme_part":["scheme_part","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::Uri::scheme_str":["scheme_str","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for &'a str>::eq":["eq","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialEq"],"uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for std::string::String>::eq":["eq","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialEq"],"uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for str>::eq":["eq","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialEq"],"uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for &'a str>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialOrd"],"uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for std::string::String>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialOrd"],"uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for str>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/authority.rs\"))","std::cmp::PartialOrd"],"uri::authority::<impl std::convert::From<uri::authority::Authority> for bytes::Bytes>::from":["from","Real(LocalPath(\"src/uri/authority.rs\"))","std::convert::From"],"uri::authority::Authority::as_str":["as_str","Real(LocalPath(\"src/uri/authority.rs\"))",""],"uri::authority::Authority::empty":["empty","Real(LocalPath(\"src/uri/authority.rs\"))",""],"uri::authority::Authority::from_shared":["from_shared","Real(LocalPath(\"src/uri/authority.rs\"))",""],"uri::authority::Authority::from_static":["from_static","Real(LocalPath(\"src/uri/authority.rs\"))",""],"uri::authority::Authority::host":["host","Real(LocalPath(\"src/uri/authority.rs\"))",""],"uri::authority::Authority::into_bytes":["into_bytes","Real(LocalPath(\"src/uri/authority.rs\"))",""],"uri::authority::Authority::parse":["parse","Real(LocalPath(\"src/uri/authority.rs\"))",""],"uri::authority::Authority::parse_non_empty":["parse_non_empty","Real(LocalPath(\"src/uri/authority.rs\"))",""],"uri::authority::Authority::port":["port","Real(LocalPath(\"src/uri/authority.rs\"))",""],"uri::authority::Authority::port_part":["port_part","Real(LocalPath(\"src/uri/authority.rs\"))",""],"uri::authority::Authority::port_u16":["port_u16","Real(LocalPath(\"src/uri/authority.rs\"))",""],"uri::authority::host":["host","Real(LocalPath(\"src/uri/authority.rs\"))",""],"uri::builder::Builder::authority":["authority","Real(LocalPath(\"src/uri/builder.rs\"))",""],"uri::builder::Builder::build":["build","Real(LocalPath(\"src/uri/builder.rs\"))",""],"uri::builder::Builder::map":["map","Real(LocalPath(\"src/uri/builder.rs\"))",""],"uri::builder::Builder::new":["new","Real(LocalPath(\"src/uri/builder.rs\"))",""],"uri::builder::Builder::path_and_query":["path_and_query","Real(LocalPath(\"src/uri/builder.rs\"))",""],"uri::builder::Builder::scheme":["scheme","Real(LocalPath(\"src/uri/builder.rs\"))",""],"uri::parse_full":["parse_full","Real(LocalPath(\"src/uri/mod.rs\"))",""],"uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for &'a str>::eq":["eq","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialEq"],"uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for std::string::String>::eq":["eq","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialEq"],"uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for str>::eq":["eq","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialEq"],"uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for &'a str>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialOrd"],"uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for std::string::String>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialOrd"],"uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for str>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/uri/path.rs\"))","std::cmp::PartialOrd"],"uri::path::<impl std::convert::From<uri::path::PathAndQuery> for bytes::Bytes>::from":["from","Real(LocalPath(\"src/uri/path.rs\"))","std::convert::From"],"uri::path::PathAndQuery::as_str":["as_str","Real(LocalPath(\"src/uri/path.rs\"))",""],"uri::path::PathAndQuery::empty":["empty","Real(LocalPath(\"src/uri/path.rs\"))",""],"uri::path::PathAndQuery::from_shared":["from_shared","Real(LocalPath(\"src/uri/path.rs\"))",""],"uri::path::PathAndQuery::from_static":["from_static","Real(LocalPath(\"src/uri/path.rs\"))",""],"uri::path::PathAndQuery::into_bytes":["into_bytes","Real(LocalPath(\"src/uri/path.rs\"))",""],"uri::path::PathAndQuery::path":["path","Real(LocalPath(\"src/uri/path.rs\"))",""],"uri::path::PathAndQuery::query":["query","Real(LocalPath(\"src/uri/path.rs\"))",""],"uri::path::PathAndQuery::slash":["slash","Real(LocalPath(\"src/uri/path.rs\"))",""],"uri::path::PathAndQuery::star":["star","Real(LocalPath(\"src/uri/path.rs\"))",""],"uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq":["eq","Real(LocalPath(\"src/uri/port.rs\"))","std::cmp::PartialEq"],"uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from":["from","Real(LocalPath(\"src/uri/port.rs\"))","std::convert::From"],"uri::port::Port::<T>::as_str":["as_str","Real(LocalPath(\"src/uri/port.rs\"))",""],"uri::port::Port::<T>::as_u16":["as_u16","Real(LocalPath(\"src/uri/port.rs\"))",""],"uri::port::Port::<T>::from_str":["from_str","Real(LocalPath(\"src/uri/port.rs\"))",""],"uri::scheme::<impl std::cmp::PartialEq<uri::scheme::Scheme> for str>::eq":["eq","Real(LocalPath(\"src/uri/scheme.rs\"))","std::cmp::PartialEq"],"uri::scheme::<impl std::convert::From<uri::scheme::Scheme> for bytes::Bytes>::from":["from","Real(LocalPath(\"src/uri/scheme.rs\"))","std::convert::From"],"uri::scheme::Protocol::len":["len","Real(LocalPath(\"src/uri/scheme.rs\"))",""],"uri::scheme::Scheme2::<T>::is_none":["is_none","Real(LocalPath(\"src/uri/scheme.rs\"))",""],"uri::scheme::Scheme2::<usize>::parse":["parse","Real(LocalPath(\"src/uri/scheme.rs\"))",""],"uri::scheme::Scheme2::<usize>::parse_exact":["parse_exact","Real(LocalPath(\"src/uri/scheme.rs\"))",""],"uri::scheme::Scheme::as_str":["as_str","Real(LocalPath(\"src/uri/scheme.rs\"))",""],"uri::scheme::Scheme::empty":["empty","Real(LocalPath(\"src/uri/scheme.rs\"))",""],"uri::scheme::Scheme::from_shared":["from_shared","Real(LocalPath(\"src/uri/scheme.rs\"))",""],"uri::scheme::Scheme::into_bytes":["into_bytes","Real(LocalPath(\"src/uri/scheme.rs\"))",""]},"trait_to_struct":{"convert::HttpTryFrom":["header::map::HeaderMap","header::name::HeaderName","header::value::HeaderValue","method::Method","status::StatusCode","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Scheme"],"convert::HttpTryInto":["<T as convert::HttpTryInto<U>>::T"],"header::map::as_header_name::AsHeaderName":["header::name::HeaderName","std::string::String"],"header::map::as_header_name::Sealed":["header::name::HeaderName","std::string::String"],"header::map::into_header_name::IntoHeaderName":["header::name::HeaderName"],"header::map::into_header_name::Sealed":["header::name::HeaderName"],"sealed::Sealed":["header::map::HeaderMap","header::name::HeaderName","header::value::HeaderValue","method::Method","status::StatusCode","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Scheme"],"std::borrow::Borrow":["header::name::HeaderName"],"std::clone::Clone":["byte_str::ByteStr","header::map::Bucket","header::map::Cursor","header::map::Danger","header::map::ExtraValue","header::map::HashValue","header::map::HeaderMap","header::map::Link","header::map::Links","header::map::Pos","header::name::Custom","header::name::HeaderName","header::name::MaybeLower","header::name::Repr","header::name::StandardHeader","header::value::HeaderValue","method::Inner","method::Method","status::StatusCode","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Http","version::Version"],"std::cmp::Eq":["byte_str::ByteStr","header::map::Cursor","header::map::HashValue","header::map::HeaderMap","header::map::Link","header::name::Custom","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","header::value::HeaderValue","method::Inner","method::Method","status::StatusCode","uri::ErrorKind","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Scheme","version::Http","version::Version"],"std::cmp::Ord":["byte_str::ByteStr","header::value::HeaderValue","status::StatusCode","version::Http","version::Version"],"std::cmp::PartialEq":["byte_str::ByteStr","header::map::Cursor","header::map::GetAll","header::map::HashValue","header::map::HeaderMap","header::map::Link","header::name::Custom","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","header::value::HeaderValue","method::Inner","method::Method","status::StatusCode","std::string::String","uri::ErrorKind","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::port::Port","uri::scheme::Scheme","version::Http","version::Version"],"std::cmp::PartialOrd":["byte_str::ByteStr","header::value::HeaderValue","status::StatusCode","std::string::String","uri::authority::Authority","uri::path::PathAndQuery","version::Http","version::Version"],"std::convert::AsRef":["header::name::HeaderName","header::value::HeaderValue","method::Method","uri::authority::Authority","uri::port::Port","uri::scheme::Scheme"],"std::convert::From":["byte_str::ByteStr","bytes::Bytes","error::Error","header::name::HdrName","header::name::HeaderName","header::value::HeaderValue","method::Method","status::StatusCode","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts","uri::Parts","uri::scheme::Scheme","uri::scheme::Scheme2"],"std::default::Default":["extensions::Extensions","extensions::IdHasher","header::map::HeaderMap","method::Method","request::Builder","request::Request","response::Builder","response::Response","status::StatusCode","uri::Parts","uri::Uri","uri::builder::Builder","version::Version"],"std::error::Error":["error::Error","error::Never","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","header::value::ToStrError","method::InvalidMethod","status::InvalidStatusCode","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts"],"std::fmt::Debug":["byte_str::ByteStr","error::Error","error::Never","extensions::Extensions","header::map::Bucket","header::map::Cursor","header::map::Drain","header::map::Entry","header::map::ExtraValue","header::map::GetAll","header::map::HashValue","header::map::HeaderMap","header::map::IntoIter","header::map::Iter","header::map::IterMut","header::map::Keys","header::map::Link","header::map::Links","header::map::OccupiedEntry","header::map::VacantEntry","header::map::ValueDrain","header::map::ValueIter","header::map::ValueIterMut","header::map::Values","header::map::ValuesMut","header::name::Custom","header::name::HdrName","header::name::HeaderName","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::name::MaybeLower","header::name::Repr","header::name::StandardHeader","header::value::HeaderValue","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","header::value::ToStrError","method::InvalidMethod","method::Method","request::Builder","request::Parts","request::Request","response::Builder","response::Parts","response::Response","status::InvalidStatusCode","status::StatusCode","uri::ErrorKind","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts","uri::Parts","uri::Uri","uri::authority::Authority","uri::builder::Builder","uri::path::PathAndQuery","uri::port::Port","uri::scheme::Protocol","uri::scheme::Scheme","uri::scheme::Scheme2","version::Version"],"std::fmt::Display":["error::Error","error::Never","header::name::HeaderName","header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes","header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes","header::value::ToStrError","method::InvalidMethod","method::Method","status::InvalidStatusCode","status::StatusCode","uri::InvalidUri","uri::InvalidUriBytes","uri::InvalidUriParts","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::port::Port","uri::scheme::Scheme"],"std::hash::Hash":["byte_str::ByteStr","header::name::Custom","header::name::HdrName","header::name::HeaderName","header::name::MaybeLower","header::name::Repr","header::name::StandardHeader","header::value::HeaderValue","method::Inner","method::Method","status::StatusCode","uri::Uri","uri::authority::Authority","uri::scheme::Scheme","version::Http","version::Version"],"std::hash::Hasher":["extensions::IdHasher"],"std::iter::DoubleEndedIterator":["header::map::ValueIter","header::map::ValueIterMut"],"std::iter::ExactSizeIterator":["header::map::Keys"],"std::iter::Extend":["header::map::HeaderMap"],"std::iter::FromIterator":["header::map::HeaderMap"],"std::iter::IntoIterator":["header::map::GetAll","header::map::HeaderMap","header::map::OccupiedEntry"],"std::iter::Iterator":["header::map::Drain","header::map::IntoIter","header::map::Iter","header::map::IterMut","header::map::Keys","header::map::ValueDrain","header::map::ValueIter","header::map::ValueIterMut","header::map::Values","header::map::ValuesMut"],"std::marker::Copy":["header::map::Cursor","header::map::HashValue","header::map::Link","header::map::Links","header::map::Pos","header::name::StandardHeader","status::StatusCode","uri::scheme::Protocol","version::Http","version::Version"],"std::marker::Send":["header::map::Drain","header::map::Iter","header::map::IterMut","header::map::ValueDrain","header::map::ValueIterMut"],"std::marker::StructuralEq":["byte_str::ByteStr","header::map::Cursor","header::map::HashValue","header::map::Link","header::name::Custom","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","method::Inner","method::Method","status::StatusCode","uri::ErrorKind","version::Http","version::Version"],"std::marker::StructuralPartialEq":["byte_str::ByteStr","header::map::Cursor","header::map::HashValue","header::map::Link","header::name::Custom","header::name::HeaderName","header::name::Repr","header::name::StandardHeader","method::Inner","method::Method","status::StatusCode","uri::ErrorKind","version::Http","version::Version"],"std::marker::Sync":["header::map::Drain","header::map::Iter","header::map::IterMut","header::map::ValueDrain","header::map::ValueIterMut"],"std::ops::Deref":["byte_str::ByteStr"],"std::ops::Drop":["header::map::Drain","header::map::IntoIter","header::map::ValueDrain"],"std::ops::Index":["header::map::HeaderMap"],"std::str::FromStr":["header::name::HeaderName","header::value::HeaderValue","method::Method","status::StatusCode","uri::Uri","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Scheme"]},"type_to_def_path":{"byte_str::ByteStr":"byte_str::ByteStr","error::Error":"error::Error","error::ErrorKind":"error::ErrorKind","error::Never":"error::Never","extensions::Extensions":"extensions::Extensions","extensions::IdHasher":"extensions::IdHasher","header::map::Bucket<T>":"header::map::Bucket","header::map::Cursor":"header::map::Cursor","header::map::Danger":"header::map::Danger","header::map::Drain<'a, T>":"header::map::Drain","header::map::Entry<'a, T>":"header::map::Entry","header::map::ExtraValue<T>":"header::map::ExtraValue","header::map::GetAll<'a, T>":"header::map::GetAll","header::map::HashValue":"header::map::HashValue","header::map::HeaderMap<T>":"header::map::HeaderMap","header::map::IntoIter<T>":"header::map::IntoIter","header::map::Iter<'a, T>":"header::map::Iter","header::map::IterMut<'a, T>":"header::map::IterMut","header::map::Keys<'a, T>":"header::map::Keys","header::map::Link":"header::map::Link","header::map::Links":"header::map::Links","header::map::OccupiedEntry<'a, T>":"header::map::OccupiedEntry","header::map::Pos":"header::map::Pos","header::map::VacantEntry<'a, T>":"header::map::VacantEntry","header::map::ValueDrain<'a, T>":"header::map::ValueDrain","header::map::ValueIter<'a, T>":"header::map::ValueIter","header::map::ValueIterMut<'a, T>":"header::map::ValueIterMut","header::map::Values<'a, T>":"header::map::Values","header::map::ValuesMut<'a, T>":"header::map::ValuesMut","header::name::Custom":"header::name::Custom","header::name::HdrName<'a>":"header::name::HdrName","header::name::HeaderName":"header::name::HeaderName","header::name::InvalidHeaderName":"header::name::InvalidHeaderName","header::name::InvalidHeaderNameBytes":"header::name::InvalidHeaderNameBytes","header::name::MaybeLower<'a>":"header::name::MaybeLower","header::name::Repr<T>":"header::name::Repr","header::name::StandardHeader":"header::name::StandardHeader","header::value::HeaderValue":"header::value::HeaderValue","header::value::InvalidHeaderValue":"header::value::InvalidHeaderValue","header::value::InvalidHeaderValueBytes":"header::value::InvalidHeaderValueBytes","header::value::ToStrError":"header::value::ToStrError","method::Inner":"method::Inner","method::InvalidMethod":"method::InvalidMethod","method::Method":"method::Method","request::Builder":"request::Builder","request::Parts":"request::Parts","request::Request<T>":"request::Request","response::Builder":"response::Builder","response::Parts":"response::Parts","response::Response<T>":"response::Response","status::InvalidStatusCode":"status::InvalidStatusCode","status::StatusCode":"status::StatusCode","uri::ErrorKind":"uri::ErrorKind","uri::InvalidUri":"uri::InvalidUri","uri::InvalidUriBytes":"uri::InvalidUriBytes","uri::InvalidUriParts":"uri::InvalidUriParts","uri::Parts":"uri::Parts","uri::Uri":"uri::Uri","uri::authority::Authority":"uri::authority::Authority","uri::builder::Builder":"uri::builder::Builder","uri::path::PathAndQuery":"uri::path::PathAndQuery","uri::port::Port<T>":"uri::port::Port","uri::scheme::Protocol":"uri::scheme::Protocol","uri::scheme::Scheme":"uri::scheme::Scheme","uri::scheme::Scheme2<T>":"uri::scheme::Scheme2","version::Http":"version::Http","version::Version":"version::Version"}}