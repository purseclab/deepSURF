{"dependencies":{"<&'a mut toodee::TooDee<T> as std::iter::IntoIterator>::into_iter":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<&'a mut view::TooDeeViewMut<'a, T> as std::iter::IntoIterator>::into_iter":["std::marker::Sized","view::TooDeeViewMut"],"<&'a toodee::TooDee<T> as std::iter::IntoIterator>::into_iter":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<&'a view::TooDeeView<'a, T> as std::iter::IntoIterator>::into_iter":["std::marker::Sized","view::TooDeeView"],"<&'a view::TooDeeViewMut<'a, T> as std::iter::IntoIterator>::into_iter":["std::marker::Sized","view::TooDeeViewMut"],"<<toodee::DrainCol<'_, T> as std::ops::Drop>::drop::DropGuard<'r, 'a, T> as std::ops::Drop>::drop":["<toodee::DrainCol<'_, T> as std::ops::Drop>::drop::DropGuard","iter::Col","std::marker::Sized","std::ptr::NonNull","toodee::DrainCol"],"<flattenexact::FlattenExact<I> as iter::TooDeeIterator>::num_cols":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"<flattenexact::FlattenExact<I> as std::iter::DoubleEndedIterator>::next_back":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"<flattenexact::FlattenExact<I> as std::iter::DoubleEndedIterator>::nth_back":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"<flattenexact::FlattenExact<I> as std::iter::DoubleEndedIterator>::rfold":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::ops::FnMut","std::option::Option","std::vec::Vec","toodee::TooDee"],"<flattenexact::FlattenExact<I> as std::iter::DoubleEndedIterator>::rfold::flatten":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::ops::FnMut","std::option::Option","std::vec::Vec","toodee::TooDee"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::fold":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::ops::FnMut","std::option::Option","std::vec::Vec","toodee::TooDee"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::fold::flatten":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::ops::FnMut","std::option::Option","std::vec::Vec","toodee::TooDee"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::last":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::next":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::nth":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::size_hint":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"<iter::Col<'a, T> as std::fmt::Debug>::fmt":["iter::Col","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<iter::Col<'a, T> as std::iter::DoubleEndedIterator>::next_back":["iter::Col","std::marker::Sized","std::option::Option"],"<iter::Col<'a, T> as std::iter::DoubleEndedIterator>::nth_back":["iter::Col","std::marker::Sized","std::option::Option"],"<iter::Col<'a, T> as std::iter::Iterator>::count":["iter::Col","std::marker::Sized"],"<iter::Col<'a, T> as std::iter::Iterator>::last":["iter::Col","std::marker::Sized","std::option::Option"],"<iter::Col<'a, T> as std::iter::Iterator>::next":["iter::Col","std::marker::Sized","std::option::Option"],"<iter::Col<'a, T> as std::iter::Iterator>::nth":["iter::Col","std::marker::Sized","std::option::Option"],"<iter::Col<'a, T> as std::iter::Iterator>::size_hint":["iter::Col","std::marker::Sized","std::option::Option"],"<iter::Col<'a, T> as std::ops::Index<usize>>::index":["iter::Col","std::marker::Sized"],"<iter::ColMut<'a, T> as std::fmt::Debug>::fmt":["iter::ColMut","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<iter::ColMut<'a, T> as std::iter::DoubleEndedIterator>::next_back":["iter::ColMut","std::marker::Sized","std::option::Option"],"<iter::ColMut<'a, T> as std::iter::DoubleEndedIterator>::nth_back":["iter::ColMut","std::marker::Sized","std::option::Option"],"<iter::ColMut<'a, T> as std::iter::Iterator>::count":["iter::ColMut","std::marker::Sized"],"<iter::ColMut<'a, T> as std::iter::Iterator>::last":["iter::ColMut","std::marker::Sized","std::option::Option"],"<iter::ColMut<'a, T> as std::iter::Iterator>::next":["iter::ColMut","std::marker::Sized","std::option::Option"],"<iter::ColMut<'a, T> as std::iter::Iterator>::nth":["iter::ColMut","std::marker::Sized","std::option::Option"],"<iter::ColMut<'a, T> as std::iter::Iterator>::size_hint":["iter::ColMut","std::marker::Sized","std::option::Option"],"<iter::ColMut<'a, T> as std::ops::Index<usize>>::index":["iter::ColMut","std::marker::Sized"],"<iter::ColMut<'a, T> as std::ops::IndexMut<usize>>::index_mut":["iter::ColMut","std::marker::Sized"],"<iter::Rows<'_, T> as iter::TooDeeIterator>::num_cols":["iter::Rows","std::marker::Sized"],"<iter::Rows<'a, T> as std::fmt::Debug>::fmt":["iter::Rows","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<iter::Rows<'a, T> as std::iter::DoubleEndedIterator>::next_back":["iter::Rows","std::marker::Sized","std::option::Option"],"<iter::Rows<'a, T> as std::iter::DoubleEndedIterator>::nth_back":["iter::Rows","std::marker::Sized","std::option::Option"],"<iter::Rows<'a, T> as std::iter::Iterator>::count":["iter::Rows","std::marker::Sized"],"<iter::Rows<'a, T> as std::iter::Iterator>::last":["iter::Rows","std::marker::Sized","std::option::Option"],"<iter::Rows<'a, T> as std::iter::Iterator>::next":["iter::Rows","std::marker::Sized","std::option::Option"],"<iter::Rows<'a, T> as std::iter::Iterator>::nth":["iter::Rows","std::marker::Sized","std::option::Option"],"<iter::Rows<'a, T> as std::iter::Iterator>::size_hint":["iter::Rows","std::marker::Sized","std::option::Option"],"<iter::RowsMut<'_, T> as iter::TooDeeIterator>::num_cols":["iter::RowsMut","std::marker::Sized"],"<iter::RowsMut<'a, T> as std::fmt::Debug>::fmt":["iter::RowsMut","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<iter::RowsMut<'a, T> as std::iter::DoubleEndedIterator>::next_back":["iter::RowsMut","std::marker::Sized","std::option::Option"],"<iter::RowsMut<'a, T> as std::iter::DoubleEndedIterator>::nth_back":["iter::RowsMut","std::marker::Sized","std::option::Option"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::count":["iter::RowsMut","std::marker::Sized"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::last":["iter::RowsMut","std::marker::Sized","std::option::Option"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::next":["iter::RowsMut","std::marker::Sized","std::option::Option"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::nth":["iter::RowsMut","std::marker::Sized","std::option::Option"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::size_hint":["iter::RowsMut","std::marker::Sized","std::option::Option"],"<toodee::DrainCol<'_, T> as std::iter::DoubleEndedIterator>::next_back":["iter::Col","std::marker::Sized","std::option::Option","std::ptr::NonNull","toodee::DrainCol"],"<toodee::DrainCol<'_, T> as std::iter::Iterator>::next":["iter::Col","std::marker::Sized","std::option::Option","std::ptr::NonNull","toodee::DrainCol"],"<toodee::DrainCol<'_, T> as std::iter::Iterator>::size_hint":["iter::Col","std::marker::Sized","std::option::Option","std::ptr::NonNull","toodee::DrainCol"],"<toodee::DrainCol<'_, T> as std::ops::Drop>::drop":["iter::Col","std::marker::Sized","std::ptr::NonNull","toodee::DrainCol"],"<toodee::DrainCol<'_, T> as std::ops::Drop>::drop::DropGuard":["<toodee::DrainCol<'_, T> as std::ops::Drop>::drop::DropGuard","iter::Col","std::marker::Sized","std::ptr::NonNull","toodee::DrainCol"],"<toodee::DrainCol<'a, T> as std::fmt::Debug>::fmt":["iter::Col","std::fmt::Formatter","std::marker::Sized","std::ptr::NonNull","std::result::Result","toodee::DrainCol"],"<toodee::TooDee<T> as copy::CopyOps<T>>::clone_from_slice":["std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as copy::CopyOps<T>>::clone_from_toodee":["ops::TooDeeOps","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as copy::CopyOps<T>>::copy_from_slice":["std::alloc::Allocator","std::marker::Copy","std::marker::Sized","std::vec::Vec","toodee::TooDee","view::TooDeeView"],"<toodee::TooDee<T> as copy::CopyOps<T>>::copy_from_toodee":["ops::TooDeeOps","std::alloc::Allocator","std::marker::Copy","std::marker::Sized","std::vec::Vec","toodee::TooDee","view::TooDeeView"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::bounds":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::col":["iter::Col","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::get_unchecked":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::get_unchecked_row":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::num_cols":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::num_rows":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::rows":["iter::Rows","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::view":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee","view::TooDeeView"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::col_mut":["iter::ColMut","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::fill":["std::alloc::Allocator","std::borrow::Borrow","std::clone::Clone","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::get_unchecked_mut":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::get_unchecked_row_mut":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::rows_mut":["iter::RowsMut","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::swap_rows":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::view_mut":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee","view::TooDeeViewMut"],"<toodee::TooDee<T> as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::cmp::Eq>::assert_receiver_is_total_eq":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::cmp::PartialEq>::eq":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::convert::AsMut<[T]>>::as_mut":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::convert::AsRef<[T]>>::as_ref":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::convert::AsRef<std::vec::Vec<T>>>::as_ref":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::convert::From<view::TooDeeView<'_, T>>>::from":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee","view::TooDeeView"],"<toodee::TooDee<T> as std::convert::From<view::TooDeeViewMut<'_, T>>>::from":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee","view::TooDeeViewMut"],"<toodee::TooDee<T> as std::convert::Into<std::boxed::Box<[T]>>>::into":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::convert::Into<std::vec::Vec<T>>>::into":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::default::Default>::default":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::hash::Hash>::hash":["std::alloc::Allocator","std::hash::Hasher","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::iter::IntoIterator>::into_iter":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::ops::Index<(usize, usize)>>::index":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::ops::Index<usize>>::index":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::ops::IndexMut<(usize, usize)>>::index_mut":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<toodee::TooDee<T> as std::ops::IndexMut<usize>>::index_mut":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"<view::TooDeeView<'_, T> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","view::TooDeeView"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::bounds":["std::marker::Sized","view::TooDeeView"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::col":["iter::Col","std::marker::Sized","view::TooDeeView"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::get_unchecked":["std::marker::Sized","view::TooDeeView"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::get_unchecked_row":["std::marker::Sized","view::TooDeeView"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::num_cols":["std::marker::Sized","view::TooDeeView"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::num_rows":["std::marker::Sized","view::TooDeeView"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::rows":["iter::Rows","std::marker::Sized","view::TooDeeView"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::view":["std::marker::Sized","view::TooDeeView"],"<view::TooDeeView<'a, T> as std::clone::Clone>::clone":["std::marker::Sized","view::TooDeeView"],"<view::TooDeeView<'a, T> as std::cmp::Eq>::assert_receiver_is_total_eq":["std::marker::Sized","view::TooDeeView"],"<view::TooDeeView<'a, T> as std::cmp::PartialEq>::eq":["std::marker::Sized","view::TooDeeView"],"<view::TooDeeView<'a, T> as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","view::TooDeeView"],"<view::TooDeeView<'a, T> as std::ops::Index<(usize, usize)>>::index":["std::marker::Sized","view::TooDeeView"],"<view::TooDeeView<'a, T> as std::ops::Index<usize>>::index":["std::marker::Sized","view::TooDeeView"],"<view::TooDeeViewMut<'_, T> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::bounds":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::col":["iter::Col","std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::get_unchecked":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::get_unchecked_row":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::num_cols":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::num_rows":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::rows":["iter::Rows","std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::view":["std::marker::Sized","view::TooDeeView","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::col_mut":["iter::ColMut","std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::get_unchecked_mut":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::get_unchecked_row_mut":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::rows_mut":["iter::RowsMut","std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::swap_rows":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::view_mut":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as std::cmp::Eq>::assert_receiver_is_total_eq":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as std::cmp::PartialEq>::eq":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as std::convert::Into<view::TooDeeView<'a, T>>>::into":["std::marker::Sized","view::TooDeeView","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as std::ops::Index<(usize, usize)>>::index":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as std::ops::Index<usize>>::index":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as std::ops::IndexMut<(usize, usize)>>::index_mut":["std::marker::Sized","view::TooDeeViewMut"],"<view::TooDeeViewMut<'a, T> as std::ops::IndexMut<usize>>::index_mut":["std::marker::Sized","view::TooDeeViewMut"],"copy::CopyOps::clone_from_slice":["std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"copy::CopyOps::clone_from_toodee":["ops::TooDeeOps","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"copy::CopyOps::copy_from_slice":["std::marker::Copy","std::marker::Sized","view::TooDeeView"],"copy::CopyOps::copy_from_toodee":["ops::TooDeeOps","std::alloc::Allocator","std::marker::Copy","std::marker::Sized","std::vec::Vec","toodee::TooDee","view::TooDeeView"],"copy::CopyOps::copy_within":["std::marker::Copy","std::marker::Sized","view::TooDeeView"],"flattenexact::FlattenExact":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"flattenexact::FlattenExact::<I>::new":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"iter::Col":["iter::Col","std::marker::Sized"],"iter::ColMut":["iter::ColMut","std::marker::Sized"],"iter::Rows":["iter::Rows","std::marker::Sized"],"iter::RowsMut":["iter::RowsMut","std::marker::Sized"],"iter::TooDeeIterator::num_cols":[],"ops::TooDeeOps::bounds":[],"ops::TooDeeOps::cells":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"ops::TooDeeOps::col":["iter::Col","std::marker::Sized"],"ops::TooDeeOps::get_unchecked":[],"ops::TooDeeOps::get_unchecked_row":[],"ops::TooDeeOps::is_empty":[],"ops::TooDeeOps::num_cols":[],"ops::TooDeeOps::num_rows":[],"ops::TooDeeOps::rows":["iter::Rows","std::marker::Sized"],"ops::TooDeeOps::size":[],"ops::TooDeeOps::view":["std::marker::Sized","view::TooDeeView"],"ops::TooDeeOpsMut::cells_mut":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"ops::TooDeeOpsMut::col_mut":["iter::ColMut","std::marker::Sized"],"ops::TooDeeOpsMut::fill":["std::alloc::Allocator","std::borrow::Borrow","std::clone::Clone","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"ops::TooDeeOpsMut::get_unchecked_mut":[],"ops::TooDeeOpsMut::get_unchecked_row_mut":[],"ops::TooDeeOpsMut::row_pair_mut":[],"ops::TooDeeOpsMut::rows_mut":["iter::RowsMut","std::marker::Sized"],"ops::TooDeeOpsMut::swap_cols":[],"ops::TooDeeOpsMut::swap_rows":[],"ops::TooDeeOpsMut::view_mut":["std::marker::Sized","view::TooDeeViewMut"],"sort::SortOps::sort_by_col":["std::marker::Sized","std::ops::FnMut"],"sort::SortOps::sort_by_col_key":["std::cmp::Ord","std::marker::Sized","std::ops::FnMut"],"sort::SortOps::sort_by_row":["std::marker::Sized","std::ops::FnMut"],"sort::SortOps::sort_by_row_key":["std::cmp::Ord","std::marker::Sized","std::ops::FnMut"],"sort::SortOps::sort_col_ord":["std::cmp::Ord","std::marker::Sized"],"sort::SortOps::sort_row_ord":["std::cmp::Ord","std::marker::Sized"],"sort::SortOps::sort_unstable_by_col":["std::marker::Sized","std::ops::FnMut"],"sort::SortOps::sort_unstable_by_col_key":["std::cmp::Ord","std::marker::Sized","std::ops::FnMut"],"sort::SortOps::sort_unstable_by_row":["std::marker::Sized","std::ops::FnMut"],"sort::SortOps::sort_unstable_by_row_key":["std::cmp::Ord","std::marker::Sized","std::ops::FnMut"],"sort::SortOps::sort_unstable_row_ord":["std::cmp::Ord","std::marker::Sized"],"sort::build_swap_trace":[],"sort::sorted_box_to_ordering":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"toodee::DrainCol":["iter::Col","std::marker::Sized","std::ptr::NonNull","toodee::DrainCol"],"toodee::TooDee":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::capacity":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::clear":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::data":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::data_mut":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::from_box":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::from_vec":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::init":["std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::insert_col":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::insert_row":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::new":["std::alloc::Allocator","std::clone::Clone","std::default::Default","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::pop_col":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::pop_row":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::push_col":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::push_row":["flattenexact::FlattenExact","iter::TooDeeIterator","std::alloc::Allocator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::option::Option","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::remove_col":["iter::Col","std::alloc::Allocator","std::marker::Sized","std::ptr::NonNull","std::vec::Vec","toodee::DrainCol","toodee::TooDee"],"toodee::TooDee::<T>::remove_row":["std::alloc::Allocator","std::marker::Sized","std::vec::Drain","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::reserve":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::reserve_exact":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::shrink_to_fit":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"toodee::TooDee::<T>::with_capacity":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"],"translate::TranslateOps::flip_cols":[],"translate::TranslateOps::flip_rows":[],"translate::TranslateOps::translate_with_wrap":[],"view::TooDeeView":["std::marker::Sized","view::TooDeeView"],"view::TooDeeView::<'a, T>::from_toodee":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee","view::TooDeeView"],"view::TooDeeView::<'a, T>::new":["std::marker::Sized","view::TooDeeView"],"view::TooDeeViewMut":["std::marker::Sized","view::TooDeeViewMut"],"view::TooDeeViewMut::<'a, T>::from_toodee":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee","view::TooDeeViewMut"],"view::TooDeeViewMut::<'a, T>::new":["std::marker::Sized","view::TooDeeViewMut"],"view::calculate_view_dimensions":["ops::TooDeeOps","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","toodee::TooDee"]},"glob_path_import":{"copy":"","flattenexact":"","iter":"","ops":"","sort":"","toodee":"","translate":"","view":""},"self_to_fn":{"<O as sort::SortOps<T>>::O":["impl<T, O> SortOps<T> for O where O : TooDeeOpsMut<T> {}"],"<O as translate::TranslateOps<T>>::O":["impl<T, O> TranslateOps<T> for O where O : TooDeeOpsMut<T> {}"],"<toodee::DrainCol<'_, T> as std::ops::Drop>::drop::DropGuard":["impl<'r, 'a, T> Drop for DropGuard<'r, 'a, T> {\n            fn drop(&mut self) {\n\n                self.0.for_each(drop);\n                \n                let col = self.0.col;\n\n                unsafe {\n                    \n                    let toodee = self.0.toodee.as_mut();\n\n                    let vec = &mut toodee.data;\n\n                    let mut dest = vec.as_mut_ptr().add(col);\n                    let mut src = dest.add(1);\n                    let orig_cols = toodee.num_cols;\n                    let new_cols = orig_cols - 1;\n                    \n                    let num_rows = toodee.num_rows;\n                    \n                    for _ in 1..num_rows {\n                        ptr::copy(src, dest, new_cols);\n                        src = src.add(orig_cols);\n                        dest = dest.add(new_cols);\n                    }\n                    \n                    ptr::copy(src, dest, orig_cols - col);\n                    \n                    toodee.num_cols -= 1;\n                    if toodee.num_cols == 0 {\n                        toodee.num_rows = 0;\n                    }\n\n                    // Set the new length based on the col/row counts\n                    vec.set_len(toodee.num_cols * toodee.num_rows);\n                }\n                \n            }\n        }"],"flattenexact::FlattenExact":["impl<I> DoubleEndedIterator for FlattenExact<I>\nwhere\n    I : ExactSizeIterator + DoubleEndedIterator + TooDeeIterator,\n    I::Item : IntoIterator,\n    <I::Item as IntoIterator>::IntoIter : DoubleEndedIterator + ExactSizeIterator,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<<I::Item as IntoIterator>::Item> {\n        loop {\n            if let Some(ref mut inner) = self.backiter {\n                if let elt @ Some(_) = inner.next_back() {\n                    return elt;\n                }\n            }\n            match self.iter.next_back() {\n                None => return self.frontiter.as_mut()?.next_back(),\n                Some(next) => self.backiter = Some(next.into_iter()),\n            }\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, mut n: usize) -> Option<<I::Item as IntoIterator>::Item> {\n        \n        let num_cols = self.num_cols();\n        \n        if num_cols == 0 {\n            return None;\n        }\n        \n        if let Some(ref mut inner) = self.backiter {\n            if n < inner.len() {\n                return inner.nth_back(n);\n            } else {\n                n -= inner.len();\n                self.backiter = None;\n            }\n        }\n        \n        let iter_skip = self.iter.len().min(n / num_cols);\n        if let Some(inner) = self.iter.nth_back(iter_skip) {\n            let mut tmp = inner.into_iter();\n            n -= iter_skip * num_cols;\n            debug_assert!(n < tmp.len());\n            let ret_val = tmp.nth_back(n);\n            self.backiter = Some(tmp);\n            ret_val\n        } else {\n            n -= iter_skip * num_cols;\n            self.frontiter.as_mut()?.nth_back(n)\n        }\n        \n    }\n    \n    #[inline]\n    // #[allow(clippy::toplevel_ref_arg)]\n    fn rfold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        #[inline]\n        fn flatten<U: DoubleEndedIterator, Acc>(\n            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n        ) -> impl FnMut(Acc, U) -> Acc + '_ {\n            move |acc, iter| iter.rfold(acc, &mut *fold)\n        }\n\n        self.frontiter\n            .into_iter()\n            .chain(self.iter.map(IntoIterator::into_iter))\n            .chain(self.backiter)\n            .rfold(init, flatten(fold))\n    }\n    \n}","impl<I> ExactSizeIterator for FlattenExact<I>\nwhere\n    I : ExactSizeIterator + DoubleEndedIterator + TooDeeIterator,\n    I::Item : IntoIterator,\n    <I::Item as IntoIterator>::IntoIter : DoubleEndedIterator + ExactSizeIterator,\n{}","impl<I> FlattenExact<I>\nwhere\n    I : ExactSizeIterator + DoubleEndedIterator + TooDeeIterator,\n    I::Item : IntoIterator,\n    <I::Item as IntoIterator>::IntoIter : DoubleEndedIterator + ExactSizeIterator,\n{\n    pub(super) fn new(iter: I) -> FlattenExact<I> {\n        FlattenExact { iter, frontiter: None, backiter: None }\n    }\n}","impl<I> Iterator for FlattenExact<I>\nwhere\n    I : ExactSizeIterator + DoubleEndedIterator + TooDeeIterator,\n    I::Item : IntoIterator,\n    <I::Item as IntoIterator>::IntoIter : DoubleEndedIterator + ExactSizeIterator,\n{\n    type Item = <I::Item as IntoIterator>::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<<I::Item as IntoIterator>::Item> {\n        loop {\n            if let Some(ref mut inner) = self.frontiter {\n                if let elt @ Some(_) = inner.next() {\n                    return elt;\n                }\n            }\n            match self.iter.next() {\n                None => return self.backiter.as_mut()?.next(),\n                Some(inner) => self.frontiter = Some(inner.into_iter()),\n            }\n        }\n    }\n    \n    #[inline]\n    fn nth(&mut self, mut n: usize) -> Option<<I::Item as IntoIterator>::Item> {\n        \n        let num_cols = self.num_cols();\n        \n        if num_cols == 0 {\n            return None;\n        }\n        \n        if let Some(ref mut inner) = self.frontiter {\n            if n < inner.len() {\n                return inner.nth(n);\n            } else {\n                n -= inner.len();\n                self.frontiter = None;\n            }\n        }\n        \n        let iter_skip = self.iter.len().min(n / num_cols);\n        if let Some(inner) = self.iter.nth(iter_skip) {\n            let mut tmp = inner.into_iter();\n            n -= iter_skip * num_cols;\n            debug_assert!(n < tmp.len());\n            let ret_val = tmp.nth(n);\n            self.frontiter = Some(tmp);\n            ret_val\n        } else {\n            n -= iter_skip * num_cols;\n            self.backiter.as_mut()?.nth(n)\n        }\n        \n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let mut len = self.num_cols() * self.iter.len();\n        len += self.frontiter.as_ref().map_or(0, |i| i.len());\n        len += self.backiter.as_ref().map_or(0, |i| i.len());\n        (len, Some(len))\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }\n    \n    #[inline]\n    // #[allow(clippy::toplevel_ref_arg)]\n    fn fold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        #[inline]\n        fn flatten<U: Iterator, Acc>(\n            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n        ) -> impl FnMut(Acc, U) -> Acc + '_ {\n            move |acc, iter| iter.fold(acc, &mut *fold)\n        }\n\n        self.frontiter\n            .into_iter()\n            .chain(self.iter.map(IntoIterator::into_iter))\n            .chain(self.backiter)\n            .fold(init, flatten(fold))\n    }\n    \n}","impl<I> TooDeeIterator for FlattenExact<I>\nwhere\n    I : ExactSizeIterator + DoubleEndedIterator + TooDeeIterator,\n    I::Item : IntoIterator,\n    <I::Item as IntoIterator>::IntoIter : DoubleEndedIterator + ExactSizeIterator,\n{\n    fn num_cols(&self) -> usize {\n        self.iter.num_cols()\n    }\n}"],"iter::Col":["Debug","impl<'a, T> DoubleEndedIterator for Col<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if let Some((last, fst)) = self.v.split_last() {\n            if fst.is_empty() {\n                self.v = &[];\n            } else {\n                // fst must contain at least one row, so we don't need a bounds check\n                unsafe {\n                    self.v = &fst.get_unchecked(..fst.len() - self.skip);\n                }\n            }\n            Some(last)\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        let (adj, overflow) = n.overflowing_mul(1 + self.skip);\n        if adj >= self.v.len() || overflow {\n            self.v = &[];\n        } else {\n            // adj < self.v.len(), so no check required\n            unsafe {\n                self.v = self.v.get_unchecked(..self.v.len() - adj);\n            }\n        }\n        self.next_back()\n    }\n}","impl<'a, T> Index<usize> for Col<'a, T> {\n    type Output = T;\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let col = toodee.col(2);\n    /// assert_eq!(col[3], 0);\n    /// ```\n    fn index(&self, idx: usize) -> &Self::Output {\n        let pos = idx * (1 + self.skip);\n        &self.v[pos]\n    }\n}","impl<'a, T> Iterator for Col<'a, T> {\n\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Some((fst, snd)) = self.v.split_first() {\n            if snd.is_empty() {\n                self.v = &[];\n            } else {\n                // snd must contain at least one row, so we don't need a bounds check\n                unsafe {\n                    self.v = &snd.get_unchecked(self.skip..);\n                }\n            }\n            Some(fst)\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.v.len();\n        let denom = 1 + self.skip;\n        let n = len / denom + (len % denom);\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n    \n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        \n        let (start, overflow) = n.overflowing_mul(1 + self.skip);\n        if start >= self.v.len() || overflow {\n            self.v = &[];\n        } else {\n            let (_, snd) = self.v.split_at(start);\n            self.v = snd;\n        }\n        self.next()\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }\n}","impl<T> ExactSizeIterator for Col<'_, T> {}"],"iter::ColMut":["Debug","impl<'a, T> DoubleEndedIterator for ColMut<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        let tmp = mem::replace(&mut self.v, &mut []);\n        if let Some((last, fst)) = tmp.split_last_mut() {\n            if fst.is_empty() {\n                self.v = &mut [];\n            } else {\n                let new_len = fst.len() - self.skip;\n                // skip <= fst.len(), so no check required\n                unsafe {\n                    self.v = fst.get_unchecked_mut(..new_len);\n                }\n            }\n            Some(last)\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n\n        let (adj, overflow) = n.overflowing_mul(1 + self.skip);\n        if adj >= self.v.len() || overflow {\n            self.v = &mut [];\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            // adj <= self.v.len(), so no check required\n            unsafe {\n                self.v = tmp.get_unchecked_mut(..self.v.len() - adj);\n            }\n        }\n        self.next_back()\n    }\n}","impl<'a, T> Index<usize> for ColMut<'a, T> {\n    type Output = T;\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let col = toodee.col_mut(2);\n    /// assert_eq!(col[3], 0);\n    /// ```\n    fn index(&self, idx: usize) -> &Self::Output {\n        let pos = idx * (1 + self.skip);\n        &self.v[pos]\n    }\n}","impl<'a, T> IndexMut<usize> for ColMut<'a, T> {\n\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let mut col = toodee.col_mut(2);\n    /// col[3] = 42;\n    /// ```\n    fn index_mut(&mut self, idx: usize) -> &mut Self::Output {\n        let pos = idx * (1 + self.skip);\n        &mut self.v[pos]\n    }\n}","impl<'a, T> Iterator for ColMut<'a, T> {\n\n    type Item = &'a mut T;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let tmp = mem::replace(&mut self.v, &mut []);\n        if let Some((fst, snd)) = tmp.split_first_mut() {\n            if snd.is_empty() {\n                self.v = &mut [];\n            } else {\n                // snd must contain at least one row, so no check required\n                unsafe {\n                    self.v = snd.get_unchecked_mut(self.skip..);\n                }\n            }\n            Some(fst)\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.v.len();\n        let denom = 1 + self.skip;\n        let n = len / denom + (len % denom);\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n    \n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        let (start, overflow) = n.overflowing_mul(1 + self.skip);\n        if start >= self.v.len() || overflow {\n            self.v = &mut [];\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (_, snd) = tmp.split_at_mut(start);\n            self.v = snd;\n        }\n        self.next()\n    }\n    \n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }    \n}","impl<T> ExactSizeIterator for ColMut<'_, T> {}"],"iter::Rows":["Debug","impl<'a, T> DoubleEndedIterator for Rows<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let (fst, snd) = self.v.split_at(self.v.len() - self.cols);\n            if fst.is_empty() {\n                self.v = &[];\n            } else {\n                // skip_cols will be <= fst.len(), so no check required\n                unsafe {\n                    self.v = fst.get_unchecked(..fst.len() - self.skip_cols);\n                }\n            }\n            Some(&snd)\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        let (adj, overflow) = n.overflowing_mul(self.cols + self.skip_cols);\n        if adj >= self.v.len() || overflow {\n            self.v = &[];\n        } else {\n            // adj < fst.len(), so no check required\n            unsafe {\n                self.v = self.v.get_unchecked(..self.v.len() - adj);\n            }\n        }\n        self.next_back()\n    }\n}","impl<'a, T> Iterator for Rows<'a, T> {\n\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let (fst, snd) = self.v.split_at(self.cols);\n            if snd.is_empty() {\n                self.v = &[];\n            } else {\n                // snd must contain at least one row, so no check required\n                unsafe {\n                    self.v = snd.get_unchecked(self.skip_cols..);\n                }\n            }\n            Some(fst)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.cols == 0 {\n            return (0, Some(0));\n        }\n        let len = self.v.len();\n        let denom = self.cols + self.skip_cols;\n        let n = len / denom + (len % denom) / self.cols;\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n    \n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        \n        let (start, overflow) = n.overflowing_mul(self.cols + self.skip_cols);\n        if start >= self.v.len() || overflow {\n            self.v = &[];\n        } else {\n            let (_, snd) = self.v.split_at(start);\n            self.v = snd;\n        }\n        self.next()\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }    \n}","impl<T> ExactSizeIterator for Rows<'_, T> {}","impl<T> TooDeeIterator for Rows<'_, T> {\n    fn num_cols(&self) -> usize {\n        self.cols\n    }\n}"],"iter::RowsMut":["Debug","impl<'a, T> DoubleEndedIterator for RowsMut<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let tmp_len = tmp.len();\n            let (fst, snd) = tmp.split_at_mut(tmp_len - self.cols);\n            if fst.is_empty() {\n                self.v = &mut [];\n            } else {\n                // fst must contain at least one row, so no check required\n                unsafe {\n                    self.v = fst.get_unchecked_mut(..tmp_len - self.cols - self.skip_cols);\n                }\n            }\n            Some(snd)\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n\n        let (adj, overflow) = n.overflowing_mul(self.cols + self.skip_cols);\n        if adj >= self.v.len() || overflow {\n            self.v = &mut [];\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            // adj < self.v.len(), so no check required\n            unsafe {\n                self.v = tmp.get_unchecked_mut(..self.v.len() - adj);\n            }\n        }\n        self.next_back()\n    }\n}","impl<'a, T> Iterator for RowsMut<'a, T> {\n\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (head, tail) = tmp.split_at_mut(self.cols);\n            if tail.is_empty() {\n                self.v = &mut [];\n            } else {\n                // tail must contain at least one row, so no check required\n                unsafe {\n                    self.v = tail.get_unchecked_mut(self.skip_cols..);\n                }\n            }\n            Some(head)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.cols == 0 {\n            return (0, Some(0));\n        }\n        let len = self.v.len();\n        let denom = self.cols + self.skip_cols;\n        let n = len / denom + (len % denom) / self.cols;\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n    \n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        let (start, overflow) = n.overflowing_mul(self.cols + self.skip_cols);\n        if start >= self.v.len() || overflow {\n            self.v = &mut [];\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (_, snd) = tmp.split_at_mut(start);\n            self.v = snd;\n        }\n        self.next()\n    }\n    \n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }    \n}","impl<T> ExactSizeIterator for RowsMut<'_, T> {}","impl<T> TooDeeIterator for RowsMut<'_, T> {\n    fn num_cols(&self) -> usize {\n        self.cols\n    }\n}"],"toodee::DrainCol":["Debug","impl<T> DoubleEndedIterator for DrainCol<'_, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n    }\n}","impl<T> Drop for DrainCol<'_, T> {\n\n    fn drop(&mut self) {\n        /// Continues dropping the remaining elements in the `DrainCol`, then repositions the\n        /// un-`Drain`ed elements to restore the original `TooDee`.\n        struct DropGuard<'r, 'a, T>(&'r mut DrainCol<'a, T>);\n\n        impl<'r, 'a, T> Drop for DropGuard<'r, 'a, T> {\n            fn drop(&mut self) {\n\n                self.0.for_each(drop);\n                \n                let col = self.0.col;\n\n                unsafe {\n                    \n                    let toodee = self.0.toodee.as_mut();\n\n                    let vec = &mut toodee.data;\n\n                    let mut dest = vec.as_mut_ptr().add(col);\n                    let mut src = dest.add(1);\n                    let orig_cols = toodee.num_cols;\n                    let new_cols = orig_cols - 1;\n                    \n                    let num_rows = toodee.num_rows;\n                    \n                    for _ in 1..num_rows {\n                        ptr::copy(src, dest, new_cols);\n                        src = src.add(orig_cols);\n                        dest = dest.add(new_cols);\n                    }\n                    \n                    ptr::copy(src, dest, orig_cols - col);\n                    \n                    toodee.num_cols -= 1;\n                    if toodee.num_cols == 0 {\n                        toodee.num_rows = 0;\n                    }\n\n                    // Set the new length based on the col/row counts\n                    vec.set_len(toodee.num_cols * toodee.num_rows);\n                }\n                \n            }\n        }\n\n        // exhaust self first\n        while let Some(item) = self.next() {\n            let guard = DropGuard(self);\n            drop(item);\n            mem::forget(guard);\n        }\n\n        // Drop a `DropGuard` to move back the non-drained tail of `self`.\n        DropGuard(self);\n    }\n}","impl<T> ExactSizeIterator for DrainCol<'_, T> { }","impl<T> Iterator for DrainCol<'_, T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}","unsafe impl<T: Send> Send for DrainCol<'_, T> {}","unsafe impl<T: Sync> Sync for DrainCol<'_, T> {}"],"toodee::TooDee":["Clone","Eq","Hash","PartialEq","impl<T> AsMut<[T]> for TooDee<T> {\n    fn as_mut(&mut self) -> &mut [T] {\n        &mut self.data\n    }\n}","impl<T> AsRef<Vec<T>> for TooDee<T> {\n    fn as_ref(&self) -> &Vec<T> {\n        &self.data\n    }\n}","impl<T> AsRef<[T]> for TooDee<T> {\n    fn as_ref(&self) -> &[T] {\n        &self.data\n    }\n}","impl<T> CopyOps<T> for TooDee<T> {\n\n    fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n        self.data_mut().copy_from_slice(src);\n    }\n    \n    fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n        self.data_mut().clone_from_slice(src);\n    }\n    \n    fn copy_from_toodee(&mut self, src: &impl TooDeeOps<T>) where T : Copy {\n        assert_eq!(self.size(), src.size());\n        let num_cols = self.num_cols();\n        let mut v = self.data_mut();\n        for r in src.rows() {\n            let (fst, snd) = v.split_at_mut(num_cols);\n            fst.copy_from_slice(r);\n            v = snd;\n        }\n    }\n\n    fn clone_from_toodee(&mut self, src: &impl TooDeeOps<T>) where T : Clone {\n        assert_eq!(self.size(), src.size());\n        let num_cols = self.num_cols();\n        let mut v = self.data_mut();\n        for r in src.rows() {\n            let (fst, snd) = v.split_at_mut(num_cols);\n            fst.clone_from_slice(r);\n            v = snd;\n        }\n    }\n}","impl<T> Debug for TooDee<T> where T : Debug {\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.rows()).finish()\n    }\n}","impl<T> Default for TooDee<T> {\n    \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::TooDee;\n    /// struct Abc { }\n    /// let toodee : TooDee<Abc> = TooDee::default();\n    /// ```\n    fn default() -> Self {\n        TooDee {\n            data : Vec::default(),\n            num_rows : 0,\n            num_cols : 0,\n        }\n    }\n}","impl<T> From<TooDeeView<'_, T>> for TooDee<T> where T : Clone {\n    fn from(view: TooDeeView<'_, T>) -> Self {\n        let num_cols = view.num_cols();\n        let num_rows = view.num_rows();\n        let mut v = Vec::with_capacity(num_cols * num_rows);\n        for r in view.rows() {\n            v.extend_from_slice(r);\n        }\n        TooDee {\n            data : v,\n            num_cols,\n            num_rows,\n        }\n    }\n}","impl<T> From<TooDeeViewMut<'_, T>> for TooDee<T> where T : Clone {\n    fn from(view: TooDeeViewMut<'_, T>) -> Self {\n        let num_cols = view.num_cols();\n        let num_rows = view.num_rows();\n        let mut v = Vec::with_capacity(num_cols * num_rows);\n        for r in view.rows() {\n            v.extend_from_slice(r);\n        }\n        TooDee {\n            data : v,\n            num_cols,\n            num_rows,\n        }\n    }\n}","impl<T> Index<Coordinate> for TooDee<T> {\n    type Output = T;\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// assert_eq!(toodee[(1,3)], 0);\n    /// ```\n    fn index(&self, coord: Coordinate) -> &Self::Output {\n        assert!(coord.1 < self.num_rows);\n        assert!(coord.0 < self.num_cols);\n        // can access the element unchecked because the above assertions hold\n        unsafe {\n            self.data.get_unchecked(coord.1 * self.num_cols + coord.0)\n        }\n    }\n}","impl<T> Index<usize> for TooDee<T> {\n    type Output = [T];\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let row = &toodee[3];\n    /// assert_eq!(row.len(), 10);\n    /// ```\n    fn index(&self, row: usize) -> &Self::Output {\n        assert!(row < self.num_rows);\n        let start = row * self.num_cols;\n        // can access the element unchecked because the above assertion holds\n        unsafe {\n            self.data.get_unchecked(start..start + self.num_cols)\n        }\n    }\n}","impl<T> IndexMut<Coordinate> for TooDee<T> {\n\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// assert_eq!(toodee[(1,3)], 0);\n    /// ```\n    fn index_mut(&mut self, coord: Coordinate) -> &mut Self::Output {\n        assert!(coord.1 < self.num_rows);\n        assert!(coord.0 < self.num_cols);\n        // can access the element unchecked because the above assertions hold\n        unsafe {\n            self.data.get_unchecked_mut(coord.1 * self.num_cols + coord.0)\n        }\n    }\n}","impl<T> IndexMut<usize> for TooDee<T> {\n\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let mut row = &mut toodee[3];\n    /// row[0] = 42;\n    /// ```\n    fn index_mut(&mut self, row: usize) -> &mut Self::Output {\n        assert!(row < self.num_rows);\n        let start = row * self.num_cols;\n        // can access the element unchecked because the above assertion holds\n        unsafe {\n            self.data.get_unchecked_mut(start..start + self.num_cols)\n        }\n    }\n}","impl<T> Into<Box<[T]>> for TooDee<T> {\n    fn into(self) -> Box<[T]> {\n        self.data.into_boxed_slice()\n    }\n}","impl<T> Into<Vec<T>> for TooDee<T> {\n    fn into(self) -> Vec<T> {\n        self.data\n    }\n}","impl<T> IntoIterator for TooDee<T> {\n    type Item = T;\n    type IntoIter = IntoIterTooDee<T>;\n    fn into_iter(self) -> Self::IntoIter {\n        self.data.into_iter()\n    }\n}","impl<T> TooDee<T> {\n\n    /// Create a new `TooDee` array of the specified dimensions, and fill it with\n    /// the type's default value.\n    /// \n    /// # Panics\n    /// \n    /// Panics if one of the dimensions is zero but the other is non-zero. This\n    /// is to enforce the rule that empty arrays have no dimensions.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// assert_eq!(toodee.num_cols(), 10);\n    /// assert_eq!(toodee.num_rows(), 5);\n    /// assert_eq!(toodee[0][0], 0);\n    /// ```\n    pub fn new(num_cols: usize, num_rows: usize) -> TooDee<T>\n    where T: Default + Clone {\n        if num_cols == 0 || num_rows == 0 {\n            assert_eq!(num_rows, num_cols);\n        }\n        let len = num_rows * num_cols;\n        let v = vec![T::default(); len];\n        TooDee {\n            data : v,\n            num_cols,\n            num_rows,\n        }\n    }\n\n    /// Create a new `TooDee` array of the specified dimensions, and fill it with\n    /// an initial value.\n    /// \n    /// # Panics\n    /// \n    /// Panics if one of the dimensions is zero but the other is non-zero. This\n    /// is to enforce the rule that empty arrays have no dimensions.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let toodee = TooDee::init(10, 5, 42u32);\n    /// assert_eq!(toodee.num_cols(), 10);\n    /// assert_eq!(toodee.num_rows(), 5);\n    /// assert_eq!(toodee[0][0], 42);\n    /// ```\n    pub fn init(num_cols: usize, num_rows: usize, init_value: T) -> TooDee<T>\n    where T: Clone {\n        if num_cols == 0 || num_rows == 0 {\n            assert_eq!(num_rows, num_cols);\n        }\n        let len = num_rows * num_cols;\n        let v = vec![init_value; len];\n        TooDee {\n            data : v,\n            num_cols,\n            num_rows,\n        }\n    }\n    \n    /// Returns the element capacity of the underlying `Vec`.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::TooDee;\n    /// let v = vec![42u32; 10];\n    /// let toodee : TooDee<u32> = TooDee::from_vec(5, 2, v);\n    /// assert!(toodee.capacity() >= 10);\n    /// ```\n    pub fn capacity(&self) -> usize {\n        self.data.capacity()\n    }\n    \n    /// Constructs a new, empty `TooDee<T>` with the specified element capacity.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::TooDee;\n    /// let toodee : TooDee<u32> = TooDee::with_capacity(50);\n    /// assert!(toodee.capacity() >= 50);\n    /// ```\n    pub fn with_capacity(capacity: usize) -> TooDee<T> {\n        TooDee {\n            data     : Vec::with_capacity(capacity),\n            num_cols : 0,\n            num_rows : 0,\n        }\n    }\n\n    /// Reserves the minimum capacity for at least `additional` more elements to be inserted\n    /// into the `TooDee<T>`.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::TooDee;\n    /// let mut toodee : TooDee<u32> = TooDee::default();\n    /// toodee.reserve_exact(50);\n    /// assert_eq!(toodee.capacity(), 50);\n    /// ```\n    pub fn reserve_exact(&mut self, capacity: usize) {\n        self.data.reserve_exact(capacity);\n    }\n    \n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the given `TooDee<T>`.    \n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::TooDee;\n    /// let mut toodee : TooDee<u32> = TooDee::default();\n    /// toodee.reserve(50);\n    /// assert!(toodee.capacity() >= 50);\n    /// ```\n    pub fn reserve(&mut self, capacity: usize) {\n        self.data.reserve(capacity);\n    }\n\n    /// Shrinks the capacity of the underlying vector as much as possible.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::TooDee;\n    /// let mut toodee : TooDee<u32> = TooDee::with_capacity(50);\n    /// toodee.shrink_to_fit();\n    /// assert_eq!(toodee.capacity(), 0);\n    /// ```\n    pub fn shrink_to_fit(&mut self) {\n        self.data.shrink_to_fit();\n    }\n    \n    /// Create a new `TooDee` array using the provided vector. The vector's length\n    /// must match the dimensions of the array.\n    /// \n    /// # Panics\n    /// \n    /// Panics if one of the dimensions is zero but the other is non-zero. This\n    /// is to enforce the rule that empty arrays have no dimensions.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let v = vec![42u32; 10];\n    /// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 2, v);\n    /// assert_eq!(toodee.num_cols(), 5);\n    /// assert_eq!(toodee.num_rows(), 2);\n    /// assert_eq!(toodee[0][0], 42);\n    /// ```\n    pub fn from_vec(num_cols: usize, num_rows: usize, v: Vec<T>) -> TooDee<T> {\n        if num_cols == 0 || num_rows == 0 {\n            assert_eq!(num_rows, num_cols);\n        }\n        assert_eq!(num_cols * num_rows, v.len());\n        TooDee {\n            data : v,\n            num_cols,\n            num_rows,\n        }\n    }\n    \n    /// Create a new `TooDee` array using the provided boxed slice. The slice's length\n    /// must match the dimensions of the array.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let v = vec![42u32; 10];\n    /// let mut toodee : TooDee<u32> = TooDee::from_box(5, 2, v.into_boxed_slice());\n    /// assert_eq!(toodee.num_cols(), 5);\n    /// assert_eq!(toodee.num_rows(), 2);\n    /// assert_eq!(toodee[0][0], 42);\n    /// ```\n    pub fn from_box(num_cols: usize, num_rows: usize, b: Box<[T]>) -> TooDee<T> {\n        TooDee::from_vec(num_cols, num_rows, b.into_vec())\n    }\n    \n    /// Returns a reference to the raw array data\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let v = vec![42u32; 10];\n    /// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 2, v);\n    /// assert_eq!(toodee.data()[0], 42);\n    /// ```\n    pub fn data(&self) -> &[T] {\n        &self.data\n    }\n\n    /// Returns a mutable reference to the raw array data\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let v = vec![42u32; 10];\n    /// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 2, v);\n    /// assert_eq!(toodee.data_mut()[0], 42);\n    /// ```\n    pub fn data_mut(&mut self) -> &mut [T] {\n        &mut self.data\n    }\n    \n    \n    /// Clears the array, removing all values and zeroing the number of columns and rows.\n    ///\n    /// Note that this method has no effect on the allocated capacity of the array.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let v = vec![42u32; 10];\n    /// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 2, v);\n    /// toodee.clear();\n    /// assert_eq!(toodee.num_cols(), 0);\n    /// assert_eq!(toodee.num_rows(), 0);\n    /// assert!(toodee.capacity() >= 10);\n    /// ```\n    pub fn clear(&mut self) {\n        self.num_cols = 0;\n        self.num_rows = 0;\n        self.data.clear();\n    }\n    \n    /// Removes the last row from the array and returns it as a `Drain`, or `None` if it is empty.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let v = vec![42u32; 15];\n    /// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n    /// {\n    ///    let drain = toodee.pop_row().unwrap();\n    ///    assert_eq!(drain.len(), 5);\n    /// }\n    /// assert_eq!(toodee.num_cols(), 5);\n    /// assert_eq!(toodee.num_rows(), 2);\n    /// ```\n    pub fn pop_row(&mut self) -> Option<DrainRow<'_, T>> {\n        if self.num_rows == 0 {\n            None\n        } else {\n            Some(self.remove_row(self.num_rows - 1))\n        }\n    }\n    \n    /// Appends a new row to the array.\n    /// \n    /// # Panics\n    /// \n    /// Panics if the data's length doesn't match the length of existing rows (if any).\n    pub fn push_row<I>(&mut self, data: impl IntoIterator<Item=T, IntoIter=I>)\n    where I : Iterator<Item=T> + ExactSizeIterator\n    {\n        self.insert_row(self.num_rows, data);\n    }\n\n    /// Inserts new `data` into the array at the specified `row`\n    /// \n    /// # Panics\n    /// \n    /// Panics if the data's length doesn't match the length of existing rows (if any).\n    pub fn insert_row<I>(&mut self, index: usize, data: impl IntoIterator<Item=T, IntoIter=I>)\n    where I : Iterator<Item=T> + ExactSizeIterator\n    {\n        assert!(index <= self.num_rows);\n        let iter = data.into_iter();\n        if self.num_rows == 0 {\n            self.num_cols = iter.len();\n        } else {\n            assert_eq!(self.num_cols, iter.len());\n        }\n        \n        self.reserve(self.num_cols);\n\n        let start = index * self.num_cols;\n        let len = self.data.len();\n        unsafe {\n            let mut p = self.data.as_mut_ptr().add(start);\n            // shift everything to make space for the new row\n            ptr::copy(p, p.add(self.num_cols), len - start);\n            for e in iter {\n                ptr::write(p, e);\n                p = p.add(1);\n            }\n            self.data.set_len(len + self.num_cols);\n        }\n\n        // update the number of rows\n        self.num_rows += 1;\n\n    }\n\n    /// Removes the specified row from the array and returns it as a `Drain`\n    /// \n    /// # Panics\n    /// \n    /// Panics if the specified row index is out of bounds.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let v = vec![42u32; 15];\n    /// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n    /// {\n    ///    let drain = toodee.remove_row(1);\n    ///    assert_eq!(drain.len(), 5);\n    /// }\n    /// assert_eq!(toodee.num_cols(), 5);\n    /// assert_eq!(toodee.num_rows(), 2);\n    /// ```\n    pub fn remove_row(&mut self, index : usize) -> DrainRow<'_, T>\n    {\n        assert!(index < self.num_rows);\n        let start = index * self.num_cols;\n        let drain = self.data.drain(start..start + self.num_cols);\n        self.num_rows -= 1;\n        if self.num_rows == 0 {\n            self.num_cols = 0;\n        }\n        drain\n    }\n\n    /// Removes the last column from the array and returns it as a `Drain`, or `None` if it is empty.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let v = vec![42u32; 15];\n    /// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n    /// {\n    ///    let drain = toodee.pop_col().unwrap();\n    ///    assert_eq!(drain.len(), 3);\n    /// }\n    /// assert_eq!(toodee.num_cols(), 4);\n    /// assert_eq!(toodee.num_rows(), 3);\n    /// ```\n    pub fn pop_col(&mut self) -> Option<DrainCol<'_, T>> {\n        if self.num_cols == 0 {\n            None\n        } else {\n            Some(self.remove_col(self.num_cols - 1))\n        }\n    }\n    \n    /// Appends a new column to the array.\n    /// \n    /// # Panics\n    /// \n    /// Panics if the data's length doesn't match the length of existing rows (if any).\n    pub fn push_col<I>(&mut self, data: impl IntoIterator<Item=T, IntoIter=I>)\n    where I : Iterator<Item=T> + ExactSizeIterator + DoubleEndedIterator\n    {\n        self.insert_col(self.num_cols, data);\n    }\n\n    /// Removes the specified column from the array and returns it as a `Drain`\n    /// \n    /// # Panics\n    /// \n    /// Panics if the specified column index is out of bounds.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let v = vec![42u32; 15];\n    /// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n    /// {\n    ///    let drain = toodee.remove_col(1);\n    ///    assert_eq!(drain.len(), 3);\n    /// }\n    /// assert_eq!(toodee.num_cols(), 4);\n    /// assert_eq!(toodee.num_rows(), 3);\n    /// ```\n    pub fn remove_col(&mut self, index: usize) -> DrainCol<'_, T>\n    {\n        assert!(index < self.num_cols);\n\n        let v = &mut self.data;\n        let num_cols = self.num_cols;\n        let slice_len = v.len() - num_cols + 1;\n        unsafe {\n            // set the vec length to 0 to amplify any leaks\n            v.set_len(0);\n            DrainCol {\n               iter : Col {\n                   skip : num_cols - 1,\n                   v : slice::from_raw_parts_mut(v.as_mut_ptr().add(index), slice_len),\n               },\n               col : index,\n               toodee : NonNull::from(self),\n            }\n        }\n    }\n\n    /// Inserts new `data` into the array at the specified `col`.\n    /// \n    /// # Panics\n    /// \n    /// Panics if the data's length doesn't match the length of existing columns (if any).\n    pub fn insert_col<I>(&mut self, index: usize, data: impl IntoIterator<Item=T, IntoIter=I>)\n    where I : Iterator<Item=T> + ExactSizeIterator + DoubleEndedIterator\n    {\n        assert!(index <= self.num_cols);\n        let iter = data.into_iter();\n        if self.num_cols == 0 {\n            self.num_rows = iter.len();\n        } else {\n            assert_eq!(self.num_rows, iter.len());\n        }\n        \n        self.reserve(self.num_rows);\n        \n        let old_len = self.data.len();\n        let new_len = old_len + self.num_rows;\n        let suffix_len = self.num_cols - index;\n        unsafe {\n            let p = self.data.as_mut_ptr();\n            let mut read_p = p.add(old_len);\n            let mut write_p = p.add(new_len);\n            for e in iter.rev() {\n                // shift suffix\n                read_p = read_p.sub(suffix_len);\n                write_p = write_p.sub(suffix_len);\n                ptr::copy(read_p, write_p, suffix_len);\n                write_p = write_p.sub(1);\n                // place new col element\n                ptr::write(write_p, e);\n                // shift prefix\n                read_p = read_p.sub(index);\n                write_p = write_p.sub(index);\n                ptr::copy(read_p, write_p, index);\n            }\n            self.data.set_len(new_len);\n        }\n\n        // update the number of columns\n        self.num_cols += 1;\n\n    }\n\n}","impl<T> TooDeeOps<T> for TooDee<T> {\n    \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// assert_eq!(toodee.num_cols(), 10);\n    ///\n    fn num_cols(&self) -> usize {\n        self.num_cols\n    }\n\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// assert_eq!(toodee.num_rows(), 5);\n    ///\n    fn num_rows(&self) -> usize {\n        self.num_rows\n    }\n\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// assert_eq!(toodee.bounds(), ((0, 0), (10, 5)));\n    /// ```\n    fn bounds(&self) -> (Coordinate, Coordinate) {\n        ((0, 0), (self.num_cols, self.num_rows))\n    }\n    \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let view = toodee.view((1,2), (8,4));\n    /// assert_eq!(view.num_cols(), 7);\n    /// assert_eq!(view.num_rows(), 2);\n    /// ```\n    fn view(&self, start: Coordinate, end: Coordinate) -> TooDeeView<'_, T> {\n        TooDeeView::from_toodee(start, end, self)\n    }\n    \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let mut rows = toodee.rows();\n    /// assert_eq!(rows.len(), 5);\n    /// let r0 = rows.next().unwrap();\n    /// assert_eq!(r0.len(), 10);\n    /// ```\n    fn rows(&self) -> Rows<'_, T> {\n        Rows {\n            v : &self.data,\n            cols : self.num_cols,\n            skip_cols : 0,\n        }\n    }\n    \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let mut col = toodee.col(8);\n    /// assert_eq!(col.len(), 5);\n    /// ```\n    fn col(&self, col: usize) -> Col<'_, T> {\n        assert!(col < self.num_cols);\n        unsafe {\n            Col {\n                v : self.data.get_unchecked(col..self.data.len() - self.num_cols + col + 1),\n                skip : self.num_cols - 1,\n            }\n        }\n    }\n\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// unsafe {\n    ///     let toodee : TooDee<u32> = TooDee::new(10, 5);\n    ///     let row = toodee.get_unchecked_row(3);\n    ///     assert_eq!(row.len(), 10);\n    /// }\n    /// ```\n    unsafe fn get_unchecked_row(&self, row: usize) -> &[T] {\n        let start = row * self.num_cols;\n        self.data.get_unchecked(start..start + self.num_cols)\n    }\n\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// unsafe {\n    ///     assert_eq!(*toodee.get_unchecked((1,3)), 0);\n    /// }\n    /// ```\n    unsafe fn get_unchecked(&self, coord: Coordinate) -> &T {\n        self.data.get_unchecked(coord.1 * self.num_cols + coord.0)\n    }\n\n}","impl<T> TooDeeOpsMut<T> for TooDee<T> {\n    \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let view = toodee.view_mut((1,2), (8,4));\n    /// assert_eq!(view.num_cols(), 7);\n    /// assert_eq!(view.num_rows(), 2);\n    /// ```\n    fn view_mut(&mut self, start: Coordinate, end: Coordinate) -> TooDeeViewMut<'_, T> {\n        TooDeeViewMut::from_toodee(start, end, self)\n    }\n    \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let mut rows = toodee.rows_mut();\n    /// assert_eq!(rows.len(), 5);\n    /// let r0 = rows.next().unwrap();\n    /// assert_eq!(r0.len(), 10);\n    /// ```\n    fn rows_mut(&mut self) -> RowsMut<'_, T> {\n        RowsMut {\n            v : &mut self.data,\n            cols : self.num_cols,\n            skip_cols : 0,\n        }\n    }\n    \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let mut col = toodee.col_mut(8);\n    /// assert_eq!(col.len(), 5);\n    /// ```\n    fn col_mut(&mut self, col: usize) -> ColMut<'_, T> {\n        assert!(col < self.num_cols);\n        let dlen = self.data.len();\n        unsafe {\n            ColMut {\n                v : self.data.get_unchecked_mut(col..dlen - self.num_cols + col + 1),\n                skip : self.num_cols - 1,\n            }\n        }\n    }\n    \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// toodee.fill(42);\n    /// assert_eq!(toodee[1][1], 42);\n    /// ```\n    fn fill<V>(&mut self, fill: V)\n    where\n        V: Borrow<T>,\n        T: Clone {\n        let value = fill.borrow();\n        for v in self.data.iter_mut() {\n            v.clone_from(value);\n        }\n    }\n\n    /// Swap/exchange the data between two rows.\n    /// \n    /// # Panics\n    /// \n    /// Panics if either row index is out of bounds.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n    /// toodee[0].iter_mut().for_each(|v| *v = 1);\n    /// assert_eq!(toodee[(0, 2)], 42);\n    /// toodee.swap_rows(0, 2);\n    /// assert_eq!(toodee[(0, 2)], 1);\n    /// ```\n    fn swap_rows(&mut self, mut r1: usize, mut r2: usize) {\n        match r1.cmp(&r2) {\n            Ordering::Less => {},\n            Ordering::Greater => {\n                // force r1 < r2\n                core::mem::swap(&mut r1, &mut r2);\n            },\n            Ordering::Equal => {\n                // swapping a row with itself\n                return;\n            }\n        }\n        assert!(r2 < self.num_rows);\n        let num_cols = self.num_cols;\n        unsafe {\n            let (first, rest) = self.data.get_unchecked_mut(r1 * num_cols..).split_at_mut(num_cols);\n            let snd_idx = (r2 - r1 - 1) * num_cols;\n            let second = rest.get_unchecked_mut(snd_idx..snd_idx + num_cols);\n            // Both slices are guaranteed to have the same length\n            debug_assert_eq!(first.len(), num_cols);\n            debug_assert_eq!(second.len(), num_cols);\n            // We know that the two slices will not overlap because r1 != r2, and we used split_at_mut()\n            ptr::swap_nonoverlapping(first.as_mut_ptr(), second.as_mut_ptr(), num_cols);\n        }\n    }\n    \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// unsafe {\n    ///     let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    ///     let row = toodee.get_unchecked_row_mut(3);\n    ///     assert_eq!(row.len(), 10);\n    /// }\n    /// ```\n    unsafe fn get_unchecked_row_mut(&mut self, row: usize) -> &mut [T] {\n        let start = row * self.num_cols;\n        self.data.get_unchecked_mut(start..start + self.num_cols)\n    }\n\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// unsafe {\n    ///     assert_eq!(*toodee.get_unchecked_mut((1,3)), 0);\n    /// }\n    /// ```\n    unsafe fn get_unchecked_mut(&mut self, coord: Coordinate) -> &mut T {\n        self.data.get_unchecked_mut(coord.1 * self.num_cols + coord.0)\n    }\n\n}"],"view::TooDeeView":["Clone","Copy","Eq","Hash","PartialEq","impl<'a, T> Index<Coordinate> for TooDeeView<'a, T> {\n\n    type Output = T;\n\n    fn index(&self, coord: Coordinate) -> &Self::Output {\n        assert!(coord.1 < self.num_rows);\n        assert!(coord.0 < self.num_cols);\n        // can access the element unchecked because the above assertions hold\n        unsafe {\n            self.data.get_unchecked(coord.1 * self.main_cols + coord.0)\n        }\n    }\n}","impl<'a, T> Index<usize> for TooDeeView<'a, T> {\n\n    type Output = [T];\n\n    fn index(&self, row: usize) -> &Self::Output {\n        assert!(row < self.num_rows);\n        let start = row * self.main_cols;\n        unsafe {\n            self.data.get_unchecked(start..start + self.num_cols)\n        }\n    }\n}","impl<'a, T> TooDeeOps<T> for TooDeeView<'a, T>\n{\n    #[inline]\n    fn num_cols(&self) -> usize {\n        self.num_cols\n    }\n\n    #[inline]\n    fn num_rows(&self) -> usize {\n        self.num_rows\n    }\n    \n    #[inline]\n    fn bounds(&self) -> (Coordinate, Coordinate) {\n        (self.start, (self.start.0 + self.num_cols, self.start.1 + self.num_rows))\n    }\n    \n    fn view(&self, start: Coordinate, end: Coordinate) -> TooDeeView<'_, T> {\n        let (num_cols, num_rows) = calculate_view_dimensions(start, end, self);\n        let data_start = start.1 * self.main_cols + start.0;\n        let data_len = {\n            if num_rows == 0 {\n                0\n            } else {\n                (num_rows - 1) * self.main_cols + num_cols\n            }\n        };\n\n        unsafe {\n            TooDeeView {\n                data: self.data.get_unchecked(data_start..data_start + data_len),\n                start: (self.start.0 + start.0, self.start.1 + start.1),\n                num_cols,\n                num_rows,\n                main_cols : self.main_cols,\n            }\n        }\n    }\n\n    fn rows(&self) -> Rows<'_, T> {\n        Rows {\n            v : &self.data,\n            cols : self.num_cols,\n            skip_cols : self.main_cols - self.num_cols,\n        }\n    }\n    \n    fn col(&self, col: usize) -> Col<'_, T> {\n        assert!(col < self.num_cols);\n        let start = col;\n        let end = {\n            if self.num_rows == 0 {\n                start\n            } else {\n                start + (self.num_rows - 1) * self.main_cols + 1\n            }\n        };\n        unsafe {\n            Col {\n                v : self.data.get_unchecked(start..end),\n                skip : self.main_cols - 1,\n            }\n        }\n    }\n\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// unsafe {\n    ///     let toodee : TooDee<u32> = TooDee::new(10, 5);\n    ///     let view = toodee.view((0,0), (10,5));\n    ///     let row = view.get_unchecked_row(3);\n    ///     assert_eq!(row.len(), 10);\n    /// }\n    /// ```\n    unsafe fn get_unchecked_row(&self, row: usize) -> &[T] {\n        let start = row * self.main_cols;\n        self.data.get_unchecked(start..start + self.num_cols)\n    }\n\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let view = toodee.view((0,0), (10,5));\n    /// unsafe {\n    ///     assert_eq!(*view.get_unchecked((1,3)), 0);\n    /// }\n    /// ```\n    unsafe fn get_unchecked(&self, coord: Coordinate) -> &T {\n        self.data.get_unchecked(coord.1 * self.main_cols + coord.0)\n    }\n\n}","impl<'a, T> TooDeeView<'a, T> {\n\n    /// Create a new `TooDeeViewMut` using the provided slice reference.\n    /// \n    /// # Panics\n    /// \n    /// Panics if one of the dimensions is zero but the other is non-zero. This\n    /// is to enforce the rule that empty arrays have no dimensions.\n    /// \n    /// Panics if the slice's length is not sufficient to represent\n    /// the desired array dimensions.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::TooDeeView;\n    /// let data = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n    /// let view = TooDeeView::new(4, 3, &data);\n    /// ```\n    pub fn new(num_cols: usize, num_rows: usize, data: &'a [T]) -> TooDeeView<'a, T> {\n        if num_cols == 0 || num_rows == 0 {\n            assert_eq!(num_rows, num_cols);\n        }\n        let size = num_cols * num_rows;\n        assert!(size <= data.len());\n        TooDeeView {\n            data : &data[..size],\n            start: (0, 0),\n            num_cols,\n            num_rows,\n            main_cols : num_cols,\n        }\n    }\n    \n    /// Used internally by `TooDee` to create a `TooDeeView`.\n    pub(super) fn from_toodee(start: Coordinate, end: Coordinate, toodee: &'a TooDee<T>) -> TooDeeView<'a, T> {\n        let (num_cols, num_rows) = calculate_view_dimensions(start, end, toodee);\n        let main_cols = toodee.num_cols();\n        let data_start = start.1 * main_cols + start.0;\n        let data_len = {\n            if num_rows == 0 {\n                0\n            } else {\n                (num_rows - 1) * main_cols + num_cols\n            }\n        };\n        unsafe {\n            TooDeeView {\n                data: toodee.data().get_unchecked(data_start..data_start + data_len),\n                start,\n                num_cols,\n                num_rows,\n                main_cols,\n            }\n        }\n    }\n\n}","impl<T> Debug for TooDeeView<'_, T> where T : Debug {\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.rows()).finish()\n    }\n}"],"view::TooDeeViewMut":["Eq","Hash","PartialEq","impl<'a, T> Index<Coordinate> for TooDeeViewMut<'a, T> {\n    type Output = T;\n    fn index(&self, coord: Coordinate) -> &Self::Output {\n        assert!(coord.1 < self.num_rows);\n        assert!(coord.0 < self.num_cols);\n        // can access the element unchecked because the above assertions hold\n        unsafe {\n            self.data.get_unchecked(coord.1 * self.main_cols + coord.0)\n        }\n    }\n}","impl<'a, T> Index<usize> for TooDeeViewMut<'a, T> {\n    type Output = [T];\n    fn index(&self, row: usize) -> &Self::Output {\n        assert!(row < self.num_rows);\n        let start = row * self.main_cols;\n        unsafe {\n            &self.data.get_unchecked(start..start + self.num_cols)\n        }\n    }\n}","impl<'a, T> IndexMut<Coordinate> for TooDeeViewMut<'a, T> {\n    fn index_mut(&mut self, coord: Coordinate) -> &mut Self::Output {\n        assert!(coord.1 < self.num_rows);\n        assert!(coord.0 < self.num_cols);\n        // can access the element unchecked because the above assertions hold\n        unsafe {\n            self.data.get_unchecked_mut(coord.1 * self.main_cols + coord.0)\n        }\n    }\n}","impl<'a, T> IndexMut<usize> for TooDeeViewMut<'a, T> {\n    fn index_mut(&mut self, row: usize) -> &mut Self::Output {\n        assert!(row < self.num_rows);\n        let start = row * self.main_cols;\n        unsafe {\n            self.data.get_unchecked_mut(start..start + self.num_cols)\n        }\n    }\n}","impl<'a, T> Into<TooDeeView<'a, T>> for TooDeeViewMut<'a, T> {\n    fn into(self) -> TooDeeView<'a, T> {\n        TooDeeView {\n            data:      self.data,\n            start:     self.start,\n            num_cols:  self.num_cols,\n            num_rows:  self.num_rows,\n            main_cols: self.main_cols,\n        }\n    }\n}","impl<'a, T> TooDeeOps<T> for TooDeeViewMut<'a,T> {\n\n    #[inline]\n    fn num_rows(&self) -> usize {\n        self.num_rows\n    }\n\n    #[inline]\n    fn num_cols(&self) -> usize {\n        self.num_cols\n    }\n\n    #[inline]\n    fn bounds(&self) -> (Coordinate, Coordinate) {\n        (self.start, (self.start.0 + self.num_cols, self.start.1 + self.num_rows))\n    }\n    \n    fn view(&self, start: Coordinate, end: Coordinate) -> TooDeeView<'_, T> {\n        let (num_cols, num_rows) = calculate_view_dimensions(start, end, self);\n        let data_start = start.1 * self.main_cols + start.0;\n        let data_len = {\n            if num_rows == 0 {\n                0\n            } else {\n                (num_rows - 1) * self.main_cols + num_cols\n            }\n        };\n        \n        TooDeeView {\n            data: &self.data[data_start..data_start + data_len],\n            start: (self.start.0 + start.0, self.start.1 + start.1),\n            num_cols,\n            num_rows,\n            main_cols : self.main_cols,\n        }\n    }\n\n    fn rows(&self) -> Rows<'_, T> {\n        Rows {\n            v : &self.data,\n            cols : self.num_cols,\n            skip_cols : self.main_cols - self.num_cols,\n        }\n    }\n\n    fn col(&self, col: usize) -> Col<'_, T> {\n        assert!(col < self.num_cols);\n        let start = col;\n        let end = {\n            if self.num_rows == 0 {\n                start\n            } else {\n                start + (self.num_rows - 1) * self.main_cols + 1\n            }\n        };\n        unsafe {\n            Col {\n                v : self.data.get_unchecked(start..end),\n                skip : self.main_cols - 1,\n            }\n        }\n    }\n\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// unsafe {\n    ///     let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    ///     let mut view = toodee.view_mut((0,0), (10,5));\n    ///     let row = view.get_unchecked_row(3);\n    ///     assert_eq!(row.len(), 10);\n    /// }\n    /// ```\n    unsafe fn get_unchecked_row(&self, row: usize) -> &[T] {\n        let start = row * self.main_cols;\n        self.data.get_unchecked(start..start + self.num_cols)\n    }\n    \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let mut view = toodee.view_mut((0,0), (10,5));\n    /// unsafe {\n    ///     assert_eq!(*view.get_unchecked((1,3)), 0);\n    /// }\n    /// ```\n    unsafe fn get_unchecked(&self, coord: Coordinate) -> &T {\n        self.data.get_unchecked(coord.1 * self.main_cols + coord.0)\n    }\n\n}","impl<'a, T> TooDeeOpsMut<T> for TooDeeViewMut<'a,T> {\n\n    fn view_mut(&mut self, start: Coordinate, end: Coordinate) -> TooDeeViewMut<'_, T> {\n        let (num_cols, num_rows) = calculate_view_dimensions(start, end, self);\n\n        let data_start = start.1 * self.main_cols + start.0;\n        let data_len = {\n            if num_rows == 0 {\n                0\n            } else {\n                (num_rows - 1) * self.main_cols + num_cols\n            }\n        };\n\n        unsafe {\n            TooDeeViewMut {\n                data: self.data.get_unchecked_mut(data_start..data_start + data_len),\n                start: (self.start.0 + start.0, self.start.1 + start.1),\n                num_cols,\n                num_rows,\n                main_cols : self.main_cols,\n            }\n        }\n    }\n    \n    fn rows_mut(&mut self) -> RowsMut<'_, T> {\n        RowsMut {\n            v : &mut self.data,\n            cols : self.num_cols,\n            skip_cols : self.main_cols - self.num_cols,\n        }\n    }\n\n    fn col_mut(&mut self, col: usize) -> ColMut<'_, T> {\n        assert!(col < self.num_cols);\n        let start = col;\n        let end = {\n            if self.num_rows == 0 {\n                start\n            } else {\n                start + (self.num_rows - 1) * self.main_cols + 1\n            }\n        };\n        unsafe {\n            ColMut {\n                v : self.data.get_unchecked_mut(start..end),\n                skip : self.main_cols - 1,\n            }\n        }\n    }\n\n    /// Swap/exchange the data between two rows.\n    /// \n    /// # Panics\n    /// \n    /// Panics if either row index is out of bounds.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n    /// toodee[0].iter_mut().for_each(|v| *v = 1);\n    /// assert_eq!(toodee[(0, 2)], 42);\n    /// toodee.swap_rows(0, 2);\n    /// assert_eq!(toodee[(0, 2)], 1);\n    /// ```\n    fn swap_rows(&mut self, mut r1: usize, mut r2: usize) {\n        match r1.cmp(&r2) {\n            Ordering::Less => {},\n            Ordering::Greater => {\n                // force r1 < r2\n                core::mem::swap(&mut r1, &mut r2);\n            },\n            Ordering::Equal => {\n                // swapping a row with itself\n                return;\n            }\n        }\n        assert!(r2 < self.num_rows);\n        let num_cols = self.num_cols;\n        unsafe {\n            let (first, rest) = self.data.get_unchecked_mut(r1 * self.main_cols..).split_at_mut(num_cols);\n            let snd_idx = (r2 - r1) * self.main_cols - num_cols;\n            let second = rest.get_unchecked_mut(snd_idx..snd_idx + num_cols);\n            // Both slices are guaranteed to have the same length\n            debug_assert_eq!(first.len(), num_cols);\n            debug_assert_eq!(second.len(), num_cols);\n            // We know that the two slices will not overlap because r1 != r2, and we used split_at_mut()\n            ptr::swap_nonoverlapping(first.as_mut_ptr(), second.as_mut_ptr(), num_cols);\n        }\n    }\n\n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// unsafe {\n    ///     let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    ///     let mut view = toodee.view_mut((0,0), (10,5));\n    ///     let row = view.get_unchecked_row_mut(3);\n    ///     assert_eq!(row.len(), 10);\n    /// }\n    /// ```\n    unsafe fn get_unchecked_row_mut(&mut self, row: usize) -> &mut [T] {\n        let start = row * self.main_cols;\n        self.data.get_unchecked_mut(start..start + self.num_cols)\n    }\n\n    \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let mut view = toodee.view_mut((0,0), (10,5));\n    /// unsafe {\n    ///     assert_eq!(*view.get_unchecked_mut((1,3)), 0);\n    /// }\n    /// ```\n    unsafe fn get_unchecked_mut(&mut self, coord: Coordinate) -> &mut T {\n        self.data.get_unchecked_mut(coord.1 * self.main_cols + coord.0)\n    }\n\n}","impl<'a, T> TooDeeViewMut<'a, T> {\n\n    /// Create a new `TooDeeViewMut` using the provided mutable slice reference.\n    /// \n    /// # Panics\n    /// \n    /// Panics if one of the dimensions is zero but the other is non-zero. This\n    /// is to enforce the rule that empty arrays have no dimensions.\n    /// \n    /// Panics if the slice's length is not sufficient to represent\n    /// the desired array dimensions.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::TooDeeViewMut;\n    /// let mut data = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n    /// let view_mut = TooDeeViewMut::new(4, 3, &mut data);\n    /// ```\n    pub fn new(num_cols: usize, num_rows: usize, data: &'a mut [T]) -> TooDeeViewMut<'a, T> {\n        if num_cols == 0 || num_rows == 0 {\n            assert_eq!(num_rows, num_cols);\n        }\n        let size = num_cols * num_rows;\n        assert!(size <= data.len());\n        unsafe {\n            TooDeeViewMut {\n                data : data.get_unchecked_mut(..size),\n                start: (0, 0),\n                num_cols,\n                num_rows,\n                main_cols : num_cols,\n            }\n        }\n    }\n\n    /// Used internally by `TooDee` to create a `TooDeeViewMut`.\n    pub(super) fn from_toodee(start: Coordinate, end: Coordinate, toodee: &'a mut TooDee<T>) -> TooDeeViewMut<'a, T> {\n        let (num_cols, num_rows) = calculate_view_dimensions(start, end, toodee);\n        let main_cols = toodee.num_cols();\n        let data_start = start.1 * main_cols + start.0;\n        let data_len = {\n            if num_rows == 0 {\n                0\n            } else {\n                (num_rows - 1) * main_cols + num_cols\n            }\n        };\n        unsafe {\n            TooDeeViewMut {\n                data: toodee.data_mut().get_unchecked_mut(data_start..data_start + data_len),\n                start,\n                num_cols,\n                num_rows,\n                main_cols,\n            }\n        }\n    }\n\n}","impl<T> CopyOps<T> for TooDeeViewMut<'_, T> {}","impl<T> Debug for TooDeeViewMut<'_, T> where T : Debug {\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.rows()).finish()\n    }\n}"]},"single_path_import":{},"srcs":{"<&'a mut toodee::TooDee<T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.cells_mut()\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<&'a mut view::TooDeeViewMut<'a, T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.cells_mut()\n    }","Real(LocalPath(\"src/view.rs\"))"],"<&'a toodee::TooDee<T> as std::iter::IntoIterator>::into_iter":["/// `Cells` is the preferred iterator type here, because it implements `TooDeeIterator`\nfn into_iter(self) -> Self::IntoIter{\n        self.cells()\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<&'a view::TooDeeView<'a, T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.cells()\n    }","Real(LocalPath(\"src/view.rs\"))"],"<&'a view::TooDeeViewMut<'a, T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.cells()\n    }","Real(LocalPath(\"src/view.rs\"))"],"<<toodee::DrainCol<'_, T> as std::ops::Drop>::drop::DropGuard<'r, 'a, T> as std::ops::Drop>::drop":["fn drop(&mut self){\n\n                self.0.for_each(drop);\n                \n                let col = self.0.col;\n\n                unsafe {\n                    \n                    let toodee = self.0.toodee.as_mut();\n\n                    let vec = &mut toodee.data;\n\n                    let mut dest = vec.as_mut_ptr().add(col);\n                    let mut src = dest.add(1);\n                    let orig_cols = toodee.num_cols;\n                    let new_cols = orig_cols - 1;\n                    \n                    let num_rows = toodee.num_rows;\n                    \n                    for _ in 1..num_rows {\n                        ptr::copy(src, dest, new_cols);\n                        src = src.add(orig_cols);\n                        dest = dest.add(new_cols);\n                    }\n                    \n                    ptr::copy(src, dest, orig_cols - col);\n                    \n                    toodee.num_cols -= 1;\n                    if toodee.num_cols == 0 {\n                        toodee.num_rows = 0;\n                    }\n\n                    // Set the new length based on the col/row counts\n                    vec.set_len(toodee.num_cols * toodee.num_rows);\n                }\n                \n            }","Real(LocalPath(\"src/toodee.rs\"))"],"<flattenexact::FlattenExact<I> as iter::TooDeeIterator>::num_cols":["fn num_cols(&self) -> usize{\n        self.iter.num_cols()\n    }","Real(LocalPath(\"src/flattenexact.rs\"))"],"<flattenexact::FlattenExact<I> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<<I::Item as IntoIterator>::Item>{\n        loop {\n            if let Some(ref mut inner) = self.backiter {\n                if let elt @ Some(_) = inner.next_back() {\n                    return elt;\n                }\n            }\n            match self.iter.next_back() {\n                None => return self.frontiter.as_mut()?.next_back(),\n                Some(next) => self.backiter = Some(next.into_iter()),\n            }\n        }\n    }","Real(LocalPath(\"src/flattenexact.rs\"))"],"<flattenexact::FlattenExact<I> as std::iter::DoubleEndedIterator>::nth_back":["#[inline]\nfn nth_back(&mut self, mut n: usize) -> Option<<I::Item as IntoIterator>::Item>{\n        \n        let num_cols = self.num_cols();\n        \n        if num_cols == 0 {\n            return None;\n        }\n        \n        if let Some(ref mut inner) = self.backiter {\n            if n < inner.len() {\n                return inner.nth_back(n);\n            } else {\n                n -= inner.len();\n                self.backiter = None;\n            }\n        }\n        \n        let iter_skip = self.iter.len().min(n / num_cols);\n        if let Some(inner) = self.iter.nth_back(iter_skip) {\n            let mut tmp = inner.into_iter();\n            n -= iter_skip * num_cols;\n            debug_assert!(n < tmp.len());\n            let ret_val = tmp.nth_back(n);\n            self.backiter = Some(tmp);\n            ret_val\n        } else {\n            n -= iter_skip * num_cols;\n            self.frontiter.as_mut()?.nth_back(n)\n        }\n        \n    }","Real(LocalPath(\"src/flattenexact.rs\"))"],"<flattenexact::FlattenExact<I> as std::iter::DoubleEndedIterator>::rfold":["#[inline]\nfn rfold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,{\n        #[inline]\n        fn flatten<U: DoubleEndedIterator, Acc>(\n            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n        ) -> impl FnMut(Acc, U) -> Acc + '_ {\n            move |acc, iter| iter.rfold(acc, &mut *fold)\n        }\n\n        self.frontiter\n            .into_iter()\n            .chain(self.iter.map(IntoIterator::into_iter))\n            .chain(self.backiter)\n            .rfold(init, flatten(fold))\n    }","Real(LocalPath(\"src/flattenexact.rs\"))"],"<flattenexact::FlattenExact<I> as std::iter::DoubleEndedIterator>::rfold::flatten":["#[inline]\nfn flatten<U: DoubleEndedIterator, Acc>(\n            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n        ) -> impl FnMut(Acc, U) -> Acc + '_{\n            move |acc, iter| iter.rfold(acc, &mut *fold)\n        }","Real(LocalPath(\"src/flattenexact.rs\"))"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::fold":["#[inline]\nfn fold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,{\n        #[inline]\n        fn flatten<U: Iterator, Acc>(\n            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n        ) -> impl FnMut(Acc, U) -> Acc + '_ {\n            move |acc, iter| iter.fold(acc, &mut *fold)\n        }\n\n        self.frontiter\n            .into_iter()\n            .chain(self.iter.map(IntoIterator::into_iter))\n            .chain(self.backiter)\n            .fold(init, flatten(fold))\n    }","Real(LocalPath(\"src/flattenexact.rs\"))"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::fold::flatten":["#[inline]\nfn flatten<U: Iterator, Acc>(\n            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n        ) -> impl FnMut(Acc, U) -> Acc + '_{\n            move |acc, iter| iter.fold(acc, &mut *fold)\n        }","Real(LocalPath(\"src/flattenexact.rs\"))"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::last":["#[inline]\nfn last(mut self) -> Option<Self::Item>{\n        self.next_back()\n    }","Real(LocalPath(\"src/flattenexact.rs\"))"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<<I::Item as IntoIterator>::Item>{\n        loop {\n            if let Some(ref mut inner) = self.frontiter {\n                if let elt @ Some(_) = inner.next() {\n                    return elt;\n                }\n            }\n            match self.iter.next() {\n                None => return self.backiter.as_mut()?.next(),\n                Some(inner) => self.frontiter = Some(inner.into_iter()),\n            }\n        }\n    }","Real(LocalPath(\"src/flattenexact.rs\"))"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::nth":["#[inline]\nfn nth(&mut self, mut n: usize) -> Option<<I::Item as IntoIterator>::Item>{\n        \n        let num_cols = self.num_cols();\n        \n        if num_cols == 0 {\n            return None;\n        }\n        \n        if let Some(ref mut inner) = self.frontiter {\n            if n < inner.len() {\n                return inner.nth(n);\n            } else {\n                n -= inner.len();\n                self.frontiter = None;\n            }\n        }\n        \n        let iter_skip = self.iter.len().min(n / num_cols);\n        if let Some(inner) = self.iter.nth(iter_skip) {\n            let mut tmp = inner.into_iter();\n            n -= iter_skip * num_cols;\n            debug_assert!(n < tmp.len());\n            let ret_val = tmp.nth(n);\n            self.frontiter = Some(tmp);\n            ret_val\n        } else {\n            n -= iter_skip * num_cols;\n            self.backiter.as_mut()?.nth(n)\n        }\n        \n    }","Real(LocalPath(\"src/flattenexact.rs\"))"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        let mut len = self.num_cols() * self.iter.len();\n        len += self.frontiter.as_ref().map_or(0, |i| i.len());\n        len += self.backiter.as_ref().map_or(0, |i| i.len());\n        (len, Some(len))\n    }","Real(LocalPath(\"src/flattenexact.rs\"))"],"<iter::Col<'a, T> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n        if let Some((last, fst)) = self.v.split_last() {\n            if fst.is_empty() {\n                self.v = &[];\n            } else {\n                // fst must contain at least one row, so we don't need a bounds check\n                unsafe {\n                    self.v = &fst.get_unchecked(..fst.len() - self.skip);\n                }\n            }\n            Some(last)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Col<'a, T> as std::iter::DoubleEndedIterator>::nth_back":["#[inline]\nfn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n        let (adj, overflow) = n.overflowing_mul(1 + self.skip);\n        if adj >= self.v.len() || overflow {\n            self.v = &[];\n        } else {\n            // adj < self.v.len(), so no check required\n            unsafe {\n                self.v = self.v.get_unchecked(..self.v.len() - adj);\n            }\n        }\n        self.next_back()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Col<'a, T> as std::iter::Iterator>::count":["#[inline]\nfn count(self) -> usize{\n        self.len()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Col<'a, T> as std::iter::Iterator>::last":["#[inline]\nfn last(mut self) -> Option<Self::Item>{\n        self.next_back()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Col<'a, T> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        if let Some((fst, snd)) = self.v.split_first() {\n            if snd.is_empty() {\n                self.v = &[];\n            } else {\n                // snd must contain at least one row, so we don't need a bounds check\n                unsafe {\n                    self.v = &snd.get_unchecked(self.skip..);\n                }\n            }\n            Some(fst)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Col<'a, T> as std::iter::Iterator>::nth":["#[inline]\nfn nth(&mut self, n: usize) -> Option<Self::Item>{\n        \n        let (start, overflow) = n.overflowing_mul(1 + self.skip);\n        if start >= self.v.len() || overflow {\n            self.v = &[];\n        } else {\n            let (_, snd) = self.v.split_at(start);\n            self.v = snd;\n        }\n        self.next()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Col<'a, T> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        let len = self.v.len();\n        let denom = 1 + self.skip;\n        let n = len / denom + (len % denom);\n        (n, Some(n))\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Col<'a, T> as std::ops::Index<usize>>::index":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let col = toodee.col(2);\n/// assert_eq!(col[3], 0);\n/// ```\nfn index(&self, idx: usize) -> &Self::Output{\n        let pos = idx * (1 + self.skip);\n        &self.v[pos]\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::ColMut<'a, T> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n        let tmp = mem::replace(&mut self.v, &mut []);\n        if let Some((last, fst)) = tmp.split_last_mut() {\n            if fst.is_empty() {\n                self.v = &mut [];\n            } else {\n                let new_len = fst.len() - self.skip;\n                // skip <= fst.len(), so no check required\n                unsafe {\n                    self.v = fst.get_unchecked_mut(..new_len);\n                }\n            }\n            Some(last)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::ColMut<'a, T> as std::iter::DoubleEndedIterator>::nth_back":["#[inline]\nfn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n\n        let (adj, overflow) = n.overflowing_mul(1 + self.skip);\n        if adj >= self.v.len() || overflow {\n            self.v = &mut [];\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            // adj <= self.v.len(), so no check required\n            unsafe {\n                self.v = tmp.get_unchecked_mut(..self.v.len() - adj);\n            }\n        }\n        self.next_back()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::ColMut<'a, T> as std::iter::Iterator>::count":["#[inline]\nfn count(self) -> usize{\n        self.len()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::ColMut<'a, T> as std::iter::Iterator>::last":["#[inline]\nfn last(mut self) -> Option<Self::Item>{\n        self.next_back()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::ColMut<'a, T> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        let tmp = mem::replace(&mut self.v, &mut []);\n        if let Some((fst, snd)) = tmp.split_first_mut() {\n            if snd.is_empty() {\n                self.v = &mut [];\n            } else {\n                // snd must contain at least one row, so no check required\n                unsafe {\n                    self.v = snd.get_unchecked_mut(self.skip..);\n                }\n            }\n            Some(fst)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::ColMut<'a, T> as std::iter::Iterator>::nth":["#[inline]\nfn nth(&mut self, n: usize) -> Option<Self::Item>{\n        let (start, overflow) = n.overflowing_mul(1 + self.skip);\n        if start >= self.v.len() || overflow {\n            self.v = &mut [];\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (_, snd) = tmp.split_at_mut(start);\n            self.v = snd;\n        }\n        self.next()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::ColMut<'a, T> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        let len = self.v.len();\n        let denom = 1 + self.skip;\n        let n = len / denom + (len % denom);\n        (n, Some(n))\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::ColMut<'a, T> as std::ops::Index<usize>>::index":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let col = toodee.col_mut(2);\n/// assert_eq!(col[3], 0);\n/// ```\nfn index(&self, idx: usize) -> &Self::Output{\n        let pos = idx * (1 + self.skip);\n        &self.v[pos]\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::ColMut<'a, T> as std::ops::IndexMut<usize>>::index_mut":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let mut col = toodee.col_mut(2);\n/// col[3] = 42;\n/// ```\nfn index_mut(&mut self, idx: usize) -> &mut Self::Output{\n        let pos = idx * (1 + self.skip);\n        &mut self.v[pos]\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Rows<'_, T> as iter::TooDeeIterator>::num_cols":["fn num_cols(&self) -> usize{\n        self.cols\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Rows<'a, T> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n        if self.v.is_empty() {\n            None\n        } else {\n            let (fst, snd) = self.v.split_at(self.v.len() - self.cols);\n            if fst.is_empty() {\n                self.v = &[];\n            } else {\n                // skip_cols will be <= fst.len(), so no check required\n                unsafe {\n                    self.v = fst.get_unchecked(..fst.len() - self.skip_cols);\n                }\n            }\n            Some(&snd)\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Rows<'a, T> as std::iter::DoubleEndedIterator>::nth_back":["#[inline]\nfn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n        let (adj, overflow) = n.overflowing_mul(self.cols + self.skip_cols);\n        if adj >= self.v.len() || overflow {\n            self.v = &[];\n        } else {\n            // adj < fst.len(), so no check required\n            unsafe {\n                self.v = self.v.get_unchecked(..self.v.len() - adj);\n            }\n        }\n        self.next_back()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Rows<'a, T> as std::iter::Iterator>::count":["#[inline]\nfn count(self) -> usize{\n        self.len()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Rows<'a, T> as std::iter::Iterator>::last":["#[inline]\nfn last(mut self) -> Option<Self::Item>{\n        self.next_back()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Rows<'a, T> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        if self.v.is_empty() {\n            None\n        } else {\n            let (fst, snd) = self.v.split_at(self.cols);\n            if snd.is_empty() {\n                self.v = &[];\n            } else {\n                // snd must contain at least one row, so no check required\n                unsafe {\n                    self.v = snd.get_unchecked(self.skip_cols..);\n                }\n            }\n            Some(fst)\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Rows<'a, T> as std::iter::Iterator>::nth":["#[inline]\nfn nth(&mut self, n: usize) -> Option<Self::Item>{\n        \n        let (start, overflow) = n.overflowing_mul(self.cols + self.skip_cols);\n        if start >= self.v.len() || overflow {\n            self.v = &[];\n        } else {\n            let (_, snd) = self.v.split_at(start);\n            self.v = snd;\n        }\n        self.next()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::Rows<'a, T> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        if self.cols == 0 {\n            return (0, Some(0));\n        }\n        let len = self.v.len();\n        let denom = self.cols + self.skip_cols;\n        let n = len / denom + (len % denom) / self.cols;\n        (n, Some(n))\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::RowsMut<'_, T> as iter::TooDeeIterator>::num_cols":["fn num_cols(&self) -> usize{\n        self.cols\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::RowsMut<'a, T> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n        if self.v.is_empty() {\n            None\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let tmp_len = tmp.len();\n            let (fst, snd) = tmp.split_at_mut(tmp_len - self.cols);\n            if fst.is_empty() {\n                self.v = &mut [];\n            } else {\n                // fst must contain at least one row, so no check required\n                unsafe {\n                    self.v = fst.get_unchecked_mut(..tmp_len - self.cols - self.skip_cols);\n                }\n            }\n            Some(snd)\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::RowsMut<'a, T> as std::iter::DoubleEndedIterator>::nth_back":["#[inline]\nfn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n\n        let (adj, overflow) = n.overflowing_mul(self.cols + self.skip_cols);\n        if adj >= self.v.len() || overflow {\n            self.v = &mut [];\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            // adj < self.v.len(), so no check required\n            unsafe {\n                self.v = tmp.get_unchecked_mut(..self.v.len() - adj);\n            }\n        }\n        self.next_back()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::count":["#[inline]\nfn count(self) -> usize{\n        self.len()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::last":["#[inline]\nfn last(mut self) -> Option<Self::Item>{\n        self.next_back()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        if self.v.is_empty() {\n            None\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (head, tail) = tmp.split_at_mut(self.cols);\n            if tail.is_empty() {\n                self.v = &mut [];\n            } else {\n                // tail must contain at least one row, so no check required\n                unsafe {\n                    self.v = tail.get_unchecked_mut(self.skip_cols..);\n                }\n            }\n            Some(head)\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::nth":["#[inline]\nfn nth(&mut self, n: usize) -> Option<Self::Item>{\n        let (start, overflow) = n.overflowing_mul(self.cols + self.skip_cols);\n        if start >= self.v.len() || overflow {\n            self.v = &mut [];\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (_, snd) = tmp.split_at_mut(start);\n            self.v = snd;\n        }\n        self.next()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        if self.cols == 0 {\n            return (0, Some(0));\n        }\n        let len = self.v.len();\n        let denom = self.cols + self.skip_cols;\n        let n = len / denom + (len % denom) / self.cols;\n        (n, Some(n))\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<toodee::DrainCol<'_, T> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<T>{\n        self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::DrainCol<'_, T> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<T>{\n        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::DrainCol<'_, T> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::DrainCol<'_, T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        /// Continues dropping the remaining elements in the `DrainCol`, then repositions the\n        /// un-`Drain`ed elements to restore the original `TooDee`.\n        struct DropGuard<'r, 'a, T>(&'r mut DrainCol<'a, T>);\n\n        impl<'r, 'a, T> Drop for DropGuard<'r, 'a, T> {\n            fn drop(&mut self) {\n\n                self.0.for_each(drop);\n                \n                let col = self.0.col;\n\n                unsafe {\n                    \n                    let toodee = self.0.toodee.as_mut();\n\n                    let vec = &mut toodee.data;\n\n                    let mut dest = vec.as_mut_ptr().add(col);\n                    let mut src = dest.add(1);\n                    let orig_cols = toodee.num_cols;\n                    let new_cols = orig_cols - 1;\n                    \n                    let num_rows = toodee.num_rows;\n                    \n                    for _ in 1..num_rows {\n                        ptr::copy(src, dest, new_cols);\n                        src = src.add(orig_cols);\n                        dest = dest.add(new_cols);\n                    }\n                    \n                    ptr::copy(src, dest, orig_cols - col);\n                    \n                    toodee.num_cols -= 1;\n                    if toodee.num_cols == 0 {\n                        toodee.num_rows = 0;\n                    }\n\n                    // Set the new length based on the col/row counts\n                    vec.set_len(toodee.num_cols * toodee.num_rows);\n                }\n                \n            }\n        }\n\n        // exhaust self first\n        while let Some(item) = self.next() {\n            let guard = DropGuard(self);\n            drop(item);\n            mem::forget(guard);\n        }\n\n        // Drop a `DropGuard` to move back the non-drained tail of `self`.\n        DropGuard(self);\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::DrainCol<'_, T> as std::ops::Drop>::drop::DropGuard":["/// Continues dropping the remaining elements in the `DrainCol`, then repositions the\n/// un-`Drain`ed elements to restore the original `TooDee`.\nstruct DropGuard<'r, 'a, T>(&'r mut DrainCol<'a, T>);","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as copy::CopyOps<T>>::clone_from_slice":["fn clone_from_slice(&mut self, src: &[T]) where T: Clone{\n        self.data_mut().clone_from_slice(src);\n    }","Real(LocalPath(\"src/copy.rs\"))"],"<toodee::TooDee<T> as copy::CopyOps<T>>::clone_from_toodee":["fn clone_from_toodee(&mut self, src: &impl TooDeeOps<T>) where T : Clone{\n        assert_eq!(self.size(), src.size());\n        let num_cols = self.num_cols();\n        let mut v = self.data_mut();\n        for r in src.rows() {\n            let (fst, snd) = v.split_at_mut(num_cols);\n            fst.clone_from_slice(r);\n            v = snd;\n        }\n    }","Real(LocalPath(\"src/copy.rs\"))"],"<toodee::TooDee<T> as copy::CopyOps<T>>::copy_from_slice":["fn copy_from_slice(&mut self, src: &[T]) where T: Copy{\n        self.data_mut().copy_from_slice(src);\n    }","Real(LocalPath(\"src/copy.rs\"))"],"<toodee::TooDee<T> as copy::CopyOps<T>>::copy_from_toodee":["fn copy_from_toodee(&mut self, src: &impl TooDeeOps<T>) where T : Copy{\n        assert_eq!(self.size(), src.size());\n        let num_cols = self.num_cols();\n        let mut v = self.data_mut();\n        for r in src.rows() {\n            let (fst, snd) = v.split_at_mut(num_cols);\n            fst.copy_from_slice(r);\n            v = snd;\n        }\n    }","Real(LocalPath(\"src/copy.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::bounds":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let toodee : TooDee<u32> = TooDee::new(10, 5);\n/// assert_eq!(toodee.bounds(), ((0, 0), (10, 5)));\n/// ```\nfn bounds(&self) -> (Coordinate, Coordinate){\n        ((0, 0), (self.num_cols, self.num_rows))\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::col":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let mut col = toodee.col(8);\n/// assert_eq!(col.len(), 5);\n/// ```\nfn col(&self, col: usize) -> Col<'_, T>{\n        assert!(col < self.num_cols);\n        unsafe {\n            Col {\n                v : self.data.get_unchecked(col..self.data.len() - self.num_cols + col + 1),\n                skip : self.num_cols - 1,\n            }\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::get_unchecked":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let toodee : TooDee<u32> = TooDee::new(10, 5);\n/// unsafe {\n///     assert_eq!(*toodee.get_unchecked((1,3)), 0);\n/// }\n/// ```\nunsafe fn get_unchecked(&self, coord: Coordinate) -> &T{\n        self.data.get_unchecked(coord.1 * self.num_cols + coord.0)\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::get_unchecked_row":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// unsafe {\n///     let toodee : TooDee<u32> = TooDee::new(10, 5);\n///     let row = toodee.get_unchecked_row(3);\n///     assert_eq!(row.len(), 10);\n/// }\n/// ```\nunsafe fn get_unchecked_row(&self, row: usize) -> &[T]{\n        let start = row * self.num_cols;\n        self.data.get_unchecked(start..start + self.num_cols)\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::num_cols":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let toodee : TooDee<u32> = TooDee::new(10, 5);\n/// assert_eq!(toodee.num_cols(), 10);\n///\nfn num_cols(&self) -> usize{\n        self.num_cols\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::num_rows":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let toodee : TooDee<u32> = TooDee::new(10, 5);\n/// assert_eq!(toodee.num_rows(), 5);\n///\nfn num_rows(&self) -> usize{\n        self.num_rows\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::rows":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let mut rows = toodee.rows();\n/// assert_eq!(rows.len(), 5);\n/// let r0 = rows.next().unwrap();\n/// assert_eq!(r0.len(), 10);\n/// ```\nfn rows(&self) -> Rows<'_, T>{\n        Rows {\n            v : &self.data,\n            cols : self.num_cols,\n            skip_cols : 0,\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::view":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let view = toodee.view((1,2), (8,4));\n/// assert_eq!(view.num_cols(), 7);\n/// assert_eq!(view.num_rows(), 2);\n/// ```\nfn view(&self, start: Coordinate, end: Coordinate) -> TooDeeView<'_, T>{\n        TooDeeView::from_toodee(start, end, self)\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::col_mut":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let mut col = toodee.col_mut(8);\n/// assert_eq!(col.len(), 5);\n/// ```\nfn col_mut(&mut self, col: usize) -> ColMut<'_, T>{\n        assert!(col < self.num_cols);\n        let dlen = self.data.len();\n        unsafe {\n            ColMut {\n                v : self.data.get_unchecked_mut(col..dlen - self.num_cols + col + 1),\n                skip : self.num_cols - 1,\n            }\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::fill":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// toodee.fill(42);\n/// assert_eq!(toodee[1][1], 42);\n/// ```\nfn fill<V>(&mut self, fill: V)\n    where\n        V: Borrow<T>,\n        T: Clone{\n        let value = fill.borrow();\n        for v in self.data.iter_mut() {\n            v.clone_from(value);\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::get_unchecked_mut":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// unsafe {\n///     assert_eq!(*toodee.get_unchecked_mut((1,3)), 0);\n/// }\n/// ```\nunsafe fn get_unchecked_mut(&mut self, coord: Coordinate) -> &mut T{\n        self.data.get_unchecked_mut(coord.1 * self.num_cols + coord.0)\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::get_unchecked_row_mut":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// unsafe {\n///     let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n///     let row = toodee.get_unchecked_row_mut(3);\n///     assert_eq!(row.len(), 10);\n/// }\n/// ```\nunsafe fn get_unchecked_row_mut(&mut self, row: usize) -> &mut [T]{\n        let start = row * self.num_cols;\n        self.data.get_unchecked_mut(start..start + self.num_cols)\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::rows_mut":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let mut rows = toodee.rows_mut();\n/// assert_eq!(rows.len(), 5);\n/// let r0 = rows.next().unwrap();\n/// assert_eq!(r0.len(), 10);\n/// ```\nfn rows_mut(&mut self) -> RowsMut<'_, T>{\n        RowsMut {\n            v : &mut self.data,\n            cols : self.num_cols,\n            skip_cols : 0,\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::swap_rows":["/// Swap/exchange the data between two rows.\n/// \n/// # Panics\n/// \n/// Panics if either row index is out of bounds.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n/// toodee[0].iter_mut().for_each(|v| *v = 1);\n/// assert_eq!(toodee[(0, 2)], 42);\n/// toodee.swap_rows(0, 2);\n/// assert_eq!(toodee[(0, 2)], 1);\n/// ```\nfn swap_rows(&mut self, mut r1: usize, mut r2: usize){\n        match r1.cmp(&r2) {\n            Ordering::Less => {},\n            Ordering::Greater => {\n                // force r1 < r2\n                core::mem::swap(&mut r1, &mut r2);\n            },\n            Ordering::Equal => {\n                // swapping a row with itself\n                return;\n            }\n        }\n        assert!(r2 < self.num_rows);\n        let num_cols = self.num_cols;\n        unsafe {\n            let (first, rest) = self.data.get_unchecked_mut(r1 * num_cols..).split_at_mut(num_cols);\n            let snd_idx = (r2 - r1 - 1) * num_cols;\n            let second = rest.get_unchecked_mut(snd_idx..snd_idx + num_cols);\n            // Both slices are guaranteed to have the same length\n            debug_assert_eq!(first.len(), num_cols);\n            debug_assert_eq!(second.len(), num_cols);\n            // We know that the two slices will not overlap because r1 != r2, and we used split_at_mut()\n            ptr::swap_nonoverlapping(first.as_mut_ptr(), second.as_mut_ptr(), num_cols);\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::view_mut":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let view = toodee.view_mut((1,2), (8,4));\n/// assert_eq!(view.num_cols(), 7);\n/// assert_eq!(view.num_rows(), 2);\n/// ```\nfn view_mut(&mut self, start: Coordinate, end: Coordinate) -> TooDeeViewMut<'_, T>{\n        TooDeeViewMut::from_toodee(start, end, self)\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::convert::AsMut<[T]>>::as_mut":["fn as_mut(&mut self) -> &mut [T]{\n        &mut self.data\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::convert::AsRef<[T]>>::as_ref":["fn as_ref(&self) -> &[T]{\n        &self.data\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::convert::AsRef<std::vec::Vec<T>>>::as_ref":["fn as_ref(&self) -> &Vec<T>{\n        &self.data\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::convert::From<view::TooDeeView<'_, T>>>::from":["fn from(view: TooDeeView<'_, T>) -> Self{\n        let num_cols = view.num_cols();\n        let num_rows = view.num_rows();\n        let mut v = Vec::with_capacity(num_cols * num_rows);\n        for r in view.rows() {\n            v.extend_from_slice(r);\n        }\n        TooDee {\n            data : v,\n            num_cols,\n            num_rows,\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::convert::From<view::TooDeeViewMut<'_, T>>>::from":["fn from(view: TooDeeViewMut<'_, T>) -> Self{\n        let num_cols = view.num_cols();\n        let num_rows = view.num_rows();\n        let mut v = Vec::with_capacity(num_cols * num_rows);\n        for r in view.rows() {\n            v.extend_from_slice(r);\n        }\n        TooDee {\n            data : v,\n            num_cols,\n            num_rows,\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::convert::Into<std::boxed::Box<[T]>>>::into":["fn into(self) -> Box<[T]>{\n        self.data.into_boxed_slice()\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::convert::Into<std::vec::Vec<T>>>::into":["fn into(self) -> Vec<T>{\n        self.data\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::default::Default>::default":["/// # Examples\n/// \n/// ```\n/// use toodee::TooDee;\n/// struct Abc { }\n/// let toodee : TooDee<Abc> = TooDee::default();\n/// ```\nfn default() -> Self{\n        TooDee {\n            data : Vec::default(),\n            num_rows : 0,\n            num_cols : 0,\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.rows()).finish()\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.data.into_iter()\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::ops::Index<(usize, usize)>>::index":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let toodee : TooDee<u32> = TooDee::new(10, 5);\n/// assert_eq!(toodee[(1,3)], 0);\n/// ```\nfn index(&self, coord: Coordinate) -> &Self::Output{\n        assert!(coord.1 < self.num_rows);\n        assert!(coord.0 < self.num_cols);\n        // can access the element unchecked because the above assertions hold\n        unsafe {\n            self.data.get_unchecked(coord.1 * self.num_cols + coord.0)\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::ops::Index<usize>>::index":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let row = &toodee[3];\n/// assert_eq!(row.len(), 10);\n/// ```\nfn index(&self, row: usize) -> &Self::Output{\n        assert!(row < self.num_rows);\n        let start = row * self.num_cols;\n        // can access the element unchecked because the above assertion holds\n        unsafe {\n            self.data.get_unchecked(start..start + self.num_cols)\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::ops::IndexMut<(usize, usize)>>::index_mut":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let toodee : TooDee<u32> = TooDee::new(10, 5);\n/// assert_eq!(toodee[(1,3)], 0);\n/// ```\nfn index_mut(&mut self, coord: Coordinate) -> &mut Self::Output{\n        assert!(coord.1 < self.num_rows);\n        assert!(coord.0 < self.num_cols);\n        // can access the element unchecked because the above assertions hold\n        unsafe {\n            self.data.get_unchecked_mut(coord.1 * self.num_cols + coord.0)\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<toodee::TooDee<T> as std::ops::IndexMut<usize>>::index_mut":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let mut row = &mut toodee[3];\n/// row[0] = 42;\n/// ```\nfn index_mut(&mut self, row: usize) -> &mut Self::Output{\n        assert!(row < self.num_rows);\n        let start = row * self.num_cols;\n        // can access the element unchecked because the above assertion holds\n        unsafe {\n            self.data.get_unchecked_mut(start..start + self.num_cols)\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"<view::TooDeeView<'_, T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.rows()).finish()\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::bounds":["#[inline]\nfn bounds(&self) -> (Coordinate, Coordinate){\n        (self.start, (self.start.0 + self.num_cols, self.start.1 + self.num_rows))\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::col":["fn col(&self, col: usize) -> Col<'_, T>{\n        assert!(col < self.num_cols);\n        let start = col;\n        let end = {\n            if self.num_rows == 0 {\n                start\n            } else {\n                start + (self.num_rows - 1) * self.main_cols + 1\n            }\n        };\n        unsafe {\n            Col {\n                v : self.data.get_unchecked(start..end),\n                skip : self.main_cols - 1,\n            }\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::get_unchecked":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let view = toodee.view((0,0), (10,5));\n/// unsafe {\n///     assert_eq!(*view.get_unchecked((1,3)), 0);\n/// }\n/// ```\nunsafe fn get_unchecked(&self, coord: Coordinate) -> &T{\n        self.data.get_unchecked(coord.1 * self.main_cols + coord.0)\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::get_unchecked_row":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// unsafe {\n///     let toodee : TooDee<u32> = TooDee::new(10, 5);\n///     let view = toodee.view((0,0), (10,5));\n///     let row = view.get_unchecked_row(3);\n///     assert_eq!(row.len(), 10);\n/// }\n/// ```\nunsafe fn get_unchecked_row(&self, row: usize) -> &[T]{\n        let start = row * self.main_cols;\n        self.data.get_unchecked(start..start + self.num_cols)\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::num_cols":["#[inline]\nfn num_cols(&self) -> usize{\n        self.num_cols\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::num_rows":["#[inline]\nfn num_rows(&self) -> usize{\n        self.num_rows\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::rows":["fn rows(&self) -> Rows<'_, T>{\n        Rows {\n            v : &self.data,\n            cols : self.num_cols,\n            skip_cols : self.main_cols - self.num_cols,\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::view":["fn view(&self, start: Coordinate, end: Coordinate) -> TooDeeView<'_, T>{\n        let (num_cols, num_rows) = calculate_view_dimensions(start, end, self);\n        let data_start = start.1 * self.main_cols + start.0;\n        let data_len = {\n            if num_rows == 0 {\n                0\n            } else {\n                (num_rows - 1) * self.main_cols + num_cols\n            }\n        };\n\n        unsafe {\n            TooDeeView {\n                data: self.data.get_unchecked(data_start..data_start + data_len),\n                start: (self.start.0 + start.0, self.start.1 + start.1),\n                num_cols,\n                num_rows,\n                main_cols : self.main_cols,\n            }\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeView<'a, T> as std::ops::Index<(usize, usize)>>::index":["fn index(&self, coord: Coordinate) -> &Self::Output{\n        assert!(coord.1 < self.num_rows);\n        assert!(coord.0 < self.num_cols);\n        // can access the element unchecked because the above assertions hold\n        unsafe {\n            self.data.get_unchecked(coord.1 * self.main_cols + coord.0)\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeView<'a, T> as std::ops::Index<usize>>::index":["fn index(&self, row: usize) -> &Self::Output{\n        assert!(row < self.num_rows);\n        let start = row * self.main_cols;\n        unsafe {\n            self.data.get_unchecked(start..start + self.num_cols)\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'_, T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.rows()).finish()\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::bounds":["#[inline]\nfn bounds(&self) -> (Coordinate, Coordinate){\n        (self.start, (self.start.0 + self.num_cols, self.start.1 + self.num_rows))\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::col":["fn col(&self, col: usize) -> Col<'_, T>{\n        assert!(col < self.num_cols);\n        let start = col;\n        let end = {\n            if self.num_rows == 0 {\n                start\n            } else {\n                start + (self.num_rows - 1) * self.main_cols + 1\n            }\n        };\n        unsafe {\n            Col {\n                v : self.data.get_unchecked(start..end),\n                skip : self.main_cols - 1,\n            }\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::get_unchecked":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let mut view = toodee.view_mut((0,0), (10,5));\n/// unsafe {\n///     assert_eq!(*view.get_unchecked((1,3)), 0);\n/// }\n/// ```\nunsafe fn get_unchecked(&self, coord: Coordinate) -> &T{\n        self.data.get_unchecked(coord.1 * self.main_cols + coord.0)\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::get_unchecked_row":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// unsafe {\n///     let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n///     let mut view = toodee.view_mut((0,0), (10,5));\n///     let row = view.get_unchecked_row(3);\n///     assert_eq!(row.len(), 10);\n/// }\n/// ```\nunsafe fn get_unchecked_row(&self, row: usize) -> &[T]{\n        let start = row * self.main_cols;\n        self.data.get_unchecked(start..start + self.num_cols)\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::num_cols":["#[inline]\nfn num_cols(&self) -> usize{\n        self.num_cols\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::num_rows":["#[inline]\nfn num_rows(&self) -> usize{\n        self.num_rows\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::rows":["fn rows(&self) -> Rows<'_, T>{\n        Rows {\n            v : &self.data,\n            cols : self.num_cols,\n            skip_cols : self.main_cols - self.num_cols,\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::view":["fn view(&self, start: Coordinate, end: Coordinate) -> TooDeeView<'_, T>{\n        let (num_cols, num_rows) = calculate_view_dimensions(start, end, self);\n        let data_start = start.1 * self.main_cols + start.0;\n        let data_len = {\n            if num_rows == 0 {\n                0\n            } else {\n                (num_rows - 1) * self.main_cols + num_cols\n            }\n        };\n        \n        TooDeeView {\n            data: &self.data[data_start..data_start + data_len],\n            start: (self.start.0 + start.0, self.start.1 + start.1),\n            num_cols,\n            num_rows,\n            main_cols : self.main_cols,\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::col_mut":["fn col_mut(&mut self, col: usize) -> ColMut<'_, T>{\n        assert!(col < self.num_cols);\n        let start = col;\n        let end = {\n            if self.num_rows == 0 {\n                start\n            } else {\n                start + (self.num_rows - 1) * self.main_cols + 1\n            }\n        };\n        unsafe {\n            ColMut {\n                v : self.data.get_unchecked_mut(start..end),\n                skip : self.main_cols - 1,\n            }\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::get_unchecked_mut":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// let mut view = toodee.view_mut((0,0), (10,5));\n/// unsafe {\n///     assert_eq!(*view.get_unchecked_mut((1,3)), 0);\n/// }\n/// ```\nunsafe fn get_unchecked_mut(&mut self, coord: Coordinate) -> &mut T{\n        self.data.get_unchecked_mut(coord.1 * self.main_cols + coord.0)\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::get_unchecked_row_mut":["/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// unsafe {\n///     let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n///     let mut view = toodee.view_mut((0,0), (10,5));\n///     let row = view.get_unchecked_row_mut(3);\n///     assert_eq!(row.len(), 10);\n/// }\n/// ```\nunsafe fn get_unchecked_row_mut(&mut self, row: usize) -> &mut [T]{\n        let start = row * self.main_cols;\n        self.data.get_unchecked_mut(start..start + self.num_cols)\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::rows_mut":["fn rows_mut(&mut self) -> RowsMut<'_, T>{\n        RowsMut {\n            v : &mut self.data,\n            cols : self.num_cols,\n            skip_cols : self.main_cols - self.num_cols,\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::swap_rows":["/// Swap/exchange the data between two rows.\n/// \n/// # Panics\n/// \n/// Panics if either row index is out of bounds.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n/// toodee[0].iter_mut().for_each(|v| *v = 1);\n/// assert_eq!(toodee[(0, 2)], 42);\n/// toodee.swap_rows(0, 2);\n/// assert_eq!(toodee[(0, 2)], 1);\n/// ```\nfn swap_rows(&mut self, mut r1: usize, mut r2: usize){\n        match r1.cmp(&r2) {\n            Ordering::Less => {},\n            Ordering::Greater => {\n                // force r1 < r2\n                core::mem::swap(&mut r1, &mut r2);\n            },\n            Ordering::Equal => {\n                // swapping a row with itself\n                return;\n            }\n        }\n        assert!(r2 < self.num_rows);\n        let num_cols = self.num_cols;\n        unsafe {\n            let (first, rest) = self.data.get_unchecked_mut(r1 * self.main_cols..).split_at_mut(num_cols);\n            let snd_idx = (r2 - r1) * self.main_cols - num_cols;\n            let second = rest.get_unchecked_mut(snd_idx..snd_idx + num_cols);\n            // Both slices are guaranteed to have the same length\n            debug_assert_eq!(first.len(), num_cols);\n            debug_assert_eq!(second.len(), num_cols);\n            // We know that the two slices will not overlap because r1 != r2, and we used split_at_mut()\n            ptr::swap_nonoverlapping(first.as_mut_ptr(), second.as_mut_ptr(), num_cols);\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::view_mut":["fn view_mut(&mut self, start: Coordinate, end: Coordinate) -> TooDeeViewMut<'_, T>{\n        let (num_cols, num_rows) = calculate_view_dimensions(start, end, self);\n\n        let data_start = start.1 * self.main_cols + start.0;\n        let data_len = {\n            if num_rows == 0 {\n                0\n            } else {\n                (num_rows - 1) * self.main_cols + num_cols\n            }\n        };\n\n        unsafe {\n            TooDeeViewMut {\n                data: self.data.get_unchecked_mut(data_start..data_start + data_len),\n                start: (self.start.0 + start.0, self.start.1 + start.1),\n                num_cols,\n                num_rows,\n                main_cols : self.main_cols,\n            }\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as std::convert::Into<view::TooDeeView<'a, T>>>::into":["fn into(self) -> TooDeeView<'a, T>{\n        TooDeeView {\n            data:      self.data,\n            start:     self.start,\n            num_cols:  self.num_cols,\n            num_rows:  self.num_rows,\n            main_cols: self.main_cols,\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as std::ops::Index<(usize, usize)>>::index":["fn index(&self, coord: Coordinate) -> &Self::Output{\n        assert!(coord.1 < self.num_rows);\n        assert!(coord.0 < self.num_cols);\n        // can access the element unchecked because the above assertions hold\n        unsafe {\n            self.data.get_unchecked(coord.1 * self.main_cols + coord.0)\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as std::ops::Index<usize>>::index":["fn index(&self, row: usize) -> &Self::Output{\n        assert!(row < self.num_rows);\n        let start = row * self.main_cols;\n        unsafe {\n            &self.data.get_unchecked(start..start + self.num_cols)\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as std::ops::IndexMut<(usize, usize)>>::index_mut":["fn index_mut(&mut self, coord: Coordinate) -> &mut Self::Output{\n        assert!(coord.1 < self.num_rows);\n        assert!(coord.0 < self.num_cols);\n        // can access the element unchecked because the above assertions hold\n        unsafe {\n            self.data.get_unchecked_mut(coord.1 * self.main_cols + coord.0)\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"<view::TooDeeViewMut<'a, T> as std::ops::IndexMut<usize>>::index_mut":["fn index_mut(&mut self, row: usize) -> &mut Self::Output{\n        assert!(row < self.num_rows);\n        let start = row * self.main_cols;\n        unsafe {\n            self.data.get_unchecked_mut(start..start + self.num_cols)\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"copy::CopyOps":["/// Provides basic copying operations for `TooDee` structures.\npub trait CopyOps<T> : TooDeeOpsMut<T> {\n\n    /// Copies data from another slice into this area. The source slice's length\n    /// must match the size of this object's area. Data is copied row by row.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut,CopyOps};\n    /// let ascending = vec![0, 1, 2, 3, 4];\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// toodee.view_mut((5, 1), (10, 2)).copy_from_slice(&ascending);\n    /// ```\n    fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n        let cols = self.num_cols();\n        assert_eq!(cols * self.num_rows(), src.len());\n        for (d, s) in self.rows_mut().zip(src.chunks_exact(cols)) {\n            d.copy_from_slice(s)\n        }\n    }\n    \n    /// Clones data from another slice into this area. The source slice's length\n    /// must match the size of this object's area. Data is cloned row by row.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut,CopyOps};\n    /// let ascending = vec![0, 1, 2, 3, 4];\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// toodee.view_mut((5, 1), (10, 2)).clone_from_slice(&ascending);\n    /// ```\n    fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n        let cols = self.num_cols();\n        assert_eq!(cols * self.num_rows(), src.len());\n        for (d, s) in self.rows_mut().zip(src.chunks_exact(cols)) {\n            d.clone_from_slice(s)\n        }\n    }\n    \n    /// Copies data from another `TooDeeOps` object into this one. The source and\n    /// destination dimensions must match.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut,CopyOps};\n    /// let ascending = TooDee::from_vec(5, 1, vec![0, 1, 2, 3, 4]);\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// toodee.view_mut((5, 1), (10, 2)).copy_from_toodee(&ascending);\n    /// ```\n    fn copy_from_toodee(&mut self, src: &impl TooDeeOps<T>) where T : Copy {\n        assert_eq!(self.size(), src.size());\n        // Data is copied row by row.\n        for (d, s) in self.rows_mut().zip(src.rows()) {\n            d.copy_from_slice(s);\n        }\n    }\n\n    /// Copies data from another `TooDeeOps` object into this one. The source and\n    /// destination dimensions must match.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut,CopyOps};\n    /// let ascending = TooDee::from_vec(5, 1, vec![0, 1, 2, 3, 4]);\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// toodee.view_mut((5, 1), (10, 2)).clone_from_toodee(&ascending);\n    /// ```\n    fn clone_from_toodee(&mut self, src: &impl TooDeeOps<T>) where T : Clone {\n        assert_eq!(self.size(), src.size());\n        // Data is copied row by row.\n        for (d, s) in self.rows_mut().zip(src.rows()) {\n            d.clone_from_slice(s);\n        }\n    }\n\n    /// Copies the `src` area (top-left to bottom-right) to a destination area. `dest` specifies\n    /// the top-left position of destination area. The `src` area will be partially overwritten\n    /// if the regions overlap.\n    /// \n    /// # Panics\n    /// \n    /// Panics if:\n    /// - `src` dimensions are outside the array's bounds\n    /// - there's insufficient room to copy all of `src` to `dest`\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut,CopyOps};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// toodee.view_mut((0, 0), (5, 1)).fill(42);\n    /// assert_eq!(toodee[(3,1)], 0);\n    /// toodee.copy_within(((0, 0), (5, 1)), (0, 1));\n    /// assert_eq!(toodee[(3,1)], 42);\n    /// ```\n    fn copy_within(&mut self, src: (Coordinate, Coordinate), dest: Coordinate)\n    where T : Copy {\n        let (top_left, bottom_right) = src;\n        assert!(top_left.0 <= bottom_right.0);\n        assert!(top_left.1 <= bottom_right.1);\n        let num_cols = self.num_cols();\n        let num_rows = self.num_rows();\n        assert!(bottom_right.0 <= num_cols);\n        assert!(bottom_right.1 <= num_rows);\n        let cols = bottom_right.0 - top_left.0;\n        let rows = bottom_right.1 - top_left.1;\n        assert!(dest.0 + cols <= num_cols);\n        assert!(dest.1 + rows <= num_rows);\n        // Ensure that we don't copy over src before copying it to dest.\n        match top_left.1.cmp(&dest.1) {\n            Ordering::Less => {\n                let row_offset = dest.1 - top_left.1;\n                for r in (top_left.1..bottom_right.1).rev() {\n                    let (s, d) = self.row_pair_mut(r, r + row_offset);\n                    d[dest.0..dest.0 + cols].copy_from_slice(&s[top_left.0..bottom_right.0]);\n                }\n            },\n            Ordering::Greater => {\n                let row_offset = top_left.1 - dest.1;\n                for r in top_left.1..bottom_right.1 {\n                    let (s, d) = self.row_pair_mut(r, r - row_offset);\n                    d[dest.0..dest.0 + cols].copy_from_slice(&s[top_left.0..bottom_right.0]);\n                }\n            },\n            Ordering::Equal => {\n                for r in top_left.1..bottom_right.1 {\n                    let row_data = &mut self[r];\n                    row_data.copy_within(top_left.0..bottom_right.0, dest.0);\n                }\n            },\n        }\n    }\n    \n}","Real(LocalPath(\"src/copy.rs\"))"],"copy::CopyOps::clone_from_slice":["/// Clones data from another slice into this area. The source slice's length\n/// must match the size of this object's area. Data is cloned row by row.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut,CopyOps};\n/// let ascending = vec![0, 1, 2, 3, 4];\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// toodee.view_mut((5, 1), (10, 2)).clone_from_slice(&ascending);\n/// ```\nfn clone_from_slice(&mut self, src: &[T]) where T: Clone{\n        let cols = self.num_cols();\n        assert_eq!(cols * self.num_rows(), src.len());\n        for (d, s) in self.rows_mut().zip(src.chunks_exact(cols)) {\n            d.clone_from_slice(s)\n        }\n    }","Real(LocalPath(\"src/copy.rs\"))"],"copy::CopyOps::clone_from_toodee":["/// Copies data from another `TooDeeOps` object into this one. The source and\n/// destination dimensions must match.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut,CopyOps};\n/// let ascending = TooDee::from_vec(5, 1, vec![0, 1, 2, 3, 4]);\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// toodee.view_mut((5, 1), (10, 2)).clone_from_toodee(&ascending);\n/// ```\nfn clone_from_toodee(&mut self, src: &impl TooDeeOps<T>) where T : Clone{\n        assert_eq!(self.size(), src.size());\n        // Data is copied row by row.\n        for (d, s) in self.rows_mut().zip(src.rows()) {\n            d.clone_from_slice(s);\n        }\n    }","Real(LocalPath(\"src/copy.rs\"))"],"copy::CopyOps::copy_from_slice":["/// Copies data from another slice into this area. The source slice's length\n/// must match the size of this object's area. Data is copied row by row.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut,CopyOps};\n/// let ascending = vec![0, 1, 2, 3, 4];\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// toodee.view_mut((5, 1), (10, 2)).copy_from_slice(&ascending);\n/// ```\nfn copy_from_slice(&mut self, src: &[T]) where T: Copy{\n        let cols = self.num_cols();\n        assert_eq!(cols * self.num_rows(), src.len());\n        for (d, s) in self.rows_mut().zip(src.chunks_exact(cols)) {\n            d.copy_from_slice(s)\n        }\n    }","Real(LocalPath(\"src/copy.rs\"))"],"copy::CopyOps::copy_from_toodee":["/// Copies data from another `TooDeeOps` object into this one. The source and\n/// destination dimensions must match.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut,CopyOps};\n/// let ascending = TooDee::from_vec(5, 1, vec![0, 1, 2, 3, 4]);\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// toodee.view_mut((5, 1), (10, 2)).copy_from_toodee(&ascending);\n/// ```\nfn copy_from_toodee(&mut self, src: &impl TooDeeOps<T>) where T : Copy{\n        assert_eq!(self.size(), src.size());\n        // Data is copied row by row.\n        for (d, s) in self.rows_mut().zip(src.rows()) {\n            d.copy_from_slice(s);\n        }\n    }","Real(LocalPath(\"src/copy.rs\"))"],"copy::CopyOps::copy_within":["/// Copies the `src` area (top-left to bottom-right) to a destination area. `dest` specifies\n/// the top-left position of destination area. The `src` area will be partially overwritten\n/// if the regions overlap.\n/// \n/// # Panics\n/// \n/// Panics if:\n/// - `src` dimensions are outside the array's bounds\n/// - there's insufficient room to copy all of `src` to `dest`\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut,CopyOps};\n/// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n/// toodee.view_mut((0, 0), (5, 1)).fill(42);\n/// assert_eq!(toodee[(3,1)], 0);\n/// toodee.copy_within(((0, 0), (5, 1)), (0, 1));\n/// assert_eq!(toodee[(3,1)], 42);\n/// ```\nfn copy_within(&mut self, src: (Coordinate, Coordinate), dest: Coordinate)\n    where T : Copy{\n        let (top_left, bottom_right) = src;\n        assert!(top_left.0 <= bottom_right.0);\n        assert!(top_left.1 <= bottom_right.1);\n        let num_cols = self.num_cols();\n        let num_rows = self.num_rows();\n        assert!(bottom_right.0 <= num_cols);\n        assert!(bottom_right.1 <= num_rows);\n        let cols = bottom_right.0 - top_left.0;\n        let rows = bottom_right.1 - top_left.1;\n        assert!(dest.0 + cols <= num_cols);\n        assert!(dest.1 + rows <= num_rows);\n        // Ensure that we don't copy over src before copying it to dest.\n        match top_left.1.cmp(&dest.1) {\n            Ordering::Less => {\n                let row_offset = dest.1 - top_left.1;\n                for r in (top_left.1..bottom_right.1).rev() {\n                    let (s, d) = self.row_pair_mut(r, r + row_offset);\n                    d[dest.0..dest.0 + cols].copy_from_slice(&s[top_left.0..bottom_right.0]);\n                }\n            },\n            Ordering::Greater => {\n                let row_offset = top_left.1 - dest.1;\n                for r in top_left.1..bottom_right.1 {\n                    let (s, d) = self.row_pair_mut(r, r - row_offset);\n                    d[dest.0..dest.0 + cols].copy_from_slice(&s[top_left.0..bottom_right.0]);\n                }\n            },\n            Ordering::Equal => {\n                for r in top_left.1..bottom_right.1 {\n                    let row_data = &mut self[r];\n                    row_data.copy_within(top_left.0..bottom_right.0, dest.0);\n                }\n            },\n        }\n    }","Real(LocalPath(\"src/copy.rs\"))"],"flattenexact::FlattenExact":["/// An iterator that behaves like `core::iter::adapters::Flatten` but has the added advantage of implementing\n/// `ExactSizeIterator` (we know how many cells there are per row in a `TooDee` array).\npub struct FlattenExact<I>\nwhere\n    I : ExactSizeIterator + DoubleEndedIterator + TooDeeIterator,\n    I::Item : IntoIterator,\n    <I::Item as IntoIterator>::IntoIter : DoubleEndedIterator + ExactSizeIterator,\n{\n    iter: I,\n    frontiter: Option<<I::Item as IntoIterator>::IntoIter>,\n    backiter: Option<<I::Item as IntoIterator>::IntoIter>,\n}","Real(LocalPath(\"src/flattenexact.rs\"))"],"flattenexact::FlattenExact::<I>::new":["pub(super) fn new(iter: I) -> FlattenExact<I>{\n        FlattenExact { iter, frontiter: None, backiter: None }\n    }","Real(LocalPath(\"src/flattenexact.rs\"))"],"iter::Col":["/// An iterator over a single column.\npub struct Col<'a, T> {\n    pub(super) v: &'a [T],\n    pub(super) skip: usize,\n}","Real(LocalPath(\"src/iter.rs\"))"],"iter::ColMut":["/// A mutable iterator over a single column.\npub struct ColMut<'a, T> {\n    pub(super) v: &'a mut [T],\n    pub(super) skip: usize,\n}","Real(LocalPath(\"src/iter.rs\"))"],"iter::Rows":["/// An `Iterator` over each row of a `TooDee[View]`, where each row is represented as a slice.\npub struct Rows<'a, T> {\n    /// This reference contains row data at each end. When iterating in either direction the row will\n    /// be pulled off the end then `skip_cols` elements will be skipped in preparation for reading the\n    /// next row.\n    pub(super) v: &'a [T],\n    pub(super) cols: usize,\n    pub(super) skip_cols: usize,\n}","Real(LocalPath(\"src/iter.rs\"))"],"iter::RowsMut":["/// A mutable Iterator over each row of a `TooDee[ViewMut]`, where each row is represented as a slice.\npub struct RowsMut<'a, T> {\n    /// This reference contains row data at each end. When iterating in either direction the row will\n    /// be pulled off the end then `skip_cols` elements will be skipped in preparation for reading the\n    /// next row.\n    pub(super) v: &'a mut [T],\n    pub(super) cols: usize,\n    pub(super) skip_cols: usize,\n}","Real(LocalPath(\"src/iter.rs\"))"],"iter::TooDeeIterator":["/// An `Iterator` that knows how many columns it emits per row.\npub trait TooDeeIterator : Iterator {\n    /// The number of columns the iterator emits per row\n    fn num_cols(&self) -> usize;\n}","Real(LocalPath(\"src/iter.rs\"))"],"ops::TooDeeOps":["/// Defines operations common to both `TooDee` and `TooDeeView`. Default implementations are provided\n/// where possible/practical.\npub trait TooDeeOps<T> : Index<usize, Output=[T]> + Index<Coordinate, Output=T> {\n    \n    /// The number of columns in the area represented by this object.\n    fn num_cols(&self) -> usize;\n    /// The number of rows in the area represented by this object.\n    fn num_rows(&self) -> usize;\n    \n    /// Returns the size/dimensions of the current object.\n    fn size(&self) -> (usize, usize) {\n        (self.num_cols(), self.num_rows())\n    }\n\n    /// Returns `true` if the array contains no elements.\n    fn is_empty(&self) -> bool {\n        self.num_cols() == 0 || self.num_rows() == 0\n    }\n\n    /// Returns the bounds of the object's area within the original `TooDee` area (views\n    /// are not nested for now).\n    fn bounds(&self) -> (Coordinate, Coordinate);\n    \n    /// Returns a view (or subset) of the current area based on the coordinates provided.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let view = toodee.view((1, 1), (9, 4));\n    /// assert_eq!(view.num_cols(), 8);\n    /// assert_eq!(view.num_rows(), 3);\n    /// ```\n    fn view(&self, start: Coordinate, end: Coordinate) -> TooDeeView<'_, T>;\n    \n    /// Returns an iterator of slices, where each slice represents an entire row.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n    /// let mut sum = 0u32;\n    /// for r in toodee.rows() {\n    ///     sum += r.iter().sum::<u32>();\n    /// }\n    /// assert_eq!(sum, 42*50);\n    /// ```\n    fn rows(&self) -> Rows<'_, T>;\n    \n    /// Returns an iterator over a single column. Note that the `Col` iterator is indexable.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n    /// let mut sum = 0u32;\n    /// for c in toodee.col(1) {\n    ///     sum += c;\n    /// }\n    /// assert_eq!(sum, 42*5);\n    /// ```\n    fn col(&self, col: usize) -> Col<'_, T>;\n\n    /// Returns an iterator that traverses all cells within the area.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps};\n    /// let toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n    /// let mut sum = toodee.cells().sum::<u32>();\n    /// assert_eq!(sum, 42*50);\n    /// ```\n    fn cells(&self) -> Cells<'_, T> {\n        FlattenExact::new(self.rows())\n    }\n    \n    /// Returns a row without checking that the row is valid. Generally it's best to use indexing instead, e.g., toodee[row]\n    /// \n    /// # Safety\n    /// \n    /// This is generally not recommended, use with caution!\n    /// Calling this method with an invalid row is *[undefined behavior]* even if the resulting reference is not used.\n    unsafe fn get_unchecked_row(&self, row: usize) -> &[T];\n\n    /// Returns a cell without checking that the cell coordinate is valid. Generally it's best to use indexing instead, e.g., toodee[(col, row)]\n    /// \n    /// # Safety\n    /// \n    /// This is generally not recommended, use with caution!\n    /// Calling this method with an invalid coordinate is *[undefined behavior]* even if the resulting reference is not used.\n    unsafe fn get_unchecked(&self, coord: Coordinate) -> &T;\n\n}","Real(LocalPath(\"src/ops.rs\"))"],"ops::TooDeeOps::cells":["/// Returns an iterator that traverses all cells within the area.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n/// let mut sum = toodee.cells().sum::<u32>();\n/// assert_eq!(sum, 42*50);\n/// ```\nfn cells(&self) -> Cells<'_, T>{\n        FlattenExact::new(self.rows())\n    }","Real(LocalPath(\"src/ops.rs\"))"],"ops::TooDeeOps::is_empty":["/// Returns `true` if the array contains no elements.\nfn is_empty(&self) -> bool{\n        self.num_cols() == 0 || self.num_rows() == 0\n    }","Real(LocalPath(\"src/ops.rs\"))"],"ops::TooDeeOps::size":["/// Returns the size/dimensions of the current object.\nfn size(&self) -> (usize, usize){\n        (self.num_cols(), self.num_rows())\n    }","Real(LocalPath(\"src/ops.rs\"))"],"ops::TooDeeOpsMut":["/// Defines operations common to both `TooDee` and `TooDeeViewMut`. Default implementations\n/// are provided where possible/practical.\npub trait TooDeeOpsMut<T> : TooDeeOps<T> + IndexMut<usize,Output=[T]>  + IndexMut<Coordinate, Output=T> {\n\n    /// Returns a mutable view (or subset) of the current area based on the coordinates provided.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::new(10, 5);\n    /// let view = toodee.view_mut((1, 1), (9, 4));\n    /// assert_eq!(view.num_cols(), 8);\n    /// assert_eq!(view.num_rows(), 3);\n    /// ```\n    fn view_mut(&mut self, start: Coordinate, end: Coordinate) -> TooDeeViewMut<'_, T>;\n    \n    /// Returns a mutable iterator of slices, where each slice represents an entire row.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n    /// for (i, r) in toodee.rows_mut().enumerate() {\n    ///    r.iter_mut().for_each(|c| *c -= i as u32);\n    /// }\n    /// assert_eq!(toodee.cells().sum::<u32>(), 42*50 - 10 - 20 - 30 - 40);\n    /// ```\n    fn rows_mut(&mut self) -> RowsMut<'_, T>;\n    \n    /// Returns a mutable iterator over a single column. Note that the `ColMut` iterator is indexable.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n    /// for c in toodee.col_mut(4) {\n    ///     *c /= 2;\n    /// }\n    /// assert_eq!(toodee.cells().sum::<u32>(), 42*45 + 21*5);\n    /// ```\n    fn col_mut(&mut self, col: usize) -> ColMut<'_, T>;\n    \n    /// Returns an iterator that traverses all cells within the area.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n    /// for c in toodee.cells_mut() {\n    ///     *c -= 1;\n    /// }\n    /// assert_eq!(toodee.cells().sum::<u32>(), 41*50);\n    /// ```\n    fn cells_mut(&mut self) -> CellsMut<'_, T> {\n        FlattenExact::new(self.rows_mut())\n    }\n    \n    /// Fills the entire area with the specified value.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n    /// let mut view = toodee.view_mut((1, 1), (9, 4));\n    /// view.fill(0);\n    /// assert_eq!(toodee.cells().sum::<u32>(), 42*(50 - 8*3));\n    /// ```\n    fn fill<V>(&mut self, fill: V)\n    where\n        V: Borrow<T>,\n        T: Clone {\n        let value = fill.borrow();\n        for r in self.rows_mut() {\n            for v in r {\n                v.clone_from(value);\n            }\n        }\n    }\n    \n    /// Swap/exchange the data between two columns.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n    /// for c in toodee.col_mut(2) {\n    ///     *c = 1;\n    /// }\n    /// assert_eq!(toodee[(4, 0)], 42);\n    /// toodee.swap_cols(2, 4);\n    /// assert_eq!(toodee[(4, 0)], 1);\n    /// ```\n    fn swap_cols(&mut self, c1: usize, c2: usize) {\n        let num_cols = self.num_cols();\n        assert!(c1 < num_cols);\n        assert!(c2 < num_cols);\n        for r in self.rows_mut() {\n            // The column indices have been checked with asserts (see above), so we can\n            // safely access and swap the elements using `get_unchecked_mut`.\n            unsafe {\n                let pa: *mut T = r.get_unchecked_mut(c1);\n                let pb: *mut T = r.get_unchecked_mut(c2);\n                ptr::swap(pa, pb);\n            }\n        }\n    }\n    \n    /// Swap/exchange the data between two rows. Note that this method is overridden in both `TooDee` and `TooDeeOpsMut`.\n    /// This implementation remains in place for other types that may wish to implement the trait.\n    /// \n    /// # Panics\n    /// \n    /// Panics if either row index is out of bounds.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n    /// toodee[0].iter_mut().for_each(|v| *v = 1);\n    /// assert_eq!(toodee[(0, 2)], 42);\n    /// toodee.view_mut((0, 0), (10, 5)).swap_rows(0, 2);\n    /// assert_eq!(toodee[(0, 2)], 1);\n    /// ```\n    fn swap_rows(&mut self, mut r1: usize, mut r2: usize) {\n        match r1.cmp(&r2) {\n            Ordering::Less => {},\n            Ordering::Greater => {\n                core::mem::swap(&mut r1, &mut r2);\n            },\n            Ordering::Equal => {\n                return;\n            }\n        }\n        assert!(r2 < self.num_rows());\n        let mut iter = self.rows_mut();\n        let tmp = iter.nth(r1).unwrap();\n        tmp.swap_with_slice(iter.nth(r2-r1-1).unwrap());\n    }\n    \n    /// Return the specified rows as mutable slices.\n    /// \n    /// # Panics\n    ///\n    /// Will panic if `r1` and `r2` are equal, or if either row index is out of bounds.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n    /// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n    /// let (r1, r2) = toodee.row_pair_mut(0, 4);\n    /// // do something with the row pair\n    /// r1.swap_with_slice(r2);\n    /// ```\n    fn row_pair_mut(&mut self, r1: usize, r2: usize) -> (&mut [T], &mut [T]) {\n        let num_rows = self.num_rows();\n        assert!(r1 < num_rows);\n        assert!(r2 < num_rows);\n        assert!(r1 != r2);\n        match r1.cmp(&r2) {\n            Ordering::Less => {\n                let mut iter = self.rows_mut();\n                let tmp = iter.nth(r1).unwrap();\n                (tmp, iter.nth(r2-r1-1).unwrap())\n            },\n            Ordering::Greater => {\n                let mut iter = self.rows_mut();\n                let tmp = iter.nth(r2).unwrap();\n                (iter.nth(r1-r2-1).unwrap(), tmp)\n            },\n            Ordering::Equal => {\n                unreachable!(\"r1 != r2\");\n            },\n        }\n    }\n    \n    /// Returns a mutable row without checking that the row is valid. Generally it's best to use indexing instead, e.g., toodee[row]\n    /// \n    /// # Safety\n    /// \n    /// This is generally not recommended, use with caution!\n    /// Calling this method with an invalid row is *[undefined behavior]* even if the resulting reference is not used.\n    unsafe fn get_unchecked_row_mut(&mut self, row: usize) -> &mut [T];\n\n    /// Returns a mutable cell without checking that the cell coordinate is valid. Generally it's best to use indexing instead, e.g., toodee[(col, row)]\n    /// \n    /// # Safety\n    /// \n    /// This is generally not recommended, use with caution!\n    /// Calling this method with an invalid coordinate is *[undefined behavior]* even if the resulting reference is not used.\n    unsafe fn get_unchecked_mut(&mut self, coord: Coordinate) -> &mut T;\n\n}","Real(LocalPath(\"src/ops.rs\"))"],"ops::TooDeeOpsMut::cells_mut":["/// Returns an iterator that traverses all cells within the area.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n/// for c in toodee.cells_mut() {\n///     *c -= 1;\n/// }\n/// assert_eq!(toodee.cells().sum::<u32>(), 41*50);\n/// ```\nfn cells_mut(&mut self) -> CellsMut<'_, T>{\n        FlattenExact::new(self.rows_mut())\n    }","Real(LocalPath(\"src/ops.rs\"))"],"ops::TooDeeOpsMut::fill":["/// Fills the entire area with the specified value.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n/// let mut view = toodee.view_mut((1, 1), (9, 4));\n/// view.fill(0);\n/// assert_eq!(toodee.cells().sum::<u32>(), 42*(50 - 8*3));\n/// ```\nfn fill<V>(&mut self, fill: V)\n    where\n        V: Borrow<T>,\n        T: Clone{\n        let value = fill.borrow();\n        for r in self.rows_mut() {\n            for v in r {\n                v.clone_from(value);\n            }\n        }\n    }","Real(LocalPath(\"src/ops.rs\"))"],"ops::TooDeeOpsMut::row_pair_mut":["/// Return the specified rows as mutable slices.\n/// \n/// # Panics\n///\n/// Will panic if `r1` and `r2` are equal, or if either row index is out of bounds.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n/// let (r1, r2) = toodee.row_pair_mut(0, 4);\n/// // do something with the row pair\n/// r1.swap_with_slice(r2);\n/// ```\nfn row_pair_mut(&mut self, r1: usize, r2: usize) -> (&mut [T], &mut [T]){\n        let num_rows = self.num_rows();\n        assert!(r1 < num_rows);\n        assert!(r2 < num_rows);\n        assert!(r1 != r2);\n        match r1.cmp(&r2) {\n            Ordering::Less => {\n                let mut iter = self.rows_mut();\n                let tmp = iter.nth(r1).unwrap();\n                (tmp, iter.nth(r2-r1-1).unwrap())\n            },\n            Ordering::Greater => {\n                let mut iter = self.rows_mut();\n                let tmp = iter.nth(r2).unwrap();\n                (iter.nth(r1-r2-1).unwrap(), tmp)\n            },\n            Ordering::Equal => {\n                unreachable!(\"r1 != r2\");\n            },\n        }\n    }","Real(LocalPath(\"src/ops.rs\"))"],"ops::TooDeeOpsMut::swap_cols":["/// Swap/exchange the data between two columns.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n/// for c in toodee.col_mut(2) {\n///     *c = 1;\n/// }\n/// assert_eq!(toodee[(4, 0)], 42);\n/// toodee.swap_cols(2, 4);\n/// assert_eq!(toodee[(4, 0)], 1);\n/// ```\nfn swap_cols(&mut self, c1: usize, c2: usize){\n        let num_cols = self.num_cols();\n        assert!(c1 < num_cols);\n        assert!(c2 < num_cols);\n        for r in self.rows_mut() {\n            // The column indices have been checked with asserts (see above), so we can\n            // safely access and swap the elements using `get_unchecked_mut`.\n            unsafe {\n                let pa: *mut T = r.get_unchecked_mut(c1);\n                let pb: *mut T = r.get_unchecked_mut(c2);\n                ptr::swap(pa, pb);\n            }\n        }\n    }","Real(LocalPath(\"src/ops.rs\"))"],"ops::TooDeeOpsMut::swap_rows":["/// Swap/exchange the data between two rows. Note that this method is overridden in both `TooDee` and `TooDeeOpsMut`.\n/// This implementation remains in place for other types that may wish to implement the trait.\n/// \n/// # Panics\n/// \n/// Panics if either row index is out of bounds.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TooDeeOpsMut};\n/// let mut toodee : TooDee<u32> = TooDee::init(10, 5, 42u32);\n/// toodee[0].iter_mut().for_each(|v| *v = 1);\n/// assert_eq!(toodee[(0, 2)], 42);\n/// toodee.view_mut((0, 0), (10, 5)).swap_rows(0, 2);\n/// assert_eq!(toodee[(0, 2)], 1);\n/// ```\nfn swap_rows(&mut self, mut r1: usize, mut r2: usize){\n        match r1.cmp(&r2) {\n            Ordering::Less => {},\n            Ordering::Greater => {\n                core::mem::swap(&mut r1, &mut r2);\n            },\n            Ordering::Equal => {\n                return;\n            }\n        }\n        assert!(r2 < self.num_rows());\n        let mut iter = self.rows_mut();\n        let tmp = iter.nth(r1).unwrap();\n        tmp.swap_with_slice(iter.nth(r2-r1-1).unwrap());\n    }","Real(LocalPath(\"src/ops.rs\"))"],"sort::SortOps":["/// Provides sorting capabilities to two-dimensional arrays. Sorting of the rows and columns\n/// is performed in-place, and care is taken to minimise row/col swaps. This is achieved by\n/// sorting the row/col and original index pair, then repositioning the rows/columns once the\n/// new sort order has been determined.\npub trait SortOps<T> : TooDeeOpsMut<T> {\n\n    /// Sort the entire two-dimensional array by comparing elements on a specific row, using the natural ordering.\n    /// This sort is stable.\n    fn sort_row_ord<F>(&mut self, row: usize) where T : Ord {\n        self.sort_by_row(row, T::cmp);\n    }\n    \n    /// Sort the entire two-dimensional array by comparing elements on a specific row, using the natural ordering.\n    /// This sort is unstable.\n    fn sort_unstable_row_ord<F>(&mut self, row: usize) where T : Ord {\n        self.sort_unstable_by_row(row, T::cmp);\n    }\n\n    /// Sort the entire two-dimensional array by comparing elements on a specific row using the provided compare function.\n    /// This sort is stable.\n    fn sort_by_row<F>(&mut self, row: usize, mut compare: F)\n        where\n        F: FnMut(&T, &T) -> Ordering, \n    {\n        assert!(row < self.num_rows());\n        \n        let mut sort_data : Box<[(usize, &T)]> = self[row].iter().enumerate().map(|(i, v)| (i, v)).collect();\n        \n        sort_data.sort_by(|i, j| compare(i.1, j.1));\n        \n        // Build up a \"trace\" of column swaps to apply\n        \n        let mut ordering = sorted_box_to_ordering(sort_data);\n        \n        let swap_trace = build_swap_trace(&mut ordering);\n        \n        // Apply the swap trace to each row. For larger arrays, this approach is faster than applying swap_cols() directly.\n        for r in self.rows_mut() {\n            for i in swap_trace.iter() {\n                // The swap indices will definitely be within the expected range,\n                // so we can use `get_unchecked_mut` here\n                unsafe {\n                    let pa: *mut T = r.get_unchecked_mut(i.0);\n                    let pb: *mut T = r.get_unchecked_mut(i.1);\n                    ptr::swap(pa, pb);\n                }\n//                r.swap(i.0, i.1);\n            }\n        }\n    }\n    \n    /// Sort the entire two-dimensional array by comparing elements on a specific row using the provided compare function.\n    /// This sort is unstable.\n    fn sort_unstable_by_row<F>(&mut self, row: usize, mut compare: F)\n        where\n        F: FnMut(&T, &T) -> Ordering, \n    {\n        assert!(row < self.num_rows());\n\n        let mut sort_data : Box<[(usize, &T)]> = self[row].iter().enumerate().map(|(i, v)| (i, v)).collect();\n        \n        sort_data.sort_unstable_by(|i, j| compare(i.1, j.1));\n\n        // Build up a \"trace\" of column swaps to apply\n\n        let mut ordering = sorted_box_to_ordering(sort_data);\n\n        let swap_trace = build_swap_trace(&mut ordering);\n        \n        // Apply the swap trace to each row. For larger arrays, this approach is faster than applying swap_cols() directly.\n        for r in self.rows_mut() {\n            for i in swap_trace.iter() {\n                // The swap indices will definitely be within the expected range,\n                // so we can use `get_unchecked_mut` here\n                unsafe {\n                    let pa: *mut T = r.get_unchecked_mut(i.0);\n                    let pb: *mut T = r.get_unchecked_mut(i.1);\n                    ptr::swap(pa, pb);\n                }\n//                r.swap(i.0, i.1);\n            }\n        }\n    }\n\n    /// Sort the entire two-dimensional array by comparing elements on a specific row using a key\n    /// extraction function.\n    /// This sort is stable.\n    fn sort_by_row_key<B, F>(&mut self, row: usize, mut f: F)\n        where\n        B: Ord,\n        F: FnMut(&T) -> B,\n    {\n        self.sort_by_row(row, |a, b| f(a).cmp(&f(b)));\n    }\n\n    /// Sort the entire two-dimensional array by comparing elements on a specific row using a key\n    /// extraction function.\n    /// This sort is unstable.\n    fn sort_unstable_by_row_key<B, F>(&mut self, row: usize, mut f: F)\n        where\n        B: Ord,\n        F: FnMut(&T) -> B,\n    {\n        self.sort_unstable_by_row(row, |a, b| f(a).cmp(&f(b)));\n    }\n\n    /// Sort the entire two-dimensional array by comparing elements on a specific column using the natural ordering.\n    /// This sort is stable.\n    fn sort_col_ord<F>(&mut self, col: usize) where T : Ord {\n        self.sort_by_col(col, T::cmp);\n    }\n    \n    /// Sort the entire two-dimensional array by comparing elements on in a specific column.\n    /// This sort is stable.\n    fn sort_by_col<F>(&mut self, col: usize, mut compare: F)\n        where\n        F: FnMut(&T, &T) -> Ordering, \n    {\n        assert!(col < self.num_cols());\n        \n        let mut sort_data : Box<[(usize, &T)]> = self.col(col).enumerate().map(|(i, v)| (i, v)).collect();\n\n        sort_data.sort_by(|i, j| compare(i.1, j.1));\n        \n        let mut ordering = sorted_box_to_ordering(sort_data);\n        \n        let swap_trace = build_swap_trace(&mut ordering);\n        \n        for i in swap_trace.iter() {\n            self.swap_rows(i.0, i.1);\n        }\n    }\n\n    /// Sort the entire two-dimensional array by comparing elements on in a specific column.\n    /// This sort is unstable.\n    fn sort_unstable_by_col<F>(&mut self, col: usize, mut compare: F)\n        where\n        F: FnMut(&T, &T) -> Ordering, \n    {\n        assert!(col < self.num_cols());\n        let mut sort_data : Box<[(usize, &T)]> = self.col(col).enumerate().map(|(i, v)| (i, v)).collect();\n\n        sort_data.sort_unstable_by(|i, j| compare(i.1, j.1));\n\n        let mut ordering = sorted_box_to_ordering(sort_data);\n        \n        let swap_trace = build_swap_trace(&mut ordering);\n\n        for i in swap_trace.iter() {\n            self.swap_rows(i.0, i.1);\n        }\n    }\n\n    /// Sort the entire two-dimensional array by comparing elements on a specific column using a key\n    /// extraction function.\n    /// This sort is stable.\n    fn sort_by_col_key<B, F>(&mut self, col: usize, mut f: F)\n        where\n        B: Ord,\n        F: FnMut(&T) -> B,\n    {\n        self.sort_by_row(col, |a, b| f(a).cmp(&f(b)));\n    }\n\n    /// Sort the entire two-dimensional array by comparing elements on a specific column using a key\n    /// extraction function.\n    /// This sort is unstable.\n    fn sort_unstable_by_col_key<B, F>(&mut self, col: usize, mut f: F)\n        where\n        B: Ord,\n        F: FnMut(&T) -> B,\n    {\n        self.sort_unstable_by_row(col, |a, b| f(a).cmp(&f(b)));\n    }\n}","Real(LocalPath(\"src/sort.rs\"))"],"sort::SortOps::sort_by_col":["/// Sort the entire two-dimensional array by comparing elements on in a specific column.\n/// This sort is stable.\nfn sort_by_col<F>(&mut self, col: usize, mut compare: F)\n        where\n        F: FnMut(&T, &T) -> Ordering,{\n        assert!(col < self.num_cols());\n        \n        let mut sort_data : Box<[(usize, &T)]> = self.col(col).enumerate().map(|(i, v)| (i, v)).collect();\n\n        sort_data.sort_by(|i, j| compare(i.1, j.1));\n        \n        let mut ordering = sorted_box_to_ordering(sort_data);\n        \n        let swap_trace = build_swap_trace(&mut ordering);\n        \n        for i in swap_trace.iter() {\n            self.swap_rows(i.0, i.1);\n        }\n    }","Real(LocalPath(\"src/sort.rs\"))"],"sort::SortOps::sort_by_col_key":["/// Sort the entire two-dimensional array by comparing elements on a specific column using a key\n/// extraction function.\n/// This sort is stable.\nfn sort_by_col_key<B, F>(&mut self, col: usize, mut f: F)\n        where\n        B: Ord,\n        F: FnMut(&T) -> B,{\n        self.sort_by_row(col, |a, b| f(a).cmp(&f(b)));\n    }","Real(LocalPath(\"src/sort.rs\"))"],"sort::SortOps::sort_by_row":["/// Sort the entire two-dimensional array by comparing elements on a specific row using the provided compare function.\n/// This sort is stable.\nfn sort_by_row<F>(&mut self, row: usize, mut compare: F)\n        where\n        F: FnMut(&T, &T) -> Ordering,{\n        assert!(row < self.num_rows());\n        \n        let mut sort_data : Box<[(usize, &T)]> = self[row].iter().enumerate().map(|(i, v)| (i, v)).collect();\n        \n        sort_data.sort_by(|i, j| compare(i.1, j.1));\n        \n        // Build up a \"trace\" of column swaps to apply\n        \n        let mut ordering = sorted_box_to_ordering(sort_data);\n        \n        let swap_trace = build_swap_trace(&mut ordering);\n        \n        // Apply the swap trace to each row. For larger arrays, this approach is faster than applying swap_cols() directly.\n        for r in self.rows_mut() {\n            for i in swap_trace.iter() {\n                // The swap indices will definitely be within the expected range,\n                // so we can use `get_unchecked_mut` here\n                unsafe {\n                    let pa: *mut T = r.get_unchecked_mut(i.0);\n                    let pb: *mut T = r.get_unchecked_mut(i.1);\n                    ptr::swap(pa, pb);\n                }\n//                r.swap(i.0, i.1);\n            }\n        }\n    }","Real(LocalPath(\"src/sort.rs\"))"],"sort::SortOps::sort_by_row_key":["/// Sort the entire two-dimensional array by comparing elements on a specific row using a key\n/// extraction function.\n/// This sort is stable.\nfn sort_by_row_key<B, F>(&mut self, row: usize, mut f: F)\n        where\n        B: Ord,\n        F: FnMut(&T) -> B,{\n        self.sort_by_row(row, |a, b| f(a).cmp(&f(b)));\n    }","Real(LocalPath(\"src/sort.rs\"))"],"sort::SortOps::sort_col_ord":["/// Sort the entire two-dimensional array by comparing elements on a specific column using the natural ordering.\n/// This sort is stable.\nfn sort_col_ord<F>(&mut self, col: usize) where T : Ord{\n        self.sort_by_col(col, T::cmp);\n    }","Real(LocalPath(\"src/sort.rs\"))"],"sort::SortOps::sort_row_ord":["/// Sort the entire two-dimensional array by comparing elements on a specific row, using the natural ordering.\n/// This sort is stable.\nfn sort_row_ord<F>(&mut self, row: usize) where T : Ord{\n        self.sort_by_row(row, T::cmp);\n    }","Real(LocalPath(\"src/sort.rs\"))"],"sort::SortOps::sort_unstable_by_col":["/// Sort the entire two-dimensional array by comparing elements on in a specific column.\n/// This sort is unstable.\nfn sort_unstable_by_col<F>(&mut self, col: usize, mut compare: F)\n        where\n        F: FnMut(&T, &T) -> Ordering,{\n        assert!(col < self.num_cols());\n        let mut sort_data : Box<[(usize, &T)]> = self.col(col).enumerate().map(|(i, v)| (i, v)).collect();\n\n        sort_data.sort_unstable_by(|i, j| compare(i.1, j.1));\n\n        let mut ordering = sorted_box_to_ordering(sort_data);\n        \n        let swap_trace = build_swap_trace(&mut ordering);\n\n        for i in swap_trace.iter() {\n            self.swap_rows(i.0, i.1);\n        }\n    }","Real(LocalPath(\"src/sort.rs\"))"],"sort::SortOps::sort_unstable_by_col_key":["/// Sort the entire two-dimensional array by comparing elements on a specific column using a key\n/// extraction function.\n/// This sort is unstable.\nfn sort_unstable_by_col_key<B, F>(&mut self, col: usize, mut f: F)\n        where\n        B: Ord,\n        F: FnMut(&T) -> B,{\n        self.sort_unstable_by_row(col, |a, b| f(a).cmp(&f(b)));\n    }","Real(LocalPath(\"src/sort.rs\"))"],"sort::SortOps::sort_unstable_by_row":["/// Sort the entire two-dimensional array by comparing elements on a specific row using the provided compare function.\n/// This sort is unstable.\nfn sort_unstable_by_row<F>(&mut self, row: usize, mut compare: F)\n        where\n        F: FnMut(&T, &T) -> Ordering,{\n        assert!(row < self.num_rows());\n\n        let mut sort_data : Box<[(usize, &T)]> = self[row].iter().enumerate().map(|(i, v)| (i, v)).collect();\n        \n        sort_data.sort_unstable_by(|i, j| compare(i.1, j.1));\n\n        // Build up a \"trace\" of column swaps to apply\n\n        let mut ordering = sorted_box_to_ordering(sort_data);\n\n        let swap_trace = build_swap_trace(&mut ordering);\n        \n        // Apply the swap trace to each row. For larger arrays, this approach is faster than applying swap_cols() directly.\n        for r in self.rows_mut() {\n            for i in swap_trace.iter() {\n                // The swap indices will definitely be within the expected range,\n                // so we can use `get_unchecked_mut` here\n                unsafe {\n                    let pa: *mut T = r.get_unchecked_mut(i.0);\n                    let pb: *mut T = r.get_unchecked_mut(i.1);\n                    ptr::swap(pa, pb);\n                }\n//                r.swap(i.0, i.1);\n            }\n        }\n    }","Real(LocalPath(\"src/sort.rs\"))"],"sort::SortOps::sort_unstable_by_row_key":["/// Sort the entire two-dimensional array by comparing elements on a specific row using a key\n/// extraction function.\n/// This sort is unstable.\nfn sort_unstable_by_row_key<B, F>(&mut self, row: usize, mut f: F)\n        where\n        B: Ord,\n        F: FnMut(&T) -> B,{\n        self.sort_unstable_by_row(row, |a, b| f(a).cmp(&f(b)));\n    }","Real(LocalPath(\"src/sort.rs\"))"],"sort::SortOps::sort_unstable_row_ord":["/// Sort the entire two-dimensional array by comparing elements on a specific row, using the natural ordering.\n/// This sort is unstable.\nfn sort_unstable_row_ord<F>(&mut self, row: usize) where T : Ord{\n        self.sort_unstable_by_row(row, T::cmp);\n    }","Real(LocalPath(\"src/sort.rs\"))"],"sort::build_swap_trace":["/// Common re-indexing logic used internally by the `SortOps` trait.\nfn build_swap_trace(ordering : &mut [(usize,usize)]) ->  &mut [(usize,usize)]{\n    let len = ordering.len();\n    \n    // Create a reverse lookup\n    for idx in 0..len {\n        unsafe {\n            // We know 0 <= idx < ordering.len(), so we don't need to check the indexing.\n            let v = ordering.get_unchecked(idx).0;\n            // It's less trivial to figure out that 0 <= v <= ordering.len() - the input\n            // array is created by sorted_box_to_ordering()\n            ordering.get_unchecked_mut(v).1 = idx;\n        }\n    }\n    \n    let mut swap_count = 0;\n    \n    // Build a swap trace that will shuffle everything into the right position.\n    for i in 0..len {\n        // Used get_unchecked for the same reason as above\n        unsafe {\n            let (other, inv_i) = *ordering.get_unchecked(i);\n            if i != other {\n                // we re-use the ordering slice to store the swap trace\n                *ordering.get_unchecked_mut(swap_count) = (i, other);\n                swap_count += 1;\n                if inv_i > i {\n                    ordering.get_unchecked_mut(inv_i).0 = other;\n                    ordering.get_unchecked_mut(other).1 = inv_i;\n                }\n            }\n        }\n    }\n    \n    // Only return the portion of the slice containing the swap trace.\n    &mut ordering[..swap_count]\n}","Real(LocalPath(\"src/sort.rs\"))"],"sort::sorted_box_to_ordering":["/// Use some unsafeness to coerce a [(usize, &T)] into a [(usize, usize)]. The `Box` is consumed,\n/// meaning that we \"unborrow\" the &T values.\nfn sorted_box_to_ordering<T>(sorted: Box<[(usize, &T)]>) -> Box<[(usize,usize)]>{\n    debug_assert_eq!(core::mem::size_of::<&T>(), core::mem::size_of::<usize>());\n    let len = sorted.len();\n    let p = Box::into_raw(sorted);\n    unsafe {\n        let p2 = slice::from_raw_parts_mut(p as *mut (usize, usize), len);\n        Box::from_raw(p2)\n    }\n}","Real(LocalPath(\"src/sort.rs\"))"],"toodee::DrainCol":["/// Drains a column.\npub struct DrainCol<'a, T> {\n    /// Current remaining elements to remove\n    iter: Col<'a, T>,\n    col: usize,\n    toodee: NonNull<TooDee<T>>,\n}","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee":["/// Represents a two-dimensional array.\n/// \n/// Empty arrays will always have dimensions of zero.\npub struct TooDee<T> {\n    data: Vec<T>,\n    num_rows: usize,\n    num_cols: usize,\n}","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::capacity":["/// Returns the element capacity of the underlying `Vec`.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::TooDee;\n/// let v = vec![42u32; 10];\n/// let toodee : TooDee<u32> = TooDee::from_vec(5, 2, v);\n/// assert!(toodee.capacity() >= 10);\n/// ```\npub fn capacity(&self) -> usize{\n        self.data.capacity()\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::clear":["/// Clears the array, removing all values and zeroing the number of columns and rows.\n///\n/// Note that this method has no effect on the allocated capacity of the array.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let v = vec![42u32; 10];\n/// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 2, v);\n/// toodee.clear();\n/// assert_eq!(toodee.num_cols(), 0);\n/// assert_eq!(toodee.num_rows(), 0);\n/// assert!(toodee.capacity() >= 10);\n/// ```\npub fn clear(&mut self){\n        self.num_cols = 0;\n        self.num_rows = 0;\n        self.data.clear();\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::data":["/// Returns a reference to the raw array data\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let v = vec![42u32; 10];\n/// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 2, v);\n/// assert_eq!(toodee.data()[0], 42);\n/// ```\npub fn data(&self) -> &[T]{\n        &self.data\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::data_mut":["/// Returns a mutable reference to the raw array data\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let v = vec![42u32; 10];\n/// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 2, v);\n/// assert_eq!(toodee.data_mut()[0], 42);\n/// ```\npub fn data_mut(&mut self) -> &mut [T]{\n        &mut self.data\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::from_box":["/// Create a new `TooDee` array using the provided boxed slice. The slice's length\n/// must match the dimensions of the array.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let v = vec![42u32; 10];\n/// let mut toodee : TooDee<u32> = TooDee::from_box(5, 2, v.into_boxed_slice());\n/// assert_eq!(toodee.num_cols(), 5);\n/// assert_eq!(toodee.num_rows(), 2);\n/// assert_eq!(toodee[0][0], 42);\n/// ```\npub fn from_box(num_cols: usize, num_rows: usize, b: Box<[T]>) -> TooDee<T>{\n        TooDee::from_vec(num_cols, num_rows, b.into_vec())\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::from_vec":["/// Create a new `TooDee` array using the provided vector. The vector's length\n/// must match the dimensions of the array.\n/// \n/// # Panics\n/// \n/// Panics if one of the dimensions is zero but the other is non-zero. This\n/// is to enforce the rule that empty arrays have no dimensions.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let v = vec![42u32; 10];\n/// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 2, v);\n/// assert_eq!(toodee.num_cols(), 5);\n/// assert_eq!(toodee.num_rows(), 2);\n/// assert_eq!(toodee[0][0], 42);\n/// ```\npub fn from_vec(num_cols: usize, num_rows: usize, v: Vec<T>) -> TooDee<T>{\n        if num_cols == 0 || num_rows == 0 {\n            assert_eq!(num_rows, num_cols);\n        }\n        assert_eq!(num_cols * num_rows, v.len());\n        TooDee {\n            data : v,\n            num_cols,\n            num_rows,\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::init":["/// Create a new `TooDee` array of the specified dimensions, and fill it with\n/// an initial value.\n/// \n/// # Panics\n/// \n/// Panics if one of the dimensions is zero but the other is non-zero. This\n/// is to enforce the rule that empty arrays have no dimensions.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let toodee = TooDee::init(10, 5, 42u32);\n/// assert_eq!(toodee.num_cols(), 10);\n/// assert_eq!(toodee.num_rows(), 5);\n/// assert_eq!(toodee[0][0], 42);\n/// ```\npub fn init(num_cols: usize, num_rows: usize, init_value: T) -> TooDee<T>\n    where T: Clone{\n        if num_cols == 0 || num_rows == 0 {\n            assert_eq!(num_rows, num_cols);\n        }\n        let len = num_rows * num_cols;\n        let v = vec![init_value; len];\n        TooDee {\n            data : v,\n            num_cols,\n            num_rows,\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::insert_col":["/// Inserts new `data` into the array at the specified `col`.\n/// \n/// # Panics\n/// \n/// Panics if the data's length doesn't match the length of existing columns (if any).\npub fn insert_col<I>(&mut self, index: usize, data: impl IntoIterator<Item=T, IntoIter=I>)\n    where I : Iterator<Item=T> + ExactSizeIterator + DoubleEndedIterator{\n        assert!(index <= self.num_cols);\n        let iter = data.into_iter();\n        if self.num_cols == 0 {\n            self.num_rows = iter.len();\n        } else {\n            assert_eq!(self.num_rows, iter.len());\n        }\n        \n        self.reserve(self.num_rows);\n        \n        let old_len = self.data.len();\n        let new_len = old_len + self.num_rows;\n        let suffix_len = self.num_cols - index;\n        unsafe {\n            let p = self.data.as_mut_ptr();\n            let mut read_p = p.add(old_len);\n            let mut write_p = p.add(new_len);\n            for e in iter.rev() {\n                // shift suffix\n                read_p = read_p.sub(suffix_len);\n                write_p = write_p.sub(suffix_len);\n                ptr::copy(read_p, write_p, suffix_len);\n                write_p = write_p.sub(1);\n                // place new col element\n                ptr::write(write_p, e);\n                // shift prefix\n                read_p = read_p.sub(index);\n                write_p = write_p.sub(index);\n                ptr::copy(read_p, write_p, index);\n            }\n            self.data.set_len(new_len);\n        }\n\n        // update the number of columns\n        self.num_cols += 1;\n\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::insert_row":["/// Inserts new `data` into the array at the specified `row`\n/// \n/// # Panics\n/// \n/// Panics if the data's length doesn't match the length of existing rows (if any).\npub fn insert_row<I>(&mut self, index: usize, data: impl IntoIterator<Item=T, IntoIter=I>)\n    where I : Iterator<Item=T> + ExactSizeIterator{\n        assert!(index <= self.num_rows);\n        let iter = data.into_iter();\n        if self.num_rows == 0 {\n            self.num_cols = iter.len();\n        } else {\n            assert_eq!(self.num_cols, iter.len());\n        }\n        \n        self.reserve(self.num_cols);\n\n        let start = index * self.num_cols;\n        let len = self.data.len();\n        unsafe {\n            let mut p = self.data.as_mut_ptr().add(start);\n            // shift everything to make space for the new row\n            ptr::copy(p, p.add(self.num_cols), len - start);\n            for e in iter {\n                ptr::write(p, e);\n                p = p.add(1);\n            }\n            self.data.set_len(len + self.num_cols);\n        }\n\n        // update the number of rows\n        self.num_rows += 1;\n\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::new":["/// Create a new `TooDee` array of the specified dimensions, and fill it with\n/// the type's default value.\n/// \n/// # Panics\n/// \n/// Panics if one of the dimensions is zero but the other is non-zero. This\n/// is to enforce the rule that empty arrays have no dimensions.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let toodee : TooDee<u32> = TooDee::new(10, 5);\n/// assert_eq!(toodee.num_cols(), 10);\n/// assert_eq!(toodee.num_rows(), 5);\n/// assert_eq!(toodee[0][0], 0);\n/// ```\npub fn new(num_cols: usize, num_rows: usize) -> TooDee<T>\n    where T: Default + Clone{\n        if num_cols == 0 || num_rows == 0 {\n            assert_eq!(num_rows, num_cols);\n        }\n        let len = num_rows * num_cols;\n        let v = vec![T::default(); len];\n        TooDee {\n            data : v,\n            num_cols,\n            num_rows,\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::pop_col":["/// Removes the last column from the array and returns it as a `Drain`, or `None` if it is empty.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let v = vec![42u32; 15];\n/// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n/// {\n///    let drain = toodee.pop_col().unwrap();\n///    assert_eq!(drain.len(), 3);\n/// }\n/// assert_eq!(toodee.num_cols(), 4);\n/// assert_eq!(toodee.num_rows(), 3);\n/// ```\npub fn pop_col(&mut self) -> Option<DrainCol<'_, T>>{\n        if self.num_cols == 0 {\n            None\n        } else {\n            Some(self.remove_col(self.num_cols - 1))\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::pop_row":["/// Removes the last row from the array and returns it as a `Drain`, or `None` if it is empty.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let v = vec![42u32; 15];\n/// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n/// {\n///    let drain = toodee.pop_row().unwrap();\n///    assert_eq!(drain.len(), 5);\n/// }\n/// assert_eq!(toodee.num_cols(), 5);\n/// assert_eq!(toodee.num_rows(), 2);\n/// ```\npub fn pop_row(&mut self) -> Option<DrainRow<'_, T>>{\n        if self.num_rows == 0 {\n            None\n        } else {\n            Some(self.remove_row(self.num_rows - 1))\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::push_col":["/// Appends a new column to the array.\n/// \n/// # Panics\n/// \n/// Panics if the data's length doesn't match the length of existing rows (if any).\npub fn push_col<I>(&mut self, data: impl IntoIterator<Item=T, IntoIter=I>)\n    where I : Iterator<Item=T> + ExactSizeIterator + DoubleEndedIterator{\n        self.insert_col(self.num_cols, data);\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::push_row":["/// Appends a new row to the array.\n/// \n/// # Panics\n/// \n/// Panics if the data's length doesn't match the length of existing rows (if any).\npub fn push_row<I>(&mut self, data: impl IntoIterator<Item=T, IntoIter=I>)\n    where I : Iterator<Item=T> + ExactSizeIterator{\n        self.insert_row(self.num_rows, data);\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::remove_col":["/// Removes the specified column from the array and returns it as a `Drain`\n/// \n/// # Panics\n/// \n/// Panics if the specified column index is out of bounds.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let v = vec![42u32; 15];\n/// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n/// {\n///    let drain = toodee.remove_col(1);\n///    assert_eq!(drain.len(), 3);\n/// }\n/// assert_eq!(toodee.num_cols(), 4);\n/// assert_eq!(toodee.num_rows(), 3);\n/// ```\npub fn remove_col(&mut self, index: usize) -> DrainCol<'_, T>{\n        assert!(index < self.num_cols);\n\n        let v = &mut self.data;\n        let num_cols = self.num_cols;\n        let slice_len = v.len() - num_cols + 1;\n        unsafe {\n            // set the vec length to 0 to amplify any leaks\n            v.set_len(0);\n            DrainCol {\n               iter : Col {\n                   skip : num_cols - 1,\n                   v : slice::from_raw_parts_mut(v.as_mut_ptr().add(index), slice_len),\n               },\n               col : index,\n               toodee : NonNull::from(self),\n            }\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::remove_row":["/// Removes the specified row from the array and returns it as a `Drain`\n/// \n/// # Panics\n/// \n/// Panics if the specified row index is out of bounds.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps};\n/// let v = vec![42u32; 15];\n/// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n/// {\n///    let drain = toodee.remove_row(1);\n///    assert_eq!(drain.len(), 5);\n/// }\n/// assert_eq!(toodee.num_cols(), 5);\n/// assert_eq!(toodee.num_rows(), 2);\n/// ```\npub fn remove_row(&mut self, index : usize) -> DrainRow<'_, T>{\n        assert!(index < self.num_rows);\n        let start = index * self.num_cols;\n        let drain = self.data.drain(start..start + self.num_cols);\n        self.num_rows -= 1;\n        if self.num_rows == 0 {\n            self.num_cols = 0;\n        }\n        drain\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::reserve":["/// Reserves capacity for at least `additional` more elements to be inserted\n/// in the given `TooDee<T>`.    \n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::TooDee;\n/// let mut toodee : TooDee<u32> = TooDee::default();\n/// toodee.reserve(50);\n/// assert!(toodee.capacity() >= 50);\n/// ```\npub fn reserve(&mut self, capacity: usize){\n        self.data.reserve(capacity);\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::reserve_exact":["/// Reserves the minimum capacity for at least `additional` more elements to be inserted\n/// into the `TooDee<T>`.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::TooDee;\n/// let mut toodee : TooDee<u32> = TooDee::default();\n/// toodee.reserve_exact(50);\n/// assert_eq!(toodee.capacity(), 50);\n/// ```\npub fn reserve_exact(&mut self, capacity: usize){\n        self.data.reserve_exact(capacity);\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::shrink_to_fit":["/// Shrinks the capacity of the underlying vector as much as possible.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::TooDee;\n/// let mut toodee : TooDee<u32> = TooDee::with_capacity(50);\n/// toodee.shrink_to_fit();\n/// assert_eq!(toodee.capacity(), 0);\n/// ```\npub fn shrink_to_fit(&mut self){\n        self.data.shrink_to_fit();\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"toodee::TooDee::<T>::with_capacity":["/// Constructs a new, empty `TooDee<T>` with the specified element capacity.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::TooDee;\n/// let toodee : TooDee<u32> = TooDee::with_capacity(50);\n/// assert!(toodee.capacity() >= 50);\n/// ```\npub fn with_capacity(capacity: usize) -> TooDee<T>{\n        TooDee {\n            data     : Vec::with_capacity(capacity),\n            num_cols : 0,\n            num_rows : 0,\n        }\n    }","Real(LocalPath(\"src/toodee.rs\"))"],"translate::TranslateOps":["/// Provides implementations for translate (also known as scroll) operations, and other internal data\n/// movement operations such as flipping.\npub trait TranslateOps<T> : TooDeeOpsMut<T> {\n\n    /// Translate (or scroll) the entire area. The `mid` coordinate will be moved to (0, 0), and\n    /// all other elements will be moved in the same fashion. All the original data is preserved by\n    /// wrapping at the array edges.\n    /// \n    /// If you don't want the wrapped data, simply overwrite it after translation.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TranslateOps};\n    /// let v = vec![42u32; 15];\n    /// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n    /// toodee[1][1] = 1;\n    /// // move (1, 1) to (0, 0)\n    /// toodee.translate_with_wrap((1, 1));\n    /// assert_eq!(toodee[0][0], 1);\n    /// assert_eq!(toodee[1][1], 42);\n    /// ```\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TranslateOps};\n    /// let v = vec![42u32; 15];\n    /// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n    /// // set (4, 2) to 1\n    /// toodee[(4, 2)] = 1;\n    /// // move (4, 2) to (0, 0)\n    /// toodee.translate_with_wrap((4, 2));\n    /// assert_eq!(toodee[0][0], 1);\n    /// assert_eq!(toodee[2][4], 42);\n    /// ```\n    fn translate_with_wrap(&mut self, mid: Coordinate) {\n\n        let (mut col_mid, mut row_mid) = mid;\n        \n        let num_cols = self.num_cols();\n        let num_rows = self.num_rows();\n\n        assert!(col_mid <= num_cols);\n        assert!(row_mid <= num_rows);\n        \n        if col_mid == num_cols {\n            col_mid = 0;\n        }\n\n        if row_mid == num_rows {\n            row_mid = 0;\n        }\n\n        if row_mid == 0 {\n            if col_mid != 0 {\n                // apply column rotation only\n                for r in self.rows_mut() {\n                    r.rotate_left(col_mid);\n                }\n            }\n            return;\n        }\n\n        let row_adj_abs = num_rows - row_mid;\n\n        // This row swapping algorithm is pretty cool. I came up with it independently,\n        // but it turns out that the concept is fairly well known. See\n        // `core::slice::ptr_rotate()` for various strategies.\n            \n        let mut swap_count = 0;\n        let mut base_row = 0;\n            \n        while swap_count < num_rows {\n\n            let mut mid = col_mid;\n\n            let mut next_row = base_row + row_adj_abs;\n                \n            loop {\n\n                if next_row >= num_rows {\n                    next_row -= num_rows;\n                }\n                \n                swap_count += 1;\n                if base_row == next_row {\n                    // finish up with a rotate\n                    if mid > 0 {\n                        unsafe {\n                            self.get_unchecked_row_mut(base_row).rotate_left(mid);\n                        }\n                    }\n                    break;\n                } else {\n            \n                    // The following logic performs a rotate while swapping, and\n                    // is more efficient than doing a swap then rotate.\n                    let (base_ref, next_ref) = self.row_pair_mut(base_row, next_row);\n                    unsafe {\n                        if mid > 0 {\n                            base_ref.get_unchecked_mut(..mid).swap_with_slice(next_ref.get_unchecked_mut(num_cols-mid..num_cols));\n                        }\n                        if mid < num_cols {\n                            base_ref.get_unchecked_mut(mid..num_cols).swap_with_slice(next_ref.get_unchecked_mut(..num_cols-mid));\n                        }\n                    }\n                    \n                    mid += col_mid;\n                    if mid >= num_cols {\n                        mid -= num_cols;\n                    }\n                }\n                \n                next_row += row_adj_abs;\n            }\n            \n            // TODO: We now know that we'll loop a further N = (num_rows / swap_count - 1) times.\n            // This means we could start swapping in chunks of N, i.e.,\n            // ([base_row..base_row+N] -> [base_row+row_adj_abs..base_row+row_adj_abs+N],\n            // which should more cache-friendly.\n            if swap_count >= num_rows {\n                break;\n            }\n            \n            base_row += 1; // advance the base\n        }\n        \n    }\n    \n    /// Flips (or mirrors) the rows.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TranslateOps};\n    /// let v = vec![42u32; 15];\n    /// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n    /// toodee[0][1] = 1;\n    /// toodee.flip_rows();\n    /// assert_eq!(toodee[2][1], 1);\n    /// ```\n    fn flip_rows(&mut self) {\n        let mut iter = self.rows_mut();\n        while let (Some(r1), Some(r2)) = (iter.next(), iter.next_back()) {\n            r1.swap_with_slice(r2);\n        }\n    }\n\n    /// Flips (or mirrors) the columns.\n    /// \n    /// ```\n    /// use toodee::{TooDee,TooDeeOps,TranslateOps};\n    /// let v = vec![42u32; 15];\n    /// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n    /// toodee[1][1] = 1;\n    /// toodee.flip_cols();\n    /// assert_eq!(toodee[1][3], 1);\n    /// ```\n    fn flip_cols(&mut self) {\n        for r in self.rows_mut() {\n            r.reverse();\n        }\n    }\n    \n}","Real(LocalPath(\"src/translate.rs\"))"],"translate::TranslateOps::flip_cols":["/// Flips (or mirrors) the columns.\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TranslateOps};\n/// let v = vec![42u32; 15];\n/// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n/// toodee[1][1] = 1;\n/// toodee.flip_cols();\n/// assert_eq!(toodee[1][3], 1);\n/// ```\nfn flip_cols(&mut self){\n        for r in self.rows_mut() {\n            r.reverse();\n        }\n    }","Real(LocalPath(\"src/translate.rs\"))"],"translate::TranslateOps::flip_rows":["/// Flips (or mirrors) the rows.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TranslateOps};\n/// let v = vec![42u32; 15];\n/// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n/// toodee[0][1] = 1;\n/// toodee.flip_rows();\n/// assert_eq!(toodee[2][1], 1);\n/// ```\nfn flip_rows(&mut self){\n        let mut iter = self.rows_mut();\n        while let (Some(r1), Some(r2)) = (iter.next(), iter.next_back()) {\n            r1.swap_with_slice(r2);\n        }\n    }","Real(LocalPath(\"src/translate.rs\"))"],"translate::TranslateOps::translate_with_wrap":["/// Translate (or scroll) the entire area. The `mid` coordinate will be moved to (0, 0), and\n/// all other elements will be moved in the same fashion. All the original data is preserved by\n/// wrapping at the array edges.\n/// \n/// If you don't want the wrapped data, simply overwrite it after translation.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TranslateOps};\n/// let v = vec![42u32; 15];\n/// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n/// toodee[1][1] = 1;\n/// // move (1, 1) to (0, 0)\n/// toodee.translate_with_wrap((1, 1));\n/// assert_eq!(toodee[0][0], 1);\n/// assert_eq!(toodee[1][1], 42);\n/// ```\n/// \n/// ```\n/// use toodee::{TooDee,TooDeeOps,TranslateOps};\n/// let v = vec![42u32; 15];\n/// let mut toodee : TooDee<u32> = TooDee::from_vec(5, 3, v);\n/// // set (4, 2) to 1\n/// toodee[(4, 2)] = 1;\n/// // move (4, 2) to (0, 0)\n/// toodee.translate_with_wrap((4, 2));\n/// assert_eq!(toodee[0][0], 1);\n/// assert_eq!(toodee[2][4], 42);\n/// ```\nfn translate_with_wrap(&mut self, mid: Coordinate){\n\n        let (mut col_mid, mut row_mid) = mid;\n        \n        let num_cols = self.num_cols();\n        let num_rows = self.num_rows();\n\n        assert!(col_mid <= num_cols);\n        assert!(row_mid <= num_rows);\n        \n        if col_mid == num_cols {\n            col_mid = 0;\n        }\n\n        if row_mid == num_rows {\n            row_mid = 0;\n        }\n\n        if row_mid == 0 {\n            if col_mid != 0 {\n                // apply column rotation only\n                for r in self.rows_mut() {\n                    r.rotate_left(col_mid);\n                }\n            }\n            return;\n        }\n\n        let row_adj_abs = num_rows - row_mid;\n\n        // This row swapping algorithm is pretty cool. I came up with it independently,\n        // but it turns out that the concept is fairly well known. See\n        // `core::slice::ptr_rotate()` for various strategies.\n            \n        let mut swap_count = 0;\n        let mut base_row = 0;\n            \n        while swap_count < num_rows {\n\n            let mut mid = col_mid;\n\n            let mut next_row = base_row + row_adj_abs;\n                \n            loop {\n\n                if next_row >= num_rows {\n                    next_row -= num_rows;\n                }\n                \n                swap_count += 1;\n                if base_row == next_row {\n                    // finish up with a rotate\n                    if mid > 0 {\n                        unsafe {\n                            self.get_unchecked_row_mut(base_row).rotate_left(mid);\n                        }\n                    }\n                    break;\n                } else {\n            \n                    // The following logic performs a rotate while swapping, and\n                    // is more efficient than doing a swap then rotate.\n                    let (base_ref, next_ref) = self.row_pair_mut(base_row, next_row);\n                    unsafe {\n                        if mid > 0 {\n                            base_ref.get_unchecked_mut(..mid).swap_with_slice(next_ref.get_unchecked_mut(num_cols-mid..num_cols));\n                        }\n                        if mid < num_cols {\n                            base_ref.get_unchecked_mut(mid..num_cols).swap_with_slice(next_ref.get_unchecked_mut(..num_cols-mid));\n                        }\n                    }\n                    \n                    mid += col_mid;\n                    if mid >= num_cols {\n                        mid -= num_cols;\n                    }\n                }\n                \n                next_row += row_adj_abs;\n            }\n            \n            // TODO: We now know that we'll loop a further N = (num_rows / swap_count - 1) times.\n            // This means we could start swapping in chunks of N, i.e.,\n            // ([base_row..base_row+N] -> [base_row+row_adj_abs..base_row+row_adj_abs+N],\n            // which should more cache-friendly.\n            if swap_count >= num_rows {\n                break;\n            }\n            \n            base_row += 1; // advance the base\n        }\n        \n    }","Real(LocalPath(\"src/translate.rs\"))"],"view::TooDeeView":["/// Provides a read-only view (or subset) of a `TooDee` array.\npub struct TooDeeView<'a, T> {\n    data: &'a [T],\n    num_cols: usize,\n    num_rows: usize,\n    main_cols: usize,\n    start: Coordinate,\n}","Real(LocalPath(\"src/view.rs\"))"],"view::TooDeeView::<'a, T>::from_toodee":["/// Used internally by `TooDee` to create a `TooDeeView`.\npub(super) fn from_toodee(start: Coordinate, end: Coordinate, toodee: &'a TooDee<T>) -> TooDeeView<'a, T>{\n        let (num_cols, num_rows) = calculate_view_dimensions(start, end, toodee);\n        let main_cols = toodee.num_cols();\n        let data_start = start.1 * main_cols + start.0;\n        let data_len = {\n            if num_rows == 0 {\n                0\n            } else {\n                (num_rows - 1) * main_cols + num_cols\n            }\n        };\n        unsafe {\n            TooDeeView {\n                data: toodee.data().get_unchecked(data_start..data_start + data_len),\n                start,\n                num_cols,\n                num_rows,\n                main_cols,\n            }\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"view::TooDeeView::<'a, T>::new":["/// Create a new `TooDeeViewMut` using the provided slice reference.\n/// \n/// # Panics\n/// \n/// Panics if one of the dimensions is zero but the other is non-zero. This\n/// is to enforce the rule that empty arrays have no dimensions.\n/// \n/// Panics if the slice's length is not sufficient to represent\n/// the desired array dimensions.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::TooDeeView;\n/// let data = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n/// let view = TooDeeView::new(4, 3, &data);\n/// ```\npub fn new(num_cols: usize, num_rows: usize, data: &'a [T]) -> TooDeeView<'a, T>{\n        if num_cols == 0 || num_rows == 0 {\n            assert_eq!(num_rows, num_cols);\n        }\n        let size = num_cols * num_rows;\n        assert!(size <= data.len());\n        TooDeeView {\n            data : &data[..size],\n            start: (0, 0),\n            num_cols,\n            num_rows,\n            main_cols : num_cols,\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"view::TooDeeViewMut":["/// Provides a mutable view (or subset), of a `TooDee` array.\npub struct TooDeeViewMut<'a, T> {\n    data: &'a mut [T],\n    num_cols: usize,\n    num_rows: usize,\n    main_cols: usize,\n    start: Coordinate,\n}","Real(LocalPath(\"src/view.rs\"))"],"view::TooDeeViewMut::<'a, T>::from_toodee":["/// Used internally by `TooDee` to create a `TooDeeViewMut`.\npub(super) fn from_toodee(start: Coordinate, end: Coordinate, toodee: &'a mut TooDee<T>) -> TooDeeViewMut<'a, T>{\n        let (num_cols, num_rows) = calculate_view_dimensions(start, end, toodee);\n        let main_cols = toodee.num_cols();\n        let data_start = start.1 * main_cols + start.0;\n        let data_len = {\n            if num_rows == 0 {\n                0\n            } else {\n                (num_rows - 1) * main_cols + num_cols\n            }\n        };\n        unsafe {\n            TooDeeViewMut {\n                data: toodee.data_mut().get_unchecked_mut(data_start..data_start + data_len),\n                start,\n                num_cols,\n                num_rows,\n                main_cols,\n            }\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"view::TooDeeViewMut::<'a, T>::new":["/// Create a new `TooDeeViewMut` using the provided mutable slice reference.\n/// \n/// # Panics\n/// \n/// Panics if one of the dimensions is zero but the other is non-zero. This\n/// is to enforce the rule that empty arrays have no dimensions.\n/// \n/// Panics if the slice's length is not sufficient to represent\n/// the desired array dimensions.\n/// \n/// # Examples\n/// \n/// ```\n/// use toodee::TooDeeViewMut;\n/// let mut data = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n/// let view_mut = TooDeeViewMut::new(4, 3, &mut data);\n/// ```\npub fn new(num_cols: usize, num_rows: usize, data: &'a mut [T]) -> TooDeeViewMut<'a, T>{\n        if num_cols == 0 || num_rows == 0 {\n            assert_eq!(num_rows, num_cols);\n        }\n        let size = num_cols * num_rows;\n        assert!(size <= data.len());\n        unsafe {\n            TooDeeViewMut {\n                data : data.get_unchecked_mut(..size),\n                start: (0, 0),\n                num_cols,\n                num_rows,\n                main_cols : num_cols,\n            }\n        }\n    }","Real(LocalPath(\"src/view.rs\"))"],"view::calculate_view_dimensions":["/// Checks the proposed view dimensions, and returns the correct cols and rows for view construction.\nfn calculate_view_dimensions<T>(start: Coordinate, end: Coordinate, toodee: &impl TooDeeOps<T>) -> (usize, usize){\n    assert!(end.0 >= start.0);\n    assert!(end.1 >= start.1);\n    assert!(end.0 <= toodee.num_cols());\n    assert!(end.1 <= toodee.num_rows());\n    let mut num_cols = end.0 - start.0;\n    let mut num_rows = end.1 - start.1;\n    // zero out dimensions for empty arrays\n    if num_cols == 0 || num_rows == 0 {\n        num_cols = 0;\n        num_rows = 0;\n    }\n    (num_cols, num_rows)\n}","Real(LocalPath(\"src/view.rs\"))"]},"struct_constructor":{"&<iter::Col<'a, T> as std::ops::Index<usize>>::Output":["index"],"&<iter::ColMut<'a, T> as std::ops::Index<usize>>::Output":["index"],"&<toodee::TooDee<T> as std::ops::Index<(usize, usize)>>::Output":["index"],"&<toodee::TooDee<T> as std::ops::Index<usize>>::Output":["index"],"&<view::TooDeeView<'a, T> as std::ops::Index<(usize, usize)>>::Output":["index"],"&<view::TooDeeView<'a, T> as std::ops::Index<usize>>::Output":["index"],"&<view::TooDeeViewMut<'a, T> as std::ops::Index<(usize, usize)>>::Output":["index"],"&<view::TooDeeViewMut<'a, T> as std::ops::Index<usize>>::Output":["index"],"&[T]":["as_ref","data","get_unchecked_row"],"&mut <iter::ColMut<'a, T> as std::ops::Index<usize>>::Output":["index_mut"],"&mut <toodee::TooDee<T> as std::ops::Index<(usize, usize)>>::Output":["index_mut"],"&mut <toodee::TooDee<T> as std::ops::Index<usize>>::Output":["index_mut"],"&mut <view::TooDeeViewMut<'a, T> as std::ops::Index<(usize, usize)>>::Output":["index_mut"],"&mut <view::TooDeeViewMut<'a, T> as std::ops::Index<usize>>::Output":["index_mut"],"&mut [T]":["as_mut","data_mut","get_unchecked_row_mut"],"(&mut [T], &mut [T])":["row_pair_mut"],"((usize, usize), (usize, usize))":["bounds"],"(usize, std::option::Option<usize>)":["size_hint"],"(usize, usize)":["size"],"<&'a mut toodee::TooDee<T> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a mut view::TooDeeViewMut<'a, T> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a toodee::TooDee<T> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a view::TooDeeView<'a, T> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a view::TooDeeViewMut<'a, T> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<<I as std::iter::Iterator>::Item as std::iter::IntoIterator>::Item":["next","next_back","nth","nth_back"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::Item":["last"],"<iter::Col<'a, T> as std::iter::Iterator>::Item":["last","next","next_back","nth","nth_back"],"<iter::ColMut<'a, T> as std::iter::Iterator>::Item":["last","next","next_back","nth","nth_back"],"<iter::Rows<'a, T> as std::iter::Iterator>::Item":["last","next","next_back","nth","nth_back"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::Item":["last","next","next_back","nth","nth_back"],"<toodee::TooDee<T> as std::iter::IntoIterator>::IntoIter":["into_iter"],"bool":["eq","is_empty"],"flattenexact::FlattenExact":["cells","cells_mut","new"],"impl FnMut(Acc, U) -> Acc + '_":["flatten"],"iter::Col":["col"],"iter::ColMut":["col_mut"],"iter::Rows":["rows"],"iter::RowsMut":["rows_mut"],"std::boxed::Box":["into"],"std::vec::Drain":["pop_row","remove_row"],"std::vec::Vec":["into"],"toodee::DrainCol":["pop_col","remove_col"],"toodee::TooDee":["clone","default","from","from_box","from_vec","init","new","with_capacity"],"usize":["capacity","count","num_cols","num_rows"],"view::TooDeeView":["clone","from_toodee","into","new","view"],"view::TooDeeViewMut":["from_toodee","new","view_mut"]},"struct_to_trait":{"<O as sort::SortOps<T>>::O":["sort::SortOps"],"<O as translate::TranslateOps<T>>::O":["translate::TranslateOps"],"<toodee::DrainCol<'_, T> as std::ops::Drop>::drop::DropGuard":["std::ops::Drop"],"flattenexact::FlattenExact":["iter::TooDeeIterator","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"iter::Col":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::ops::Index"],"iter::ColMut":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::ops::Index","std::ops::IndexMut"],"iter::Rows":["iter::TooDeeIterator","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"iter::RowsMut":["iter::TooDeeIterator","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"toodee::DrainCol":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync","std::ops::Drop"],"toodee::TooDee":["copy::CopyOps","ops::TooDeeOps","ops::TooDeeOpsMut","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::AsMut","std::convert::AsRef","std::convert::From","std::convert::Into","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::IntoIterator","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Index","std::ops::IndexMut"],"view::TooDeeView":["ops::TooDeeOps","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Index"],"view::TooDeeViewMut":["copy::CopyOps","ops::TooDeeOps","ops::TooDeeOpsMut","std::cmp::Eq","std::cmp::PartialEq","std::convert::Into","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Index","std::ops::IndexMut"]},"targets":{"<&'a mut toodee::TooDee<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/toodee.rs\"))","std::iter::IntoIterator"],"<&'a mut view::TooDeeViewMut<'a, T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/view.rs\"))","std::iter::IntoIterator"],"<&'a toodee::TooDee<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/toodee.rs\"))","std::iter::IntoIterator"],"<&'a view::TooDeeView<'a, T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/view.rs\"))","std::iter::IntoIterator"],"<&'a view::TooDeeViewMut<'a, T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/view.rs\"))","std::iter::IntoIterator"],"<<toodee::DrainCol<'_, T> as std::ops::Drop>::drop::DropGuard<'r, 'a, T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/toodee.rs\"))","std::ops::Drop"],"<flattenexact::FlattenExact<I> as iter::TooDeeIterator>::num_cols":["num_cols","Real(LocalPath(\"src/flattenexact.rs\"))","iter::TooDeeIterator"],"<flattenexact::FlattenExact<I> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/flattenexact.rs\"))","std::iter::DoubleEndedIterator"],"<flattenexact::FlattenExact<I> as std::iter::DoubleEndedIterator>::nth_back":["nth_back","Real(LocalPath(\"src/flattenexact.rs\"))","std::iter::DoubleEndedIterator"],"<flattenexact::FlattenExact<I> as std::iter::DoubleEndedIterator>::rfold":["rfold","Real(LocalPath(\"src/flattenexact.rs\"))","std::iter::DoubleEndedIterator"],"<flattenexact::FlattenExact<I> as std::iter::DoubleEndedIterator>::rfold::flatten":["flatten","Real(LocalPath(\"src/flattenexact.rs\"))",""],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::fold":["fold","Real(LocalPath(\"src/flattenexact.rs\"))","std::iter::Iterator"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::fold::flatten":["flatten","Real(LocalPath(\"src/flattenexact.rs\"))",""],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::last":["last","Real(LocalPath(\"src/flattenexact.rs\"))","std::iter::Iterator"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/flattenexact.rs\"))","std::iter::Iterator"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::nth":["nth","Real(LocalPath(\"src/flattenexact.rs\"))","std::iter::Iterator"],"<flattenexact::FlattenExact<I> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/flattenexact.rs\"))","std::iter::Iterator"],"<iter::Col<'a, T> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iter.rs\"))","std::iter::DoubleEndedIterator"],"<iter::Col<'a, T> as std::iter::DoubleEndedIterator>::nth_back":["nth_back","Real(LocalPath(\"src/iter.rs\"))","std::iter::DoubleEndedIterator"],"<iter::Col<'a, T> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::Col<'a, T> as std::iter::Iterator>::last":["last","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::Col<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::Col<'a, T> as std::iter::Iterator>::nth":["nth","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::Col<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::Col<'a, T> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/iter.rs\"))","std::ops::Index"],"<iter::ColMut<'a, T> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iter.rs\"))","std::iter::DoubleEndedIterator"],"<iter::ColMut<'a, T> as std::iter::DoubleEndedIterator>::nth_back":["nth_back","Real(LocalPath(\"src/iter.rs\"))","std::iter::DoubleEndedIterator"],"<iter::ColMut<'a, T> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::ColMut<'a, T> as std::iter::Iterator>::last":["last","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::ColMut<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::ColMut<'a, T> as std::iter::Iterator>::nth":["nth","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::ColMut<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::ColMut<'a, T> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/iter.rs\"))","std::ops::Index"],"<iter::ColMut<'a, T> as std::ops::IndexMut<usize>>::index_mut":["index_mut","Real(LocalPath(\"src/iter.rs\"))","std::ops::IndexMut"],"<iter::Rows<'_, T> as iter::TooDeeIterator>::num_cols":["num_cols","Real(LocalPath(\"src/iter.rs\"))","iter::TooDeeIterator"],"<iter::Rows<'a, T> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iter.rs\"))","std::iter::DoubleEndedIterator"],"<iter::Rows<'a, T> as std::iter::DoubleEndedIterator>::nth_back":["nth_back","Real(LocalPath(\"src/iter.rs\"))","std::iter::DoubleEndedIterator"],"<iter::Rows<'a, T> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::Rows<'a, T> as std::iter::Iterator>::last":["last","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::Rows<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::Rows<'a, T> as std::iter::Iterator>::nth":["nth","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::Rows<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::RowsMut<'_, T> as iter::TooDeeIterator>::num_cols":["num_cols","Real(LocalPath(\"src/iter.rs\"))","iter::TooDeeIterator"],"<iter::RowsMut<'a, T> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iter.rs\"))","std::iter::DoubleEndedIterator"],"<iter::RowsMut<'a, T> as std::iter::DoubleEndedIterator>::nth_back":["nth_back","Real(LocalPath(\"src/iter.rs\"))","std::iter::DoubleEndedIterator"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::last":["last","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::nth":["nth","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::RowsMut<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<toodee::DrainCol<'_, T> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/toodee.rs\"))","std::iter::DoubleEndedIterator"],"<toodee::DrainCol<'_, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/toodee.rs\"))","std::iter::Iterator"],"<toodee::DrainCol<'_, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/toodee.rs\"))","std::iter::Iterator"],"<toodee::DrainCol<'_, T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/toodee.rs\"))","std::ops::Drop"],"<toodee::TooDee<T> as copy::CopyOps<T>>::clone_from_slice":["clone_from_slice","Real(LocalPath(\"src/copy.rs\"))","copy::CopyOps"],"<toodee::TooDee<T> as copy::CopyOps<T>>::clone_from_toodee":["clone_from_toodee","Real(LocalPath(\"src/copy.rs\"))","copy::CopyOps"],"<toodee::TooDee<T> as copy::CopyOps<T>>::copy_from_slice":["copy_from_slice","Real(LocalPath(\"src/copy.rs\"))","copy::CopyOps"],"<toodee::TooDee<T> as copy::CopyOps<T>>::copy_from_toodee":["copy_from_toodee","Real(LocalPath(\"src/copy.rs\"))","copy::CopyOps"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::bounds":["bounds","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOps"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::col":["col","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOps"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::get_unchecked":["get_unchecked","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOps"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::get_unchecked_row":["get_unchecked_row","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOps"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::num_cols":["num_cols","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOps"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::num_rows":["num_rows","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOps"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::rows":["rows","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOps"],"<toodee::TooDee<T> as ops::TooDeeOps<T>>::view":["view","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOps"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::col_mut":["col_mut","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOpsMut"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::fill":["fill","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOpsMut"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::get_unchecked_mut":["get_unchecked_mut","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOpsMut"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::get_unchecked_row_mut":["get_unchecked_row_mut","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOpsMut"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::rows_mut":["rows_mut","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOpsMut"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::swap_rows":["swap_rows","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOpsMut"],"<toodee::TooDee<T> as ops::TooDeeOpsMut<T>>::view_mut":["view_mut","Real(LocalPath(\"src/toodee.rs\"))","ops::TooDeeOpsMut"],"<toodee::TooDee<T> as std::convert::AsMut<[T]>>::as_mut":["as_mut","Real(LocalPath(\"src/toodee.rs\"))","std::convert::AsMut"],"<toodee::TooDee<T> as std::convert::AsRef<[T]>>::as_ref":["as_ref","Real(LocalPath(\"src/toodee.rs\"))","std::convert::AsRef"],"<toodee::TooDee<T> as std::convert::AsRef<std::vec::Vec<T>>>::as_ref":["as_ref","Real(LocalPath(\"src/toodee.rs\"))","std::convert::AsRef"],"<toodee::TooDee<T> as std::convert::From<view::TooDeeView<'_, T>>>::from":["from","Real(LocalPath(\"src/toodee.rs\"))","std::convert::From"],"<toodee::TooDee<T> as std::convert::From<view::TooDeeViewMut<'_, T>>>::from":["from","Real(LocalPath(\"src/toodee.rs\"))","std::convert::From"],"<toodee::TooDee<T> as std::convert::Into<std::boxed::Box<[T]>>>::into":["into","Real(LocalPath(\"src/toodee.rs\"))","std::convert::Into"],"<toodee::TooDee<T> as std::convert::Into<std::vec::Vec<T>>>::into":["into","Real(LocalPath(\"src/toodee.rs\"))","std::convert::Into"],"<toodee::TooDee<T> as std::default::Default>::default":["default","Real(LocalPath(\"src/toodee.rs\"))","std::default::Default"],"<toodee::TooDee<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/toodee.rs\"))","std::fmt::Debug"],"<toodee::TooDee<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/toodee.rs\"))","std::iter::IntoIterator"],"<toodee::TooDee<T> as std::ops::Index<(usize, usize)>>::index":["index","Real(LocalPath(\"src/toodee.rs\"))","std::ops::Index"],"<toodee::TooDee<T> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/toodee.rs\"))","std::ops::Index"],"<toodee::TooDee<T> as std::ops::IndexMut<(usize, usize)>>::index_mut":["index_mut","Real(LocalPath(\"src/toodee.rs\"))","std::ops::IndexMut"],"<toodee::TooDee<T> as std::ops::IndexMut<usize>>::index_mut":["index_mut","Real(LocalPath(\"src/toodee.rs\"))","std::ops::IndexMut"],"<view::TooDeeView<'_, T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/view.rs\"))","std::fmt::Debug"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::bounds":["bounds","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::col":["col","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::get_unchecked":["get_unchecked","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::get_unchecked_row":["get_unchecked_row","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::num_cols":["num_cols","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::num_rows":["num_rows","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::rows":["rows","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeView<'a, T> as ops::TooDeeOps<T>>::view":["view","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeView<'a, T> as std::ops::Index<(usize, usize)>>::index":["index","Real(LocalPath(\"src/view.rs\"))","std::ops::Index"],"<view::TooDeeView<'a, T> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/view.rs\"))","std::ops::Index"],"<view::TooDeeViewMut<'_, T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/view.rs\"))","std::fmt::Debug"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::bounds":["bounds","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::col":["col","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::get_unchecked":["get_unchecked","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::get_unchecked_row":["get_unchecked_row","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::num_cols":["num_cols","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::num_rows":["num_rows","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::rows":["rows","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOps<T>>::view":["view","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOps"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::col_mut":["col_mut","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOpsMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::get_unchecked_mut":["get_unchecked_mut","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOpsMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::get_unchecked_row_mut":["get_unchecked_row_mut","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOpsMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::rows_mut":["rows_mut","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOpsMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::swap_rows":["swap_rows","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOpsMut"],"<view::TooDeeViewMut<'a, T> as ops::TooDeeOpsMut<T>>::view_mut":["view_mut","Real(LocalPath(\"src/view.rs\"))","ops::TooDeeOpsMut"],"<view::TooDeeViewMut<'a, T> as std::convert::Into<view::TooDeeView<'a, T>>>::into":["into","Real(LocalPath(\"src/view.rs\"))","std::convert::Into"],"<view::TooDeeViewMut<'a, T> as std::ops::Index<(usize, usize)>>::index":["index","Real(LocalPath(\"src/view.rs\"))","std::ops::Index"],"<view::TooDeeViewMut<'a, T> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/view.rs\"))","std::ops::Index"],"<view::TooDeeViewMut<'a, T> as std::ops::IndexMut<(usize, usize)>>::index_mut":["index_mut","Real(LocalPath(\"src/view.rs\"))","std::ops::IndexMut"],"<view::TooDeeViewMut<'a, T> as std::ops::IndexMut<usize>>::index_mut":["index_mut","Real(LocalPath(\"src/view.rs\"))","std::ops::IndexMut"],"copy::CopyOps::clone_from_slice":["clone_from_slice","Real(LocalPath(\"src/copy.rs\"))",""],"copy::CopyOps::clone_from_toodee":["clone_from_toodee","Real(LocalPath(\"src/copy.rs\"))",""],"copy::CopyOps::copy_from_slice":["copy_from_slice","Real(LocalPath(\"src/copy.rs\"))",""],"copy::CopyOps::copy_from_toodee":["copy_from_toodee","Real(LocalPath(\"src/copy.rs\"))",""],"copy::CopyOps::copy_within":["copy_within","Real(LocalPath(\"src/copy.rs\"))",""],"flattenexact::FlattenExact::<I>::new":["new","Real(LocalPath(\"src/flattenexact.rs\"))",""],"ops::TooDeeOps::cells":["cells","Real(LocalPath(\"src/ops.rs\"))",""],"ops::TooDeeOps::is_empty":["is_empty","Real(LocalPath(\"src/ops.rs\"))",""],"ops::TooDeeOps::size":["size","Real(LocalPath(\"src/ops.rs\"))",""],"ops::TooDeeOpsMut::cells_mut":["cells_mut","Real(LocalPath(\"src/ops.rs\"))",""],"ops::TooDeeOpsMut::fill":["fill","Real(LocalPath(\"src/ops.rs\"))",""],"ops::TooDeeOpsMut::row_pair_mut":["row_pair_mut","Real(LocalPath(\"src/ops.rs\"))",""],"ops::TooDeeOpsMut::swap_cols":["swap_cols","Real(LocalPath(\"src/ops.rs\"))",""],"ops::TooDeeOpsMut::swap_rows":["swap_rows","Real(LocalPath(\"src/ops.rs\"))",""],"sort::SortOps::sort_by_col":["sort_by_col","Real(LocalPath(\"src/sort.rs\"))",""],"sort::SortOps::sort_by_col_key":["sort_by_col_key","Real(LocalPath(\"src/sort.rs\"))",""],"sort::SortOps::sort_by_row":["sort_by_row","Real(LocalPath(\"src/sort.rs\"))",""],"sort::SortOps::sort_by_row_key":["sort_by_row_key","Real(LocalPath(\"src/sort.rs\"))",""],"sort::SortOps::sort_col_ord":["sort_col_ord","Real(LocalPath(\"src/sort.rs\"))",""],"sort::SortOps::sort_row_ord":["sort_row_ord","Real(LocalPath(\"src/sort.rs\"))",""],"sort::SortOps::sort_unstable_by_col":["sort_unstable_by_col","Real(LocalPath(\"src/sort.rs\"))",""],"sort::SortOps::sort_unstable_by_col_key":["sort_unstable_by_col_key","Real(LocalPath(\"src/sort.rs\"))",""],"sort::SortOps::sort_unstable_by_row":["sort_unstable_by_row","Real(LocalPath(\"src/sort.rs\"))",""],"sort::SortOps::sort_unstable_by_row_key":["sort_unstable_by_row_key","Real(LocalPath(\"src/sort.rs\"))",""],"sort::SortOps::sort_unstable_row_ord":["sort_unstable_row_ord","Real(LocalPath(\"src/sort.rs\"))",""],"sort::build_swap_trace":["build_swap_trace","Real(LocalPath(\"src/sort.rs\"))",""],"sort::sorted_box_to_ordering":["sorted_box_to_ordering","Real(LocalPath(\"src/sort.rs\"))",""],"toodee::TooDee::<T>::capacity":["capacity","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::clear":["clear","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::data":["data","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::data_mut":["data_mut","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::from_box":["from_box","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::from_vec":["from_vec","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::init":["init","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::insert_col":["insert_col","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::insert_row":["insert_row","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::new":["new","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::pop_col":["pop_col","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::pop_row":["pop_row","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::push_col":["push_col","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::push_row":["push_row","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::remove_col":["remove_col","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::remove_row":["remove_row","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::reserve":["reserve","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::reserve_exact":["reserve_exact","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::shrink_to_fit":["shrink_to_fit","Real(LocalPath(\"src/toodee.rs\"))",""],"toodee::TooDee::<T>::with_capacity":["with_capacity","Real(LocalPath(\"src/toodee.rs\"))",""],"translate::TranslateOps::flip_cols":["flip_cols","Real(LocalPath(\"src/translate.rs\"))",""],"translate::TranslateOps::flip_rows":["flip_rows","Real(LocalPath(\"src/translate.rs\"))",""],"translate::TranslateOps::translate_with_wrap":["translate_with_wrap","Real(LocalPath(\"src/translate.rs\"))",""],"view::TooDeeView::<'a, T>::from_toodee":["from_toodee","Real(LocalPath(\"src/view.rs\"))",""],"view::TooDeeView::<'a, T>::new":["new","Real(LocalPath(\"src/view.rs\"))",""],"view::TooDeeViewMut::<'a, T>::from_toodee":["from_toodee","Real(LocalPath(\"src/view.rs\"))",""],"view::TooDeeViewMut::<'a, T>::new":["new","Real(LocalPath(\"src/view.rs\"))",""],"view::calculate_view_dimensions":["calculate_view_dimensions","Real(LocalPath(\"src/view.rs\"))",""]},"trait_to_struct":{"copy::CopyOps":["toodee::TooDee","view::TooDeeViewMut"],"iter::TooDeeIterator":["flattenexact::FlattenExact","iter::Rows","iter::RowsMut"],"ops::TooDeeOps":["toodee::TooDee","view::TooDeeView","view::TooDeeViewMut"],"ops::TooDeeOpsMut":["toodee::TooDee","view::TooDeeViewMut"],"sort::SortOps":["<O as sort::SortOps<T>>::O"],"std::clone::Clone":["toodee::TooDee","view::TooDeeView"],"std::cmp::Eq":["toodee::TooDee","view::TooDeeView","view::TooDeeViewMut"],"std::cmp::PartialEq":["toodee::TooDee","view::TooDeeView","view::TooDeeViewMut"],"std::convert::AsMut":["toodee::TooDee"],"std::convert::AsRef":["toodee::TooDee"],"std::convert::From":["toodee::TooDee"],"std::convert::Into":["toodee::TooDee","view::TooDeeViewMut"],"std::default::Default":["toodee::TooDee"],"std::fmt::Debug":["iter::Col","iter::ColMut","iter::Rows","iter::RowsMut","toodee::DrainCol","toodee::TooDee","view::TooDeeView","view::TooDeeViewMut"],"std::hash::Hash":["toodee::TooDee","view::TooDeeView","view::TooDeeViewMut"],"std::iter::DoubleEndedIterator":["flattenexact::FlattenExact","iter::Col","iter::ColMut","iter::Rows","iter::RowsMut","toodee::DrainCol"],"std::iter::ExactSizeIterator":["flattenexact::FlattenExact","iter::Col","iter::ColMut","iter::Rows","iter::RowsMut","toodee::DrainCol"],"std::iter::IntoIterator":["toodee::TooDee"],"std::iter::Iterator":["flattenexact::FlattenExact","iter::Col","iter::ColMut","iter::Rows","iter::RowsMut","toodee::DrainCol"],"std::marker::Copy":["view::TooDeeView"],"std::marker::Send":["toodee::DrainCol"],"std::marker::StructuralEq":["toodee::TooDee","view::TooDeeView","view::TooDeeViewMut"],"std::marker::StructuralPartialEq":["toodee::TooDee","view::TooDeeView","view::TooDeeViewMut"],"std::marker::Sync":["toodee::DrainCol"],"std::ops::Drop":["<toodee::DrainCol<'_, T> as std::ops::Drop>::drop::DropGuard","toodee::DrainCol"],"std::ops::Index":["iter::Col","iter::ColMut","toodee::TooDee","view::TooDeeView","view::TooDeeViewMut"],"std::ops::IndexMut":["iter::ColMut","toodee::TooDee","view::TooDeeViewMut"],"translate::TranslateOps":["<O as translate::TranslateOps<T>>::O"]},"type_to_def_path":{"<toodee::DrainCol<'_, T> as std::ops::Drop>::drop::DropGuard<'r, 'a, T>":"<toodee::DrainCol<'_, T> as std::ops::Drop>::drop::DropGuard","flattenexact::FlattenExact<I>":"flattenexact::FlattenExact","iter::Col<'a, T>":"iter::Col","iter::ColMut<'a, T>":"iter::ColMut","iter::Rows<'a, T>":"iter::Rows","iter::RowsMut<'a, T>":"iter::RowsMut","toodee::DrainCol<'a, T>":"toodee::DrainCol","toodee::TooDee<T>":"toodee::TooDee","view::TooDeeView<'a, T>":"view::TooDeeView","view::TooDeeViewMut<'a, T>":"view::TooDeeViewMut"}}