-----------------
/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs debt::THREAD_HEAD::__init
deps:{}
candidates:{}
+debt::THREAD_HEAD::__init();
+crate::debt::THREAD_HEAD::__init();
+crate::debt::THREAD_HEAD::__init();
-----------------
/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs debt::THREAD_HEAD::__getit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<&mut std::option::Option<debt::DebtHead>>
+debt::THREAD_HEAD::__getit(p0);
+crate::debt::THREAD_HEAD::__getit(p0);
+crate::debt::THREAD_HEAD::__getit(p0);
-----------------
src/debt.rs debt::traverse
deps:{"debt::traverse":{"F":["std::ops::FnMut","std::marker::Sized"],"R":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"debt::traverse":{"F":["core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"],"R":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+debt::traverse(p0);
+crate::debt::traverse(p0);
+crate::debt::traverse(p0);
-----------------
src/gen_lock.rs gen_lock::snapshot
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [std::sync::atomic::AtomicUsize; _]
+gen_lock::snapshot(p0);
+crate::gen_lock::snapshot(p0);
+crate::gen_lock::snapshot(p0);
-----------------
/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs gen_lock::THREAD_SHARD::__init
deps:{}
candidates:{}
+gen_lock::THREAD_SHARD::__init();
+crate::gen_lock::THREAD_SHARD::__init();
+crate::gen_lock::THREAD_SHARD::__init();
-----------------
/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs gen_lock::THREAD_SHARD::__getit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<&mut std::option::Option<std::cell::Cell<usize>>>
+gen_lock::THREAD_SHARD::__getit(p0);
+crate::gen_lock::THREAD_SHARD::__getit(p0);
+crate::gen_lock::THREAD_SHARD::__getit(p0);
-----------------
src/gen_lock.rs gen_lock::wait_for_readers
deps:{"gen_lock::wait_for_readers":{"S":["gen_lock::LockStorage","std::marker::Sized"]}}
candidates:{"gen_lock::wait_for_readers":{"S":["gen_lock::Global","gen_lock::PrivateUnsharded"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // S
+gen_lock::wait_for_readers(p0);
+crate::gen_lock::wait_for_readers(p0);
+crate::gen_lock::wait_for_readers(p0);
-----------------
src/lib.rs ptr_eq
deps:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::marker::Sized","std::default::Default","std::fmt::Display","std::fmt::Debug"]},"ptr_eq":{"A":["as_raw::AsRaw","std::marker::Sized"],"B":["as_raw::AsRaw","std::marker::Sized"],"Base":["std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::marker::Copy","std::marker::Sized","std::clone::Clone","std::default::Default"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::clone::Clone","strategy::sealed::InnerStrategy","std::marker::Sized"]}}
candidates:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","std::sync::RwLock","strategy::gen_lock::GenLockStrategy"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc<T>","std::sync::Arc<T>"]},"ptr_eq":{"A":["<*mut T as as_raw::AsRaw<T>>","Guard"],"B":["Guard","<*const T as as_raw::AsRaw<T>>","<*mut T as as_raw::AsRaw<T>>"],"Base":["RUG_ANY"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // A
let mut p1 = MaybeUninit::uninit().assume_init(); // B
+ptr_eq(p0, p1);
+crate::ptr_eq(p0, p1);
+crate::ptr_eq(p0, p1);
-----------------
src/access.rs access::Access::load
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<P as access::Access<T>>":{"P":["std::ops::Deref","std::marker::Sized"]},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"ArcSwapAny":{"S":["std::default::Default","strategy::Strategy","std::marker::Sized"],"T":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::default::Default","ref_cnt::RefCnt"]},"Guard":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::marker::Sized","std::fmt::Display","ref_cnt::RefCnt","std::default::Default","std::fmt::Debug"]},"access::Access::load":{"Self":["access::Access"],"T":["std::marker::Sized"]},"access::Constant":{"T":["std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Ord","std::cmp::Eq"]},"access::ConstantDeref":{"T":["std::hash::Hash","std::fmt::Debug","std::marker::Copy","std::cmp::PartialOrd","std::clone::Clone","std::cmp::PartialEq","std::cmp::Ord","std::marker::Sized","std::cmp::Eq"]},"access::DirectDeref":{"S":["std::marker::Sized","strategy::Strategy","std::fmt::Debug"],"T":["ref_cnt::RefCnt","std::fmt::Debug","std::marker::Sized"]},"access::Map":{"A":["std::marker::Copy","access::Access","std::fmt::Debug","std::clone::Clone","std::marker::Sized"],"F":["std::ops::Fn","std::marker::Copy","std::fmt::Debug","std::clone::Clone","std::marker::Sized"],"T":["std::marker::Copy","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"access::MapGuard":{"G":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Copy","std::marker::Sync"],"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::marker::Copy"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::clone::Clone","std::marker::Copy","std::default::Default","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","strategy::sealed::InnerStrategy","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<P as access::Access<T>>":{"P":["access::DynGuard","<&T as std::ops::Deref>","Guard","access::ConstantDeref","access::DirectDeref","access::MapGuard"]},"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc<T>","std::sync::Arc<T>"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc","std::sync::Arc<T>","std::rc::Rc<T>"]},"access::Access::load":{"Self":["access::Map","<P as access::Access<T>>","access::Constant","ArcSwapAny"],"T":["RUG_ANY"]},"access::Constant":{"T":["std::ptr::const_ptr::<impl std::cmp::Ord for *const T>","access::Constant","access::ConstantDeref"]},"access::ConstantDeref":{"T":["<*const T as std::fmt::Debug>","access::Constant","access::ConstantDeref"]},"access::DirectDeref":{"T":["std::rc::Rc<T>","std::option::Option<T>","std::sync::Arc<T>","std::rc::Rc"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["access::MapGuard","access::ConstantDeref","access::Constant","access::Map","<&T as std::fmt::Debug>"]},"access::MapGuard":{"G":["<*mut T as std::marker::Sync>","access::MapGuard"],"T":["access::MapGuard","access::Constant","access::Map","access::ConstantDeref","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.load();
+access::Access::load(p0);
+crate::access::Access::load(p0);
+crate::access::Access::load(p0);
-----------------
src/access.rs access::DynAccess::load
deps:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<A as access::DynAccess<T>>":{"A":["std::marker::Sized","access::Access"]},"<P as access::Access<T>>":{"P":["std::ops::Deref","std::marker::Sized"]},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"ArcSwapAny":{"S":["strategy::Strategy","std::default::Default","std::marker::Sized"],"T":["std::marker::Sized","std::default::Default","std::fmt::Debug","ref_cnt::RefCnt","std::fmt::Display"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::fmt::Display","std::default::Default","std::fmt::Debug"]},"access::Constant":{"T":["std::clone::Clone","std::fmt::Debug","std::cmp::Ord","std::marker::Copy","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::cmp::PartialOrd","std::hash::Hash"]},"access::ConstantDeref":{"T":["std::cmp::PartialEq","std::cmp::Ord","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialOrd","std::marker::Copy","std::cmp::Eq","std::hash::Hash"]},"access::DirectDeref":{"S":["strategy::Strategy","std::marker::Sized","std::fmt::Debug"],"T":["ref_cnt::RefCnt","std::fmt::Debug","std::marker::Sized"]},"access::DynAccess::load":{"Self":["access::DynAccess"],"T":["std::marker::Sized"]},"access::Map":{"A":["access::Access","std::marker::Sized","std::clone::Clone","std::marker::Copy","std::fmt::Debug"],"F":["std::marker::Sized","std::marker::Copy","std::clone::Clone","std::fmt::Debug","std::ops::Fn"],"T":["std::fmt::Debug","std::clone::Clone","std::marker::Copy","std::marker::Sized"]},"access::MapGuard":{"G":["std::marker::Copy","std::clone::Clone","std::marker::Send","std::marker::Sized","std::marker::Sync","std::fmt::Debug"],"T":["std::marker::Sized","std::marker::Copy","std::clone::Clone","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Copy","std::default::Default","std::clone::Clone","std::marker::Sized","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","std::default::Default","strategy::sealed::InnerStrategy","std::clone::Clone"]}}
candidates:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<A as access::DynAccess<T>>":{"A":["access::Constant","access::Map","ArcSwapAny","<P as access::Access<T>>"]},"<P as access::Access<T>>":{"P":["access::DirectDeref","Guard","access::MapGuard","<&T as std::ops::Deref>","access::ConstantDeref","access::DynGuard"]},"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc<T>","std::sync::Arc<T>","std::sync::Arc","std::rc::Rc"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc<T>","std::sync::Arc<T>"]},"access::Constant":{"T":["access::ConstantDeref","access::Constant","std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>"]},"access::ConstantDeref":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","access::Constant","access::ConstantDeref"]},"access::DirectDeref":{"T":["std::sync::Arc<T>","std::rc::Rc<T>","std::option::Option<T>","std::option::Option"]},"access::DynAccess::load":{"Self":["<A as access::DynAccess<T>>"],"T":["RUG_ANY"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["access::Constant","access::ConstantDeref","access::Map","access::MapGuard","std::clone::impls::<impl std::clone::Clone for &T>"]},"access::MapGuard":{"G":["access::MapGuard","<*const T as std::marker::Send>"],"T":["access::Map","access::ConstantDeref","access::MapGuard","std::clone::impls::<impl std::clone::Clone for *mut T>","access::Constant"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.load();
+access::DynAccess::load(p0);
+crate::access::DynAccess::load(p0);
+crate::access::DynAccess::load(p0);
-----------------
src/as_raw.rs as_raw::AsRaw::as_raw
deps:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::default::Default","std::marker::Sized","std::fmt::Debug","std::fmt::Display","ref_cnt::RefCnt"]},"as_raw::<impl as_raw::sealed::Sealed for &'a T>":{},"as_raw::<impl as_raw::sealed::Sealed for *mut T>":{},"as_raw::AsRaw::as_raw":{"Self":["as_raw::sealed::Sealed","as_raw::AsRaw"],"T":["std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::clone::Clone","gen_lock::LockStorage","std::default::Default","std::marker::Copy"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","strategy::sealed::InnerStrategy","std::marker::Sized","std::default::Default"]}}
candidates:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock","strategy::hybrid::HybridStrategy"]},"Guard":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>","<S as strategy::Strategy<T>>"],"T":["std::sync::Arc<T>","std::rc::Rc<T>","std::rc::Rc"]},"as_raw::<impl as_raw::sealed::Sealed for &'a T>":{},"as_raw::<impl as_raw::sealed::Sealed for *mut T>":{},"as_raw::AsRaw::as_raw":{"Self":["<*const T as as_raw::AsRaw<T>>","as_raw::<impl as_raw::sealed::Sealed for &'a T>","Guard"],"T":["RUG_ANY"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.as_raw();
+as_raw::AsRaw::as_raw(p0);
+crate::as_raw::AsRaw::as_raw(p0);
+crate::as_raw::AsRaw::as_raw(p0);
-----------------
src/cache.rs cache::Access::load
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"access::Constant":{"T":["std::cmp::PartialOrd","std::cmp::Eq","std::marker::Copy","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::hash::Hash","std::cmp::Ord","std::fmt::Debug"]},"access::ConstantDeref":{"T":["std::marker::Sized","std::hash::Hash","std::marker::Copy","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::Eq","std::cmp::Ord","std::clone::Clone","std::cmp::PartialEq"]},"access::Map":{"A":["std::fmt::Debug","std::marker::Copy","std::marker::Sized","access::Access","std::clone::Clone"],"F":["std::marker::Sized","std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::ops::Fn"],"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::marker::Copy"]},"access::MapGuard":{"G":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::marker::Send","std::marker::Sync","std::marker::Copy"],"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::marker::Copy"]},"cache::Access::load":{"Self":["cache::Access"],"T":["std::marker::Sized"]},"cache::Cache":{"A":["std::marker::Sized","std::fmt::Debug","std::ops::Deref","std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","ref_cnt::RefCnt","std::ops::Deref"]},"cache::MapCache":{"A":["std::clone::Clone","std::ops::Deref","std::marker::Sized","std::fmt::Debug"],"F":["std::ops::FnMut","std::marker::Sized","std::clone::Clone","std::fmt::Debug"],"T":["std::clone::Clone","ref_cnt::RefCnt","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"access::Constant":{"T":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","access::Constant","access::ConstantDeref"]},"access::ConstantDeref":{"T":["access::ConstantDeref","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","access::Constant"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["std::marker::copy_impls::<impl std::marker::Copy for *mut T>","access::Map","access::ConstantDeref","access::MapGuard","access::Constant"]},"access::MapGuard":{"G":["access::MapGuard","std::clone::impls::<impl std::clone::Clone for *const T>"],"T":["access::Map","access::MapGuard","access::Constant","<*mut T as std::fmt::Debug>","access::ConstantDeref"]},"cache::Access::load":{"Self":["cache::MapCache","cache::Cache"],"T":["RUG_ANY"]},"cache::Cache":{"A":["access::ConstantDeref","<&T as std::fmt::Debug>","access::MapGuard"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"cache::MapCache":{"A":["access::MapGuard","std::clone::impls::<impl std::clone::Clone for &T>","access::ConstantDeref"],"T":["std::sync::Arc<T>","std::option::Option<T>","std::rc::Rc<T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.load();
+cache::Access::load(p0);
+crate::cache::Access::load(p0);
+crate::cache::Access::load(p0);
-----------------
src/gen_lock.rs gen_lock::LockStorage::gen_idx
deps:{"gen_lock::LockStorage::gen_idx":{"Self":["std::default::Default","gen_lock::LockStorage"]}}
candidates:{"gen_lock::LockStorage::gen_idx":{"Self":["gen_lock::PrivateUnsharded","gen_lock::Global"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.gen_idx();
+gen_lock::LockStorage::gen_idx(p0);
+crate::gen_lock::LockStorage::gen_idx(p0);
+crate::gen_lock::LockStorage::gen_idx(p0);
-----------------
src/gen_lock.rs gen_lock::LockStorage::shards
deps:{"gen_lock::LockStorage::shards":{"Self":["std::default::Default","gen_lock::LockStorage"]}}
candidates:{"gen_lock::LockStorage::shards":{"Self":["gen_lock::Global","gen_lock::PrivateUnsharded"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.shards();
+gen_lock::LockStorage::shards(p0);
+crate::gen_lock::LockStorage::shards(p0);
+crate::gen_lock::LockStorage::shards(p0);
-----------------
src/gen_lock.rs gen_lock::LockStorage::choose_shard
deps:{"gen_lock::LockStorage::choose_shard":{"Self":["gen_lock::LockStorage","std::default::Default"]}}
candidates:{"gen_lock::LockStorage::choose_shard":{"Self":["gen_lock::Global","gen_lock::PrivateUnsharded"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.choose_shard();
+gen_lock::LockStorage::choose_shard(p0);
+crate::gen_lock::LockStorage::choose_shard(p0);
+crate::gen_lock::LockStorage::choose_shard(p0);
-----------------
src/ref_cnt.rs ref_cnt::RefCnt::into_ptr
deps:{"ref_cnt::RefCnt::into_ptr":{"Self":["ref_cnt::RefCnt","std::clone::Clone"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]}}
candidates:{"ref_cnt::RefCnt::into_ptr":{"Self":["std::option::Option","std::rc::Rc"]},"std::option::Option":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+ref_cnt::RefCnt::into_ptr(p0);
+crate::ref_cnt::RefCnt::into_ptr(p0);
+crate::ref_cnt::RefCnt::into_ptr(p0);
-----------------
src/ref_cnt.rs ref_cnt::RefCnt::as_ptr
deps:{"ref_cnt::RefCnt::as_ptr":{"Self":["std::clone::Clone","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"ref_cnt::RefCnt::as_ptr":{"Self":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+ref_cnt::RefCnt::as_ptr(p0);
+crate::ref_cnt::RefCnt::as_ptr(p0);
+crate::ref_cnt::RefCnt::as_ptr(p0);
-----------------
src/ref_cnt.rs ref_cnt::RefCnt::from_ptr
deps:{"ref_cnt::RefCnt::from_ptr":{"Self":["std::clone::Clone","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"ref_cnt::RefCnt::from_ptr":{"Self":["std::option::Option","std::rc::Rc"]},"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // *const <Self as ref_cnt::RefCnt>::Base
+ref_cnt::RefCnt::from_ptr(p0);
+crate::ref_cnt::RefCnt::from_ptr(p0);
+crate::ref_cnt::RefCnt::from_ptr(p0);
-----------------
src/ref_cnt.rs ref_cnt::RefCnt::inc
deps:{"ref_cnt::RefCnt::inc":{"Self":["std::clone::Clone","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"ref_cnt::RefCnt::inc":{"Self":["std::option::Option<T>","std::sync::Arc","std::option::Option","std::rc::Rc<T>","std::sync::Arc<T>"]},"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+ref_cnt::RefCnt::inc(p0);
+crate::ref_cnt::RefCnt::inc(p0);
+crate::ref_cnt::RefCnt::inc(p0);
-----------------
src/ref_cnt.rs ref_cnt::RefCnt::dec
deps:{"ref_cnt::RefCnt::dec":{"Self":["std::clone::Clone","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"ref_cnt::RefCnt::dec":{"Self":["std::option::Option","std::option::Option<T>","std::sync::Arc<T>","std::sync::Arc","std::rc::Rc<T>"]},"std::option::Option":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // *const <Self as ref_cnt::RefCnt>::Base
+ref_cnt::RefCnt::dec(p0);
+crate::ref_cnt::RefCnt::dec(p0);
+crate::ref_cnt::RefCnt::dec(p0);
-----------------
src/strategy/mod.rs strategy::sealed::Protected::into_inner
deps:{"<T as std::borrow::Borrow<T>>":{},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::hybrid::HybridProtection":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::rw_lock::<impl strategy::sealed::Protected<T> for T>":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::sealed::Protected::into_inner":{"Self":["strategy::sealed::Protected","std::borrow::Borrow"],"T":["std::marker::Sized"]}}
candidates:{"<T as std::borrow::Borrow<T>>":{},"std::option::Option":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]},"strategy::hybrid::HybridProtection":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"strategy::rw_lock::<impl strategy::sealed::Protected<T> for T>":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"strategy::sealed::Protected::into_inner":{"Self":["strategy::rw_lock::<impl strategy::sealed::Protected<T> for T>","<T as std::borrow::Borrow<T>>","strategy::hybrid::HybridProtection"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.into_inner();
+strategy::sealed::Protected::into_inner(p0);
+crate::strategy::sealed::Protected::into_inner(p0);
+crate::strategy::sealed::Protected::into_inner(p0);
-----------------
src/strategy/mod.rs strategy::sealed::Protected::from_inner
deps:{"<T as std::borrow::Borrow<T>>":{},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::hybrid::HybridProtection":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::sealed::Protected::from_inner":{"Self":["std::borrow::Borrow","strategy::sealed::Protected"],"T":["std::marker::Sized"]}}
candidates:{"<T as std::borrow::Borrow<T>>":{},"std::option::Option":{"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]},"strategy::hybrid::HybridProtection":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"strategy::sealed::Protected::from_inner":{"Self":["strategy::hybrid::HybridProtection","<T as std::borrow::Borrow<T>>"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+strategy::sealed::Protected::from_inner(p0);
+crate::strategy::sealed::Protected::from_inner(p0);
+crate::strategy::sealed::Protected::from_inner(p0);
-----------------
src/strategy/mod.rs strategy::sealed::InnerStrategy::load
deps:{"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::clone::Clone","gen_lock::LockStorage","std::marker::Copy","std::marker::Sized","std::default::Default"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","std::clone::Clone","strategy::sealed::InnerStrategy","std::default::Default"]},"strategy::sealed::InnerStrategy::load":{"Self":["strategy::sealed::InnerStrategy"],"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"std::option::Option":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]},"strategy::sealed::InnerStrategy::load":{"Self":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock","strategy::hybrid::HybridStrategy"],"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::sync::atomic::AtomicPtr<<T as ref_cnt::RefCnt>::Base>
+p0.load(p1);
+strategy::sealed::InnerStrategy::load(p0, p1);
+crate::strategy::sealed::InnerStrategy::load(p0, p1);
+crate::strategy::sealed::InnerStrategy::load(p0, p1);
-----------------
src/strategy/mod.rs strategy::sealed::InnerStrategy::wait_for_readers
deps:{"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::clone::Clone","std::marker::Copy","std::default::Default","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::marker::Sized","std::clone::Clone","std::default::Default"]},"strategy::sealed::InnerStrategy::wait_for_readers":{"Self":["strategy::sealed::InnerStrategy"],"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]},"strategy::sealed::InnerStrategy::wait_for_readers":{"Self":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock","strategy::hybrid::HybridStrategy"],"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // *const <T as ref_cnt::RefCnt>::Base
+p0.wait_for_readers(p1);
+strategy::sealed::InnerStrategy::wait_for_readers(p0, p1);
+crate::strategy::sealed::InnerStrategy::wait_for_readers(p0, p1);
+crate::strategy::sealed::InnerStrategy::wait_for_readers(p0, p1);
-----------------
src/strategy/mod.rs strategy::sealed::CaS::compare_and_swap
deps:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::default::Default","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::default::Default","std::marker::Sized","std::clone::Clone","std::marker::Copy"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","std::default::Default","std::marker::Sized","strategy::sealed::InnerStrategy"]},"strategy::sealed::CaS::compare_and_swap":{"C":["as_raw::AsRaw","std::marker::Sized"],"Self":["strategy::sealed::InnerStrategy","strategy::sealed::CaS"],"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc","std::sync::Arc"]},"std::option::Option":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]},"strategy::sealed::CaS::compare_and_swap":{"C":["<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>","Guard"],"Self":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock"],"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::sync::atomic::AtomicPtr<<T as ref_cnt::RefCnt>::Base>
let mut p2 = MaybeUninit::uninit().assume_init(); // C
let mut p3 = MaybeUninit::uninit().assume_init(); // T
+p0.compare_and_swap(p1, p2, p3);
+strategy::sealed::CaS::compare_and_swap(p0, p1, p2, p3);
+crate::strategy::sealed::CaS::compare_and_swap(p0, p1, p2, p3);
+crate::strategy::sealed::CaS::compare_and_swap(p0, p1, p2, p3);
-----------------
src/access.rs <P as access::Access<T>>::load
deps:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<P as access::Access<T>>":{"P":["std::marker::Sized","std::ops::Deref"]},"<P as access::Access<T>>::load":{"A":["std::marker::Sized","access::Access"],"P":["std::marker::Sized","std::ops::Deref"],"T":["std::marker::Sized"]},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"ArcSwapAny":{"S":["strategy::Strategy","std::default::Default","std::marker::Sized"],"T":["std::fmt::Display","ref_cnt::RefCnt","std::default::Default","std::fmt::Debug","std::marker::Sized"]},"Guard":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::fmt::Debug","std::fmt::Display","std::default::Default"]},"access::Constant":{"T":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Copy","std::marker::Sized","std::cmp::PartialEq","std::hash::Hash","std::cmp::PartialOrd","std::cmp::Ord"]},"access::ConstantDeref":{"T":["std::marker::Sized","std::marker::Copy","std::clone::Clone","std::cmp::Ord","std::cmp::PartialEq","std::cmp::Eq","std::cmp::PartialOrd","std::hash::Hash","std::fmt::Debug"]},"access::DirectDeref":{"S":["std::fmt::Debug","std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::fmt::Debug"]},"access::Map":{"A":["std::marker::Copy","std::fmt::Debug","access::Access","std::marker::Sized","std::clone::Clone"],"F":["std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::ops::Fn","std::marker::Sized"],"T":["std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::marker::Sized"]},"access::MapGuard":{"G":["std::fmt::Debug","std::marker::Send","std::clone::Clone","std::marker::Copy","std::marker::Sync","std::marker::Sized"],"T":["std::marker::Copy","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Copy","gen_lock::LockStorage","std::marker::Sized","std::default::Default","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","std::marker::Sized","strategy::sealed::InnerStrategy","std::default::Default"]}}
candidates:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<P as access::Access<T>>":{"P":["access::DirectDeref","<&mut T as std::ops::Deref>","Guard","access::DynGuard","access::MapGuard","access::ConstantDeref"]},"<P as access::Access<T>>::load":{"A":["access::Constant","ArcSwapAny","<P as access::Access<T>>","access::Map"],"P":["access::ConstantDeref","access::MapGuard","<&mut T as std::ops::Deref>","Guard","access::DirectDeref","<&T as std::ops::Deref>","access::DynGuard"],"T":["RUG_ANY"]},"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","std::sync::RwLock","strategy::gen_lock::GenLockStrategy"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc<T>","std::sync::Arc<T>"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc","std::rc::Rc"]},"access::Constant":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>","access::Constant","access::ConstantDeref"]},"access::ConstantDeref":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","access::ConstantDeref","access::Constant"]},"access::DirectDeref":{"T":["std::sync::Arc","std::option::Option"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["access::Constant","access::ConstantDeref","std::clone::impls::<impl std::clone::Clone for *const T>","access::MapGuard","access::Map"]},"access::MapGuard":{"G":["<*const T as std::fmt::Debug>","access::MapGuard"],"T":["access::Constant","access::MapGuard","access::ConstantDeref","std::marker::copy_impls::<impl std::marker::Copy for *mut T>","access::Map"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // P
+p0.load();
+<P as access::Access<T>>::load(p0);
+crate::<P as access::Access<T>>::load(p0);
+<P>::load(p0);
-----------------
src/access.rs <ArcSwapAny<T, S> as access::Access<T>>::load
deps:{"<ArcSwapAny<T, S> as access::Access<T>>::load":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","gen_lock::LockStorage","std::marker::Copy","std::clone::Clone","std::default::Default"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::clone::Clone","std::default::Default","std::marker::Sized"]}}
candidates:{"<ArcSwapAny<T, S> as access::Access<T>>::load":{"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock","strategy::hybrid::HybridStrategy"]},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ArcSwapAny<T, S>
+p0.load();
+<ArcSwapAny<T, S> as access::Access<T>>::load(p0);
+crate::<ArcSwapAny<T, S> as access::Access<T>>::load(p0);
+<ArcSwapAny<T, S>>::load(p0);
-----------------
src/access.rs <access::DirectDeref<T, S> as std::fmt::Debug>::fmt
deps:{"<access::DirectDeref<T, S> as std::fmt::Debug>::fmt":{"S":["std::marker::Sized","std::fmt::Debug","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<access::DirectDeref<T, S> as std::fmt::Debug>::fmt":{"T":["std::rc::Rc","std::sync::Arc","std::rc::Rc<T>","std::sync::Arc<T>","std::option::Option<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::DirectDeref<T, S>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<access::DirectDeref<T, S> as std::fmt::Debug>::fmt(p0, p1);
+crate::<access::DirectDeref<T, S> as std::fmt::Debug>::fmt(p0, p1);
+<access::DirectDeref<T, S>>::fmt(p0, p1);
-----------------
src/access.rs <access::DirectDeref<std::sync::Arc<T>, S> as std::ops::Deref>::deref
deps:{"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"<access::DirectDeref<std::sync::Arc<T>, S> as std::ops::Deref>::deref":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","gen_lock::LockStorage","std::marker::Copy","std::default::Default","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","std::clone::Clone","std::default::Default","strategy::sealed::InnerStrategy"]}}
candidates:{"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy","std::sync::RwLock"]},"<access::DirectDeref<std::sync::Arc<T>, S> as std::ops::Deref>::deref":{"S":["<S as strategy::Strategy<T>>"],"T":["RUG_ANY"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::DirectDeref<std::sync::Arc<T>, S>
+p0.deref();
+<access::DirectDeref<std::sync::Arc<T>, S> as std::ops::Deref>::deref(p0);
+crate::<access::DirectDeref<std::sync::Arc<T>, S> as std::ops::Deref>::deref(p0);
+<access::DirectDeref<std::sync::Arc<T>, S>>::deref(p0);
-----------------
src/access.rs <ArcSwapAny<std::sync::Arc<T>, S> as access::Access<T>>::load
deps:{"<ArcSwapAny<std::sync::Arc<T>, S> as access::Access<T>>::load":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized"]},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::clone::Clone","std::marker::Copy","std::marker::Sized","std::default::Default","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::marker::Sized","std::clone::Clone","strategy::sealed::InnerStrategy"]}}
candidates:{"<ArcSwapAny<std::sync::Arc<T>, S> as access::Access<T>>::load":{"S":["<S as strategy::Strategy<T>>"],"T":["RUG_ANY"]},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock","strategy::hybrid::HybridStrategy"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ArcSwapAny<std::sync::Arc<T>, S>
+p0.load();
+<ArcSwapAny<std::sync::Arc<T>, S> as access::Access<T>>::load(p0);
+crate::<ArcSwapAny<std::sync::Arc<T>, S> as access::Access<T>>::load(p0);
+<ArcSwapAny<std::sync::Arc<T>, S>>::load(p0);
-----------------
src/access.rs <access::DirectDeref<std::rc::Rc<T>, S> as std::ops::Deref>::deref
deps:{"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"<access::DirectDeref<std::rc::Rc<T>, S> as std::ops::Deref>::deref":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::clone::Clone","gen_lock::LockStorage","std::marker::Sized","std::default::Default","std::marker::Copy"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","strategy::sealed::InnerStrategy","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock","strategy::hybrid::HybridStrategy"]},"<access::DirectDeref<std::rc::Rc<T>, S> as std::ops::Deref>::deref":{"S":["<S as strategy::Strategy<T>>"],"T":["RUG_ANY"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::DirectDeref<std::rc::Rc<T>, S>
+p0.deref();
+<access::DirectDeref<std::rc::Rc<T>, S> as std::ops::Deref>::deref(p0);
+crate::<access::DirectDeref<std::rc::Rc<T>, S> as std::ops::Deref>::deref(p0);
+<access::DirectDeref<std::rc::Rc<T>, S>>::deref(p0);
-----------------
src/access.rs <ArcSwapAny<std::rc::Rc<T>, S> as access::Access<T>>::load
deps:{"<ArcSwapAny<std::rc::Rc<T>, S> as access::Access<T>>::load":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::marker::Sized"]},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::default::Default","std::marker::Copy","std::marker::Sized","std::clone::Clone","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","strategy::sealed::InnerStrategy","std::clone::Clone","std::default::Default"]}}
candidates:{"<ArcSwapAny<std::rc::Rc<T>, S> as access::Access<T>>::load":{"S":["<S as strategy::Strategy<T>>"],"T":["RUG_ANY"]},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ArcSwapAny<std::rc::Rc<T>, S>
+p0.load();
+<ArcSwapAny<std::rc::Rc<T>, S> as access::Access<T>>::load(p0);
+crate::<ArcSwapAny<std::rc::Rc<T>, S> as access::Access<T>>::load(p0);
+<ArcSwapAny<std::rc::Rc<T>, S>>::load(p0);
-----------------
src/access.rs <access::DynGuard<T> as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::DynGuard<T>
+p0.deref();
+<access::DynGuard<T> as std::ops::Deref>::deref(p0);
+crate::<access::DynGuard<T> as std::ops::Deref>::deref(p0);
+<access::DynGuard<T>>::deref(p0);
-----------------
src/access.rs <A as access::DynAccess<T>>::load
deps:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<A as access::DynAccess<T>>::load":{"A":["access::Access","std::marker::Sized"],"T":["std::marker::Sized"]},"<P as access::Access<T>>":{"P":["std::marker::Sized","std::ops::Deref"]},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"ArcSwapAny":{"S":["std::default::Default","strategy::Strategy","std::marker::Sized"],"T":["std::marker::Sized","std::default::Default","std::fmt::Debug","std::fmt::Display","ref_cnt::RefCnt"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::fmt::Debug","std::fmt::Display","std::default::Default"]},"access::Constant":{"T":["std::marker::Copy","std::cmp::PartialOrd","std::hash::Hash","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Ord","std::marker::Sized","std::clone::Clone"]},"access::ConstantDeref":{"T":["std::cmp::Ord","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Copy"]},"access::DirectDeref":{"S":["std::fmt::Debug","std::marker::Sized","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::marker::Sized","std::fmt::Debug"]},"access::Map":{"A":["std::fmt::Debug","std::marker::Sized","std::marker::Copy","std::clone::Clone","access::Access"],"F":["std::marker::Sized","std::ops::Fn","std::clone::Clone","std::marker::Copy","std::fmt::Debug"],"T":["std::marker::Sized","std::clone::Clone","std::marker::Copy","std::fmt::Debug"]},"access::MapGuard":{"G":["std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::marker::Sized","std::marker::Send","std::marker::Sync"],"T":["std::marker::Copy","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::default::Default","gen_lock::LockStorage","std::marker::Copy","std::marker::Sized","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","std::marker::Sized","strategy::sealed::InnerStrategy","std::default::Default"]}}
candidates:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<A as access::DynAccess<T>>::load":{"A":["access::Constant","ArcSwapAny","access::Map","<P as access::Access<T>>"],"T":["RUG_ANY"]},"<P as access::Access<T>>":{"P":["<&T as std::ops::Deref>","access::ConstantDeref","access::DynGuard","access::DirectDeref","Guard","<&mut T as std::ops::Deref>","access::MapGuard"]},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc","std::rc::Rc<T>","std::sync::Arc<T>"]},"access::Constant":{"T":["access::Constant","access::ConstantDeref","<*mut T as std::fmt::Debug>"]},"access::ConstantDeref":{"T":["std::marker::copy_impls::<impl std::marker::Copy for *const T>","access::ConstantDeref","access::Constant"]},"access::DirectDeref":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["access::Map","access::Constant","access::MapGuard","access::ConstantDeref","std::marker::copy_impls::<impl std::marker::Copy for *mut T>"]},"access::MapGuard":{"G":["access::MapGuard","<*mut T as std::fmt::Debug>"],"T":["access::ConstantDeref","access::Constant","access::Map","access::MapGuard","<*mut T as std::fmt::Debug>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // A
+p0.load();
+<A as access::DynAccess<T>>::load(p0);
+crate::<A as access::DynAccess<T>>::load(p0);
+<A>::load(p0);
-----------------
src/access.rs <access::MapGuard<G, T> as std::clone::Clone>::clone
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<access::MapGuard<G, T> as std::clone::Clone>::clone":{"G":["std::clone::Clone","std::marker::Sized"],"T":["std::marker::Sized","std::clone::Clone"]},"access::Constant":{"T":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::cmp::PartialOrd","std::hash::Hash","std::cmp::Ord","std::marker::Sized","std::marker::Copy","std::fmt::Debug"]},"access::ConstantDeref":{"T":["std::cmp::Eq","std::cmp::PartialOrd","std::marker::Copy","std::cmp::Ord","std::fmt::Debug","std::clone::Clone","std::hash::Hash","std::cmp::PartialEq","std::marker::Sized"]},"access::Map":{"A":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","access::Access","std::marker::Copy"],"F":["std::clone::Clone","std::marker::Sized","std::marker::Copy","std::fmt::Debug","std::ops::Fn"],"T":["std::marker::Sized","std::fmt::Debug","std::marker::Copy","std::clone::Clone"]},"access::MapGuard":{"G":["std::marker::Sized","std::marker::Copy","std::clone::Clone","std::marker::Sync","std::fmt::Debug","std::marker::Send"],"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::marker::Copy"]},"cache::Cache":{"A":["std::fmt::Debug","std::ops::Deref","std::marker::Sized","std::clone::Clone"],"T":["std::clone::Clone","std::ops::Deref","ref_cnt::RefCnt","std::fmt::Debug","std::marker::Sized"]},"cache::MapCache":{"A":["std::fmt::Debug","std::ops::Deref","std::marker::Sized","std::clone::Clone"],"F":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::ops::FnMut"],"T":["ref_cnt::RefCnt","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::clone::Clone","std::marker::Copy","std::default::Default","std::marker::Sized","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::clone::Clone","std::default::Default","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<access::MapGuard<G, T> as std::clone::Clone>::clone":{"G":["strategy::gen_lock::GenLockStrategy","std::clone::impls::<impl std::clone::Clone for *mut T>","access::ConstantDeref","std::clone::impls::<impl std::clone::Clone for *const T>","access::Constant","cache::Cache","gen_lock::Global","cache::MapCache","access::MapGuard","strategy::hybrid::HybridStrategy","access::Map"],"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","gen_lock::Global","cache::Cache","access::Constant","access::MapGuard","access::Map","cache::MapCache","access::ConstantDeref"]},"access::Constant":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","access::ConstantDeref","access::Constant"]},"access::ConstantDeref":{"T":["access::Constant","std::hash::impls::<impl std::hash::Hash for *const T>","access::ConstantDeref"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["access::Map","access::Constant","access::ConstantDeref","access::MapGuard","std::clone::impls::<impl std::clone::Clone for *const T>"]},"access::MapGuard":{"G":["std::marker::copy_impls::<impl std::marker::Copy for *mut T>","access::MapGuard"],"T":["access::Map","<*const T as std::fmt::Debug>","access::Constant","access::MapGuard","access::ConstantDeref"]},"cache::Cache":{"A":["access::ConstantDeref","<&T as std::fmt::Debug>","access::MapGuard"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"cache::MapCache":{"A":["access::MapGuard","access::ConstantDeref","std::clone::impls::<impl std::clone::Clone for &T>"],"T":["std::rc::Rc","std::sync::Arc"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::MapGuard<G, T>
+p0.clone();
+<access::MapGuard<G, T> as std::clone::Clone>::clone(p0);
+crate::<access::MapGuard<G, T> as std::clone::Clone>::clone(p0);
+<access::MapGuard<G, T>>::clone(p0);
-----------------
src/access.rs <access::MapGuard<G, T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"<access::MapGuard<G, T> as std::fmt::Debug>::fmt":{"G":["std::fmt::Debug","std::marker::Sized"],"T":["std::marker::Sized","std::fmt::Debug"]},"ArcSwapAny":{"S":["strategy::Strategy","std::marker::Sized","std::default::Default"],"T":["std::marker::Sized","std::default::Default","std::fmt::Debug","ref_cnt::RefCnt","std::fmt::Display"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::fmt::Display","ref_cnt::RefCnt","std::default::Default","std::marker::Sized","std::fmt::Debug"]},"access::Constant":{"T":["std::cmp::Ord","std::marker::Sized","std::marker::Copy","std::cmp::PartialOrd","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::hash::Hash"]},"access::ConstantDeref":{"T":["std::cmp::PartialOrd","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Ord","std::marker::Sized","std::hash::Hash","std::marker::Copy","std::cmp::Eq"]},"access::DirectDeref":{"S":["std::marker::Sized","strategy::Strategy","std::fmt::Debug"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::fmt::Debug"]},"access::Map":{"A":["std::fmt::Debug","std::marker::Copy","access::Access","std::clone::Clone","std::marker::Sized"],"F":["std::marker::Sized","std::marker::Copy","std::clone::Clone","std::ops::Fn","std::fmt::Debug"],"T":["std::marker::Copy","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"access::MapGuard":{"G":["std::marker::Send","std::clone::Clone","std::marker::Sized","std::marker::Copy","std::fmt::Debug","std::marker::Sync"],"T":["std::marker::Copy","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"cache::Cache":{"A":["std::marker::Sized","std::ops::Deref","std::fmt::Debug","std::clone::Clone"],"T":["ref_cnt::RefCnt","std::marker::Sized","std::ops::Deref","std::fmt::Debug","std::clone::Clone"]},"cache::MapCache":{"A":["std::clone::Clone","std::ops::Deref","std::fmt::Debug","std::marker::Sized"],"F":["std::ops::FnMut","std::marker::Sized","std::clone::Clone","std::fmt::Debug"],"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","ref_cnt::RefCnt"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::default::Default","gen_lock::LockStorage","std::clone::Clone","std::marker::Copy","std::marker::Sized"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::default::Default","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"]},"<access::MapGuard<G, T> as std::fmt::Debug>::fmt":{"G":["access::ConstantDeref","<*const T as std::fmt::Debug>","access::DirectDeref","access::MapGuard","<&T as std::fmt::Debug>","cache::MapCache","cache::Cache","ArcSwapAny","access::Map","access::Constant","Guard"],"T":["access::DirectDeref","access::MapGuard","<&T as std::fmt::Debug>","cache::Cache","access::Constant","access::ConstantDeref","Guard","cache::MapCache","ArcSwapAny","access::Map"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc","std::sync::Arc"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc<T>","std::sync::Arc","std::rc::Rc<T>"]},"access::Constant":{"T":["access::Constant","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","access::ConstantDeref"]},"access::ConstantDeref":{"T":["<*mut T as std::fmt::Debug>","access::ConstantDeref","access::Constant"]},"access::DirectDeref":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["std::marker::copy_impls::<impl std::marker::Copy for &T>","access::Map","access::MapGuard","access::ConstantDeref","access::Constant"]},"access::MapGuard":{"G":["access::MapGuard","<*const T as std::fmt::Debug>"],"T":["access::Map","<&T as std::fmt::Debug>","access::MapGuard","access::ConstantDeref","access::Constant"]},"cache::Cache":{"A":["access::MapGuard","std::clone::impls::<impl std::clone::Clone for &mut T>","access::ConstantDeref"],"T":["std::rc::Rc<T>","std::sync::Arc<T>"]},"cache::MapCache":{"A":["access::ConstantDeref","<&mut T as std::fmt::Debug>","access::MapGuard"],"T":["std::rc::Rc","std::sync::Arc"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::MapGuard<G, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<access::MapGuard<G, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<access::MapGuard<G, T> as std::fmt::Debug>::fmt(p0, p1);
+<access::MapGuard<G, T>>::fmt(p0, p1);
-----------------
src/access.rs <access::MapGuard<G, T> as std::ops::Deref>::deref
deps:{"<access::MapGuard<G, T> as std::ops::Deref>::deref":{"G":["std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"<access::MapGuard<G, T> as std::ops::Deref>::deref":{"G":["RUG_ANY"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::MapGuard<G, T>
+p0.deref();
+<access::MapGuard<G, T> as std::ops::Deref>::deref(p0);
+crate::<access::MapGuard<G, T> as std::ops::Deref>::deref(p0);
+<access::MapGuard<G, T>>::deref(p0);
-----------------
src/access.rs <access::Map<A, T, F> as std::clone::Clone>::clone
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<access::Map<A, T, F> as std::clone::Clone>::clone":{"A":["std::marker::Sized","std::clone::Clone"],"F":["std::marker::Sized","std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone"]},"access::Constant":{"T":["std::fmt::Debug","std::hash::Hash","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::marker::Sized","std::marker::Copy","std::cmp::PartialOrd","std::cmp::PartialEq"]},"access::ConstantDeref":{"T":["std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::clone::Clone","std::cmp::Ord","std::hash::Hash"]},"access::Map":{"A":["std::clone::Clone","std::marker::Sized","access::Access","std::marker::Copy","std::fmt::Debug"],"F":["std::marker::Copy","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::ops::Fn"],"T":["std::marker::Sized","std::marker::Copy","std::clone::Clone","std::fmt::Debug"]},"access::MapGuard":{"G":["std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Copy","std::clone::Clone","std::marker::Sync"],"T":["std::marker::Sized","std::fmt::Debug","std::marker::Copy","std::clone::Clone"]},"cache::Cache":{"A":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::ops::Deref"],"T":["std::fmt::Debug","ref_cnt::RefCnt","std::marker::Sized","std::clone::Clone","std::ops::Deref"]},"cache::MapCache":{"A":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::ops::Deref"],"F":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::ops::FnMut"],"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","ref_cnt::RefCnt"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Copy","std::default::Default","gen_lock::LockStorage","std::marker::Sized","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","std::marker::Sized","std::default::Default","strategy::sealed::InnerStrategy"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<access::Map<A, T, F> as std::clone::Clone>::clone":{"A":["access::ConstantDeref","std::clone::impls::<impl std::clone::Clone for *const T>","cache::Cache","strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy","access::Map","access::Constant","gen_lock::Global","access::MapGuard","cache::MapCache"],"F":["strategy::hybrid::HybridStrategy","std::clone::impls::<impl std::clone::Clone for *mut T>","cache::Cache","access::MapGuard","access::Map","std::clone::impls::<impl std::clone::Clone for &T>","access::ConstantDeref","strategy::gen_lock::GenLockStrategy","gen_lock::Global","cache::MapCache","access::Constant"],"T":["access::Map","std::clone::impls::<impl std::clone::Clone for &T>","access::Constant","cache::MapCache","strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","cache::Cache","gen_lock::Global","access::MapGuard","access::ConstantDeref"]},"access::Constant":{"T":["access::Constant","access::ConstantDeref","std::clone::impls::<impl std::clone::Clone for *const T>"]},"access::ConstantDeref":{"T":["access::ConstantDeref","std::marker::copy_impls::<impl std::marker::Copy for *mut T>","access::Constant"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["access::Constant","access::Map","access::MapGuard","std::clone::impls::<impl std::clone::Clone for *const T>","access::ConstantDeref"]},"access::MapGuard":{"G":["<*mut T as std::marker::Send>","access::MapGuard"],"T":["access::Map","access::MapGuard","access::ConstantDeref","std::clone::impls::<impl std::clone::Clone for *mut T>","access::Constant"]},"cache::Cache":{"A":["access::MapGuard","std::clone::impls::<impl std::clone::Clone for &T>","access::ConstantDeref"],"T":["std::sync::Arc"]},"cache::MapCache":{"A":["std::clone::impls::<impl std::clone::Clone for &mut T>","access::ConstantDeref","access::MapGuard"],"T":["std::option::Option"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::Map<A, T, F>
+p0.clone();
+<access::Map<A, T, F> as std::clone::Clone>::clone(p0);
+crate::<access::Map<A, T, F> as std::clone::Clone>::clone(p0);
+<access::Map<A, T, F>>::clone(p0);
-----------------
src/access.rs <access::Map<A, T, F> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"<access::Map<A, T, F> as std::fmt::Debug>::fmt":{"A":["std::marker::Sized","std::fmt::Debug"],"F":["std::marker::Sized","std::fmt::Debug"],"T":["std::marker::Sized","std::fmt::Debug"]},"ArcSwapAny":{"S":["std::marker::Sized","strategy::Strategy","std::default::Default"],"T":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::default::Default","ref_cnt::RefCnt"]},"Guard":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::marker::Sized","std::default::Default","std::fmt::Debug","std::fmt::Display","ref_cnt::RefCnt"]},"access::Constant":{"T":["std::cmp::PartialEq","std::hash::Hash","std::cmp::PartialOrd","std::fmt::Debug","std::cmp::Ord","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::marker::Copy"]},"access::ConstantDeref":{"T":["std::cmp::PartialEq","std::cmp::PartialOrd","std::cmp::Ord","std::fmt::Debug","std::marker::Copy","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::hash::Hash"]},"access::DirectDeref":{"S":["std::fmt::Debug","strategy::Strategy","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::fmt::Debug"]},"access::Map":{"A":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::marker::Copy","access::Access"],"F":["std::marker::Copy","std::marker::Sized","std::fmt::Debug","std::ops::Fn","std::clone::Clone"],"T":["std::marker::Copy","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"access::MapGuard":{"G":["std::marker::Copy","std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Sync","std::clone::Clone"],"T":["std::clone::Clone","std::marker::Copy","std::marker::Sized","std::fmt::Debug"]},"cache::Cache":{"A":["std::marker::Sized","std::ops::Deref","std::fmt::Debug","std::clone::Clone"],"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::ops::Deref","ref_cnt::RefCnt"]},"cache::MapCache":{"A":["std::clone::Clone","std::ops::Deref","std::fmt::Debug","std::marker::Sized"],"F":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::ops::FnMut"],"T":["std::fmt::Debug","ref_cnt::RefCnt","std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::clone::Clone","std::marker::Sized","std::default::Default","std::marker::Copy"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::marker::Sized","strategy::sealed::InnerStrategy","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","std::sync::RwLock","strategy::gen_lock::GenLockStrategy"]},"<access::Map<A, T, F> as std::fmt::Debug>::fmt":{"A":["Guard","access::ConstantDeref","<&T as std::fmt::Debug>","cache::MapCache","ArcSwapAny","cache::Cache","access::DirectDeref","access::MapGuard","<*mut T as std::fmt::Debug>","access::Constant","access::Map"],"F":["<*mut T as std::fmt::Debug>","Guard","cache::MapCache","access::DirectDeref","access::ConstantDeref","access::MapGuard","access::Map","access::Constant","ArcSwapAny","cache::Cache"],"T":["cache::Cache","access::Map","access::ConstantDeref","access::MapGuard","Guard","ArcSwapAny","access::DirectDeref","access::Constant","cache::MapCache","<&T as std::fmt::Debug>"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"access::Constant":{"T":["access::Constant","std::hash::impls::<impl std::hash::Hash for *const T>","access::ConstantDeref"]},"access::ConstantDeref":{"T":["access::ConstantDeref","std::hash::impls::<impl std::hash::Hash for *const T>","access::Constant"]},"access::DirectDeref":{"T":["std::option::Option","std::sync::Arc"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["std::clone::impls::<impl std::clone::Clone for *const T>","access::Map","access::ConstantDeref","access::MapGuard","access::Constant"]},"access::MapGuard":{"G":["access::MapGuard","std::marker::copy_impls::<impl std::marker::Copy for *const T>"],"T":["std::clone::impls::<impl std::clone::Clone for *const T>","access::Map","access::MapGuard","access::ConstantDeref","access::Constant"]},"cache::Cache":{"A":["std::clone::impls::<impl std::clone::Clone for &mut T>","access::ConstantDeref","access::MapGuard"],"T":["std::rc::Rc"]},"cache::MapCache":{"A":["<&T as std::fmt::Debug>","access::ConstantDeref","access::MapGuard"],"T":["std::sync::Arc"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::Map<A, T, F>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<access::Map<A, T, F> as std::fmt::Debug>::fmt(p0, p1);
+crate::<access::Map<A, T, F> as std::fmt::Debug>::fmt(p0, p1);
+<access::Map<A, T, F>>::fmt(p0, p1);
-----------------
src/access.rs access::Map::<A, T, F>::new
deps:{"access::Map::<A, T, F>::new":{"A":["std::marker::Sized"],"F":["std::ops::Fn","std::marker::Sized"],"R":["std::marker::Sized"],"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"access::Map::<A, T, F>::new":{"A":["RUG_ANY"],"F":["core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode"],"R":["RUG_ANY"],"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // A
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+access::Map::<A, T, F>::new(p0, p1);
+crate::access::Map::<A, T, F>::new(p0, p1);
+<access::Map<A, T, F>>::new(p0, p1);
-----------------
src/access.rs <access::Map<A, T, F> as access::Access<R>>::load
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*mut T as std::fmt::Debug>":{},"<P as access::Access<T>>":{"P":["std::ops::Deref","std::marker::Sized"]},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"<access::Map<A, T, F> as access::Access<R>>::load":{"A":["std::marker::Sized","access::Access"],"F":["std::marker::Sized","std::ops::Fn"],"R":["std::marker::Sized"],"T":["std::marker::Sized"]},"ArcSwapAny":{"S":["strategy::Strategy","std::marker::Sized","std::default::Default"],"T":["std::fmt::Display","std::default::Default","ref_cnt::RefCnt","std::fmt::Debug","std::marker::Sized"]},"Guard":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","ref_cnt::RefCnt","std::default::Default"]},"access::Constant":{"T":["std::marker::Sized","std::cmp::Ord","std::fmt::Debug","std::cmp::PartialEq","std::marker::Copy","std::cmp::Eq","std::hash::Hash","std::clone::Clone","std::cmp::PartialOrd"]},"access::ConstantDeref":{"T":["std::clone::Clone","std::cmp::PartialEq","std::marker::Copy","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::Ord","std::hash::Hash","std::cmp::Eq","std::marker::Sized"]},"access::DirectDeref":{"S":["strategy::Strategy","std::marker::Sized","std::fmt::Debug"],"T":["ref_cnt::RefCnt","std::fmt::Debug","std::marker::Sized"]},"access::Map":{"A":["std::clone::Clone","std::marker::Sized","std::marker::Copy","std::fmt::Debug","access::Access"],"F":["std::marker::Copy","std::ops::Fn","std::marker::Sized","std::clone::Clone","std::fmt::Debug"],"T":["std::marker::Sized","std::marker::Copy","std::fmt::Debug","std::clone::Clone"]},"access::MapGuard":{"G":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::marker::Sync","std::marker::Copy","std::marker::Send"],"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::marker::Copy"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::clone::Clone","std::marker::Sized","std::marker::Copy","std::default::Default","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","strategy::sealed::InnerStrategy","std::marker::Sized","std::default::Default"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*mut T as std::fmt::Debug>":{},"<P as access::Access<T>>":{"P":["access::MapGuard","access::ConstantDeref","access::DirectDeref","Guard","access::DynGuard","<&T as std::ops::Deref>"]},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock","strategy::hybrid::HybridStrategy"]},"<access::Map<A, T, F> as access::Access<R>>::load":{"A":["ArcSwapAny","access::Constant","<P as access::Access<T>>","access::Map"],"F":["std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr"],"R":["RUG_ANY"],"T":["RUG_ANY"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc","std::rc::Rc<T>","std::rc::Rc","std::sync::Arc<T>"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc<T>","std::rc::Rc","std::sync::Arc<T>"]},"access::Constant":{"T":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","access::ConstantDeref","access::Constant"]},"access::ConstantDeref":{"T":["std::marker::copy_impls::<impl std::marker::Copy for *const T>","access::Constant","access::ConstantDeref"]},"access::DirectDeref":{"T":["std::option::Option","std::sync::Arc"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["std::marker::copy_impls::<impl std::marker::Copy for *const T>","access::ConstantDeref","access::MapGuard","access::Constant","access::Map"]},"access::MapGuard":{"G":["std::marker::copy_impls::<impl std::marker::Copy for *const T>","access::MapGuard"],"T":["<*mut T as std::fmt::Debug>","access::Map","access::Constant","access::MapGuard","access::ConstantDeref"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::Map<A, T, F>
+p0.load();
+<access::Map<A, T, F> as access::Access<R>>::load(p0);
+crate::<access::Map<A, T, F> as access::Access<R>>::load(p0);
+<access::Map<A, T, F>>::load(p0);
-----------------
src/access.rs <access::ConstantDeref<T> as std::clone::Clone>::clone
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<access::ConstantDeref<T> as std::clone::Clone>::clone":{"T":["std::marker::Sized","std::clone::Clone"]},"access::Constant":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::Ord","std::cmp::PartialEq","std::clone::Clone","std::marker::Copy","std::cmp::Eq","std::hash::Hash","std::cmp::PartialOrd"]},"access::ConstantDeref":{"T":["std::marker::Sized","std::cmp::Eq","std::hash::Hash","std::clone::Clone","std::cmp::PartialOrd","std::marker::Copy","std::cmp::PartialEq","std::cmp::Ord","std::fmt::Debug"]},"access::Map":{"A":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","access::Access","std::marker::Copy"],"F":["std::marker::Copy","std::ops::Fn","std::clone::Clone","std::fmt::Debug","std::marker::Sized"],"T":["std::marker::Copy","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"access::MapGuard":{"G":["std::marker::Sized","std::marker::Sync","std::marker::Copy","std::clone::Clone","std::fmt::Debug","std::marker::Send"],"T":["std::marker::Sized","std::marker::Copy","std::clone::Clone","std::fmt::Debug"]},"cache::Cache":{"A":["std::fmt::Debug","std::marker::Sized","std::ops::Deref","std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized","ref_cnt::RefCnt","std::fmt::Debug","std::ops::Deref"]},"cache::MapCache":{"A":["std::marker::Sized","std::clone::Clone","std::ops::Deref","std::fmt::Debug"],"F":["std::ops::FnMut","std::clone::Clone","std::fmt::Debug","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::clone::Clone","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::marker::Sized","std::default::Default","std::marker::Copy","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::marker::Sized","strategy::sealed::InnerStrategy","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<access::ConstantDeref<T> as std::clone::Clone>::clone":{"T":["access::Map","access::ConstantDeref","access::MapGuard","access::Constant","strategy::hybrid::HybridStrategy","gen_lock::Global","cache::MapCache","cache::Cache","std::clone::impls::<impl std::clone::Clone for *mut T>","strategy::gen_lock::GenLockStrategy","std::clone::impls::<impl std::clone::Clone for &T>"]},"access::Constant":{"T":["access::Constant","access::ConstantDeref","std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>"]},"access::ConstantDeref":{"T":["access::Constant","access::ConstantDeref","std::hash::impls::<impl std::hash::Hash for *const T>"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["<&T as std::fmt::Debug>","access::Constant","access::MapGuard","access::Map","access::ConstantDeref"]},"access::MapGuard":{"G":["access::MapGuard","std::clone::impls::<impl std::clone::Clone for *mut T>"],"T":["<*const T as std::fmt::Debug>","access::Map","access::Constant","access::MapGuard","access::ConstantDeref"]},"cache::Cache":{"A":["std::clone::impls::<impl std::clone::Clone for &T>","access::MapGuard","access::ConstantDeref"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"cache::MapCache":{"A":["<&T as std::ops::Deref>","access::MapGuard","access::ConstantDeref"],"T":["std::sync::Arc<T>","std::rc::Rc<T>","std::option::Option<T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::ConstantDeref<T>
+p0.clone();
+<access::ConstantDeref<T> as std::clone::Clone>::clone(p0);
+crate::<access::ConstantDeref<T> as std::clone::Clone>::clone(p0);
+<access::ConstantDeref<T>>::clone(p0);
-----------------
src/access.rs <access::ConstantDeref<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"<access::ConstantDeref<T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"ArcSwapAny":{"S":["std::marker::Sized","strategy::Strategy","std::default::Default"],"T":["ref_cnt::RefCnt","std::fmt::Display","std::default::Default","std::fmt::Debug","std::marker::Sized"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::default::Default","std::fmt::Debug","std::fmt::Display"]},"access::Constant":{"T":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::Ord","std::fmt::Debug","std::marker::Copy","std::cmp::PartialEq","std::cmp::PartialOrd","std::hash::Hash"]},"access::ConstantDeref":{"T":["std::fmt::Debug","std::marker::Copy","std::cmp::Eq","std::cmp::Ord","std::clone::Clone","std::cmp::PartialOrd","std::hash::Hash","std::cmp::PartialEq","std::marker::Sized"]},"access::DirectDeref":{"S":["std::marker::Sized","strategy::Strategy","std::fmt::Debug"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::fmt::Debug"]},"access::Map":{"A":["std::marker::Sized","std::marker::Copy","std::clone::Clone","access::Access","std::fmt::Debug"],"F":["std::fmt::Debug","std::ops::Fn","std::marker::Copy","std::marker::Sized","std::clone::Clone"],"T":["std::marker::Sized","std::fmt::Debug","std::marker::Copy","std::clone::Clone"]},"access::MapGuard":{"G":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::clone::Clone","std::marker::Send","std::marker::Copy"],"T":["std::marker::Copy","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"cache::Cache":{"A":["std::fmt::Debug","std::clone::Clone","std::ops::Deref","std::marker::Sized"],"T":["std::clone::Clone","std::marker::Sized","ref_cnt::RefCnt","std::ops::Deref","std::fmt::Debug"]},"cache::MapCache":{"A":["std::fmt::Debug","std::ops::Deref","std::clone::Clone","std::marker::Sized"],"F":["std::ops::FnMut","std::fmt::Debug","std::clone::Clone","std::marker::Sized"],"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","ref_cnt::RefCnt"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::marker::Sized","std::clone::Clone","std::marker::Copy","std::default::Default"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::marker::Sized","std::clone::Clone","std::default::Default"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock","strategy::hybrid::HybridStrategy"]},"<access::ConstantDeref<T> as std::fmt::Debug>::fmt":{"T":["access::ConstantDeref","<*mut T as std::fmt::Debug>","access::DirectDeref","cache::MapCache","access::Map","ArcSwapAny","cache::Cache","Guard","access::MapGuard","access::Constant"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc<T>","std::sync::Arc<T>","std::sync::Arc"]},"access::Constant":{"T":["access::ConstantDeref","std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>","access::Constant"]},"access::ConstantDeref":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","access::Constant","access::ConstantDeref"]},"access::DirectDeref":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["access::Constant","access::Map","access::MapGuard","access::ConstantDeref","std::marker::copy_impls::<impl std::marker::Copy for *mut T>"]},"access::MapGuard":{"G":["access::MapGuard","std::clone::impls::<impl std::clone::Clone for *const T>"],"T":["access::ConstantDeref","access::Constant","access::Map","access::MapGuard","std::marker::copy_impls::<impl std::marker::Copy for *const T>"]},"cache::Cache":{"A":["access::MapGuard","std::clone::impls::<impl std::clone::Clone for &mut T>","access::ConstantDeref"],"T":["std::sync::Arc"]},"cache::MapCache":{"A":["access::ConstantDeref","<&mut T as std::ops::Deref>","access::MapGuard"],"T":["std::rc::Rc<T>","std::option::Option<T>","std::sync::Arc<T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::ConstantDeref<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<access::ConstantDeref<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<access::ConstantDeref<T> as std::fmt::Debug>::fmt(p0, p1);
+<access::ConstantDeref<T>>::fmt(p0, p1);
-----------------
src/access.rs <access::ConstantDeref<T> as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{"<access::ConstantDeref<T> as std::cmp::Eq>::assert_receiver_is_total_eq":{"T":["std::cmp::Eq","std::marker::Sized"]},"access::Constant":{"T":["std::hash::Hash","std::clone::Clone","std::cmp::Ord","std::fmt::Debug","std::marker::Copy","std::cmp::PartialOrd","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"access::ConstantDeref":{"T":["std::marker::Copy","std::fmt::Debug","std::hash::Hash","std::cmp::Ord","std::cmp::Eq","std::cmp::PartialOrd","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<access::ConstantDeref<T> as std::cmp::Eq>::assert_receiver_is_total_eq":{"T":["access::ConstantDeref","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","std::cmp::impls::<impl std::cmp::Eq for &mut A>","access::Constant"]},"access::Constant":{"T":["access::Constant","std::clone::impls::<impl std::clone::Clone for *const T>","access::ConstantDeref"]},"access::ConstantDeref":{"T":["std::marker::copy_impls::<impl std::marker::Copy for *mut T>","access::Constant","access::ConstantDeref"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::ConstantDeref<T>
+p0.assert_receiver_is_total_eq();
+<access::ConstantDeref<T> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<access::ConstantDeref<T> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<access::ConstantDeref<T>>::assert_receiver_is_total_eq(p0);
-----------------
src/access.rs <access::ConstantDeref<T> as std::cmp::PartialEq>::eq
deps:{"<access::ConstantDeref<T> as std::cmp::PartialEq>::eq":{"T":["std::cmp::PartialEq","std::marker::Sized"]},"access::Constant":{"T":["std::cmp::PartialEq","std::hash::Hash","std::cmp::Ord","std::cmp::PartialOrd","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Copy","std::marker::Sized"]},"access::ConstantDeref":{"T":["std::cmp::Eq","std::clone::Clone","std::marker::Copy","std::cmp::Ord","std::cmp::PartialOrd","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::hash::Hash"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<access::ConstantDeref<T> as std::cmp::PartialEq>::eq":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","access::Constant","access::ConstantDeref"]},"access::Constant":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","access::Constant","access::ConstantDeref"]},"access::ConstantDeref":{"T":["std::hash::impls::<impl std::hash::Hash for *const T>","access::Constant","access::ConstantDeref"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::ConstantDeref<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // access::ConstantDeref<T>
+p0.eq(p1);
+<access::ConstantDeref<T> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<access::ConstantDeref<T> as std::cmp::PartialEq>::eq(p0, p1);
+<access::ConstantDeref<T>>::eq(p0, p1);
-----------------
src/access.rs <access::ConstantDeref<T> as std::cmp::Ord>::cmp
deps:{"<*mut T as std::fmt::Debug>":{},"<access::ConstantDeref<T> as std::cmp::Ord>::cmp":{"T":["std::cmp::Ord","std::marker::Sized"]},"access::Constant":{"T":["std::clone::Clone","std::cmp::PartialOrd","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::cmp::Ord"]},"access::ConstantDeref":{"T":["std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::fmt::Debug","std::clone::Clone","std::marker::Copy","std::cmp::PartialEq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::Ord for &A>":{},"std::cmp::impls::<impl std::cmp::Ord for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<access::ConstantDeref<T> as std::cmp::Ord>::cmp":{"T":["std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","std::cmp::impls::<impl std::cmp::Ord for &mut A>","access::ConstantDeref","access::Constant"]},"access::Constant":{"T":["<*mut T as std::fmt::Debug>","access::Constant","access::ConstantDeref"]},"access::ConstantDeref":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","access::Constant","access::ConstantDeref"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::Ord for &A>":{},"std::cmp::impls::<impl std::cmp::Ord for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::ConstantDeref<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // access::ConstantDeref<T>
+p0.cmp(p1);
+<access::ConstantDeref<T> as std::cmp::Ord>::cmp(p0, p1);
+crate::<access::ConstantDeref<T> as std::cmp::Ord>::cmp(p0, p1);
+<access::ConstantDeref<T>>::cmp(p0, p1);
-----------------
src/access.rs <access::ConstantDeref<T> as std::cmp::PartialOrd>::partial_cmp
deps:{"<access::ConstantDeref<T> as std::cmp::PartialOrd>::partial_cmp":{"T":["std::marker::Sized","std::cmp::PartialOrd"]},"access::Constant":{"T":["std::marker::Copy","std::cmp::Eq","std::fmt::Debug","std::hash::Hash","std::marker::Sized","std::cmp::Ord","std::clone::Clone","std::cmp::PartialOrd","std::cmp::PartialEq"]},"access::ConstantDeref":{"T":["std::fmt::Debug","std::cmp::Ord","std::marker::Copy","std::hash::Hash","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::cmp::PartialOrd","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<access::ConstantDeref<T> as std::cmp::PartialOrd>::partial_cmp":{"T":["access::ConstantDeref","access::Constant","std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>","std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>"]},"access::Constant":{"T":["access::Constant","std::ptr::const_ptr::<impl std::cmp::Ord for *const T>","access::ConstantDeref"]},"access::ConstantDeref":{"T":["access::ConstantDeref","access::Constant","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::ConstantDeref<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // access::ConstantDeref<T>
+p0.partial_cmp(p1);
+<access::ConstantDeref<T> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<access::ConstantDeref<T> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<access::ConstantDeref<T>>::partial_cmp(p0, p1);
-----------------
src/access.rs <access::ConstantDeref<T> as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<access::ConstantDeref<T> as std::hash::Hash>::hash":{"T":["std::marker::Sized","std::hash::Hash"],"__H":["std::marker::Sized","std::hash::Hasher"]},"access::Constant":{"T":["std::cmp::PartialOrd","std::marker::Sized","std::fmt::Debug","std::hash::Hash","std::cmp::PartialEq","std::marker::Copy","std::cmp::Eq","std::cmp::Ord","std::clone::Clone"]},"access::ConstantDeref":{"T":["std::cmp::PartialOrd","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash","std::cmp::Ord","std::marker::Copy"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<access::ConstantDeref<T> as std::hash::Hash>::hash":{"T":["access::Constant","std::hash::impls::<impl std::hash::Hash for *const T>","std::hash::impls::<impl std::hash::Hash for *mut T>","access::ConstantDeref"],"__H":["std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>","<&mut H as std::hash::Hasher>","std::hash::SipHasher13"]},"access::Constant":{"T":["access::ConstantDeref","access::Constant","std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>"]},"access::ConstantDeref":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","access::Constant","access::ConstantDeref"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::ConstantDeref<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<access::ConstantDeref<T> as std::hash::Hash>::hash(p0, p1);
+crate::<access::ConstantDeref<T> as std::hash::Hash>::hash(p0, p1);
+<access::ConstantDeref<T>>::hash(p0, p1);
-----------------
src/access.rs <access::ConstantDeref<T> as std::ops::Deref>::deref
deps:{"<access::ConstantDeref<T> as std::ops::Deref>::deref":{"T":["std::marker::Sized"]}}
candidates:{"<access::ConstantDeref<T> as std::ops::Deref>::deref":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::ConstantDeref<T>
+p0.deref();
+<access::ConstantDeref<T> as std::ops::Deref>::deref(p0);
+crate::<access::ConstantDeref<T> as std::ops::Deref>::deref(p0);
+<access::ConstantDeref<T>>::deref(p0);
-----------------
src/access.rs <access::Constant<T> as std::clone::Clone>::clone
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<access::Constant<T> as std::clone::Clone>::clone":{"T":["std::marker::Sized","std::clone::Clone"]},"access::Constant":{"T":["std::hash::Hash","std::cmp::PartialOrd","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::marker::Copy","std::cmp::Ord","std::cmp::PartialEq"]},"access::ConstantDeref":{"T":["std::clone::Clone","std::cmp::PartialOrd","std::fmt::Debug","std::cmp::Eq","std::marker::Copy","std::cmp::PartialEq","std::hash::Hash","std::marker::Sized","std::cmp::Ord"]},"access::Map":{"A":["std::marker::Sized","std::fmt::Debug","access::Access","std::clone::Clone","std::marker::Copy"],"F":["std::marker::Sized","std::marker::Copy","std::fmt::Debug","std::ops::Fn","std::clone::Clone"],"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::marker::Copy"]},"access::MapGuard":{"G":["std::marker::Send","std::marker::Copy","std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::clone::Clone"],"T":["std::marker::Copy","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"cache::Cache":{"A":["std::clone::Clone","std::ops::Deref","std::fmt::Debug","std::marker::Sized"],"T":["ref_cnt::RefCnt","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::ops::Deref"]},"cache::MapCache":{"A":["std::ops::Deref","std::marker::Sized","std::clone::Clone","std::fmt::Debug"],"F":["std::clone::Clone","std::marker::Sized","std::ops::FnMut","std::fmt::Debug"],"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","ref_cnt::RefCnt"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::marker::Copy","std::default::Default","std::clone::Clone","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::clone::Clone","strategy::sealed::InnerStrategy","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<access::Constant<T> as std::clone::Clone>::clone":{"T":["access::MapGuard","gen_lock::Global","cache::MapCache","access::Constant","cache::Cache","access::Map","std::clone::impls::<impl std::clone::Clone for &mut T>","strategy::hybrid::HybridStrategy","std::clone::impls::<impl std::clone::Clone for &T>","strategy::gen_lock::GenLockStrategy","access::ConstantDeref"]},"access::Constant":{"T":["access::Constant","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","access::ConstantDeref"]},"access::ConstantDeref":{"T":["access::ConstantDeref","std::clone::impls::<impl std::clone::Clone for *mut T>","access::Constant"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["access::Constant","access::ConstantDeref","access::MapGuard","access::Map","std::clone::impls::<impl std::clone::Clone for *const T>"]},"access::MapGuard":{"G":["<*mut T as std::marker::Sync>","access::MapGuard"],"T":["std::marker::copy_impls::<impl std::marker::Copy for *mut T>","access::Constant","access::Map","access::MapGuard","access::ConstantDeref"]},"cache::Cache":{"A":["access::MapGuard","<&T as std::ops::Deref>","access::ConstantDeref"],"T":["std::sync::Arc"]},"cache::MapCache":{"A":["<&mut T as std::ops::Deref>","access::ConstantDeref","access::MapGuard"],"T":["std::option::Option"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::Constant<T>
+p0.clone();
+<access::Constant<T> as std::clone::Clone>::clone(p0);
+crate::<access::Constant<T> as std::clone::Clone>::clone(p0);
+<access::Constant<T>>::clone(p0);
-----------------
src/access.rs <access::Constant<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"<access::Constant<T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"ArcSwapAny":{"S":["std::marker::Sized","strategy::Strategy","std::default::Default"],"T":["std::marker::Sized","std::fmt::Display","ref_cnt::RefCnt","std::fmt::Debug","std::default::Default"]},"Guard":{"S":["strategy::Strategy","std::marker::Sized"],"T":["ref_cnt::RefCnt","std::default::Default","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"access::Constant":{"T":["std::cmp::PartialEq","std::cmp::Ord","std::cmp::PartialOrd","std::marker::Copy","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::hash::Hash"]},"access::ConstantDeref":{"T":["std::marker::Copy","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::PartialOrd","std::cmp::Ord","std::marker::Sized","std::cmp::Eq","std::hash::Hash"]},"access::DirectDeref":{"S":["std::marker::Sized","strategy::Strategy","std::fmt::Debug"],"T":["std::fmt::Debug","std::marker::Sized","ref_cnt::RefCnt"]},"access::Map":{"A":["std::marker::Sized","std::fmt::Debug","std::marker::Copy","access::Access","std::clone::Clone"],"F":["std::ops::Fn","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::marker::Copy"],"T":["std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::marker::Sized"]},"access::MapGuard":{"G":["std::marker::Sync","std::marker::Copy","std::clone::Clone","std::marker::Send","std::fmt::Debug","std::marker::Sized"],"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::marker::Copy"]},"cache::Cache":{"A":["std::marker::Sized","std::ops::Deref","std::clone::Clone","std::fmt::Debug"],"T":["std::clone::Clone","std::ops::Deref","std::fmt::Debug","std::marker::Sized","ref_cnt::RefCnt"]},"cache::MapCache":{"A":["std::marker::Sized","std::clone::Clone","std::ops::Deref","std::fmt::Debug"],"F":["std::ops::FnMut","std::clone::Clone","std::fmt::Debug","std::marker::Sized"],"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","ref_cnt::RefCnt"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::default::Default","std::marker::Sized","std::clone::Clone","gen_lock::LockStorage","std::marker::Copy"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","strategy::sealed::InnerStrategy","std::default::Default","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","std::sync::RwLock","strategy::gen_lock::GenLockStrategy"]},"<access::Constant<T> as std::fmt::Debug>::fmt":{"T":["ArcSwapAny","cache::Cache","access::ConstantDeref","access::Constant","<*mut T as std::fmt::Debug>","Guard","access::DirectDeref","<&T as std::fmt::Debug>","access::Map","cache::MapCache","access::MapGuard"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc","std::sync::Arc"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc<T>","std::sync::Arc<T>","std::rc::Rc"]},"access::Constant":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","access::Constant","access::ConstantDeref"]},"access::ConstantDeref":{"T":["access::ConstantDeref","access::Constant","std::marker::copy_impls::<impl std::marker::Copy for *const T>"]},"access::DirectDeref":{"T":["std::rc::Rc","std::sync::Arc"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["access::MapGuard","std::clone::impls::<impl std::clone::Clone for *const T>","access::Constant","access::ConstantDeref","access::Map"]},"access::MapGuard":{"G":["<*const T as std::marker::Sync>","access::MapGuard"],"T":["<*mut T as std::fmt::Debug>","access::Map","access::Constant","access::ConstantDeref","access::MapGuard"]},"cache::Cache":{"A":["access::MapGuard","<&mut T as std::ops::Deref>","access::ConstantDeref"],"T":["std::rc::Rc<T>","std::sync::Arc<T>"]},"cache::MapCache":{"A":["access::MapGuard","<&mut T as std::ops::Deref>","access::ConstantDeref"],"T":["std::sync::Arc","std::option::Option"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::option::Option":{"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::Constant<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<access::Constant<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<access::Constant<T> as std::fmt::Debug>::fmt(p0, p1);
+<access::Constant<T>>::fmt(p0, p1);
-----------------
src/access.rs <access::Constant<T> as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{"<*const T as std::fmt::Debug>":{},"<access::Constant<T> as std::cmp::Eq>::assert_receiver_is_total_eq":{"T":["std::cmp::Eq","std::marker::Sized"]},"access::Constant":{"T":["std::cmp::Eq","std::cmp::PartialOrd","std::marker::Copy","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Ord","std::hash::Hash"]},"access::ConstantDeref":{"T":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::marker::Sized","std::cmp::PartialEq","std::cmp::PartialOrd","std::hash::Hash","std::fmt::Debug","std::marker::Copy"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<access::Constant<T> as std::cmp::Eq>::assert_receiver_is_total_eq":{"T":["access::ConstantDeref","std::cmp::impls::<impl std::cmp::Eq for &A>","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","access::Constant"]},"access::Constant":{"T":["access::ConstantDeref","std::marker::copy_impls::<impl std::marker::Copy for *const T>","access::Constant"]},"access::ConstantDeref":{"T":["access::Constant","access::ConstantDeref","std::marker::copy_impls::<impl std::marker::Copy for *mut T>"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::Constant<T>
+p0.assert_receiver_is_total_eq();
+<access::Constant<T> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<access::Constant<T> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<access::Constant<T>>::assert_receiver_is_total_eq(p0);
-----------------
src/access.rs <access::Constant<T> as std::cmp::PartialEq>::eq
deps:{"<access::Constant<T> as std::cmp::PartialEq>::eq":{"T":["std::cmp::PartialEq","std::marker::Sized"]},"access::Constant":{"T":["std::fmt::Debug","std::hash::Hash","std::cmp::PartialEq","std::cmp::Eq","std::marker::Copy","std::marker::Sized","std::clone::Clone","std::cmp::Ord","std::cmp::PartialOrd"]},"access::ConstantDeref":{"T":["std::hash::Hash","std::marker::Copy","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialOrd","std::marker::Sized","std::cmp::PartialEq","std::cmp::Ord"]},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<access::Constant<T> as std::cmp::PartialEq>::eq":{"T":["access::ConstantDeref","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","access::Constant"]},"access::Constant":{"T":["std::marker::copy_impls::<impl std::marker::Copy for *const T>","access::Constant","access::ConstantDeref"]},"access::ConstantDeref":{"T":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","access::Constant","access::ConstantDeref"]},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::Constant<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // access::Constant<T>
+p0.eq(p1);
+<access::Constant<T> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<access::Constant<T> as std::cmp::PartialEq>::eq(p0, p1);
+<access::Constant<T>>::eq(p0, p1);
-----------------
src/access.rs <access::Constant<T> as std::cmp::Ord>::cmp
deps:{"<*mut T as std::fmt::Debug>":{},"<access::Constant<T> as std::cmp::Ord>::cmp":{"T":["std::marker::Sized","std::cmp::Ord"]},"access::Constant":{"T":["std::cmp::Eq","std::cmp::PartialEq","std::cmp::Ord","std::marker::Copy","std::cmp::PartialOrd","std::hash::Hash","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"access::ConstantDeref":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Ord","std::hash::Hash","std::cmp::Eq","std::marker::Copy","std::cmp::PartialOrd","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::Ord for &A>":{},"std::cmp::impls::<impl std::cmp::Ord for &mut A>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<access::Constant<T> as std::cmp::Ord>::cmp":{"T":["std::cmp::impls::<impl std::cmp::Ord for &mut A>","access::ConstantDeref","std::ptr::const_ptr::<impl std::cmp::Ord for *const T>","access::Constant"]},"access::Constant":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","access::ConstantDeref","access::Constant"]},"access::ConstantDeref":{"T":["<*mut T as std::fmt::Debug>","access::ConstantDeref","access::Constant"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::Ord for &A>":{},"std::cmp::impls::<impl std::cmp::Ord for &mut A>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::Constant<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // access::Constant<T>
+p0.cmp(p1);
+<access::Constant<T> as std::cmp::Ord>::cmp(p0, p1);
+crate::<access::Constant<T> as std::cmp::Ord>::cmp(p0, p1);
+<access::Constant<T>>::cmp(p0, p1);
-----------------
src/access.rs <access::Constant<T> as std::cmp::PartialOrd>::partial_cmp
deps:{"<*mut T as std::fmt::Debug>":{},"<access::Constant<T> as std::cmp::PartialOrd>::partial_cmp":{"T":["std::cmp::PartialOrd","std::marker::Sized"]},"access::Constant":{"T":["std::marker::Copy","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::cmp::Eq","std::cmp::Ord","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"access::ConstantDeref":{"T":["std::cmp::PartialOrd","std::hash::Hash","std::cmp::Eq","std::marker::Copy","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Ord","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<access::Constant<T> as std::cmp::PartialOrd>::partial_cmp":{"T":["access::ConstantDeref","std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>","std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","access::Constant"]},"access::Constant":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","access::ConstantDeref","access::Constant"]},"access::ConstantDeref":{"T":["std::hash::impls::<impl std::hash::Hash for *mut T>","access::ConstantDeref","access::Constant"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::Constant<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // access::Constant<T>
+p0.partial_cmp(p1);
+<access::Constant<T> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<access::Constant<T> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<access::Constant<T>>::partial_cmp(p0, p1);
-----------------
src/access.rs <access::Constant<T> as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<*mut T as std::fmt::Debug>":{},"<access::Constant<T> as std::hash::Hash>::hash":{"T":["std::hash::Hash","std::marker::Sized"],"__H":["std::marker::Sized","std::hash::Hasher"]},"access::Constant":{"T":["std::cmp::Ord","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::cmp::PartialOrd","std::marker::Sized","std::marker::Copy","std::hash::Hash"]},"access::ConstantDeref":{"T":["std::cmp::PartialEq","std::clone::Clone","std::cmp::PartialOrd","std::cmp::Ord","std::cmp::Eq","std::marker::Copy","std::hash::Hash","std::marker::Sized","std::fmt::Debug"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<*mut T as std::fmt::Debug>":{},"<access::Constant<T> as std::hash::Hash>::hash":{"T":["access::ConstantDeref","access::Constant","std::hash::impls::<impl std::hash::Hash for *const T>","std::hash::impls::<impl std::hash::Hash for &mut T>"],"__H":["std::hash::SipHasher","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>"]},"access::Constant":{"T":["access::Constant","access::ConstantDeref","std::hash::impls::<impl std::hash::Hash for *const T>"]},"access::ConstantDeref":{"T":["access::ConstantDeref","access::Constant","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::Constant<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<access::Constant<T> as std::hash::Hash>::hash(p0, p1);
+crate::<access::Constant<T> as std::hash::Hash>::hash(p0, p1);
+<access::Constant<T>>::hash(p0, p1);
-----------------
src/access.rs <access::Constant<T> as access::Access<T>>::load
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<access::Constant<T> as access::Access<T>>::load":{"T":["std::marker::Sized","std::clone::Clone"]},"access::Constant":{"T":["std::cmp::Ord","std::clone::Clone","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::marker::Copy"]},"access::ConstantDeref":{"T":["std::cmp::PartialOrd","std::hash::Hash","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Ord","std::fmt::Debug","std::cmp::Eq","std::marker::Copy"]},"access::Map":{"A":["std::marker::Copy","access::Access","std::marker::Sized","std::clone::Clone","std::fmt::Debug"],"F":["std::marker::Copy","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::ops::Fn"],"T":["std::marker::Sized","std::fmt::Debug","std::marker::Copy","std::clone::Clone"]},"access::MapGuard":{"G":["std::fmt::Debug","std::clone::Clone","std::marker::Send","std::marker::Sync","std::marker::Sized","std::marker::Copy"],"T":["std::clone::Clone","std::marker::Copy","std::marker::Sized","std::fmt::Debug"]},"cache::Cache":{"A":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::ops::Deref"],"T":["std::fmt::Debug","ref_cnt::RefCnt","std::marker::Sized","std::ops::Deref","std::clone::Clone"]},"cache::MapCache":{"A":["std::fmt::Debug","std::ops::Deref","std::marker::Sized","std::clone::Clone"],"F":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::ops::FnMut"],"T":["ref_cnt::RefCnt","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::clone::Clone","std::marker::Sized","std::default::Default","std::marker::Copy"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::marker::Sized","std::clone::Clone","strategy::sealed::InnerStrategy"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<access::Constant<T> as access::Access<T>>::load":{"T":["access::ConstantDeref","cache::Cache","cache::MapCache","gen_lock::Global","strategy::hybrid::HybridStrategy","access::Map","std::clone::impls::<impl std::clone::Clone for *const T>","access::Constant","std::clone::impls::<impl std::clone::Clone for &T>","strategy::gen_lock::GenLockStrategy","access::MapGuard"]},"access::Constant":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","access::Constant","access::ConstantDeref"]},"access::ConstantDeref":{"T":["access::Constant","std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","access::ConstantDeref"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["std::marker::copy_impls::<impl std::marker::Copy for &T>","access::ConstantDeref","access::Constant","access::Map","access::MapGuard"]},"access::MapGuard":{"G":["<*mut T as std::marker::Sync>","access::MapGuard"],"T":["access::ConstantDeref","std::marker::copy_impls::<impl std::marker::Copy for *mut T>","access::Map","access::Constant","access::MapGuard"]},"cache::Cache":{"A":["access::MapGuard","access::ConstantDeref","std::clone::impls::<impl std::clone::Clone for &T>"],"T":["std::rc::Rc"]},"cache::MapCache":{"A":["access::MapGuard","<&T as std::ops::Deref>","access::ConstantDeref"],"T":["std::option::Option","std::rc::Rc"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // access::Constant<T>
+p0.load();
+<access::Constant<T> as access::Access<T>>::load(p0);
+crate::<access::Constant<T> as access::Access<T>>::load(p0);
+<access::Constant<T>>::load(p0);
-----------------
src/as_raw.rs <&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw
'a
deps:{"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]}}
candidates:{"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
+p0.as_raw();
+<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw(p0);
+crate::<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw(p0);
+<&'a T>::as_raw(p0);
-----------------
src/as_raw.rs <&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw
'a
deps:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::option::Option":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // Guard<T>
+p0.as_raw();
+<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw(p0);
+crate::<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw(p0);
+<&'a Guard<T>>::as_raw(p0);
-----------------
src/as_raw.rs <Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw
'a
deps:{"<Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]}}
candidates:{"<Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Guard<T>
+p0.as_raw();
+<Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw(p0);
+crate::<Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>::as_raw(p0);
+<Guard<T>>::as_raw(p0);
-----------------
src/as_raw.rs <*mut T as as_raw::AsRaw<T>>::as_raw
deps:{"<*mut T as as_raw::AsRaw<T>>::as_raw":{"T":["std::marker::Sized"]}}
candidates:{"<*mut T as as_raw::AsRaw<T>>::as_raw":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // *mut T
+p0.as_raw();
+<*mut T as as_raw::AsRaw<T>>::as_raw(p0);
+crate::<*mut T as as_raw::AsRaw<T>>::as_raw(p0);
+<*mut T>::as_raw(p0);
-----------------
src/as_raw.rs <*const T as as_raw::AsRaw<T>>::as_raw
deps:{"<*const T as as_raw::AsRaw<T>>::as_raw":{"T":["std::marker::Sized"]}}
candidates:{"<*const T as as_raw::AsRaw<T>>::as_raw":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // *const T
+p0.as_raw();
+<*const T as as_raw::AsRaw<T>>::as_raw(p0);
+crate::<*const T as as_raw::AsRaw<T>>::as_raw(p0);
+<*const T>::as_raw(p0);
-----------------
src/cache.rs <cache::Cache<A, T> as std::clone::Clone>::clone
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<cache::Cache<A, T> as std::clone::Clone>::clone":{"A":["std::marker::Sized","std::clone::Clone"],"T":["std::clone::Clone","std::marker::Sized"]},"access::Constant":{"T":["std::marker::Sized","std::hash::Hash","std::cmp::Eq","std::marker::Copy","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::clone::Clone","std::cmp::Ord"]},"access::ConstantDeref":{"T":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::hash::Hash","std::marker::Copy","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug"]},"access::Map":{"A":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::marker::Copy","access::Access"],"F":["std::ops::Fn","std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::marker::Sized"],"T":["std::fmt::Debug","std::marker::Sized","std::marker::Copy","std::clone::Clone"]},"access::MapGuard":{"G":["std::marker::Copy","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"],"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::marker::Copy"]},"cache::Cache":{"A":["std::ops::Deref","std::marker::Sized","std::clone::Clone","std::fmt::Debug"],"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::ops::Deref","ref_cnt::RefCnt"]},"cache::MapCache":{"A":["std::ops::Deref","std::clone::Clone","std::fmt::Debug","std::marker::Sized"],"F":["std::marker::Sized","std::clone::Clone","std::ops::FnMut","std::fmt::Debug"],"T":["std::fmt::Debug","ref_cnt::RefCnt","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::default::Default","std::marker::Copy","std::marker::Sized","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","strategy::sealed::InnerStrategy","std::marker::Sized","std::default::Default"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<cache::Cache<A, T> as std::clone::Clone>::clone":{"A":["access::ConstantDeref","strategy::gen_lock::GenLockStrategy","access::Map","gen_lock::Global","access::MapGuard","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for &mut T>","access::Constant","cache::Cache","strategy::hybrid::HybridStrategy","cache::MapCache"],"T":["cache::MapCache","access::Map","access::ConstantDeref","cache::Cache","std::clone::impls::<impl std::clone::Clone for *const T>","access::MapGuard","strategy::gen_lock::GenLockStrategy","gen_lock::Global","strategy::hybrid::HybridStrategy","access::Constant"]},"access::Constant":{"T":["access::Constant","access::ConstantDeref","std::hash::impls::<impl std::hash::Hash for *const T>"]},"access::ConstantDeref":{"T":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","access::ConstantDeref","access::Constant"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["access::ConstantDeref","access::Map","access::Constant","std::clone::impls::<impl std::clone::Clone for *const T>","access::MapGuard"]},"access::MapGuard":{"G":["<*const T as std::fmt::Debug>","access::MapGuard"],"T":["access::Constant","access::MapGuard","access::ConstantDeref","std::marker::copy_impls::<impl std::marker::Copy for &T>","access::Map"]},"cache::Cache":{"A":["access::ConstantDeref","access::MapGuard","<&mut T as std::ops::Deref>"],"T":["std::rc::Rc"]},"cache::MapCache":{"A":["std::clone::impls::<impl std::clone::Clone for &T>","access::ConstantDeref","access::MapGuard"],"T":["std::option::Option<T>","std::rc::Rc<T>","std::sync::Arc<T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // cache::Cache<A, T>
+p0.clone();
+<cache::Cache<A, T> as std::clone::Clone>::clone(p0);
+crate::<cache::Cache<A, T> as std::clone::Clone>::clone(p0);
+<cache::Cache<A, T>>::clone(p0);
-----------------
src/cache.rs <cache::Cache<A, T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"<cache::Cache<A, T> as std::fmt::Debug>::fmt":{"A":["std::marker::Sized","std::fmt::Debug"],"T":["std::fmt::Debug","std::marker::Sized"]},"ArcSwapAny":{"S":["strategy::Strategy","std::marker::Sized","std::default::Default"],"T":["std::default::Default","std::fmt::Debug","std::marker::Sized","std::fmt::Display","ref_cnt::RefCnt"]},"Guard":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","ref_cnt::RefCnt","std::default::Default"]},"access::Constant":{"T":["std::clone::Clone","std::marker::Copy","std::cmp::PartialOrd","std::marker::Sized","std::hash::Hash","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Ord","std::cmp::Eq"]},"access::ConstantDeref":{"T":["std::marker::Copy","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Ord","std::cmp::PartialOrd","std::cmp::Eq","std::hash::Hash"]},"access::DirectDeref":{"S":["std::fmt::Debug","std::marker::Sized","strategy::Strategy"],"T":["std::fmt::Debug","ref_cnt::RefCnt","std::marker::Sized"]},"access::Map":{"A":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::marker::Copy","access::Access"],"F":["std::fmt::Debug","std::clone::Clone","std::ops::Fn","std::marker::Copy","std::marker::Sized"],"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::marker::Copy"]},"access::MapGuard":{"G":["std::marker::Send","std::marker::Copy","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::marker::Sync"],"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::marker::Copy"]},"cache::Cache":{"A":["std::clone::Clone","std::fmt::Debug","std::ops::Deref","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::ops::Deref","std::fmt::Debug","std::clone::Clone"]},"cache::MapCache":{"A":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::ops::Deref"],"F":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::ops::FnMut"],"T":["std::clone::Clone","std::fmt::Debug","ref_cnt::RefCnt","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::marker::Copy","std::default::Default","gen_lock::LockStorage","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::default::Default","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock","strategy::hybrid::HybridStrategy"]},"<cache::Cache<A, T> as std::fmt::Debug>::fmt":{"A":["Guard","access::Constant","cache::MapCache","cache::Cache","access::ConstantDeref","access::Map","<&T as std::fmt::Debug>","access::DirectDeref","ArcSwapAny","access::MapGuard"],"T":["access::MapGuard","<*mut T as std::fmt::Debug>","cache::Cache","access::ConstantDeref","access::Map","access::Constant","ArcSwapAny","cache::MapCache","access::DirectDeref","Guard"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc","std::rc::Rc"]},"Guard":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>","<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::sync::Arc<T>","std::rc::Rc<T>","std::rc::Rc"]},"access::Constant":{"T":["access::ConstantDeref","access::Constant","std::ptr::const_ptr::<impl std::cmp::Ord for *const T>"]},"access::ConstantDeref":{"T":["access::Constant","access::ConstantDeref","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"access::DirectDeref":{"T":["std::option::Option","std::rc::Rc"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["access::ConstantDeref","<*mut T as std::fmt::Debug>","access::Map","access::MapGuard","access::Constant"]},"access::MapGuard":{"G":["access::MapGuard","std::clone::impls::<impl std::clone::Clone for *const T>"],"T":["access::MapGuard","std::clone::impls::<impl std::clone::Clone for *mut T>","access::Constant","access::ConstantDeref","access::Map"]},"cache::Cache":{"A":["<&T as std::fmt::Debug>","access::MapGuard","access::ConstantDeref"],"T":["std::sync::Arc"]},"cache::MapCache":{"A":["access::ConstantDeref","access::MapGuard","<&mut T as std::ops::Deref>"],"T":["std::rc::Rc<T>","std::sync::Arc<T>","std::option::Option<T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // cache::Cache<A, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<cache::Cache<A, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<cache::Cache<A, T> as std::fmt::Debug>::fmt(p0, p1);
+<cache::Cache<A, T>>::fmt(p0, p1);
-----------------
src/cache.rs cache::Cache::<A, T>::new
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::fmt::Debug","ref_cnt::RefCnt","std::fmt::Display","std::marker::Sized","std::default::Default"]},"access::Constant":{"T":["std::marker::Copy","std::cmp::PartialOrd","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Ord","std::clone::Clone","std::hash::Hash","std::marker::Sized"]},"access::ConstantDeref":{"T":["std::cmp::PartialOrd","std::hash::Hash","std::cmp::Ord","std::marker::Copy","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"access::DirectDeref":{"S":["std::marker::Sized","strategy::Strategy","std::fmt::Debug"],"T":["ref_cnt::RefCnt","std::fmt::Debug","std::marker::Sized"]},"access::Map":{"A":["std::marker::Sized","std::fmt::Debug","std::marker::Copy","access::Access","std::clone::Clone"],"F":["std::clone::Clone","std::fmt::Debug","std::ops::Fn","std::marker::Sized","std::marker::Copy"],"T":["std::marker::Sized","std::marker::Copy","std::clone::Clone","std::fmt::Debug"]},"access::MapGuard":{"G":["std::marker::Sync","std::marker::Sized","std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::marker::Send"],"T":["std::marker::Copy","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"cache::Cache::<A, T>::new":{"A":["std::marker::Sized","std::ops::Deref"],"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::clone::Clone","std::marker::Sized","std::marker::Copy","std::default::Default","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","std::marker::Sized","std::default::Default","strategy::sealed::InnerStrategy"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","std::sync::RwLock","strategy::gen_lock::GenLockStrategy"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc","std::sync::Arc"]},"access::Constant":{"T":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","access::ConstantDeref","access::Constant"]},"access::ConstantDeref":{"T":["access::ConstantDeref","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","access::Constant"]},"access::DirectDeref":{"T":["std::rc::Rc<T>","std::rc::Rc","std::option::Option<T>","std::sync::Arc<T>","std::option::Option"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["access::ConstantDeref","access::Constant","std::marker::copy_impls::<impl std::marker::Copy for &T>","access::MapGuard","access::Map"]},"access::MapGuard":{"G":["<*mut T as std::marker::Sync>","access::MapGuard"],"T":["access::ConstantDeref","access::Constant","access::MapGuard","access::Map","<*mut T as std::fmt::Debug>"]},"cache::Cache::<A, T>::new":{"A":["access::DynGuard","access::ConstantDeref","<&mut T as std::ops::Deref>","Guard","access::MapGuard","access::DirectDeref"],"S":["<S as strategy::Strategy<T>>"],"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // A
+cache::Cache::<A, T>::new(p0);
+crate::cache::Cache::<A, T>::new(p0);
+<cache::Cache<A, T>>::new(p0);
-----------------
src/cache.rs cache::Cache::<A, T>::arc_swap
deps:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","std::fmt::Debug","ref_cnt::RefCnt","std::fmt::Display","std::default::Default"]},"access::Constant":{"T":["std::cmp::Eq","std::cmp::PartialEq","std::cmp::PartialOrd","std::marker::Sized","std::fmt::Debug","std::marker::Copy","std::cmp::Ord","std::hash::Hash","std::clone::Clone"]},"access::ConstantDeref":{"T":["std::marker::Sized","std::marker::Copy","std::cmp::Ord","std::cmp::PartialOrd","std::cmp::PartialEq","std::hash::Hash","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"access::DirectDeref":{"S":["std::fmt::Debug","std::marker::Sized","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::fmt::Debug","std::marker::Sized"]},"access::Map":{"A":["std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::marker::Sized","access::Access"],"F":["std::marker::Copy","std::ops::Fn","std::clone::Clone","std::fmt::Debug","std::marker::Sized"],"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::marker::Copy"]},"access::MapGuard":{"G":["std::marker::Sized","std::marker::Copy","std::marker::Send","std::marker::Sync","std::clone::Clone","std::fmt::Debug"],"T":["std::marker::Copy","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"cache::Cache::<A, T>::arc_swap":{"A":["std::marker::Sized","std::ops::Deref"],"S":["std::marker::Sized","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::clone::Clone","std::default::Default","std::marker::Sized","std::marker::Copy","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","strategy::sealed::InnerStrategy","std::default::Default","std::clone::Clone"]}}
candidates:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]},"Guard":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>","<S as strategy::Strategy<T>>"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"access::Constant":{"T":["access::ConstantDeref","std::hash::impls::<impl std::hash::Hash for *mut T>","access::Constant"]},"access::ConstantDeref":{"T":["std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","access::ConstantDeref","access::Constant"]},"access::DirectDeref":{"T":["std::rc::Rc<T>","std::option::Option<T>","std::sync::Arc<T>","std::sync::Arc"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["<*const T as std::fmt::Debug>","access::Constant","access::MapGuard","access::Map","access::ConstantDeref"]},"access::MapGuard":{"G":["access::MapGuard","<*const T as std::marker::Send>"],"T":["std::clone::impls::<impl std::clone::Clone for *const T>","access::ConstantDeref","access::Map","access::Constant","access::MapGuard"]},"cache::Cache::<A, T>::arc_swap":{"A":["<&mut T as std::ops::Deref>","access::MapGuard","access::ConstantDeref","access::DynGuard","<&T as std::ops::Deref>","Guard","access::DirectDeref"],"S":["<S as strategy::Strategy<T>>"],"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // cache::Cache<A, T>
+p0.arc_swap();
+cache::Cache::<A, T>::arc_swap(p0);
+crate::cache::Cache::<A, T>::arc_swap(p0);
+<cache::Cache<A, T>>::arc_swap(p0);
-----------------
src/cache.rs cache::Cache::<A, T>::load
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"Guard":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::fmt::Debug","ref_cnt::RefCnt","std::default::Default","std::marker::Sized","std::fmt::Display"]},"access::Constant":{"T":["std::marker::Sized","std::cmp::Ord","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::cmp::PartialOrd","std::marker::Copy","std::fmt::Debug","std::hash::Hash"]},"access::ConstantDeref":{"T":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::marker::Copy","std::cmp::Eq","std::fmt::Debug","std::hash::Hash","std::cmp::Ord","std::cmp::PartialOrd"]},"access::DirectDeref":{"S":["strategy::Strategy","std::marker::Sized","std::fmt::Debug"],"T":["std::marker::Sized","std::fmt::Debug","ref_cnt::RefCnt"]},"access::Map":{"A":["std::fmt::Debug","std::marker::Copy","std::marker::Sized","access::Access","std::clone::Clone"],"F":["std::ops::Fn","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::marker::Copy"],"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::marker::Copy"]},"access::MapGuard":{"G":["std::marker::Sized","std::marker::Send","std::marker::Copy","std::clone::Clone","std::fmt::Debug","std::marker::Sync"],"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::marker::Copy"]},"cache::Cache::<A, T>::load":{"A":["std::ops::Deref","std::marker::Sized"],"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::clone::Clone","std::default::Default","gen_lock::LockStorage","std::marker::Copy"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::clone::Clone","std::default::Default","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock","strategy::hybrid::HybridStrategy"]},"Guard":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>","<S as strategy::Strategy<T>>"],"T":["std::rc::Rc<T>","std::sync::Arc<T>"]},"access::Constant":{"T":["std::marker::copy_impls::<impl std::marker::Copy for *mut T>","access::ConstantDeref","access::Constant"]},"access::ConstantDeref":{"T":["access::ConstantDeref","std::ptr::const_ptr::<impl std::cmp::Ord for *const T>","access::Constant"]},"access::DirectDeref":{"T":["std::rc::Rc","std::option::Option"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["access::ConstantDeref","access::MapGuard","access::Constant","std::marker::copy_impls::<impl std::marker::Copy for *mut T>","access::Map"]},"access::MapGuard":{"G":["<*mut T as std::marker::Sync>","access::MapGuard"],"T":["access::Constant","access::Map","std::clone::impls::<impl std::clone::Clone for *mut T>","access::ConstantDeref","access::MapGuard"]},"cache::Cache::<A, T>::load":{"A":["access::DirectDeref","Guard","access::ConstantDeref","access::MapGuard","<&T as std::ops::Deref>","access::DynGuard"],"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // cache::Cache<A, T>
+p0.load();
+cache::Cache::<A, T>::load(p0);
+crate::cache::Cache::<A, T>::load(p0);
+<cache::Cache<A, T>>::load(p0);
-----------------
src/cache.rs cache::Cache::<A, T>::load_no_revalidate
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::default::Default"]},"access::Constant":{"T":["std::cmp::Ord","std::cmp::Eq","std::hash::Hash","std::cmp::PartialOrd","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::marker::Copy"]},"access::ConstantDeref":{"T":["std::cmp::PartialOrd","std::fmt::Debug","std::marker::Sized","std::marker::Copy","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::cmp::Ord","std::hash::Hash"]},"access::DirectDeref":{"S":["std::marker::Sized","strategy::Strategy","std::fmt::Debug"],"T":["ref_cnt::RefCnt","std::fmt::Debug","std::marker::Sized"]},"access::Map":{"A":["access::Access","std::fmt::Debug","std::marker::Sized","std::marker::Copy","std::clone::Clone"],"F":["std::marker::Sized","std::clone::Clone","std::ops::Fn","std::marker::Copy","std::fmt::Debug"],"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::marker::Copy"]},"access::MapGuard":{"G":["std::clone::Clone","std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send","std::marker::Copy"],"T":["std::clone::Clone","std::marker::Sized","std::marker::Copy","std::fmt::Debug"]},"cache::Cache::<A, T>::load_no_revalidate":{"A":["std::ops::Deref","std::marker::Sized"],"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::default::Default","gen_lock::LockStorage","std::marker::Copy","std::clone::Clone","std::marker::Sized"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","std::default::Default","strategy::sealed::InnerStrategy","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"access::Constant":{"T":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","access::ConstantDeref","access::Constant"]},"access::ConstantDeref":{"T":["access::Constant","std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","access::ConstantDeref"]},"access::DirectDeref":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc<T>","std::option::Option<T>","std::rc::Rc<T>"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["<*mut T as std::fmt::Debug>","access::Map","access::MapGuard","access::ConstantDeref","access::Constant"]},"access::MapGuard":{"G":["<*const T as std::marker::Sync>","access::MapGuard"],"T":["access::ConstantDeref","<*mut T as std::fmt::Debug>","access::Constant","access::MapGuard","access::Map"]},"cache::Cache::<A, T>::load_no_revalidate":{"A":["Guard","access::DynGuard","access::ConstantDeref","<&T as std::ops::Deref>","access::DirectDeref","access::MapGuard"],"S":["<S as strategy::Strategy<T>>"],"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // cache::Cache<A, T>
+p0.load_no_revalidate();
+cache::Cache::<A, T>::load_no_revalidate(p0);
+crate::cache::Cache::<A, T>::load_no_revalidate(p0);
+<cache::Cache<A, T>>::load_no_revalidate(p0);
-----------------
src/cache.rs cache::Cache::<A, T>::revalidate
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"Guard":{"S":["strategy::Strategy","std::marker::Sized"],"T":["ref_cnt::RefCnt","std::fmt::Debug","std::fmt::Display","std::default::Default","std::marker::Sized"]},"access::Constant":{"T":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Ord","std::cmp::PartialOrd","std::marker::Copy","std::marker::Sized","std::hash::Hash","std::cmp::Eq","std::fmt::Debug"]},"access::ConstantDeref":{"T":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::marker::Copy","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::cmp::Eq"]},"access::DirectDeref":{"S":["strategy::Strategy","std::fmt::Debug","std::marker::Sized"],"T":["ref_cnt::RefCnt","std::marker::Sized","std::fmt::Debug"]},"access::Map":{"A":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::marker::Copy","access::Access"],"F":["std::clone::Clone","std::fmt::Debug","std::marker::Copy","std::marker::Sized","std::ops::Fn"],"T":["std::marker::Copy","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"access::MapGuard":{"G":["std::marker::Sized","std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::marker::Send","std::marker::Sync"],"T":["std::marker::Copy","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"cache::Cache::<A, T>::revalidate":{"A":["std::ops::Deref","std::marker::Sized"],"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","gen_lock::LockStorage","std::marker::Copy","std::default::Default","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","std::clone::Clone","std::default::Default","strategy::sealed::InnerStrategy"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc","std::rc::Rc<T>","std::sync::Arc<T>"]},"access::Constant":{"T":["access::Constant","std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","access::ConstantDeref"]},"access::ConstantDeref":{"T":["access::Constant","access::ConstantDeref","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"access::DirectDeref":{"T":["std::sync::Arc","std::option::Option"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["access::Map","access::ConstantDeref","access::MapGuard","std::marker::copy_impls::<impl std::marker::Copy for *mut T>","access::Constant"]},"access::MapGuard":{"G":["access::MapGuard","<*mut T as std::fmt::Debug>"],"T":["std::marker::copy_impls::<impl std::marker::Copy for *const T>","access::ConstantDeref","access::Map","access::Constant","access::MapGuard"]},"cache::Cache::<A, T>::revalidate":{"A":["<&T as std::ops::Deref>","access::DirectDeref","access::DynGuard","access::MapGuard","access::ConstantDeref","Guard"],"S":["<S as strategy::Strategy<T>>"],"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // cache::Cache<A, T>
+p0.revalidate();
+cache::Cache::<A, T>::revalidate(p0);
+crate::cache::Cache::<A, T>::revalidate(p0);
+<cache::Cache<A, T>>::revalidate(p0);
-----------------
src/cache.rs cache::Cache::<A, T>::map
deps:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"Guard":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::fmt::Display","ref_cnt::RefCnt","std::marker::Sized","std::fmt::Debug","std::default::Default"]},"access::Constant":{"T":["std::fmt::Debug","std::cmp::Ord","std::cmp::Eq","std::marker::Sized","std::marker::Copy","std::clone::Clone","std::hash::Hash","std::cmp::PartialOrd","std::cmp::PartialEq"]},"access::ConstantDeref":{"T":["std::clone::Clone","std::marker::Sized","std::hash::Hash","std::cmp::Ord","std::cmp::PartialEq","std::cmp::Eq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy"]},"access::DirectDeref":{"S":["std::fmt::Debug","std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::fmt::Debug"]},"access::Map":{"A":["std::marker::Sized","std::clone::Clone","access::Access","std::marker::Copy","std::fmt::Debug"],"F":["std::clone::Clone","std::marker::Copy","std::marker::Sized","std::fmt::Debug","std::ops::Fn"],"T":["std::marker::Sized","std::clone::Clone","std::marker::Copy","std::fmt::Debug"]},"access::MapGuard":{"G":["std::marker::Send","std::marker::Sync","std::marker::Copy","std::marker::Sized","std::fmt::Debug","std::clone::Clone"],"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::marker::Copy"]},"cache::Cache::<A, T>::map":{"A":["std::marker::Sized","std::ops::Deref"],"F":["std::ops::FnMut","std::marker::Sized"],"S":["std::marker::Sized","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::marker::Sized"],"U":["std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::default::Default","std::marker::Sized","std::marker::Copy","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::default::Default","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","std::sync::RwLock","strategy::gen_lock::GenLockStrategy"]},"Guard":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>","<S as strategy::Strategy<T>>"],"T":["std::rc::Rc"]},"access::Constant":{"T":["access::ConstantDeref","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","access::Constant"]},"access::ConstantDeref":{"T":["std::ptr::const_ptr::<impl std::cmp::Ord for *const T>","access::Constant","access::ConstantDeref"]},"access::DirectDeref":{"T":["std::sync::Arc","std::rc::Rc"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["access::MapGuard","access::Constant","access::Map","std::clone::impls::<impl std::clone::Clone for *mut T>","access::ConstantDeref"]},"access::MapGuard":{"G":["access::MapGuard","<*mut T as std::fmt::Debug>"],"T":["access::Map","access::ConstantDeref","access::Constant","access::MapGuard","std::clone::impls::<impl std::clone::Clone for *const T>"]},"cache::Cache::<A, T>::map":{"A":["<&T as std::ops::Deref>","Guard","access::ConstantDeref","access::DirectDeref","access::DynGuard","<&mut T as std::ops::Deref>","access::MapGuard"],"F":["core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap"],"S":["<S as strategy::Strategy<T>>"],"T":["std::option::Option","std::rc::Rc","std::sync::Arc"],"U":["RUG_ANY"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::option::Option":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // cache::Cache<A, T>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map(p1);
+cache::Cache::<A, T>::map(p0, p1);
+crate::cache::Cache::<A, T>::map(p0, p1);
+<cache::Cache<A, T>>::map(p0, p1);
-----------------
src/cache.rs <cache::Cache<A, T> as cache::Access<<T as std::ops::Deref>::Target>>::load
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"<cache::Cache<A, T> as cache::Access<<T as std::ops::Deref>::Target>>::load":{"A":["std::marker::Sized","std::ops::Deref"],"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","std::ops::Deref","ref_cnt::RefCnt"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::fmt::Display","std::fmt::Debug","ref_cnt::RefCnt","std::marker::Sized","std::default::Default"]},"access::Constant":{"T":["std::marker::Copy","std::marker::Sized","std::cmp::Ord","std::fmt::Debug","std::hash::Hash","std::cmp::Eq","std::cmp::PartialEq","std::cmp::PartialOrd","std::clone::Clone"]},"access::ConstantDeref":{"T":["std::cmp::PartialOrd","std::cmp::Ord","std::hash::Hash","std::cmp::Eq","std::cmp::PartialEq","std::marker::Copy","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"access::DirectDeref":{"S":["std::marker::Sized","strategy::Strategy","std::fmt::Debug"],"T":["std::fmt::Debug","ref_cnt::RefCnt","std::marker::Sized"]},"access::Map":{"A":["std::marker::Copy","std::clone::Clone","std::marker::Sized","access::Access","std::fmt::Debug"],"F":["std::ops::Fn","std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::marker::Sized"],"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::marker::Copy"]},"access::MapGuard":{"G":["std::marker::Copy","std::marker::Sync","std::marker::Send","std::clone::Clone","std::fmt::Debug","std::marker::Sized"],"T":["std::marker::Copy","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::default::Default","std::clone::Clone","gen_lock::LockStorage","std::marker::Copy"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::marker::Sized","strategy::sealed::InnerStrategy","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]},"<cache::Cache<A, T> as cache::Access<<T as std::ops::Deref>::Target>>::load":{"A":["Guard","access::ConstantDeref","access::DirectDeref","<&T as std::ops::Deref>","access::DynGuard","<&mut T as std::ops::Deref>","access::MapGuard"],"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::rc::Rc"]},"Guard":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>","<S as strategy::Strategy<T>>"],"T":["std::rc::Rc","std::sync::Arc"]},"access::Constant":{"T":["std::hash::impls::<impl std::hash::Hash for *mut T>","access::ConstantDeref","access::Constant"]},"access::ConstantDeref":{"T":["access::ConstantDeref","access::Constant","std::marker::copy_impls::<impl std::marker::Copy for *const T>"]},"access::DirectDeref":{"T":["std::rc::Rc","std::sync::Arc"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["access::Map","access::MapGuard","access::ConstantDeref","access::Constant","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"access::MapGuard":{"G":["<*const T as std::marker::Sync>","access::MapGuard"],"T":["access::ConstantDeref","access::Constant","access::Map","<&T as std::fmt::Debug>","access::MapGuard"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // cache::Cache<A, T>
+p0.load();
+<cache::Cache<A, T> as cache::Access<<T as std::ops::Deref>::Target>>::load(p0);
+crate::<cache::Cache<A, T> as cache::Access<<T as std::ops::Deref>::Target>>::load(p0);
+<cache::Cache<A, T>>::load(p0);
-----------------
src/cache.rs <cache::Cache<A, T> as std::convert::From<A>>::from
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"<cache::Cache<A, T> as std::convert::From<A>>::from":{"A":["std::marker::Sized","std::ops::Deref"],"S":["strategy::Strategy","std::marker::Sized"],"T":["ref_cnt::RefCnt","std::marker::Sized"]},"Guard":{"S":["strategy::Strategy","std::marker::Sized"],"T":["ref_cnt::RefCnt","std::fmt::Display","std::fmt::Debug","std::default::Default","std::marker::Sized"]},"access::Constant":{"T":["std::cmp::Eq","std::hash::Hash","std::fmt::Debug","std::marker::Copy","std::clone::Clone","std::cmp::PartialOrd","std::marker::Sized","std::cmp::Ord","std::cmp::PartialEq"]},"access::ConstantDeref":{"T":["std::cmp::PartialEq","std::marker::Copy","std::clone::Clone","std::cmp::PartialOrd","std::cmp::Eq","std::hash::Hash","std::fmt::Debug","std::cmp::Ord","std::marker::Sized"]},"access::DirectDeref":{"S":["strategy::Strategy","std::fmt::Debug","std::marker::Sized"],"T":["std::fmt::Debug","std::marker::Sized","ref_cnt::RefCnt"]},"access::Map":{"A":["std::fmt::Debug","access::Access","std::clone::Clone","std::marker::Copy","std::marker::Sized"],"F":["std::fmt::Debug","std::ops::Fn","std::marker::Copy","std::clone::Clone","std::marker::Sized"],"T":["std::marker::Sized","std::clone::Clone","std::marker::Copy","std::fmt::Debug"]},"access::MapGuard":{"G":["std::marker::Sync","std::marker::Copy","std::clone::Clone","std::marker::Sized","std::marker::Send","std::fmt::Debug"],"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::marker::Copy"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Copy","std::clone::Clone","std::marker::Sized","gen_lock::LockStorage","std::default::Default"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","std::clone::Clone","strategy::sealed::InnerStrategy","std::default::Default"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]},"<cache::Cache<A, T> as std::convert::From<A>>::from":{"A":["Guard","access::MapGuard","<&mut T as std::ops::Deref>","access::ConstantDeref","access::DynGuard","access::DirectDeref","<&T as std::ops::Deref>"],"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc<T>","std::rc::Rc","std::rc::Rc<T>"]},"access::Constant":{"T":["access::ConstantDeref","access::Constant","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"access::ConstantDeref":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>","access::ConstantDeref","access::Constant"]},"access::DirectDeref":{"T":["std::sync::Arc<T>","std::option::Option<T>","std::rc::Rc","std::rc::Rc<T>","std::sync::Arc"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["access::MapGuard","access::Constant","std::clone::impls::<impl std::clone::Clone for &T>","access::ConstantDeref","access::Map"]},"access::MapGuard":{"G":["<*const T as std::marker::Sync>","access::MapGuard"],"T":["access::Map","access::MapGuard","std::marker::copy_impls::<impl std::marker::Copy for *const T>","access::Constant","access::ConstantDeref"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // A
+<cache::Cache<A, T> as std::convert::From<A>>::from(p0);
+crate::<cache::Cache<A, T> as std::convert::From<A>>::from(p0);
+<cache::Cache<A, T>>::from(p0);
-----------------
src/cache.rs <cache::MapCache<A, T, F> as std::clone::Clone>::clone
deps:{"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<cache::MapCache<A, T, F> as std::clone::Clone>::clone":{"A":["std::marker::Sized","std::clone::Clone"],"F":["std::clone::Clone","std::marker::Sized"],"T":["std::clone::Clone","std::marker::Sized"]},"access::Constant":{"T":["std::marker::Copy","std::cmp::PartialOrd","std::cmp::Ord","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash","std::clone::Clone"]},"access::ConstantDeref":{"T":["std::marker::Copy","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialOrd","std::cmp::Ord","std::cmp::PartialEq"]},"access::Map":{"A":["access::Access","std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::marker::Sized"],"F":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::ops::Fn","std::marker::Copy"],"T":["std::fmt::Debug","std::marker::Sized","std::marker::Copy","std::clone::Clone"]},"access::MapGuard":{"G":["std::marker::Sync","std::clone::Clone","std::fmt::Debug","std::marker::Copy","std::marker::Sized","std::marker::Send"],"T":["std::marker::Copy","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"cache::Cache":{"A":["std::marker::Sized","std::clone::Clone","std::ops::Deref","std::fmt::Debug"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::ops::Deref","std::clone::Clone","std::fmt::Debug"]},"cache::MapCache":{"A":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::ops::Deref"],"F":["std::marker::Sized","std::fmt::Debug","std::ops::FnMut","std::clone::Clone"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::clone::Clone","std::marker::Copy","gen_lock::LockStorage","std::default::Default","std::marker::Sized"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","strategy::sealed::InnerStrategy","std::marker::Sized","std::default::Default"]}}
candidates:{"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<cache::MapCache<A, T, F> as std::clone::Clone>::clone":{"A":["gen_lock::Global","strategy::gen_lock::GenLockStrategy","std::clone::impls::<impl std::clone::Clone for *mut T>","cache::MapCache","access::Constant","cache::Cache","strategy::hybrid::HybridStrategy","std::clone::impls::<impl std::clone::Clone for &T>","access::ConstantDeref","access::Map","access::MapGuard"],"F":["access::MapGuard","strategy::hybrid::HybridStrategy","std::clone::impls::<impl std::clone::Clone for *mut T>","access::ConstantDeref","cache::Cache","access::Map","cache::MapCache","gen_lock::Global","strategy::gen_lock::GenLockStrategy","std::clone::impls::<impl std::clone::Clone for &mut T>","access::Constant"],"T":["cache::Cache","strategy::gen_lock::GenLockStrategy","access::ConstantDeref","cache::MapCache","access::Map","access::Constant","strategy::hybrid::HybridStrategy","gen_lock::Global","std::clone::impls::<impl std::clone::Clone for &T>","access::MapGuard"]},"access::Constant":{"T":["access::ConstantDeref","access::Constant","<*const T as std::fmt::Debug>"]},"access::ConstantDeref":{"T":["std::ptr::const_ptr::<impl std::cmp::Ord for *const T>","access::ConstantDeref","access::Constant"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["access::Constant","access::Map","access::MapGuard","access::ConstantDeref","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"access::MapGuard":{"G":["std::marker::copy_impls::<impl std::marker::Copy for *mut T>","access::MapGuard"],"T":["access::ConstantDeref","access::Map","access::Constant","access::MapGuard","std::marker::copy_impls::<impl std::marker::Copy for *const T>"]},"cache::Cache":{"A":["<&mut T as std::fmt::Debug>","access::MapGuard","access::ConstantDeref"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"cache::MapCache":{"A":["access::ConstantDeref","access::MapGuard","std::clone::impls::<impl std::clone::Clone for &mut T>"],"T":["std::sync::Arc","std::option::Option"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::option::Option":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // cache::MapCache<A, T, F>
+p0.clone();
+<cache::MapCache<A, T, F> as std::clone::Clone>::clone(p0);
+crate::<cache::MapCache<A, T, F> as std::clone::Clone>::clone(p0);
+<cache::MapCache<A, T, F>>::clone(p0);
-----------------
src/cache.rs <cache::MapCache<A, T, F> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"<cache::MapCache<A, T, F> as std::fmt::Debug>::fmt":{"A":["std::marker::Sized","std::fmt::Debug"],"F":["std::fmt::Debug","std::marker::Sized"],"T":["std::marker::Sized","std::fmt::Debug"]},"ArcSwapAny":{"S":["std::marker::Sized","strategy::Strategy","std::default::Default"],"T":["std::default::Default","ref_cnt::RefCnt","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","std::fmt::Debug","ref_cnt::RefCnt","std::fmt::Display","std::default::Default"]},"access::Constant":{"T":["std::hash::Hash","std::cmp::Ord","std::cmp::PartialOrd","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::marker::Copy"]},"access::ConstantDeref":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::PartialOrd","std::marker::Copy","std::cmp::Ord","std::marker::Sized","std::cmp::Eq","std::hash::Hash","std::clone::Clone"]},"access::DirectDeref":{"S":["std::fmt::Debug","std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::fmt::Debug"]},"access::Map":{"A":["std::marker::Sized","std::fmt::Debug","std::marker::Copy","access::Access","std::clone::Clone"],"F":["std::ops::Fn","std::marker::Copy","std::clone::Clone","std::marker::Sized","std::fmt::Debug"],"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::marker::Copy"]},"access::MapGuard":{"G":["std::fmt::Debug","std::marker::Copy","std::marker::Sync","std::marker::Sized","std::clone::Clone","std::marker::Send"],"T":["std::fmt::Debug","std::marker::Sized","std::marker::Copy","std::clone::Clone"]},"cache::Cache":{"A":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::ops::Deref"],"T":["ref_cnt::RefCnt","std::fmt::Debug","std::ops::Deref","std::marker::Sized","std::clone::Clone"]},"cache::MapCache":{"A":["std::fmt::Debug","std::clone::Clone","std::ops::Deref","std::marker::Sized"],"F":["std::ops::FnMut","std::fmt::Debug","std::clone::Clone","std::marker::Sized"],"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","ref_cnt::RefCnt"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Copy","std::marker::Sized","std::default::Default","std::clone::Clone","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","strategy::sealed::InnerStrategy","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"]},"<cache::MapCache<A, T, F> as std::fmt::Debug>::fmt":{"A":["ArcSwapAny","access::MapGuard","access::Constant","<*const T as std::fmt::Debug>","<&mut T as std::fmt::Debug>","cache::MapCache","access::DirectDeref","cache::Cache","access::Map","access::ConstantDeref","Guard"],"F":["<*const T as std::fmt::Debug>","access::DirectDeref","access::ConstantDeref","access::Constant","access::Map","access::MapGuard","Guard","ArcSwapAny","cache::MapCache","<*mut T as std::fmt::Debug>","cache::Cache"],"T":["access::Map","<&T as std::fmt::Debug>","<*mut T as std::fmt::Debug>","access::Constant","cache::MapCache","cache::Cache","ArcSwapAny","access::ConstantDeref","Guard","access::DirectDeref","access::MapGuard"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc","std::sync::Arc"]},"access::Constant":{"T":["access::ConstantDeref","access::Constant","<*mut T as std::fmt::Debug>"]},"access::ConstantDeref":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","access::ConstantDeref","access::Constant"]},"access::DirectDeref":{"T":["std::sync::Arc","std::rc::Rc"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["access::ConstantDeref","access::MapGuard","access::Map","<*const T as std::fmt::Debug>","access::Constant"]},"access::MapGuard":{"G":["<*mut T as std::marker::Send>","access::MapGuard"],"T":["<*mut T as std::fmt::Debug>","access::MapGuard","access::Map","access::ConstantDeref","access::Constant"]},"cache::Cache":{"A":["access::ConstantDeref","std::clone::impls::<impl std::clone::Clone for &mut T>","access::MapGuard"],"T":["std::sync::Arc"]},"cache::MapCache":{"A":["access::ConstantDeref","std::clone::impls::<impl std::clone::Clone for &mut T>","access::MapGuard"],"T":["std::rc::Rc"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // cache::MapCache<A, T, F>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<cache::MapCache<A, T, F> as std::fmt::Debug>::fmt(p0, p1);
+crate::<cache::MapCache<A, T, F> as std::fmt::Debug>::fmt(p0, p1);
+<cache::MapCache<A, T, F>>::fmt(p0, p1);
-----------------
src/cache.rs <cache::MapCache<A, T, F> as cache::Access<U>>::load
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"<cache::MapCache<A, T, F> as cache::Access<U>>::load":{"A":["std::ops::Deref","std::marker::Sized"],"F":["std::marker::Sized","std::ops::FnMut"],"S":["strategy::Strategy","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt"],"U":["std::marker::Sized"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::default::Default"]},"access::Constant":{"T":["std::cmp::Eq","std::fmt::Debug","std::marker::Copy","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::PartialOrd","std::hash::Hash","std::cmp::Ord"]},"access::ConstantDeref":{"T":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Ord","std::cmp::PartialOrd","std::cmp::Eq","std::marker::Copy","std::marker::Sized","std::fmt::Debug","std::hash::Hash"]},"access::DirectDeref":{"S":["std::fmt::Debug","std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::fmt::Debug"]},"access::Map":{"A":["std::fmt::Debug","access::Access","std::clone::Clone","std::marker::Sized","std::marker::Copy"],"F":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::marker::Copy","std::ops::Fn"],"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::marker::Copy"]},"access::MapGuard":{"G":["std::marker::Sized","std::clone::Clone","std::marker::Copy","std::marker::Send","std::fmt::Debug","std::marker::Sync"],"T":["std::fmt::Debug","std::clone::Clone","std::marker::Copy","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::clone::Clone","std::marker::Copy","std::marker::Sized","std::default::Default"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::marker::Sized","strategy::sealed::InnerStrategy","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]},"<cache::MapCache<A, T, F> as cache::Access<U>>::load":{"A":["access::DirectDeref","Guard","<&mut T as std::ops::Deref>","access::DynGuard","access::ConstantDeref","access::MapGuard"],"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace"],"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::option::Option","std::rc::Rc"],"U":["RUG_ANY"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"access::Constant":{"T":["access::ConstantDeref","access::Constant","std::hash::impls::<impl std::hash::Hash for *const T>"]},"access::ConstantDeref":{"T":["access::ConstantDeref","std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","access::Constant"]},"access::DirectDeref":{"T":["std::sync::Arc","std::rc::Rc<T>","std::option::Option<T>","std::sync::Arc<T>"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["access::ConstantDeref","access::Map","access::Constant","access::MapGuard","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"access::MapGuard":{"G":["access::MapGuard","<*const T as std::marker::Sync>"],"T":["access::Constant","access::Map","access::ConstantDeref","access::MapGuard","<*const T as std::fmt::Debug>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::option::Option":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // cache::MapCache<A, T, F>
+p0.load();
+<cache::MapCache<A, T, F> as cache::Access<U>>::load(p0);
+crate::<cache::MapCache<A, T, F> as cache::Access<U>>::load(p0);
+<cache::MapCache<A, T, F>>::load(p0);
-----------------
src/debt.rs <debt::Debt as std::default::Default>::default
deps:{}
candidates:{}
+<debt::Debt as std::default::Default>::default();
+crate::<debt::Debt as std::default::Default>::default();
+<debt::Debt>::default();
-----------------
src/debt.rs <debt::Slots as std::default::Default>::default
deps:{}
candidates:{}
+<debt::Slots as std::default::Default>::default();
+crate::<debt::Slots as std::default::Default>::default();
+<debt::Slots>::default();
-----------------
src/debt.rs <debt::Node as std::default::Default>::default
deps:{}
candidates:{}
+<debt::Node as std::default::Default>::default();
+crate::<debt::Node as std::default::Default>::default();
+<debt::Node>::default();
-----------------
src/debt.rs debt::Node::get
deps:{}
candidates:{}
+debt::Node::get();
+crate::debt::Node::get();
+<debt::Node>::get();
-----------------
src/debt.rs <debt::DebtHead as std::ops::Drop>::drop
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // debt::DebtHead
+p0.drop();
+<debt::DebtHead as std::ops::Drop>::drop(p0);
+crate::<debt::DebtHead as std::ops::Drop>::drop(p0);
+<debt::DebtHead>::drop(p0);
-----------------
src/debt.rs debt::Debt::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+debt::Debt::new(p0);
+crate::debt::Debt::new(p0);
+<debt::Debt>::new(p0);
-----------------
src/debt.rs debt::Debt::pay
deps:{"debt::Debt::pay":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"debt::Debt::pay":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::option::Option":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // debt::Debt
let mut p1 = MaybeUninit::uninit().assume_init(); // *const <T as ref_cnt::RefCnt>::Base
+p0.pay(p1);
+debt::Debt::pay(p0, p1);
+crate::debt::Debt::pay(p0, p1);
+<debt::Debt>::pay(p0, p1);
-----------------
src/debt.rs debt::Debt::pay_all
deps:{"debt::Debt::pay_all":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"debt::Debt::pay_all":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // *const <T as ref_cnt::RefCnt>::Base
+debt::Debt::pay_all(p0);
+crate::debt::Debt::pay_all(p0);
+<debt::Debt>::pay_all(p0);
-----------------
src/gen_lock.rs <gen_lock::Shard as std::default::Default>::default
deps:{}
candidates:{}
+<gen_lock::Shard as std::default::Default>::default();
+crate::<gen_lock::Shard as std::default::Default>::default();
+<gen_lock::Shard>::default();
-----------------
src/gen_lock.rs <gen_lock::Shard as std::borrow::Borrow<[std::sync::atomic::AtomicUsize; _]>>::borrow
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // gen_lock::Shard
+p0.borrow();
+<gen_lock::Shard as std::borrow::Borrow<[std::sync::atomic::AtomicUsize; _]>>::borrow(p0);
+crate::<gen_lock::Shard as std::borrow::Borrow<[std::sync::atomic::AtomicUsize; _]>>::borrow(p0);
+<gen_lock::Shard>::borrow(p0);
-----------------
src/gen_lock.rs <gen_lock::Global as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // gen_lock::Global
+p0.clone();
+<gen_lock::Global as std::clone::Clone>::clone(p0);
+crate::<gen_lock::Global as std::clone::Clone>::clone(p0);
+<gen_lock::Global>::clone(p0);
-----------------
src/gen_lock.rs <gen_lock::Global as std::default::Default>::default
deps:{}
candidates:{}
+<gen_lock::Global as std::default::Default>::default();
+crate::<gen_lock::Global as std::default::Default>::default();
+<gen_lock::Global>::default();
-----------------
src/gen_lock.rs <gen_lock::Global as gen_lock::LockStorage>::gen_idx
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // gen_lock::Global
+p0.gen_idx();
+<gen_lock::Global as gen_lock::LockStorage>::gen_idx(p0);
+crate::<gen_lock::Global as gen_lock::LockStorage>::gen_idx(p0);
+<gen_lock::Global>::gen_idx(p0);
-----------------
src/gen_lock.rs <gen_lock::Global as gen_lock::LockStorage>::shards
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // gen_lock::Global
+p0.shards();
+<gen_lock::Global as gen_lock::LockStorage>::shards(p0);
+crate::<gen_lock::Global as gen_lock::LockStorage>::shards(p0);
+<gen_lock::Global>::shards(p0);
-----------------
src/gen_lock.rs <gen_lock::Global as gen_lock::LockStorage>::choose_shard
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // gen_lock::Global
+p0.choose_shard();
+<gen_lock::Global as gen_lock::LockStorage>::choose_shard(p0);
+crate::<gen_lock::Global as gen_lock::LockStorage>::choose_shard(p0);
+<gen_lock::Global>::choose_shard(p0);
-----------------
src/gen_lock.rs <gen_lock::PrivateUnsharded as std::default::Default>::default
deps:{}
candidates:{}
+<gen_lock::PrivateUnsharded as std::default::Default>::default();
+crate::<gen_lock::PrivateUnsharded as std::default::Default>::default();
+<gen_lock::PrivateUnsharded>::default();
-----------------
src/gen_lock.rs <gen_lock::PrivateUnsharded as gen_lock::LockStorage>::gen_idx
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // gen_lock::PrivateUnsharded
+p0.gen_idx();
+<gen_lock::PrivateUnsharded as gen_lock::LockStorage>::gen_idx(p0);
+crate::<gen_lock::PrivateUnsharded as gen_lock::LockStorage>::gen_idx(p0);
+<gen_lock::PrivateUnsharded>::gen_idx(p0);
-----------------
src/gen_lock.rs <gen_lock::PrivateUnsharded as gen_lock::LockStorage>::shards
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // gen_lock::PrivateUnsharded
+p0.shards();
+<gen_lock::PrivateUnsharded as gen_lock::LockStorage>::shards(p0);
+crate::<gen_lock::PrivateUnsharded as gen_lock::LockStorage>::shards(p0);
+<gen_lock::PrivateUnsharded>::shards(p0);
-----------------
src/gen_lock.rs <gen_lock::PrivateUnsharded as gen_lock::LockStorage>::choose_shard
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // gen_lock::PrivateUnsharded
+p0.choose_shard();
+<gen_lock::PrivateUnsharded as gen_lock::LockStorage>::choose_shard(p0);
+crate::<gen_lock::PrivateUnsharded as gen_lock::LockStorage>::choose_shard(p0);
+<gen_lock::PrivateUnsharded>::choose_shard(p0);
-----------------
src/gen_lock.rs gen_lock::GenLock::<'a>::new
'a
deps:{"gen_lock::GenLock::<'a>::new":{"S":["gen_lock::LockStorage","std::marker::Sized"]}}
candidates:{"gen_lock::GenLock::<'a>::new":{"S":["gen_lock::Global","gen_lock::PrivateUnsharded"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // S
+gen_lock::GenLock::<'a>::new(p0);
+crate::gen_lock::GenLock::<'a>::new(p0);
+<gen_lock::GenLock<'a>>::new(p0);
-----------------
src/gen_lock.rs <gen_lock::GenLock<'_> as std::ops::Drop>::drop
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // gen_lock::GenLock<'_>
+p0.drop();
+<gen_lock::GenLock<'_> as std::ops::Drop>::drop(p0);
+crate::<gen_lock::GenLock<'_> as std::ops::Drop>::drop(p0);
+<gen_lock::GenLock<'_>>::drop(p0);
-----------------
src/ref_cnt.rs <std::sync::Arc<T> as ref_cnt::RefCnt>::into_ptr
deps:{"<std::sync::Arc<T> as ref_cnt::RefCnt>::into_ptr":{"T":["std::marker::Sized"]}}
candidates:{"<std::sync::Arc<T> as ref_cnt::RefCnt>::into_ptr":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::sync::Arc<T>
+<std::sync::Arc<T> as ref_cnt::RefCnt>::into_ptr(p0);
+crate::<std::sync::Arc<T> as ref_cnt::RefCnt>::into_ptr(p0);
+<std::sync::Arc<T>>::into_ptr(p0);
-----------------
src/ref_cnt.rs <std::sync::Arc<T> as ref_cnt::RefCnt>::as_ptr
deps:{"<std::sync::Arc<T> as ref_cnt::RefCnt>::as_ptr":{"T":["std::marker::Sized"]}}
candidates:{"<std::sync::Arc<T> as ref_cnt::RefCnt>::as_ptr":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::Arc<T>
+<std::sync::Arc<T> as ref_cnt::RefCnt>::as_ptr(p0);
+crate::<std::sync::Arc<T> as ref_cnt::RefCnt>::as_ptr(p0);
+<std::sync::Arc<T>>::as_ptr(p0);
-----------------
src/ref_cnt.rs <std::sync::Arc<T> as ref_cnt::RefCnt>::from_ptr
deps:{"<std::sync::Arc<T> as ref_cnt::RefCnt>::from_ptr":{"T":["std::marker::Sized"]}}
candidates:{"<std::sync::Arc<T> as ref_cnt::RefCnt>::from_ptr":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // *const T
+<std::sync::Arc<T> as ref_cnt::RefCnt>::from_ptr(p0);
+crate::<std::sync::Arc<T> as ref_cnt::RefCnt>::from_ptr(p0);
+<std::sync::Arc<T>>::from_ptr(p0);
-----------------
src/ref_cnt.rs <std::rc::Rc<T> as ref_cnt::RefCnt>::into_ptr
deps:{"<std::rc::Rc<T> as ref_cnt::RefCnt>::into_ptr":{"T":["std::marker::Sized"]}}
candidates:{"<std::rc::Rc<T> as ref_cnt::RefCnt>::into_ptr":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::rc::Rc<T>
+<std::rc::Rc<T> as ref_cnt::RefCnt>::into_ptr(p0);
+crate::<std::rc::Rc<T> as ref_cnt::RefCnt>::into_ptr(p0);
+<std::rc::Rc<T>>::into_ptr(p0);
-----------------
src/ref_cnt.rs <std::rc::Rc<T> as ref_cnt::RefCnt>::as_ptr
deps:{"<std::rc::Rc<T> as ref_cnt::RefCnt>::as_ptr":{"T":["std::marker::Sized"]}}
candidates:{"<std::rc::Rc<T> as ref_cnt::RefCnt>::as_ptr":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::rc::Rc<T>
+<std::rc::Rc<T> as ref_cnt::RefCnt>::as_ptr(p0);
+crate::<std::rc::Rc<T> as ref_cnt::RefCnt>::as_ptr(p0);
+<std::rc::Rc<T>>::as_ptr(p0);
-----------------
src/ref_cnt.rs <std::rc::Rc<T> as ref_cnt::RefCnt>::from_ptr
deps:{"<std::rc::Rc<T> as ref_cnt::RefCnt>::from_ptr":{"T":["std::marker::Sized"]}}
candidates:{"<std::rc::Rc<T> as ref_cnt::RefCnt>::from_ptr":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // *const T
+<std::rc::Rc<T> as ref_cnt::RefCnt>::from_ptr(p0);
+crate::<std::rc::Rc<T> as ref_cnt::RefCnt>::from_ptr(p0);
+<std::rc::Rc<T>>::from_ptr(p0);
-----------------
src/ref_cnt.rs <std::option::Option<T> as ref_cnt::RefCnt>::into_ptr
deps:{"<std::option::Option<T> as ref_cnt::RefCnt>::into_ptr":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]}}
candidates:{"<std::option::Option<T> as ref_cnt::RefCnt>::into_ptr":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<T>
+<std::option::Option<T> as ref_cnt::RefCnt>::into_ptr(p0);
+crate::<std::option::Option<T> as ref_cnt::RefCnt>::into_ptr(p0);
+<std::option::Option<T>>::into_ptr(p0);
-----------------
src/ref_cnt.rs <std::option::Option<T> as ref_cnt::RefCnt>::as_ptr
deps:{"<std::option::Option<T> as ref_cnt::RefCnt>::as_ptr":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"<std::option::Option<T> as ref_cnt::RefCnt>::as_ptr":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]},"std::option::Option":{"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::option::Option<T>
+<std::option::Option<T> as ref_cnt::RefCnt>::as_ptr(p0);
+crate::<std::option::Option<T> as ref_cnt::RefCnt>::as_ptr(p0);
+<std::option::Option<T>>::as_ptr(p0);
-----------------
src/ref_cnt.rs <std::option::Option<T> as ref_cnt::RefCnt>::from_ptr
deps:{"<std::option::Option<T> as ref_cnt::RefCnt>::from_ptr":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"<std::option::Option<T> as ref_cnt::RefCnt>::from_ptr":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::option::Option":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // *const <T as ref_cnt::RefCnt>::Base
+<std::option::Option<T> as ref_cnt::RefCnt>::from_ptr(p0);
+crate::<std::option::Option<T> as ref_cnt::RefCnt>::from_ptr(p0);
+<std::option::Option<T>>::from_ptr(p0);
-----------------
src/strategy/gen_lock.rs <strategy::gen_lock::GenLockStrategy<L> as std::clone::Clone>::clone
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<strategy::gen_lock::GenLockStrategy<L> as std::clone::Clone>::clone":{"L":["std::clone::Clone","std::marker::Sized"]},"access::Constant":{"T":["std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash","std::fmt::Debug","std::marker::Copy","std::marker::Sized","std::cmp::PartialOrd","std::clone::Clone","std::cmp::Ord"]},"access::ConstantDeref":{"T":["std::fmt::Debug","std::cmp::Eq","std::hash::Hash","std::marker::Copy","std::cmp::PartialEq","std::clone::Clone","std::cmp::Ord","std::marker::Sized","std::cmp::PartialOrd"]},"access::Map":{"A":["access::Access","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::marker::Copy"],"F":["std::marker::Copy","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::ops::Fn"],"T":["std::marker::Sized","std::clone::Clone","std::marker::Copy","std::fmt::Debug"]},"access::MapGuard":{"G":["std::marker::Sync","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Copy"],"T":["std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::marker::Sized"]},"cache::Cache":{"A":["std::ops::Deref","std::marker::Sized","std::clone::Clone","std::fmt::Debug"],"T":["std::fmt::Debug","ref_cnt::RefCnt","std::clone::Clone","std::marker::Sized","std::ops::Deref"]},"cache::MapCache":{"A":["std::marker::Sized","std::clone::Clone","std::ops::Deref","std::fmt::Debug"],"F":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::ops::FnMut"],"T":["std::marker::Sized","std::clone::Clone","ref_cnt::RefCnt","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::marker::Sized","std::default::Default","std::marker::Copy","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","std::clone::Clone","std::default::Default","strategy::sealed::InnerStrategy"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<strategy::gen_lock::GenLockStrategy<L> as std::clone::Clone>::clone":{"L":["strategy::gen_lock::GenLockStrategy","access::Constant","cache::MapCache","gen_lock::Global","access::Map","std::clone::impls::<impl std::clone::Clone for &T>","strategy::hybrid::HybridStrategy","access::MapGuard","std::clone::impls::<impl std::clone::Clone for *mut T>","access::ConstantDeref","cache::Cache"]},"access::Constant":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","access::ConstantDeref","access::Constant"]},"access::ConstantDeref":{"T":["access::Constant","std::ptr::const_ptr::<impl std::cmp::Ord for *const T>","access::ConstantDeref"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["access::ConstantDeref","access::MapGuard","access::Map","access::Constant","std::marker::copy_impls::<impl std::marker::Copy for *const T>"]},"access::MapGuard":{"G":["std::marker::copy_impls::<impl std::marker::Copy for *mut T>","access::MapGuard"],"T":["std::marker::copy_impls::<impl std::marker::Copy for *mut T>","access::Constant","access::MapGuard","access::ConstantDeref","access::Map"]},"cache::Cache":{"A":["access::MapGuard","std::clone::impls::<impl std::clone::Clone for &T>","access::ConstantDeref"],"T":["std::rc::Rc<T>","std::sync::Arc<T>"]},"cache::MapCache":{"A":["std::clone::impls::<impl std::clone::Clone for &mut T>","access::ConstantDeref","access::MapGuard"],"T":["std::sync::Arc","std::rc::Rc"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // strategy::gen_lock::GenLockStrategy<L>
+p0.clone();
+<strategy::gen_lock::GenLockStrategy<L> as std::clone::Clone>::clone(p0);
+crate::<strategy::gen_lock::GenLockStrategy<L> as std::clone::Clone>::clone(p0);
+<strategy::gen_lock::GenLockStrategy<L>>::clone(p0);
-----------------
src/strategy/gen_lock.rs <strategy::gen_lock::GenLockStrategy<L> as std::default::Default>::default
deps:{"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"<strategy::gen_lock::GenLockStrategy<L> as std::default::Default>::default":{"L":["std::marker::Sized","std::default::Default"]},"ArcSwapAny":{"S":["std::marker::Sized","strategy::Strategy","std::default::Default"],"T":["std::fmt::Display","std::fmt::Debug","std::default::Default","std::marker::Sized","ref_cnt::RefCnt"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","ref_cnt::RefCnt","std::default::Default"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::default::Default","std::marker::Copy","std::marker::Sized","std::clone::Clone","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","std::default::Default","std::marker::Sized","strategy::sealed::InnerStrategy"]}}
candidates:{"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]},"<strategy::gen_lock::GenLockStrategy<L> as std::default::Default>::default":{"L":["debt::Debt","gen_lock::Shard","ArcSwapAny","debt::Slots","gen_lock::Global","Guard","debt::Node","gen_lock::PrivateUnsharded","strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"Guard":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>","<S as strategy::Strategy<T>>"],"T":["std::sync::Arc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
+<strategy::gen_lock::GenLockStrategy<L> as std::default::Default>::default();
+crate::<strategy::gen_lock::GenLockStrategy<L> as std::default::Default>::default();
+<strategy::gen_lock::GenLockStrategy<L>>::default();
-----------------
src/strategy/gen_lock.rs <strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::InnerStrategy<T>>::load
deps:{"<strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::InnerStrategy<T>>::load":{"L":["gen_lock::LockStorage","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"<strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::InnerStrategy<T>>::load":{"L":["gen_lock::PrivateUnsharded","gen_lock::Global"],"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::option::Option":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // strategy::gen_lock::GenLockStrategy<L>
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::sync::atomic::AtomicPtr<<T as ref_cnt::RefCnt>::Base>
+p0.load(p1);
+<strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::InnerStrategy<T>>::load(p0, p1);
+crate::<strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::InnerStrategy<T>>::load(p0, p1);
+<strategy::gen_lock::GenLockStrategy<L>>::load(p0, p1);
-----------------
src/strategy/gen_lock.rs <strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::InnerStrategy<T>>::wait_for_readers
deps:{"<strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::InnerStrategy<T>>::wait_for_readers":{"L":["std::marker::Sized","gen_lock::LockStorage"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"<strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::InnerStrategy<T>>::wait_for_readers":{"L":["gen_lock::Global","gen_lock::PrivateUnsharded"],"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // strategy::gen_lock::GenLockStrategy<L>
let mut p1 = MaybeUninit::uninit().assume_init(); // *const <T as ref_cnt::RefCnt>::Base
+p0.wait_for_readers(p1);
+<strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::InnerStrategy<T>>::wait_for_readers(p0, p1);
+crate::<strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::InnerStrategy<T>>::wait_for_readers(p0, p1);
+<strategy::gen_lock::GenLockStrategy<L>>::wait_for_readers(p0, p1);
-----------------
src/strategy/gen_lock.rs <strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::CaS<T>>::compare_and_swap
deps:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"<strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::CaS<T>>::compare_and_swap":{"C":["as_raw::AsRaw","std::marker::Sized"],"L":["gen_lock::LockStorage","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::fmt::Display","ref_cnt::RefCnt","std::marker::Sized","std::fmt::Debug","std::default::Default"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::default::Default","std::clone::Clone","std::marker::Copy","std::marker::Sized"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","std::default::Default","strategy::sealed::InnerStrategy","std::marker::Sized"]}}
candidates:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]},"<strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::CaS<T>>::compare_and_swap":{"C":["<*const T as as_raw::AsRaw<T>>","<*mut T as as_raw::AsRaw<T>>","Guard"],"L":["gen_lock::PrivateUnsharded","gen_lock::Global"],"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"Guard":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>","<S as strategy::Strategy<T>>"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"std::option::Option":{"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // strategy::gen_lock::GenLockStrategy<L>
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::sync::atomic::AtomicPtr<<T as ref_cnt::RefCnt>::Base>
let mut p2 = MaybeUninit::uninit().assume_init(); // C
let mut p3 = MaybeUninit::uninit().assume_init(); // T
+p0.compare_and_swap(p1, p2, p3);
+<strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::CaS<T>>::compare_and_swap(p0, p1, p2, p3);
+crate::<strategy::gen_lock::GenLockStrategy<L> as strategy::sealed::CaS<T>>::compare_and_swap(p0, p1, p2, p3);
+<strategy::gen_lock::GenLockStrategy<L>>::compare_and_swap(p0, p1, p2, p3);
-----------------
src/strategy/hybrid.rs strategy::hybrid::HybridProtection::<T>::new
deps:{"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::hybrid::HybridProtection::<T>::new":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"std::option::Option":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]},"strategy::hybrid::HybridProtection::<T>::new":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // *const <T as ref_cnt::RefCnt>::Base
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<&'static debt::Debt>
+strategy::hybrid::HybridProtection::<T>::new(p0, p1);
+crate::strategy::hybrid::HybridProtection::<T>::new(p0, p1);
+<strategy::hybrid::HybridProtection<T>>::new(p0, p1);
-----------------
src/strategy/hybrid.rs strategy::hybrid::HybridProtection::<T>::attempt
deps:{"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::hybrid::HybridProtection::<T>::attempt":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"strategy::hybrid::HybridProtection::<T>::attempt":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::atomic::AtomicPtr<<T as ref_cnt::RefCnt>::Base>
+strategy::hybrid::HybridProtection::<T>::attempt(p0);
+crate::strategy::hybrid::HybridProtection::<T>::attempt(p0);
+<strategy::hybrid::HybridProtection<T>>::attempt(p0);
-----------------
src/strategy/hybrid.rs <strategy::hybrid::HybridProtection<T> as std::ops::Drop>::drop
deps:{"<strategy::hybrid::HybridProtection<T> as std::ops::Drop>::drop":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"<strategy::hybrid::HybridProtection<T> as std::ops::Drop>::drop":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]},"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // strategy::hybrid::HybridProtection<T>
+p0.drop();
+<strategy::hybrid::HybridProtection<T> as std::ops::Drop>::drop(p0);
+crate::<strategy::hybrid::HybridProtection<T> as std::ops::Drop>::drop(p0);
+<strategy::hybrid::HybridProtection<T>>::drop(p0);
-----------------
src/strategy/hybrid.rs <strategy::hybrid::HybridProtection<T> as strategy::sealed::Protected<T>>::from_inner
deps:{"<strategy::hybrid::HybridProtection<T> as strategy::sealed::Protected<T>>::from_inner":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]}}
candidates:{"<strategy::hybrid::HybridProtection<T> as strategy::sealed::Protected<T>>::from_inner":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+<strategy::hybrid::HybridProtection<T> as strategy::sealed::Protected<T>>::from_inner(p0);
+crate::<strategy::hybrid::HybridProtection<T> as strategy::sealed::Protected<T>>::from_inner(p0);
+<strategy::hybrid::HybridProtection<T>>::from_inner(p0);
-----------------
src/strategy/hybrid.rs <strategy::hybrid::HybridProtection<T> as strategy::sealed::Protected<T>>::into_inner
deps:{"<strategy::hybrid::HybridProtection<T> as strategy::sealed::Protected<T>>::into_inner":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]}}
candidates:{"<strategy::hybrid::HybridProtection<T> as strategy::sealed::Protected<T>>::into_inner":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // strategy::hybrid::HybridProtection<T>
+p0.into_inner();
+<strategy::hybrid::HybridProtection<T> as strategy::sealed::Protected<T>>::into_inner(p0);
+crate::<strategy::hybrid::HybridProtection<T> as strategy::sealed::Protected<T>>::into_inner(p0);
+<strategy::hybrid::HybridProtection<T>>::into_inner(p0);
-----------------
src/strategy/hybrid.rs <strategy::hybrid::HybridProtection<T> as std::borrow::Borrow<T>>::borrow
deps:{"<strategy::hybrid::HybridProtection<T> as std::borrow::Borrow<T>>::borrow":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"<strategy::hybrid::HybridProtection<T> as std::borrow::Borrow<T>>::borrow":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]},"std::option::Option":{"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // strategy::hybrid::HybridProtection<T>
+p0.borrow();
+<strategy::hybrid::HybridProtection<T> as std::borrow::Borrow<T>>::borrow(p0);
+crate::<strategy::hybrid::HybridProtection<T> as std::borrow::Borrow<T>>::borrow(p0);
+<strategy::hybrid::HybridProtection<T>>::borrow(p0);
-----------------
src/strategy/hybrid.rs <strategy::hybrid::HybridStrategy<F> as std::clone::Clone>::clone
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<strategy::hybrid::HybridStrategy<F> as std::clone::Clone>::clone":{"F":["std::marker::Sized","std::clone::Clone"]},"access::Constant":{"T":["std::hash::Hash","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::PartialOrd","std::cmp::Ord","std::marker::Copy"]},"access::ConstantDeref":{"T":["std::marker::Sized","std::cmp::PartialOrd","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::marker::Copy","std::hash::Hash","std::fmt::Debug","std::clone::Clone"]},"access::Map":{"A":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::marker::Copy","access::Access"],"F":["std::clone::Clone","std::marker::Sized","std::marker::Copy","std::fmt::Debug","std::ops::Fn"],"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::marker::Copy"]},"access::MapGuard":{"G":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::marker::Send","std::marker::Copy","std::marker::Sync"],"T":["std::marker::Copy","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"cache::Cache":{"A":["std::ops::Deref","std::clone::Clone","std::marker::Sized","std::fmt::Debug"],"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::ops::Deref","ref_cnt::RefCnt"]},"cache::MapCache":{"A":["std::ops::Deref","std::fmt::Debug","std::clone::Clone","std::marker::Sized"],"F":["std::marker::Sized","std::ops::FnMut","std::clone::Clone","std::fmt::Debug"],"T":["std::marker::Sized","std::fmt::Debug","ref_cnt::RefCnt","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::clone::Clone","std::marker::Sized","std::marker::Copy","std::default::Default"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::marker::Sized","std::default::Default","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<strategy::hybrid::HybridStrategy<F> as std::clone::Clone>::clone":{"F":["gen_lock::Global","access::MapGuard","std::clone::impls::<impl std::clone::Clone for *const T>","access::Constant","cache::MapCache","std::clone::impls::<impl std::clone::Clone for &mut T>","strategy::hybrid::HybridStrategy","access::ConstantDeref","access::Map","cache::Cache","strategy::gen_lock::GenLockStrategy"]},"access::Constant":{"T":["access::ConstantDeref","access::Constant","std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>"]},"access::ConstantDeref":{"T":["<*mut T as std::fmt::Debug>","access::ConstantDeref","access::Constant"]},"access::Map":{"A":["access::Constant","access::Map"],"T":["access::MapGuard","<*mut T as std::fmt::Debug>","access::ConstantDeref","access::Constant","access::Map"]},"access::MapGuard":{"G":["access::MapGuard","std::clone::impls::<impl std::clone::Clone for *mut T>"],"T":["access::Constant","std::clone::impls::<impl std::clone::Clone for *const T>","access::MapGuard","access::Map","access::ConstantDeref"]},"cache::Cache":{"A":["<&T as std::ops::Deref>","access::MapGuard","access::ConstantDeref"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"cache::MapCache":{"A":["access::MapGuard","std::clone::impls::<impl std::clone::Clone for &T>","access::ConstantDeref"],"T":["std::sync::Arc","std::rc::Rc"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // strategy::hybrid::HybridStrategy<F>
+p0.clone();
+<strategy::hybrid::HybridStrategy<F> as std::clone::Clone>::clone(p0);
+crate::<strategy::hybrid::HybridStrategy<F> as std::clone::Clone>::clone(p0);
+<strategy::hybrid::HybridStrategy<F>>::clone(p0);
-----------------
src/strategy/hybrid.rs <strategy::hybrid::HybridStrategy<F> as std::default::Default>::default
deps:{"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"<strategy::hybrid::HybridStrategy<F> as std::default::Default>::default":{"F":["std::marker::Sized","std::default::Default"]},"ArcSwapAny":{"S":["std::marker::Sized","strategy::Strategy","std::default::Default"],"T":["std::default::Default","ref_cnt::RefCnt","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::fmt::Debug","std::fmt::Display","std::default::Default","std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::marker::Copy","std::clone::Clone","gen_lock::LockStorage","std::default::Default"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::marker::Sized","std::clone::Clone","std::default::Default"]}}
candidates:{"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"]},"<strategy::hybrid::HybridStrategy<F> as std::default::Default>::default":{"F":["gen_lock::PrivateUnsharded","strategy::hybrid::HybridStrategy","gen_lock::Global","debt::Debt","debt::Slots","ArcSwapAny","debt::Node","gen_lock::Shard","strategy::gen_lock::GenLockStrategy","Guard"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc<T>","std::rc::Rc<T>"]},"Guard":{"S":["<S as strategy::Strategy<T>>","strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::sync::Arc<T>","std::sync::Arc","std::rc::Rc<T>"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
+<strategy::hybrid::HybridStrategy<F> as std::default::Default>::default();
+crate::<strategy::hybrid::HybridStrategy<F> as std::default::Default>::default();
+<strategy::hybrid::HybridStrategy<F>>::default();
-----------------
src/strategy/hybrid.rs <strategy::hybrid::HybridStrategy<F> as strategy::sealed::InnerStrategy<T>>::load
deps:{"<strategy::hybrid::HybridStrategy<F> as strategy::sealed::InnerStrategy<T>>::load":{"F":["strategy::sealed::InnerStrategy","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","gen_lock::LockStorage","std::marker::Copy","std::default::Default","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","std::clone::Clone","std::default::Default","strategy::sealed::InnerStrategy"]}}
candidates:{"<strategy::hybrid::HybridStrategy<F> as strategy::sealed::InnerStrategy<T>>::load":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"],"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"std::option::Option":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // strategy::hybrid::HybridStrategy<F>
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::sync::atomic::AtomicPtr<<T as ref_cnt::RefCnt>::Base>
+p0.load(p1);
+<strategy::hybrid::HybridStrategy<F> as strategy::sealed::InnerStrategy<T>>::load(p0, p1);
+crate::<strategy::hybrid::HybridStrategy<F> as strategy::sealed::InnerStrategy<T>>::load(p0, p1);
+<strategy::hybrid::HybridStrategy<F>>::load(p0, p1);
-----------------
src/strategy/hybrid.rs <strategy::hybrid::HybridStrategy<F> as strategy::sealed::InnerStrategy<T>>::wait_for_readers
deps:{"<strategy::hybrid::HybridStrategy<F> as strategy::sealed::InnerStrategy<T>>::wait_for_readers":{"F":["std::marker::Sized","strategy::sealed::InnerStrategy"],"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::default::Default","std::marker::Copy","std::clone::Clone","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","std::marker::Sized","std::default::Default","strategy::sealed::InnerStrategy"]}}
candidates:{"<strategy::hybrid::HybridStrategy<F> as strategy::sealed::InnerStrategy<T>>::wait_for_readers":{"F":["std::sync::RwLock","strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"],"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // strategy::hybrid::HybridStrategy<F>
let mut p1 = MaybeUninit::uninit().assume_init(); // *const <T as ref_cnt::RefCnt>::Base
+p0.wait_for_readers(p1);
+<strategy::hybrid::HybridStrategy<F> as strategy::sealed::InnerStrategy<T>>::wait_for_readers(p0, p1);
+crate::<strategy::hybrid::HybridStrategy<F> as strategy::sealed::InnerStrategy<T>>::wait_for_readers(p0, p1);
+<strategy::hybrid::HybridStrategy<F>>::wait_for_readers(p0, p1);
-----------------
src/strategy/hybrid.rs <strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<L>> as strategy::sealed::CaS<T>>::compare_and_swap
deps:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"<strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<L>> as strategy::sealed::CaS<T>>::compare_and_swap":{"C":["as_raw::AsRaw","std::marker::Sized"],"L":["gen_lock::LockStorage","std::marker::Sized"],"T":["ref_cnt::RefCnt","std::marker::Sized"]},"Guard":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::default::Default","std::fmt::Display","std::fmt::Debug","ref_cnt::RefCnt","std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::marker::Copy","std::default::Default","std::clone::Clone","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","strategy::sealed::InnerStrategy","std::default::Default","std::marker::Sized"]}}
candidates:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock","strategy::hybrid::HybridStrategy"]},"<strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<L>> as strategy::sealed::CaS<T>>::compare_and_swap":{"C":["<*const T as as_raw::AsRaw<T>>","Guard"],"L":["gen_lock::PrivateUnsharded","gen_lock::Global"],"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]},"Guard":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>","<S as strategy::Strategy<T>>"],"T":["std::rc::Rc<T>","std::sync::Arc<T>","std::rc::Rc"]},"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<L>>
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::sync::atomic::AtomicPtr<<T as ref_cnt::RefCnt>::Base>
let mut p2 = MaybeUninit::uninit().assume_init(); // C
let mut p3 = MaybeUninit::uninit().assume_init(); // T
+p0.compare_and_swap(p1, p2, p3);
+<strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<L>> as strategy::sealed::CaS<T>>::compare_and_swap(p0, p1, p2, p3);
+crate::<strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<L>> as strategy::sealed::CaS<T>>::compare_and_swap(p0, p1, p2, p3);
+<strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<L>>>::compare_and_swap(p0, p1, p2, p3);
-----------------
src/strategy/rw_lock.rs strategy::rw_lock::<impl strategy::sealed::Protected<T> for T>::from_inner
deps:{"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::rw_lock::<impl strategy::sealed::Protected<T> for T>::from_inner":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"std::option::Option":{"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]},"strategy::rw_lock::<impl strategy::sealed::Protected<T> for T>::from_inner":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+strategy::rw_lock::<impl strategy::sealed::Protected<T> for T>::from_inner(p0);
+crate::strategy::rw_lock::<impl strategy::sealed::Protected<T> for T>::from_inner(p0);
+<T>::from_inner(p0);
-----------------
src/strategy/rw_lock.rs strategy::rw_lock::<impl strategy::sealed::Protected<T> for T>::into_inner
deps:{"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::rw_lock::<impl strategy::sealed::Protected<T> for T>::into_inner":{"T":["ref_cnt::RefCnt","std::marker::Sized"]}}
candidates:{"std::option::Option":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"strategy::rw_lock::<impl strategy::sealed::Protected<T> for T>::into_inner":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+p0.into_inner();
+strategy::rw_lock::<impl strategy::sealed::Protected<T> for T>::into_inner(p0);
+crate::strategy::rw_lock::<impl strategy::sealed::Protected<T> for T>::into_inner(p0);
+<T>::into_inner(p0);
-----------------
src/strategy/rw_lock.rs strategy::rw_lock::<impl strategy::sealed::InnerStrategy<T> for std::sync::RwLock<()>>::load
deps:{"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::rw_lock::<impl strategy::sealed::InnerStrategy<T> for std::sync::RwLock<()>>::load":{"T":["ref_cnt::RefCnt","std::marker::Sized"]}}
candidates:{"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"strategy::rw_lock::<impl strategy::sealed::InnerStrategy<T> for std::sync::RwLock<()>>::load":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::RwLock<()>
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::sync::atomic::AtomicPtr<<T as ref_cnt::RefCnt>::Base>
+p0.load(p1);
+strategy::rw_lock::<impl strategy::sealed::InnerStrategy<T> for std::sync::RwLock<()>>::load(p0, p1);
+crate::strategy::rw_lock::<impl strategy::sealed::InnerStrategy<T> for std::sync::RwLock<()>>::load(p0, p1);
+<std::sync::RwLock<()>>::load(p0, p1);
-----------------
src/strategy/rw_lock.rs strategy::rw_lock::<impl strategy::sealed::InnerStrategy<T> for std::sync::RwLock<()>>::wait_for_readers
deps:{"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::rw_lock::<impl strategy::sealed::InnerStrategy<T> for std::sync::RwLock<()>>::wait_for_readers":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"std::option::Option":{"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]},"strategy::rw_lock::<impl strategy::sealed::InnerStrategy<T> for std::sync::RwLock<()>>::wait_for_readers":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::RwLock<()>
let mut p1 = MaybeUninit::uninit().assume_init(); // *const <T as ref_cnt::RefCnt>::Base
+p0.wait_for_readers(p1);
+strategy::rw_lock::<impl strategy::sealed::InnerStrategy<T> for std::sync::RwLock<()>>::wait_for_readers(p0, p1);
+crate::strategy::rw_lock::<impl strategy::sealed::InnerStrategy<T> for std::sync::RwLock<()>>::wait_for_readers(p0, p1);
+<std::sync::RwLock<()>>::wait_for_readers(p0, p1);
-----------------
src/strategy/rw_lock.rs strategy::rw_lock::<impl strategy::sealed::CaS<T> for std::sync::RwLock<()>>::compare_and_swap
deps:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::default::Default"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::default::Default","gen_lock::LockStorage","std::marker::Copy","std::marker::Sized","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","std::marker::Sized","strategy::sealed::InnerStrategy","std::default::Default"]},"strategy::rw_lock::<impl strategy::sealed::CaS<T> for std::sync::RwLock<()>>::compare_and_swap":{"C":["as_raw::AsRaw","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"]},"Guard":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>","<S as strategy::Strategy<T>>"],"T":["std::sync::Arc<T>","std::rc::Rc<T>","std::rc::Rc"]},"std::option::Option":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]},"strategy::rw_lock::<impl strategy::sealed::CaS<T> for std::sync::RwLock<()>>::compare_and_swap":{"C":["Guard","<*mut T as as_raw::AsRaw<T>>","<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>"],"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::RwLock<()>
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::sync::atomic::AtomicPtr<<T as ref_cnt::RefCnt>::Base>
let mut p2 = MaybeUninit::uninit().assume_init(); // C
let mut p3 = MaybeUninit::uninit().assume_init(); // T
+p0.compare_and_swap(p1, p2, p3);
+strategy::rw_lock::<impl strategy::sealed::CaS<T> for std::sync::RwLock<()>>::compare_and_swap(p0, p1, p2, p3);
+crate::strategy::rw_lock::<impl strategy::sealed::CaS<T> for std::sync::RwLock<()>>::compare_and_swap(p0, p1, p2, p3);
+<std::sync::RwLock<()>>::compare_and_swap(p0, p1, p2, p3);
-----------------
src/lib.rs Guard::<T, S>::into_inner
'a
deps:{"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"Guard::<T, S>::into_inner":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Copy","std::marker::Sized","gen_lock::LockStorage","std::clone::Clone","std::default::Default"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::clone::Clone","std::marker::Sized","strategy::sealed::InnerStrategy"]}}
candidates:{"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"]},"Guard::<T, S>::into_inner":{"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"std::option::Option":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Guard<T, S>
+Guard::<T, S>::into_inner(p0);
+crate::Guard::<T, S>::into_inner(p0);
+<Guard<T, S>>::into_inner(p0);
-----------------
src/lib.rs Guard::<T, S>::from_inner
'a
deps:{"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"Guard::<T, S>::from_inner":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::marker::Copy","std::clone::Clone","std::default::Default","std::marker::Sized"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","std::default::Default","std::marker::Sized","strategy::sealed::InnerStrategy"]}}
candidates:{"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy","std::sync::RwLock"]},"Guard::<T, S>::from_inner":{"S":["<S as strategy::Strategy<T>>"],"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::option::Option":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+Guard::<T, S>::from_inner(p0);
+crate::Guard::<T, S>::from_inner(p0);
+<Guard<T, S>>::from_inner(p0);
-----------------
src/lib.rs <Guard<T, S> as std::ops::Deref>::deref
'a
deps:{"<Guard<T, S> as std::ops::Deref>::deref":{"S":["strategy::Strategy","std::marker::Sized"],"T":["ref_cnt::RefCnt","std::marker::Sized"]},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Copy","std::marker::Sized","gen_lock::LockStorage","std::default::Default","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","std::default::Default","std::clone::Clone","strategy::sealed::InnerStrategy"]}}
candidates:{"<Guard<T, S> as std::ops::Deref>::deref":{"S":["<S as strategy::Strategy<T>>"],"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]},"std::option::Option":{"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Guard<T, S>
+p0.deref();
+<Guard<T, S> as std::ops::Deref>::deref(p0);
+crate::<Guard<T, S> as std::ops::Deref>::deref(p0);
+<Guard<T, S>>::deref(p0);
-----------------
src/lib.rs <Guard<T, S> as std::convert::From<T>>::from
deps:{"<Guard<T, S> as std::convert::From<T>>::from":{"S":["std::marker::Sized","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::marker::Sized"]},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","gen_lock::LockStorage","std::clone::Clone","std::marker::Copy","std::default::Default"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::marker::Sized","std::clone::Clone","std::default::Default"]}}
candidates:{"<Guard<T, S> as std::convert::From<T>>::from":{"S":["<S as strategy::Strategy<T>>"],"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","std::sync::RwLock","strategy::gen_lock::GenLockStrategy"]},"std::option::Option":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+<Guard<T, S> as std::convert::From<T>>::from(p0);
+crate::<Guard<T, S> as std::convert::From<T>>::from(p0);
+<Guard<T, S>>::from(p0);
-----------------
src/lib.rs <Guard<T, S> as std::default::Default>::default
deps:{"<Guard<T, S> as std::default::Default>::default":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::default::Default","std::marker::Sized","ref_cnt::RefCnt"]},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Copy","gen_lock::LockStorage","std::default::Default","std::clone::Clone","std::marker::Sized"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","strategy::sealed::InnerStrategy","std::marker::Sized","std::default::Default"]}}
candidates:{"<Guard<T, S> as std::default::Default>::default":{"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::sync::Arc<T>","std::rc::Rc<T>","std::option::Option<T>","std::option::Option","std::rc::Rc"]},"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy","std::sync::RwLock"]},"std::option::Option":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
+<Guard<T, S> as std::default::Default>::default();
+crate::<Guard<T, S> as std::default::Default>::default();
+<Guard<T, S>>::default();
-----------------
src/lib.rs <Guard<T, S> as std::fmt::Debug>::fmt
deps:{"<Guard<T, S> as std::fmt::Debug>::fmt":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::marker::Sized","std::fmt::Debug","ref_cnt::RefCnt"]},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::clone::Clone","std::marker::Sized","std::default::Default","gen_lock::LockStorage","std::marker::Copy"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::marker::Sized","std::clone::Clone","strategy::sealed::InnerStrategy"]}}
candidates:{"<Guard<T, S> as std::fmt::Debug>::fmt":{"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","std::sync::RwLock","strategy::gen_lock::GenLockStrategy"]},"std::option::Option":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Guard<T, S>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<Guard<T, S> as std::fmt::Debug>::fmt(p0, p1);
+crate::<Guard<T, S> as std::fmt::Debug>::fmt(p0, p1);
+<Guard<T, S>>::fmt(p0, p1);
-----------------
src/lib.rs <Guard<T, S> as std::fmt::Display>::fmt
deps:{"<Guard<T, S> as std::fmt::Display>::fmt":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::fmt::Display","ref_cnt::RefCnt","std::marker::Sized"]},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::default::Default","std::marker::Copy","std::clone::Clone","std::marker::Sized","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::marker::Sized","strategy::sealed::InnerStrategy","std::clone::Clone"]}}
candidates:{"<Guard<T, S> as std::fmt::Display>::fmt":{"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc<T>","std::rc::Rc<T>","std::rc::Rc","std::sync::Arc"]},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock","strategy::hybrid::HybridStrategy"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Guard<T, S>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<Guard<T, S> as std::fmt::Display>::fmt(p0, p1);
+crate::<Guard<T, S> as std::fmt::Display>::fmt(p0, p1);
+<Guard<T, S>>::fmt(p0, p1);
-----------------
src/lib.rs <ArcSwapAny<T, S> as std::convert::From<T>>::from
deps:{"<ArcSwapAny<T, S> as std::convert::From<T>>::from":{"S":["std::default::Default","std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"<ArcSwapAny<T, S> as std::convert::From<T>>::from":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::option::Option":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+<ArcSwapAny<T, S> as std::convert::From<T>>::from(p0);
+crate::<ArcSwapAny<T, S> as std::convert::From<T>>::from(p0);
+<ArcSwapAny<T, S>>::from(p0);
-----------------
src/lib.rs <ArcSwapAny<T, S> as std::ops::Drop>::drop
deps:{"<ArcSwapAny<T, S> as std::ops::Drop>::drop":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Copy","std::clone::Clone","std::default::Default","gen_lock::LockStorage","std::marker::Sized"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","std::clone::Clone","strategy::sealed::InnerStrategy","std::default::Default"]}}
candidates:{"<ArcSwapAny<T, S> as std::ops::Drop>::drop":{"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ArcSwapAny<T, S>
+p0.drop();
+<ArcSwapAny<T, S> as std::ops::Drop>::drop(p0);
+crate::<ArcSwapAny<T, S> as std::ops::Drop>::drop(p0);
+<ArcSwapAny<T, S>>::drop(p0);
-----------------
src/lib.rs <ArcSwapAny<T, S> as std::fmt::Debug>::fmt
deps:{"<ArcSwapAny<T, S> as std::fmt::Debug>::fmt":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::fmt::Debug","ref_cnt::RefCnt","std::marker::Sized"]},"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::clone::Clone","std::default::Default","std::marker::Copy","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::clone::Clone","std::default::Default","std::marker::Sized"]}}
candidates:{"<ArcSwapAny<T, S> as std::fmt::Debug>::fmt":{"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::rc::Rc","std::option::Option<T>","std::option::Option","std::sync::Arc<T>","std::rc::Rc<T>"]},"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy","std::sync::RwLock"]},"std::option::Option":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ArcSwapAny<T, S>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ArcSwapAny<T, S> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ArcSwapAny<T, S> as std::fmt::Debug>::fmt(p0, p1);
+<ArcSwapAny<T, S>>::fmt(p0, p1);
-----------------
src/lib.rs <ArcSwapAny<T, S> as std::fmt::Display>::fmt
deps:{"<ArcSwapAny<T, S> as std::fmt::Display>::fmt":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","std::fmt::Display","ref_cnt::RefCnt"]},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::default::Default","gen_lock::LockStorage","std::marker::Copy","std::marker::Sized","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","std::clone::Clone","strategy::sealed::InnerStrategy","std::default::Default"]}}
candidates:{"<ArcSwapAny<T, S> as std::fmt::Display>::fmt":{"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::rc::Rc"]},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ArcSwapAny<T, S>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<ArcSwapAny<T, S> as std::fmt::Display>::fmt(p0, p1);
+crate::<ArcSwapAny<T, S> as std::fmt::Display>::fmt(p0, p1);
+<ArcSwapAny<T, S>>::fmt(p0, p1);
-----------------
src/lib.rs <ArcSwapAny<T, S> as std::default::Default>::default
deps:{"<ArcSwapAny<T, S> as std::default::Default>::default":{"S":["strategy::Strategy","std::marker::Sized","std::default::Default"],"T":["ref_cnt::RefCnt","std::marker::Sized","std::default::Default"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"<ArcSwapAny<T, S> as std::default::Default>::default":{"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::option::Option":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]}}
+<ArcSwapAny<T, S> as std::default::Default>::default();
+crate::<ArcSwapAny<T, S> as std::default::Default>::default();
+<ArcSwapAny<T, S>>::default();
-----------------
src/lib.rs ArcSwapAny::<T, S>::new
deps:{"ArcSwapAny::<T, S>::new":{"S":["strategy::Strategy","std::default::Default","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]}}
candidates:{"ArcSwapAny::<T, S>::new":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+ArcSwapAny::<T, S>::new(p0);
+crate::ArcSwapAny::<T, S>::new(p0);
+<ArcSwapAny<T, S>>::new(p0);
-----------------
src/lib.rs ArcSwapAny::<T, S>::with_strategy
deps:{"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"ArcSwapAny::<T, S>::with_strategy":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Copy","std::marker::Sized","std::default::Default","std::clone::Clone","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::clone::Clone","strategy::sealed::InnerStrategy","std::marker::Sized"]}}
candidates:{"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]},"ArcSwapAny::<T, S>::with_strategy":{"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"std::option::Option":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+ArcSwapAny::<T, S>::with_strategy(p0, p1);
+crate::ArcSwapAny::<T, S>::with_strategy(p0, p1);
+<ArcSwapAny<T, S>>::with_strategy(p0, p1);
-----------------
src/lib.rs ArcSwapAny::<T, S>::into_inner
deps:{"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"ArcSwapAny::<T, S>::into_inner":{"S":["std::marker::Sized","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::clone::Clone","std::marker::Copy","gen_lock::LockStorage","std::default::Default"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","std::default::Default","strategy::sealed::InnerStrategy","std::clone::Clone"]}}
candidates:{"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"]},"ArcSwapAny::<T, S>::into_inner":{"S":["<S as strategy::Strategy<T>>"],"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ArcSwapAny<T, S>
+p0.into_inner();
+ArcSwapAny::<T, S>::into_inner(p0);
+crate::ArcSwapAny::<T, S>::into_inner(p0);
+<ArcSwapAny<T, S>>::into_inner(p0);
-----------------
src/lib.rs ArcSwapAny::<T, S>::load_full
deps:{"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"ArcSwapAny::<T, S>::load_full":{"S":["strategy::Strategy","std::marker::Sized"],"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::marker::Copy","std::default::Default","std::marker::Sized","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::clone::Clone","strategy::sealed::InnerStrategy","std::marker::Sized"]}}
candidates:{"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","std::sync::RwLock","strategy::gen_lock::GenLockStrategy"]},"ArcSwapAny::<T, S>::load_full":{"S":["<S as strategy::Strategy<T>>"],"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"std::option::Option":{"T":["std::option::Option","std::rc::Rc","std::sync::Arc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ArcSwapAny<T, S>
+p0.load_full();
+ArcSwapAny::<T, S>::load_full(p0);
+crate::ArcSwapAny::<T, S>::load_full(p0);
+<ArcSwapAny<T, S>>::load_full(p0);
-----------------
src/lib.rs ArcSwapAny::<T, S>::load
deps:{"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"ArcSwapAny::<T, S>::load":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::clone::Clone","std::default::Default","gen_lock::LockStorage","std::marker::Copy","std::marker::Sized"]},"strategy::hybrid::HybridStrategy":{"F":["std::default::Default","std::marker::Sized","std::clone::Clone","strategy::sealed::InnerStrategy"]}}
candidates:{"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"]},"ArcSwapAny::<T, S>::load":{"S":["<S as strategy::Strategy<T>>"],"T":["std::rc::Rc","std::sync::Arc","std::option::Option"]},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ArcSwapAny<T, S>
+p0.load();
+ArcSwapAny::<T, S>::load(p0);
+crate::ArcSwapAny::<T, S>::load(p0);
+<ArcSwapAny<T, S>>::load(p0);
-----------------
src/lib.rs ArcSwapAny::<T, S>::store
deps:{"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"ArcSwapAny::<T, S>::store":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::default::Default","gen_lock::LockStorage","std::marker::Copy","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::marker::Sized","std::clone::Clone","strategy::sealed::InnerStrategy","std::default::Default"]}}
candidates:{"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"]},"ArcSwapAny::<T, S>::store":{"S":["<S as strategy::Strategy<T>>"],"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"std::option::Option":{"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ArcSwapAny<T, S>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.store(p1);
+ArcSwapAny::<T, S>::store(p0, p1);
+crate::ArcSwapAny::<T, S>::store(p0, p1);
+<ArcSwapAny<T, S>>::store(p0, p1);
-----------------
src/lib.rs ArcSwapAny::<T, S>::swap
deps:{"<S as strategy::Strategy<T>>":{"S":["std::marker::Sized","strategy::sealed::InnerStrategy"]},"ArcSwapAny::<T, S>::swap":{"S":["strategy::Strategy","std::marker::Sized"],"T":["ref_cnt::RefCnt","std::marker::Sized"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::clone::Clone","std::default::Default","std::marker::Copy","std::marker::Sized","gen_lock::LockStorage"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::default::Default","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy","std::sync::RwLock"]},"ArcSwapAny::<T, S>::swap":{"S":["<S as strategy::Strategy<T>>"],"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"std::option::Option":{"T":["std::rc::Rc","std::option::Option","std::sync::Arc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ArcSwapAny<T, S>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.swap(p1);
+ArcSwapAny::<T, S>::swap(p0, p1);
+crate::ArcSwapAny::<T, S>::swap(p0, p1);
+<ArcSwapAny<T, S>>::swap(p0, p1);
-----------------
src/lib.rs ArcSwapAny::<T, S>::compare_and_swap
deps:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::CaS<T>>":{"S":["std::marker::Sized","strategy::sealed::CaS"]},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"ArcSwapAny::<T, S>::compare_and_swap":{"C":["std::marker::Sized","as_raw::AsRaw"],"S":["std::marker::Sized","strategy::Strategy","strategy::CaS"],"T":["ref_cnt::RefCnt","std::marker::Sized"]},"Guard":{"S":["strategy::Strategy","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt","std::fmt::Debug","std::default::Default","std::fmt::Display"]},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::LockStorage","std::marker::Sized","std::marker::Copy","std::default::Default","std::clone::Clone"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","std::default::Default","std::marker::Sized","strategy::sealed::InnerStrategy"]}}
candidates:{"<&'a Guard<T> as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<&'a T as as_raw::AsRaw<<T as ref_cnt::RefCnt>::Base>>":{},"<*const T as as_raw::AsRaw<T>>":{},"<*mut T as as_raw::AsRaw<T>>":{},"<S as strategy::CaS<T>>":{"S":["std::sync::RwLock","strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]},"<S as strategy::Strategy<T>>":{"S":["std::sync::RwLock","strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]},"ArcSwapAny::<T, S>::compare_and_swap":{"C":["<*mut T as as_raw::AsRaw<T>>","Guard"],"S":["<S as strategy::CaS<T>>","<S as strategy::Strategy<T>>"],"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"Guard":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>","<S as strategy::Strategy<T>>"],"T":["std::sync::Arc"]},"std::option::Option":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ArcSwapAny<T, S>
let mut p1 = MaybeUninit::uninit().assume_init(); // C
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.compare_and_swap(p1, p2);
+ArcSwapAny::<T, S>::compare_and_swap(p0, p1, p2);
+crate::ArcSwapAny::<T, S>::compare_and_swap(p0, p1, p2);
+<ArcSwapAny<T, S>>::compare_and_swap(p0, p1, p2);
-----------------
src/lib.rs ArcSwapAny::<T, S>::rcu
deps:{"<S as strategy::CaS<T>>":{"S":["strategy::sealed::CaS","std::marker::Sized"]},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"ArcSwapAny::<T, S>::rcu":{"F":["std::marker::Sized","std::ops::FnMut"],"R":["std::convert::Into","std::marker::Sized"],"S":["strategy::CaS","strategy::Strategy","std::marker::Sized"],"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::option::Option":{"T":["ref_cnt::RefCnt","std::marker::Sized"]},"strategy::gen_lock::GenLockStrategy":{"L":["std::marker::Sized","std::clone::Clone","std::default::Default","gen_lock::LockStorage","std::marker::Copy"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::sealed::InnerStrategy","std::clone::Clone","std::marker::Sized","std::default::Default"]}}
candidates:{"<S as strategy::CaS<T>>":{"S":["std::sync::RwLock","strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]},"<S as strategy::Strategy<T>>":{"S":["strategy::hybrid::HybridStrategy","std::sync::RwLock","strategy::gen_lock::GenLockStrategy"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"ArcSwapAny::<T, S>::rcu":{"F":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"],"R":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"],"S":["<S as strategy::Strategy<T>>","<S as strategy::CaS<T>>"],"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::option::Option":{"T":["std::sync::Arc","std::option::Option","std::rc::Rc"]},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::gen_lock::GenLockStrategy","strategy::hybrid::HybridStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ArcSwapAny<T, S>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.rcu(p1);
+ArcSwapAny::<T, S>::rcu(p0, p1);
+crate::ArcSwapAny::<T, S>::rcu(p0, p1);
+<ArcSwapAny<T, S>>::rcu(p0, p1);
-----------------
src/lib.rs ArcSwapAny::<T, S>::map
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<P as access::Access<T>>":{"P":["std::ops::Deref","std::marker::Sized"]},"<S as strategy::Strategy<T>>":{"S":["strategy::sealed::InnerStrategy","std::marker::Sized"]},"ArcSwapAny":{"S":["std::default::Default","std::marker::Sized","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::default::Default"]},"ArcSwapAny::<T, S>::map":{"ArcSwapAny<T, S>":["access::Access"],"F":["std::ops::Fn","std::marker::Sized"],"I":["std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::marker::Sized"]},"Guard":{"S":["std::marker::Sized","strategy::Strategy"],"T":["std::default::Default","std::fmt::Debug","ref_cnt::RefCnt","std::marker::Sized","std::fmt::Display"]},"access::Constant":{"T":["std::cmp::PartialEq","std::marker::Sized","std::marker::Copy","std::fmt::Debug","std::cmp::PartialOrd","std::clone::Clone","std::cmp::Eq","std::hash::Hash","std::cmp::Ord"]},"access::ConstantDeref":{"T":["std::hash::Hash","std::marker::Copy","std::clone::Clone","std::cmp::PartialOrd","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq"]},"access::DirectDeref":{"S":["std::marker::Sized","std::fmt::Debug","strategy::Strategy"],"T":["ref_cnt::RefCnt","std::fmt::Debug","std::marker::Sized"]},"access::Map":{"A":["access::Access","std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::marker::Sized"],"F":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::marker::Copy","std::ops::Fn"],"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::marker::Copy"]},"access::MapGuard":{"G":["std::marker::Sync","std::clone::Clone","std::fmt::Debug","std::marker::Copy","std::marker::Sized","std::marker::Send"],"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::marker::Copy"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::option::Option":{"T":["std::marker::Sized","ref_cnt::RefCnt"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["std::clone::Clone","std::marker::Sized","std::default::Default","gen_lock::LockStorage","std::marker::Copy"]},"strategy::hybrid::HybridStrategy":{"F":["std::clone::Clone","strategy::sealed::InnerStrategy","std::marker::Sized","std::default::Default"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<P as access::Access<T>>":{"P":["access::DirectDeref","Guard","access::MapGuard","access::DynGuard","<&T as std::ops::Deref>","access::ConstantDeref"]},"<S as strategy::Strategy<T>>":{"S":["strategy::gen_lock::GenLockStrategy","std::sync::RwLock","strategy::hybrid::HybridStrategy"]},"ArcSwapAny":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>"],"T":["std::rc::Rc","std::rc::Rc<T>","std::sync::Arc<T>"]},"ArcSwapAny::<T, S>::map":{"ArcSwapAny<T, S>":["access::Map","access::Constant","<P as access::Access<T>>","ArcSwapAny"],"F":["core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr"],"I":["RUG_ANY"],"R":["RUG_ANY"],"S":["<S as strategy::Strategy<T>>"],"T":["std::option::Option","std::sync::Arc","std::rc::Rc"]},"Guard":{"S":["strategy::hybrid::HybridStrategy<strategy::gen_lock::GenLockStrategy<gen_lock::Global>>","<S as strategy::Strategy<T>>"],"T":["std::sync::Arc"]},"access::Constant":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>","access::Constant","access::ConstantDeref"]},"access::ConstantDeref":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","access::Constant","access::ConstantDeref"]},"access::DirectDeref":{"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]},"access::Map":{"A":["access::Map","access::Constant"],"T":["access::ConstantDeref","access::MapGuard","access::Constant","std::clone::impls::<impl std::clone::Clone for *const T>","access::Map"]},"access::MapGuard":{"G":["<*const T as std::marker::Sync>","access::MapGuard"],"T":["std::marker::copy_impls::<impl std::marker::Copy for &T>","access::Constant","access::MapGuard","access::ConstantDeref","access::Map"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::option::Option":{"T":["std::sync::Arc","std::rc::Rc","std::option::Option"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"strategy::gen_lock::GenLockStrategy":{"L":["gen_lock::Global"]},"strategy::hybrid::HybridStrategy":{"F":["strategy::hybrid::HybridStrategy","strategy::gen_lock::GenLockStrategy"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ArcSwapAny<T, S>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map(p1);
+ArcSwapAny::<T, S>::map(p0, p1);
+crate::ArcSwapAny::<T, S>::map(p0, p1);
+<ArcSwapAny<T, S>>::map(p0, p1);
-----------------
src/lib.rs ArcSwapAny::<std::sync::Arc<T>, S>::from_pointee
deps:{"ArcSwapAny::<std::sync::Arc<T>, S>::from_pointee":{"S":["std::default::Default","std::marker::Sized","strategy::Strategy"],"T":["std::marker::Sized"]}}
candidates:{"ArcSwapAny::<std::sync::Arc<T>, S>::from_pointee":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+ArcSwapAny::<std::sync::Arc<T>, S>::from_pointee(p0);
+crate::ArcSwapAny::<std::sync::Arc<T>, S>::from_pointee(p0);
+<ArcSwapAny<std::sync::Arc<T>, S>>::from_pointee(p0);
-----------------
src/lib.rs ArcSwapAny::<std::option::Option<std::sync::Arc<T>>, S>::from_pointee
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"ArcSwapAny::<std::option::Option<std::sync::Arc<T>>, S>::from_pointee":{"S":["strategy::Strategy","std::default::Default","std::marker::Sized"],"T":["std::marker::Sized"],"V":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"ArcSwapAny::<std::option::Option<std::sync::Arc<T>>, S>::from_pointee":{"T":["RUG_ANY"],"V":["std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","<T as std::convert::Into<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // V
+ArcSwapAny::<std::option::Option<std::sync::Arc<T>>, S>::from_pointee(p0);
+crate::ArcSwapAny::<std::option::Option<std::sync::Arc<T>>, S>::from_pointee(p0);
+<ArcSwapAny<std::option::Option<std::sync::Arc<T>>, S>>::from_pointee(p0);
-----------------
src/lib.rs ArcSwapAny::<std::option::Option<std::sync::Arc<T>>, S>::empty
deps:{"ArcSwapAny::<std::option::Option<std::sync::Arc<T>>, S>::empty":{"S":["strategy::Strategy","std::default::Default","std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"ArcSwapAny::<std::option::Option<std::sync::Arc<T>>, S>::empty":{"T":["RUG_ANY"]}}
+ArcSwapAny::<std::option::Option<std::sync::Arc<T>>, S>::empty();
+crate::ArcSwapAny::<std::option::Option<std::sync::Arc<T>>, S>::empty();
+<ArcSwapAny<std::option::Option<std::sync::Arc<T>>, S>>::empty();