{"dependencies":{"<LiteralReplacer as syn::fold::Fold>::fold_expr":["LiteralReplacer","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::Expr"],"<LiteralReplacer as syn::fold::Fold>::fold_expr_macro":["LiteralReplacer","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::ExprMacro"],"<LiteralReplacer as syn::fold::Fold>::fold_expr_repeat":["LiteralReplacer","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::ExprRepeat"],"<LiteralReplacer as syn::fold::Fold>::fold_item_fn":["LiteralReplacer","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::ItemFn"],"<LiteralReplacer as syn::fold::Fold>::fold_item_mod":["LiteralReplacer","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::ItemMod"],"<LiteralReplacer as syn::fold::Fold>::fold_type":["LiteralReplacer","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::Type"],"LiteralReplacer":["LiteralReplacer","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"LiteralReplacer::clean":["LiteralReplacer","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"LiteralReplacer::generate_declarations":["LiteralReplacer","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::Stmt"],"LiteralReplacer::new":["LiteralReplacer","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"LiteralReplacer::new_with_target":["LiteralReplacer","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"are_lits_equal":["syn::Lit"],"lit_to_string":["std::string::String","syn::Lit"],"main":["std::marker::Sized","std::result::Result"]},"glob_path_import":{},"self_to_fn":{"LiteralReplacer":["impl Fold for LiteralReplacer {\n\n\n    fn fold_expr(&mut self, expr: Expr) -> Expr {\n        // println!(\"exprrrrrrr {} {} {}\", self.in_mod, self.in_fn, expr.to_token_stream().to_string());\n        if !self.in_mod || !self.in_fn {\n            return fold::fold_expr(self, expr);\n        }\n        // println!(\"in {}\", expr.to_token_stream().to_string());\n        match expr {\n            Expr::Lit(expr_lit) => {\n                let var_name = format!(\"rug_fuzz_{}\", self.primitives.len());\n                let i = expr_lit.lit;\n                let (lit, ty) = match &i {\n                    Lit::Str(_) => (i.clone(), quote!(&str)),\n                    Lit::ByteStr(_) => (i.clone(), quote!(&[u8])),\n                    Lit::Byte(_) => (i.clone(), quote!(u8)),\n                    Lit::Char(_) => (i.clone(), quote!(char)),\n                    Lit::Int(lit_int) => {\n                        let ty = quote!(u8);\n                        (i.clone(), ty)\n                    }\n                    Lit::Float(lit_float) => {\n                        let ty = quote!(f32);\n                        (i.clone(), ty)\n                    }\n                    Lit::Bool(_) => (i.clone(), quote!(bool)),\n                    Lit::Verbatim(_) => (i.clone(), quote!()),\n                        &_ => todo!()\n                };\n\n                self.primitives.push((lit, var_name.clone(), ty));\n                self.replacements.push((i.clone(), Ident::new(&var_name.clone(), proc_macro2::Span::call_site())));\n\n                let var_ident = syn::Ident::new(&*var_name, proc_macro2::Span::call_site());\n\n                    let replaced_expr = Expr::Path(syn::ExprPath {\n                        attrs: Vec::new(),\n                        qself: None,\n                        path: var_ident.into(),\n                    });\n                return fold::fold_expr(self, replaced_expr);\n\n            },\n            // Delegate to the default fold implementation\n            _ => fold::fold_expr(self, expr),\n        }\n    }\n    fn fold_expr_repeat(&mut self, i: ExprRepeat) -> ExprRepeat {\n        let mut ans = i.clone();\n        ans.expr = Box::new(self.fold_expr( *i.expr));\n        ans\n    }\n\n    fn fold_type(&mut self, i: Type) -> Type {\n        i\n    }\n\n    fn fold_expr_macro(&mut self, node: ExprMacro) -> ExprMacro {\n        // println!(\"{} {} {}\", self.in_mod, self.in_fn, node.to_token_stream().to_string());\n        if !self.in_mod || !self.in_fn {\n            return fold::fold_expr_macro(self, node);\n        }\n        let macro_name = node.mac.path.segments.last().unwrap().ident.to_string();\n\n        let new_macro_name = match macro_name.as_str() {\n            \"assert\" => String::from(\"debug_assert\"),\n            \"assert_eq\" => String::from(\"debug_assert_eq\"),\n            \"assert_ne\" => String::from(\"debug_assert_ne\"),\n            \"assert_matches\" => String::from(\"debug_assert_matches\"),\n            _ => {\n                macro_name.clone()\n            }\n        };\n        if new_macro_name.starts_with(\"assert\"){\n            println!(\"missing {}\", new_macro_name);\n        }\n        let mut new_macro = node.clone();\n        let tmp = format!(\"f({})\", node.mac.tokens.to_string());\n        // Parse the code into a syntax tree\n        if let Ok(syntax_tree) = syn::parse_str::<ExprCall>(&tmp){\n            let mut first = true;\n            let mut parsed = String::new();\n            if macro_name.eq(\"format\") || macro_name.eq(\"println\") || macro_name.eq(\"print\") || macro_name.eq(\"panic\"){\n                for ex in syntax_tree.args {\n                    if first {\n                        parsed += &*ex.to_token_stream().to_string();\n                        first = false;\n                    } else {\n                        let nf = self.fold_expr(ex);\n                        parsed += &*nf.to_token_stream().to_string();\n\n                    }\n                    parsed += \", \";\n                }\n            }else {\n                for ex in syntax_tree.args {\n                    if first {\n                        let nf = self.fold_expr(ex);\n                        parsed += &*nf.to_token_stream().to_string();\n                        first = false;\n                    } else {\n                        parsed += &*ex.to_token_stream().to_string();\n                    }\n                    parsed += \", \";\n                }\n            }\n            let t = &*parsed;\n            let end = if parsed.len() > 2 { parsed.len() - 2} else { parsed.len() };\n            new_macro.mac.tokens = proc_macro2::TokenStream::from_str(&t[0..end]).unwrap();\n        }\n        if !macro_name.eq(&new_macro_name) {\n            // Create an identifier for `sel_println`\n            let new_ident = Ident::new(&*new_macro_name.clone(), proc_macro2::Span::call_site());\n            new_macro.mac.path = new_ident.into();\n        }\n\n        // Return the original macro if it's not `println!`\n        return fold::fold_expr_macro(self, new_macro);\n    }\n    fn fold_item_mod(&mut self, i: ItemMod) -> ItemMod {\n\n        if i.ident.to_string().starts_with(\"tests_llm_16\") || i.ident.to_string().starts_with(\"tests_rug\"){\n            // println!(\"item mod {}\", i.ident.to_string());\n            if let Some(tar) = &self.target_mod{\n                if tar.eq(&i.ident.to_string()){\n                    self.in_mod = true;\n                    let ans = fold::fold_item_mod(self,i);\n                    self.in_mod = false;\n                    return ans\n                }\n                return fold::fold_item_mod(self, i);\n            }else {\n                println!(\"{}\",i.ident.to_string());\n                return fold::fold_item_mod(self, i);\n            }\n\n        }else {\n            return fold::fold_item_mod(self, i);\n        }\n    }\n\n    fn fold_item_fn(&mut self, i: ItemFn) -> ItemFn {\n        self.cur_fn = i.sig.ident.to_string();\n        if self.in_mod {\n            // println!(\"mod f {}\", i.to_token_stream().to_string());\n            self.clean();\n            self.in_fn = true;\n            let mut ans = fold::fold_item_fn(self,i);\n            self.in_fn = false;\n            let (t, st, ed) = self.generate_declarations();\n            // Insert the new variable declarations at the beginning of the block\n            ans.block.stmts.splice(0..0, t);\n            ans.block.stmts.insert(0, st);\n            ans.block.stmts.push(ed);\n            return ans;\n        }else {\n            return fold::fold_item_fn(self, i);\n        }\n\n    }\n}","impl LiteralReplacer {\n    fn new() -> Self {\n        LiteralReplacer { primitives: vec![],     replacements: Vec::<(Lit, Ident)>::new(),  in_mod:false, in_fn: false, target_mod: None, cur_fn: String::new()}\n    }\n\n    fn new_with_target(t: String) -> Self {\n        LiteralReplacer { primitives: vec![],     replacements: Vec::<(Lit, Ident)>::new(),  in_mod:false, in_fn: false, target_mod: Some(t), cur_fn: String::new()}\n    }\n\n\n    fn clean(&mut self){\n        self.replacements.clear();\n        self.primitives.clear();\n    }\n    fn generate_declarations(&self) -> (Vec<Stmt>, Stmt, Stmt) {\n\n        let ans1 = self.primitives.iter().map(|(lit, var_name, ty)| {\n            let var_ident = syn::Ident::new(var_name, proc_macro2::Span::call_site());\n            let declaration = quote! {\n                let #var_ident = #lit;\n            };\n            print!(\"{}~{}~{}~{}_rrrruuuugggg_\", self.target_mod.clone().unwrap(), self.cur_fn, var_name, lit.to_token_stream().to_string());\n            syn::parse2(declaration).unwrap()\n        }).collect();\n        let start_comment = syn::parse_str::<Stmt>(&*format!(\"let _rug_st_{}_rrrruuuugggg_{}=0;\", self.target_mod.clone().unwrap(), self.cur_fn)).unwrap();\n        let end_comment = syn::parse_str::<Stmt>(&*format!(\"let _rug_ed_{}_rrrruuuugggg_{}=0;\", self.target_mod.clone().unwrap(), self.cur_fn)).unwrap();\n        return (ans1, start_comment, end_comment);\n    }\n}"]},"single_path_import":{},"srcs":{"<LiteralReplacer as syn::fold::Fold>::fold_expr":["fn fold_expr(&mut self, expr: Expr) -> Expr{\n        // println!(\"exprrrrrrr {} {} {}\", self.in_mod, self.in_fn, expr.to_token_stream().to_string());\n        if !self.in_mod || !self.in_fn {\n            return fold::fold_expr(self, expr);\n        }\n        // println!(\"in {}\", expr.to_token_stream().to_string());\n        match expr {\n            Expr::Lit(expr_lit) => {\n                let var_name = format!(\"rug_fuzz_{}\", self.primitives.len());\n                let i = expr_lit.lit;\n                let (lit, ty) = match &i {\n                    Lit::Str(_) => (i.clone(), quote!(&str)),\n                    Lit::ByteStr(_) => (i.clone(), quote!(&[u8])),\n                    Lit::Byte(_) => (i.clone(), quote!(u8)),\n                    Lit::Char(_) => (i.clone(), quote!(char)),\n                    Lit::Int(lit_int) => {\n                        let ty = quote!(u8);\n                        (i.clone(), ty)\n                    }\n                    Lit::Float(lit_float) => {\n                        let ty = quote!(f32);\n                        (i.clone(), ty)\n                    }\n                    Lit::Bool(_) => (i.clone(), quote!(bool)),\n                    Lit::Verbatim(_) => (i.clone(), quote!()),\n                        &_ => todo!()\n                };\n\n                self.primitives.push((lit, var_name.clone(), ty));\n                self.replacements.push((i.clone(), Ident::new(&var_name.clone(), proc_macro2::Span::call_site())));\n\n                let var_ident = syn::Ident::new(&*var_name, proc_macro2::Span::call_site());\n\n                    let replaced_expr = Expr::Path(syn::ExprPath {\n                        attrs: Vec::new(),\n                        qself: None,\n                        path: var_ident.into(),\n                    });\n                return fold::fold_expr(self, replaced_expr);\n\n            },\n            // Delegate to the default fold implementation\n            _ => fold::fold_expr(self, expr),\n        }\n    }","Real(LocalPath(\"src/main.rs\"))"],"<LiteralReplacer as syn::fold::Fold>::fold_expr_macro":["fn fold_expr_macro(&mut self, node: ExprMacro) -> ExprMacro{\n        // println!(\"{} {} {}\", self.in_mod, self.in_fn, node.to_token_stream().to_string());\n        if !self.in_mod || !self.in_fn {\n            return fold::fold_expr_macro(self, node);\n        }\n        let macro_name = node.mac.path.segments.last().unwrap().ident.to_string();\n\n        let new_macro_name = match macro_name.as_str() {\n            \"assert\" => String::from(\"debug_assert\"),\n            \"assert_eq\" => String::from(\"debug_assert_eq\"),\n            \"assert_ne\" => String::from(\"debug_assert_ne\"),\n            \"assert_matches\" => String::from(\"debug_assert_matches\"),\n            _ => {\n                macro_name.clone()\n            }\n        };\n        if new_macro_name.starts_with(\"assert\"){\n            println!(\"missing {}\", new_macro_name);\n        }\n        let mut new_macro = node.clone();\n        let tmp = format!(\"f({})\", node.mac.tokens.to_string());\n        // Parse the code into a syntax tree\n        if let Ok(syntax_tree) = syn::parse_str::<ExprCall>(&tmp){\n            let mut first = true;\n            let mut parsed = String::new();\n            if macro_name.eq(\"format\") || macro_name.eq(\"println\") || macro_name.eq(\"print\") || macro_name.eq(\"panic\"){\n                for ex in syntax_tree.args {\n                    if first {\n                        parsed += &*ex.to_token_stream().to_string();\n                        first = false;\n                    } else {\n                        let nf = self.fold_expr(ex);\n                        parsed += &*nf.to_token_stream().to_string();\n\n                    }\n                    parsed += \", \";\n                }\n            }else {\n                for ex in syntax_tree.args {\n                    if first {\n                        let nf = self.fold_expr(ex);\n                        parsed += &*nf.to_token_stream().to_string();\n                        first = false;\n                    } else {\n                        parsed += &*ex.to_token_stream().to_string();\n                    }\n                    parsed += \", \";\n                }\n            }\n            let t = &*parsed;\n            let end = if parsed.len() > 2 { parsed.len() - 2} else { parsed.len() };\n            new_macro.mac.tokens = proc_macro2::TokenStream::from_str(&t[0..end]).unwrap();\n        }\n        if !macro_name.eq(&new_macro_name) {\n            // Create an identifier for `sel_println`\n            let new_ident = Ident::new(&*new_macro_name.clone(), proc_macro2::Span::call_site());\n            new_macro.mac.path = new_ident.into();\n        }\n\n        // Return the original macro if it's not `println!`\n        return fold::fold_expr_macro(self, new_macro);\n    }","Real(LocalPath(\"src/main.rs\"))"],"<LiteralReplacer as syn::fold::Fold>::fold_expr_repeat":["fn fold_expr_repeat(&mut self, i: ExprRepeat) -> ExprRepeat{\n        let mut ans = i.clone();\n        ans.expr = Box::new(self.fold_expr( *i.expr));\n        ans\n    }","Real(LocalPath(\"src/main.rs\"))"],"<LiteralReplacer as syn::fold::Fold>::fold_item_fn":["fn fold_item_fn(&mut self, i: ItemFn) -> ItemFn{\n        self.cur_fn = i.sig.ident.to_string();\n        if self.in_mod {\n            // println!(\"mod f {}\", i.to_token_stream().to_string());\n            self.clean();\n            self.in_fn = true;\n            let mut ans = fold::fold_item_fn(self,i);\n            self.in_fn = false;\n            let (t, st, ed) = self.generate_declarations();\n            // Insert the new variable declarations at the beginning of the block\n            ans.block.stmts.splice(0..0, t);\n            ans.block.stmts.insert(0, st);\n            ans.block.stmts.push(ed);\n            return ans;\n        }else {\n            return fold::fold_item_fn(self, i);\n        }\n\n    }","Real(LocalPath(\"src/main.rs\"))"],"<LiteralReplacer as syn::fold::Fold>::fold_item_mod":["fn fold_item_mod(&mut self, i: ItemMod) -> ItemMod{\n\n        if i.ident.to_string().starts_with(\"tests_llm_16\") || i.ident.to_string().starts_with(\"tests_rug\"){\n            // println!(\"item mod {}\", i.ident.to_string());\n            if let Some(tar) = &self.target_mod{\n                if tar.eq(&i.ident.to_string()){\n                    self.in_mod = true;\n                    let ans = fold::fold_item_mod(self,i);\n                    self.in_mod = false;\n                    return ans\n                }\n                return fold::fold_item_mod(self, i);\n            }else {\n                println!(\"{}\",i.ident.to_string());\n                return fold::fold_item_mod(self, i);\n            }\n\n        }else {\n            return fold::fold_item_mod(self, i);\n        }\n    }","Real(LocalPath(\"src/main.rs\"))"],"<LiteralReplacer as syn::fold::Fold>::fold_type":["fn fold_type(&mut self, i: Type) -> Type{\n        i\n    }","Real(LocalPath(\"src/main.rs\"))"],"LiteralReplacer":["struct LiteralReplacer {\n    primitives: Vec<(Lit, String, TokenStream)>,\n    // This holds the mapping of literals to variable identifiers.\n    replacements: Vec<(Lit, Ident)>,\n    in_mod: bool,\n    in_fn: bool,\n    target_mod: Option<String>,\n    cur_fn: String\n}","Real(LocalPath(\"src/main.rs\"))"],"LiteralReplacer::clean":["fn clean(&mut self){\n        self.replacements.clear();\n        self.primitives.clear();\n    }","Real(LocalPath(\"src/main.rs\"))"],"LiteralReplacer::generate_declarations":["fn generate_declarations(&self) -> (Vec<Stmt>, Stmt, Stmt){\n\n        let ans1 = self.primitives.iter().map(|(lit, var_name, ty)| {\n            let var_ident = syn::Ident::new(var_name, proc_macro2::Span::call_site());\n            let declaration = quote! {\n                let #var_ident = #lit;\n            };\n            print!(\"{}~{}~{}~{}_rrrruuuugggg_\", self.target_mod.clone().unwrap(), self.cur_fn, var_name, lit.to_token_stream().to_string());\n            syn::parse2(declaration).unwrap()\n        }).collect();\n        let start_comment = syn::parse_str::<Stmt>(&*format!(\"let _rug_st_{}_rrrruuuugggg_{}=0;\", self.target_mod.clone().unwrap(), self.cur_fn)).unwrap();\n        let end_comment = syn::parse_str::<Stmt>(&*format!(\"let _rug_ed_{}_rrrruuuugggg_{}=0;\", self.target_mod.clone().unwrap(), self.cur_fn)).unwrap();\n        return (ans1, start_comment, end_comment);\n    }","Real(LocalPath(\"src/main.rs\"))"],"LiteralReplacer::new":["fn new() -> Self{\n        LiteralReplacer { primitives: vec![],     replacements: Vec::<(Lit, Ident)>::new(),  in_mod:false, in_fn: false, target_mod: None, cur_fn: String::new()}\n    }","Real(LocalPath(\"src/main.rs\"))"],"LiteralReplacer::new_with_target":["fn new_with_target(t: String) -> Self{\n        LiteralReplacer { primitives: vec![],     replacements: Vec::<(Lit, Ident)>::new(),  in_mod:false, in_fn: false, target_mod: Some(t), cur_fn: String::new()}\n    }","Real(LocalPath(\"src/main.rs\"))"],"are_lits_equal":["fn are_lits_equal(lit1: &Lit, lit2: &Lit) -> bool{\n    match (lit1, lit2) {\n        (Lit::Str(lit_str1), Lit::Str(lit_str2)) => lit_str1.value() == lit_str2.value(),\n        (Lit::ByteStr(lit_byte_str1), Lit::ByteStr(lit_byte_str2)) => {\n            lit_byte_str1.value() == lit_byte_str2.value()\n        }\n        (Lit::Byte(lit_byte1), Lit::Byte(lit_byte2)) => lit_byte1.value() == lit_byte2.value(),\n        (Lit::Char(lit_char1), Lit::Char(lit_char2)) => lit_char1.value() == lit_char2.value(),\n        (Lit::Int(lit_int1), Lit::Int(lit_int2)) => {\n            lit_int1.base10_digits() == lit_int2.base10_digits() && lit_int1.suffix() == lit_int2.suffix()\n        }\n        (Lit::Float(lit_float1), Lit::Float(lit_float2)) => {\n            lit_float1.base10_digits() == lit_float2.base10_digits() && lit_float1.suffix() == lit_float2.suffix()\n        }\n        (Lit::Bool(lit_bool1), Lit::Bool(lit_bool2)) => lit_bool1.value == lit_bool2.value,\n        (Lit::Verbatim(lit_verbatim1), Lit::Verbatim(lit_verbatim2)) => {\n            lit_verbatim1.to_string() == lit_verbatim2.to_string()\n        }\n        // If they are different variants, they are not equal\n        _ => false,\n    }\n}","Real(LocalPath(\"src/main.rs\"))"],"lit_to_string":["fn lit_to_string(lit: &Lit) -> String{\n    match lit {\n        Lit::Str(lit_str) => lit_str.value(), // Gets the actual string without quotes\n        Lit::ByteStr(lit_bytestr) => {\n            // Format as a byte string literal, including the prefix `b`\n            format!(\"b{:?}\", &lit_bytestr.value())\n        }\n        Lit::Byte(lit_byte) => {\n            // Format as a byte literal, including the prefix `b`\n            format!(\"b'{}'\", lit_byte.value() as char)\n        }\n        Lit::Char(lit_char) => {\n            // Format as a char literal\n            format!(\"'{}'\", lit_char.value())\n        }\n        Lit::Int(lit_int) => {\n            // Gets the string representation of the integer\n            lit_int.to_string()\n        }\n        Lit::Float(lit_float) => {\n            // Gets the string representation of the float\n            lit_float.to_string()\n        }\n        Lit::Bool(lit_bool) => {\n            // Gets the string representation of the boolean\n            lit_bool.value().to_string()\n        }\n        Lit::Verbatim(lit_verbatim) => {\n            // Gets the direct string representation of the literal\n            lit_verbatim.to_string()\n        }\n        &_ => todo!()\n    }\n}","Real(LocalPath(\"src/main.rs\"))"],"main":["fn main()-> std::io::Result<()>{\n    let args: Vec<String> = std::env::args().collect();\n    if let Some(loc) = args.get(1){\n        let mut file = std::fs::File::open(loc)?;\n        let mut contents = String::new();\n        file.read_to_string(&mut contents)?;\n        let syntax_tree = syn::parse_file(&*contents).unwrap();\n        let mut replacer = LiteralReplacer::new();\n        if let Some(tar) = args.get(2){\n            replacer = LiteralReplacer::new_with_target(tar.clone());\n            let n_tree = replacer.fold_file(syntax_tree);\n            let formt = prettyplease::unparse(&n_tree);\n            // println!(\"{}\", formt);\n            std::fs::write(loc, formt)?;\n        }else {\n            let _ = replacer.fold_file(syntax_tree);\n        }\n    }\n\n    // Parse the code into a syntax tree\n\n    Ok(())\n}","Real(LocalPath(\"src/main.rs\"))"]},"struct_constructor":{"(std::vec::Vec<syn::Stmt>, syn::Stmt, syn::Stmt)":["generate_declarations"],"LiteralReplacer":["new","new_with_target"],"bool":["are_lits_equal"],"std::string::String":["lit_to_string"]},"struct_to_trait":{"LiteralReplacer":["syn::fold::Fold"]},"targets":{"<LiteralReplacer as syn::fold::Fold>::fold_expr":["fold_expr","Real(LocalPath(\"src/main.rs\"))","syn::fold::Fold"],"<LiteralReplacer as syn::fold::Fold>::fold_expr_macro":["fold_expr_macro","Real(LocalPath(\"src/main.rs\"))","syn::fold::Fold"],"<LiteralReplacer as syn::fold::Fold>::fold_expr_repeat":["fold_expr_repeat","Real(LocalPath(\"src/main.rs\"))","syn::fold::Fold"],"<LiteralReplacer as syn::fold::Fold>::fold_item_fn":["fold_item_fn","Real(LocalPath(\"src/main.rs\"))","syn::fold::Fold"],"<LiteralReplacer as syn::fold::Fold>::fold_item_mod":["fold_item_mod","Real(LocalPath(\"src/main.rs\"))","syn::fold::Fold"],"<LiteralReplacer as syn::fold::Fold>::fold_type":["fold_type","Real(LocalPath(\"src/main.rs\"))","syn::fold::Fold"],"LiteralReplacer::clean":["clean","Real(LocalPath(\"src/main.rs\"))",""],"LiteralReplacer::generate_declarations":["generate_declarations","Real(LocalPath(\"src/main.rs\"))",""],"LiteralReplacer::new":["new","Real(LocalPath(\"src/main.rs\"))",""],"LiteralReplacer::new_with_target":["new_with_target","Real(LocalPath(\"src/main.rs\"))",""],"are_lits_equal":["are_lits_equal","Real(LocalPath(\"src/main.rs\"))",""],"lit_to_string":["lit_to_string","Real(LocalPath(\"src/main.rs\"))",""],"main":["main","Real(LocalPath(\"src/main.rs\"))",""]},"trait_to_struct":{"syn::fold::Fold":["LiteralReplacer"]},"type_to_def_path":{"LiteralReplacer":"LiteralReplacer"}}