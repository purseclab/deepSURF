{"dependencies":{"<Arena<T> as std::convert::Into<std::vec::Vec<T>>>::into":["Arena","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<Arena<T> as std::default::Default>::default":["Arena","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<Arena<T> as std::iter::FromIterator<T>>::from_iter":["Arena","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec"],"<Entries<'a, T> as std::iter::Iterator>::next":["Entries","std::marker::Sized","std::option::Option","std::slice::Iter"],"<EntriesMut<'a, T> as std::iter::Iterator>::next":["EntriesMut","std::marker::Sized","std::option::Option","std::slice::IterMut"],"<Idx as std::clone::Clone>::clone":["Idx","std::sync::Arc"],"<Idx as std::cmp::PartialEq>::eq":["Idx","std::sync::Arc"],"<Idx as std::fmt::Debug>::fmt":["Idx","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc"],"<Idx as std::hash::Hash>::hash":["Idx","std::hash::Hasher","std::marker::Sized","std::sync::Arc"],"<Iter<'a, T> as std::iter::Iterator>::next":["Iter","std::iter::Map","std::marker::Sized","std::option::Option"],"<IterMut<'a, T> as std::iter::Iterator>::next":["IterMut","std::iter::Map","std::marker::Sized","std::option::Option"],"Arena":["Arena","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Arena::<T>::alloc":["Arena","Idx","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"Arena::<T>::alloc_with":["Arena","Idx","std::alloc::Allocator","std::marker::Sized","std::ops::FnOnce","std::sync::Arc","std::vec::Vec"],"Arena::<T>::alloc_with_idx":["Arena","Idx","std::alloc::Allocator","std::marker::Sized","std::ops::FnOnce","std::sync::Arc","std::vec::Vec"],"Arena::<T>::apply_ordering":["Arena","std::alloc::Allocator","std::borrow::Borrow","std::marker::Sized","std::vec::Vec"],"Arena::<T>::capacity":["Arena","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Arena::<T>::entries":["Arena","Entries","std::alloc::Allocator","std::marker::Sized","std::slice::Iter","std::vec::Vec"],"Arena::<T>::entries_mut":["Arena","EntriesMut","std::alloc::Allocator","std::marker::Sized","std::slice::IterMut","std::vec::Vec"],"Arena::<T>::get":["Arena","std::alloc::Allocator","std::borrow::Borrow","std::marker::Sized","std::option::Option","std::vec::Vec"],"Arena::<T>::get_idx_at_index":["Arena","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"Arena::<T>::get_mut":["Arena","std::alloc::Allocator","std::borrow::Borrow","std::marker::Sized","std::option::Option","std::vec::Vec"],"Arena::<T>::insert":["Arena","Idx","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"Arena::<T>::iter":["Arena","Iter","std::alloc::Allocator","std::iter::Map","std::marker::Sized","std::vec::Vec"],"Arena::<T>::iter_mut":["Arena","IterMut","std::alloc::Allocator","std::iter::Map","std::marker::Sized","std::vec::Vec"],"Arena::<T>::len":["Arena","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Arena::<T>::new":["Arena","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Arena::<T>::position":["Arena","std::alloc::Allocator","std::marker::Sized","std::ops::Fn","std::option::Option","std::vec::Vec"],"Arena::<T>::remove":["Arena","std::alloc::Allocator","std::borrow::Borrow","std::marker::Sized","std::vec::Vec"],"Arena::<T>::remove_index":["Arena","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Arena::<T>::retain":["Arena","std::alloc::Allocator","std::marker::Sized","std::ops::FnMut","std::vec::Vec"],"Arena::<T>::split_at":["Arena","std::alloc::Allocator","std::borrow::Borrow","std::marker::Sized","std::option::Option","std::vec::Vec"],"Arena::<T>::swap":["Arena","std::alloc::Allocator","std::borrow::Borrow","std::marker::Sized","std::vec::Vec"],"Arena::<T>::swap_index":["Arena","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Arena::<T>::swap_remove":["Arena","std::alloc::Allocator","std::borrow::Borrow","std::marker::Sized","std::vec::Vec"],"Arena::<T>::swap_remove_index":["Arena","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"Arena::<T>::to_vec":["Arena","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Arena::<T>::truncate":["Arena","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Arena::<T>::with_capacity":["Arena","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Entries":["Entries","std::marker::Sized","std::slice::Iter"],"EntriesMut":["EntriesMut","std::marker::Sized","std::slice::IterMut"],"Idx":["Idx","std::sync::Arc"],"Idx::value":["Idx","std::marker::Sized","std::option::Option","std::sync::Arc"],"IdxInner":["IdxInner","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"IdxInner::index":["IdxInner","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"Iter":["Iter","std::iter::Map","std::marker::Sized"],"IterMut":["IterMut","std::iter::Map","std::marker::Sized"],"choose_second_member_of_tuple_mut":["std::marker::Sized"],"choose_second_member_of_tuple_ref":["std::marker::Sized"],"create_idx":["std::sync::Arc"],"split::ArenaSplit":["Arena","Idx","split::ArenaSplit","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"split::ArenaSplit::<'_, T>::get":["Arena","Idx","split::ArenaSplit","std::alloc::Allocator","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"split::ArenaSplit::<'_, T>::get_mut":["Arena","Idx","split::ArenaSplit","std::alloc::Allocator","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"]},"glob_path_import":{},"self_to_fn":{"Arena":["impl<T> Arena<T> {\n    pub fn new() -> Arena<T> {\n        Self::with_capacity(DEFAULT_CAPACITY)\n    }\n\n    pub fn with_capacity(capacity: usize) -> Arena<T> {\n        Self {\n            values: Vec::with_capacity(capacity),\n        }\n    }\n\n    pub fn capacity(&self) -> usize {\n        self.values.capacity()\n    }\n\n    #[inline]\n    pub fn alloc_with_idx<F: FnOnce(Idx) -> T>(&mut self, func: F) -> Idx {\n        let len = self.values.len();\n        let inner = create_idx(len);\n        let idx = Idx {\n            inner: inner.clone(),\n        };\n        self.values.push((inner.clone(), func(idx)));\n        Idx { inner }\n    }\n\n    #[inline]\n    pub fn alloc_with<F: FnOnce() -> T>(&mut self, func: F) -> Idx {\n        self.alloc_with_idx(|_| func())\n    }\n\n    #[inline]\n    pub fn insert(&mut self, value: T) -> Idx {\n        self.alloc(value)\n    }\n\n    #[inline]\n    pub fn alloc(&mut self, value: T) -> Idx {\n        self.alloc_with(|| value)\n    }\n\n    pub fn len(&self) -> usize {\n        self.values.len()\n    }\n\n    pub fn get_idx_at_index(&self, index: usize) -> Option<Idx> {\n        self.values.get(index).map(|(inner, _)| Idx {\n            inner: Arc::clone(&inner),\n        })\n    }\n\n    pub fn split_at<'a, I: Borrow<Idx>>(\n        &'a mut self,\n        selected: I,\n    ) -> Option<(&mut T, ArenaSplit<'a, T>)> {\n        let selected = selected.borrow();\n\n        if let Some(value) = self.get_mut(selected) {\n            Some((\n                unsafe { (value as *mut T).as_mut().unwrap() },\n                ArenaSplit {\n                    selected: selected.clone(),\n                    arena: self,\n                    __type: Default::default(),\n                },\n            ))\n        } else {\n            None\n        }\n    }\n\n    pub fn truncate(&mut self, len: usize) {\n        let end = self.values.len();\n        let start = end - (end - len);\n\n        for i in (start..end).rev() {\n            self.remove_index(i);\n        }\n    }\n\n    pub fn retain<F: FnMut(&T) -> bool>(&mut self, mut f: F) {\n        let len = self.values.len();\n        let mut del = 0;\n\n        for i in 0..len {\n            if !f(&self.values[i].1) {\n                del += 1;\n            } else {\n                self.swap_index(i - del, i);\n            }\n        }\n\n        if del > 0 {\n            self.truncate(len - del);\n        }\n    }\n\n    pub fn entries<'a>(&'a self) -> Entries<'a, T> {\n        Entries {\n            iterator: self.values.iter(),\n        }\n    }\n\n    pub fn entries_mut<'a>(&'a mut self) -> EntriesMut<'a, T> {\n        EntriesMut {\n            iterator: self.values.iter_mut(),\n        }\n    }\n\n    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n        IterMut {\n            iterator: self\n                .values\n                .iter_mut()\n                .map(&choose_second_member_of_tuple_mut),\n        }\n    }\n\n    pub fn iter<'a>(&'a self) -> Iter<'a, T> {\n        Iter {\n            iterator: self.values.iter().map(&choose_second_member_of_tuple_ref),\n        }\n    }\n\n    pub fn to_vec(self) -> Vec<T> {\n        self.into()\n    }\n\n    fn remove_index(&mut self, index: usize) -> T {\n        let (removed_index, value) = self.values.remove(index);\n\n        for (index, (idx, _)) in self.values.iter().enumerate().skip(index) {\n            idx.index.store(index, Ordering::Relaxed);\n        }\n\n        removed_index.removed.store(true, Ordering::Relaxed);\n\n        value\n    }\n\n    pub fn remove<I: Borrow<Idx>>(&mut self, index: I) -> T {\n        if let Some(index) = index.borrow().value() {\n            self.remove_index(index)\n        } else {\n            panic!(\"Trying to remove index that has already been removed!\");\n        }\n    }\n\n    fn swap_index(&mut self, a: usize, b: usize) {\n        self.values.swap(a, b);\n        self.values[a].0.index.store(a, Ordering::Relaxed);\n        self.values[b].0.index.store(b, Ordering::Relaxed);\n    }\n\n    pub fn swap<A: Borrow<Idx>, B: Borrow<Idx>>(&mut self, a: A, b: B) {\n        if let Some((a_index, b_index)) = a\n            .borrow()\n            .value()\n            .and_then(|a| b.borrow().value().map(|b| (a, b)))\n        {\n            self.swap_index(a_index, b_index);\n        }\n    }\n\n    pub fn position<F: Fn(&T) -> bool>(&self, func: F) -> Option<Idx> {\n        for (inner, value) in self.values.iter() {\n            if func(value) {\n                return Some(Idx {\n                    inner: Arc::clone(&inner),\n                });\n            }\n        }\n\n        None\n    }\n\n    pub fn apply_ordering<I: Borrow<Idx>>(&mut self, ordering: &Vec<I>) {\n        assert!(ordering.len() == self.values.len());\n\n        let mut old_arena = Arena::<T>::with_capacity(self.capacity());\n        std::mem::swap(&mut old_arena.values, &mut self.values);\n\n        for idx in ordering.iter() {\n            let new_index = self.values.len();\n            let old_index = idx.borrow().value().unwrap();\n\n            let (inner, value) = old_arena.swap_remove_index(old_index);\n\n            inner.index.store(new_index, Ordering::Relaxed);\n\n            self.values.push((inner, value));\n\n            idx.borrow().inner.index.store(new_index, Ordering::Relaxed);\n        }\n    }\n\n    fn swap_remove_index(&mut self, index: usize) -> (Arc<IdxInner>, T) {\n        let (removed_index, value) = self.values.swap_remove(index);\n\n        if self.values.len() > 0 && index != self.values.len() {\n            self.values[index].0.index.store(index, Ordering::Relaxed);\n        }\n\n        (removed_index, value)\n    }\n\n    #[cfg(test)]\n    fn get_index(&mut self, index: usize) -> &mut T {\n        &mut self.values[index].1\n    }\n\n    pub fn swap_remove<I: Borrow<Idx>>(&mut self, index: I) -> T {\n        if let Some(index) = index.borrow().value() {\n            let (removed_index, value) = self.swap_remove_index(index);\n            removed_index.removed.store(true, Ordering::Relaxed);\n            value\n        } else {\n            panic!(\"Trying to remove index that has already been removed!\");\n        }\n    }\n\n    pub fn get<I: Borrow<Idx>>(&self, index: I) -> Option<&T> {\n        index\n            .borrow()\n            .value()\n            .and_then(|index| self.values.get(index).and_then(|(_, value)| Some(value)))\n    }\n\n    pub fn get_mut<I: Borrow<Idx>>(&mut self, index: I) -> Option<&mut T> {\n        if let Some(index) = index.borrow().value() {\n            self.values\n                .get_mut(index)\n                .and_then(|(_, value)| Some(value))\n        } else {\n            None\n        }\n    }\n}","impl<T> Default for Arena<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}","impl<T> FromIterator<T> for Arena<T> {\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n        Arena {\n            values: iter\n                .into_iter()\n                .enumerate()\n                .map(|(index, value)| (create_idx(index), value))\n                .collect(),\n        }\n    }\n}","impl<T> Into<Vec<T>> for Arena<T> {\n    fn into(self) -> Vec<T> {\n        // Set all the indexes to removed, since we can't use them anymore\n        for (idx, _) in self.values.iter() {\n            idx.removed.store(true, Ordering::Relaxed);\n        }\n\n        // Grab all the values and turn them into an array\n        self.values.into_iter().map(|(_, value)| value).collect()\n    }\n}"],"Entries":["impl<'a, T> Iterator for Entries<'a, T> {\n    type Item = (Idx, &'a T);\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iterator.next().map(|(inner, value)| {\n            (\n                Idx {\n                    inner: inner.clone(),\n                },\n                value,\n            )\n        })\n    }\n}"],"EntriesMut":["impl<'a, T> Iterator for EntriesMut<'a, T> {\n    type Item = (Idx, &'a mut T);\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iterator.next().map(|(inner, value)| {\n            (\n                Idx {\n                    inner: inner.clone(),\n                },\n                value,\n            )\n        })\n    }\n}"],"Idx":["Clone","impl Eq for Idx {}","impl Hash for Idx {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        std::ptr::hash(self.inner.as_ref(), state)\n    }\n}","impl Idx {\n    pub fn value(&self) -> Option<usize> {\n        self.inner.index()\n    }\n}","impl PartialEq for Idx {\n    fn eq(&self, rhs: &Idx) -> bool {\n        Arc::ptr_eq(&self.inner, &rhs.inner)\n    }\n}","impl std::fmt::Debug for Idx {\n    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n        formatter.write_str(&format!(\n            \"{}Idx ( {} )\",\n            if self.inner.removed.load(Ordering::Relaxed) {\n                \"Removed \"\n            } else {\n                \"\"\n            },\n            self.inner.index.load(Ordering::Relaxed)\n        ))\n    }\n}"],"IdxInner":["impl IdxInner {\n    fn index(&self) -> Option<usize> {\n        let removed = self.removed.load(Ordering::Relaxed);\n        if !removed {\n            Some(self.index.load(Ordering::Relaxed))\n        } else {\n            None\n        }\n    }\n}"],"Iter":["impl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iterator.next()\n    }\n}"],"IterMut":["impl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iterator.next()\n    }\n}"],"split::ArenaSplit":["impl<T> ArenaSplit<'_, T> {\n    pub fn get<I: Borrow<Idx>>(&self, index: I) -> Option<&T> {\n        if index.borrow() == &self.selected {\n            None\n        } else {\n            self.arena.get(index)\n        }\n    }\n\n    pub fn get_mut<I: Borrow<Idx>>(&mut self, index: I) -> Option<&mut T> {\n        if index.borrow() == &self.selected {\n            None\n        } else {\n            self.arena.get_mut(index)\n        }\n    }\n}"]},"single_path_import":{},"srcs":{"<Arena<T> as std::convert::Into<std::vec::Vec<T>>>::into":["fn into(self) -> Vec<T>{\n        // Set all the indexes to removed, since we can't use them anymore\n        for (idx, _) in self.values.iter() {\n            idx.removed.store(true, Ordering::Relaxed);\n        }\n\n        // Grab all the values and turn them into an array\n        self.values.into_iter().map(|(_, value)| value).collect()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Arena<T> as std::default::Default>::default":["fn default() -> Self{\n        Self::new()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Arena<T> as std::iter::FromIterator<T>>::from_iter":["fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self{\n        Arena {\n            values: iter\n                .into_iter()\n                .enumerate()\n                .map(|(index, value)| (create_idx(index), value))\n                .collect(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Entries<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iterator.next().map(|(inner, value)| {\n            (\n                Idx {\n                    inner: inner.clone(),\n                },\n                value,\n            )\n        })\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<EntriesMut<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iterator.next().map(|(inner, value)| {\n            (\n                Idx {\n                    inner: inner.clone(),\n                },\n                value,\n            )\n        })\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Idx as std::cmp::PartialEq>::eq":["fn eq(&self, rhs: &Idx) -> bool{\n        Arc::ptr_eq(&self.inner, &rhs.inner)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Idx as std::fmt::Debug>::fmt":["fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error>{\n        formatter.write_str(&format!(\n            \"{}Idx ( {} )\",\n            if self.inner.removed.load(Ordering::Relaxed) {\n                \"Removed \"\n            } else {\n                \"\"\n            },\n            self.inner.index.load(Ordering::Relaxed)\n        ))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Idx as std::hash::Hash>::hash":["fn hash<H: Hasher>(&self, state: &mut H){\n        std::ptr::hash(self.inner.as_ref(), state)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Iter<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iterator.next()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IterMut<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iterator.next()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena":["pub struct Arena<T> {\n    values: Vec<(Arc<IdxInner>, T)>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::alloc":["#[inline]\npub fn alloc(&mut self, value: T) -> Idx{\n        self.alloc_with(|| value)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::alloc_with":["#[inline]\npub fn alloc_with<F: FnOnce() -> T>(&mut self, func: F) -> Idx{\n        self.alloc_with_idx(|_| func())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::alloc_with_idx":["#[inline]\npub fn alloc_with_idx<F: FnOnce(Idx) -> T>(&mut self, func: F) -> Idx{\n        let len = self.values.len();\n        let inner = create_idx(len);\n        let idx = Idx {\n            inner: inner.clone(),\n        };\n        self.values.push((inner.clone(), func(idx)));\n        Idx { inner }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::apply_ordering":["pub fn apply_ordering<I: Borrow<Idx>>(&mut self, ordering: &Vec<I>){\n        assert!(ordering.len() == self.values.len());\n\n        let mut old_arena = Arena::<T>::with_capacity(self.capacity());\n        std::mem::swap(&mut old_arena.values, &mut self.values);\n\n        for idx in ordering.iter() {\n            let new_index = self.values.len();\n            let old_index = idx.borrow().value().unwrap();\n\n            let (inner, value) = old_arena.swap_remove_index(old_index);\n\n            inner.index.store(new_index, Ordering::Relaxed);\n\n            self.values.push((inner, value));\n\n            idx.borrow().inner.index.store(new_index, Ordering::Relaxed);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::capacity":["pub fn capacity(&self) -> usize{\n        self.values.capacity()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::entries":["pub fn entries<'a>(&'a self) -> Entries<'a, T>{\n        Entries {\n            iterator: self.values.iter(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::entries_mut":["pub fn entries_mut<'a>(&'a mut self) -> EntriesMut<'a, T>{\n        EntriesMut {\n            iterator: self.values.iter_mut(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::get":["pub fn get<I: Borrow<Idx>>(&self, index: I) -> Option<&T>{\n        index\n            .borrow()\n            .value()\n            .and_then(|index| self.values.get(index).and_then(|(_, value)| Some(value)))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::get_idx_at_index":["pub fn get_idx_at_index(&self, index: usize) -> Option<Idx>{\n        self.values.get(index).map(|(inner, _)| Idx {\n            inner: Arc::clone(&inner),\n        })\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::get_mut":["pub fn get_mut<I: Borrow<Idx>>(&mut self, index: I) -> Option<&mut T>{\n        if let Some(index) = index.borrow().value() {\n            self.values\n                .get_mut(index)\n                .and_then(|(_, value)| Some(value))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::insert":["#[inline]\npub fn insert(&mut self, value: T) -> Idx{\n        self.alloc(value)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::iter":["pub fn iter<'a>(&'a self) -> Iter<'a, T>{\n        Iter {\n            iterator: self.values.iter().map(&choose_second_member_of_tuple_ref),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::iter_mut":["pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T>{\n        IterMut {\n            iterator: self\n                .values\n                .iter_mut()\n                .map(&choose_second_member_of_tuple_mut),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::len":["pub fn len(&self) -> usize{\n        self.values.len()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::new":["pub fn new() -> Arena<T>{\n        Self::with_capacity(DEFAULT_CAPACITY)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::position":["pub fn position<F: Fn(&T) -> bool>(&self, func: F) -> Option<Idx>{\n        for (inner, value) in self.values.iter() {\n            if func(value) {\n                return Some(Idx {\n                    inner: Arc::clone(&inner),\n                });\n            }\n        }\n\n        None\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::remove":["pub fn remove<I: Borrow<Idx>>(&mut self, index: I) -> T{\n        if let Some(index) = index.borrow().value() {\n            self.remove_index(index)\n        } else {\n            panic!(\"Trying to remove index that has already been removed!\");\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::remove_index":["fn remove_index(&mut self, index: usize) -> T{\n        let (removed_index, value) = self.values.remove(index);\n\n        for (index, (idx, _)) in self.values.iter().enumerate().skip(index) {\n            idx.index.store(index, Ordering::Relaxed);\n        }\n\n        removed_index.removed.store(true, Ordering::Relaxed);\n\n        value\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::retain":["pub fn retain<F: FnMut(&T) -> bool>(&mut self, mut f: F){\n        let len = self.values.len();\n        let mut del = 0;\n\n        for i in 0..len {\n            if !f(&self.values[i].1) {\n                del += 1;\n            } else {\n                self.swap_index(i - del, i);\n            }\n        }\n\n        if del > 0 {\n            self.truncate(len - del);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::split_at":["pub fn split_at<'a, I: Borrow<Idx>>(\n        &'a mut self,\n        selected: I,\n    ) -> Option<(&mut T, ArenaSplit<'a, T>)>{\n        let selected = selected.borrow();\n\n        if let Some(value) = self.get_mut(selected) {\n            Some((\n                unsafe { (value as *mut T).as_mut().unwrap() },\n                ArenaSplit {\n                    selected: selected.clone(),\n                    arena: self,\n                    __type: Default::default(),\n                },\n            ))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::swap":["pub fn swap<A: Borrow<Idx>, B: Borrow<Idx>>(&mut self, a: A, b: B){\n        if let Some((a_index, b_index)) = a\n            .borrow()\n            .value()\n            .and_then(|a| b.borrow().value().map(|b| (a, b)))\n        {\n            self.swap_index(a_index, b_index);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::swap_index":["fn swap_index(&mut self, a: usize, b: usize){\n        self.values.swap(a, b);\n        self.values[a].0.index.store(a, Ordering::Relaxed);\n        self.values[b].0.index.store(b, Ordering::Relaxed);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::swap_remove":["pub fn swap_remove<I: Borrow<Idx>>(&mut self, index: I) -> T{\n        if let Some(index) = index.borrow().value() {\n            let (removed_index, value) = self.swap_remove_index(index);\n            removed_index.removed.store(true, Ordering::Relaxed);\n            value\n        } else {\n            panic!(\"Trying to remove index that has already been removed!\");\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::swap_remove_index":["fn swap_remove_index(&mut self, index: usize) -> (Arc<IdxInner>, T){\n        let (removed_index, value) = self.values.swap_remove(index);\n\n        if self.values.len() > 0 && index != self.values.len() {\n            self.values[index].0.index.store(index, Ordering::Relaxed);\n        }\n\n        (removed_index, value)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::to_vec":["pub fn to_vec(self) -> Vec<T>{\n        self.into()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::truncate":["pub fn truncate(&mut self, len: usize){\n        let end = self.values.len();\n        let start = end - (end - len);\n\n        for i in (start..end).rev() {\n            self.remove_index(i);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Arena::<T>::with_capacity":["pub fn with_capacity(capacity: usize) -> Arena<T>{\n        Self {\n            values: Vec::with_capacity(capacity),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Entries":["pub struct Entries<'a, T> {\n    iterator: std::slice::Iter<'a, (Arc<IdxInner>, T)>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"EntriesMut":["pub struct EntriesMut<'a, T> {\n    iterator: std::slice::IterMut<'a, (Arc<IdxInner>, T)>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Idx":["pub struct Idx {\n    inner: Arc<IdxInner>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Idx::value":["pub fn value(&self) -> Option<usize>{\n        self.inner.index()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"IdxInner":["struct IdxInner {\n    index: AtomicUsize,\n    removed: AtomicBool,\n}","Real(LocalPath(\"src/lib.rs\"))"],"IdxInner::index":["fn index(&self) -> Option<usize>{\n        let removed = self.removed.load(Ordering::Relaxed);\n        if !removed {\n            Some(self.index.load(Ordering::Relaxed))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Iter":["pub struct Iter<'a, T> {\n    iterator: std::iter::Map<\n        std::slice::Iter<'a, (Arc<IdxInner>, T)>,\n        &'a dyn Fn(&(Arc<IdxInner>, T)) -> &T,\n    >,\n}","Real(LocalPath(\"src/lib.rs\"))"],"IterMut":["pub struct IterMut<'a, T> {\n    iterator: std::iter::Map<\n        std::slice::IterMut<'a, (Arc<IdxInner>, T)>,\n        &'a dyn Fn(&mut (Arc<IdxInner>, T)) -> &mut T,\n    >,\n}","Real(LocalPath(\"src/lib.rs\"))"],"choose_second_member_of_tuple_mut":["#[inline]\nfn choose_second_member_of_tuple_mut<A, B>((_, value): &mut (A, B)) -> &mut B{\n    value\n}","Real(LocalPath(\"src/lib.rs\"))"],"choose_second_member_of_tuple_ref":["#[inline]\nfn choose_second_member_of_tuple_ref<A, B>((_, value): &(A, B)) -> &B{\n    value\n}","Real(LocalPath(\"src/lib.rs\"))"],"create_idx":["#[inline]\nfn create_idx(index: usize) -> Arc<IdxInner>{\n    Arc::new(IdxInner {\n        index: AtomicUsize::new(index),\n        removed: AtomicBool::new(false),\n    })\n}","Real(LocalPath(\"src/lib.rs\"))"],"split::ArenaSplit":["pub struct ArenaSplit<'a, T> {\n    pub(crate) selected: Idx,\n    pub(crate) arena: &'a mut Arena<T>,\n    pub(crate) __type: std::marker::PhantomData<T>,\n}","Real(LocalPath(\"src/split.rs\"))"],"split::ArenaSplit::<'_, T>::get":["pub fn get<I: Borrow<Idx>>(&self, index: I) -> Option<&T>{\n        if index.borrow() == &self.selected {\n            None\n        } else {\n            self.arena.get(index)\n        }\n    }","Real(LocalPath(\"src/split.rs\"))"],"split::ArenaSplit::<'_, T>::get_mut":["pub fn get_mut<I: Borrow<Idx>>(&mut self, index: I) -> Option<&mut T>{\n        if index.borrow() == &self.selected {\n            None\n        } else {\n            self.arena.get_mut(index)\n        }\n    }","Real(LocalPath(\"src/split.rs\"))"]},"struct_constructor":{"(&'a mut T, split::ArenaSplit<'a, T>)":["split_at"],"(std::sync::Arc<IdxInner>, T)":["swap_remove_index"],"<Entries<'a, T> as std::iter::Iterator>::Item":["next"],"<EntriesMut<'a, T> as std::iter::Iterator>::Item":["next"],"<Iter<'a, T> as std::iter::Iterator>::Item":["next"],"<IterMut<'a, T> as std::iter::Iterator>::Item":["next"],"Arena":["default","from_iter","new","with_capacity"],"Entries":["entries"],"EntriesMut":["entries_mut"],"Idx":["alloc","alloc_with","alloc_with_idx","clone","get_idx_at_index","insert","position"],"Iter":["iter"],"IterMut":["iter_mut"],"bool":["eq"],"std::sync::Arc":["create_idx"],"std::vec::Vec":["into","to_vec"],"usize":["capacity","index","len","value"]},"struct_to_trait":{"Arena":["std::convert::Into","std::default::Default","std::iter::FromIterator"],"Entries":["std::iter::Iterator"],"EntriesMut":["std::iter::Iterator"],"Idx":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash"],"Iter":["std::iter::Iterator"],"IterMut":["std::iter::Iterator"]},"targets":{"<Arena<T> as std::convert::Into<std::vec::Vec<T>>>::into":["into","Real(LocalPath(\"src/lib.rs\"))","std::convert::Into"],"<Arena<T> as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<Arena<T> as std::iter::FromIterator<T>>::from_iter":["from_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::FromIterator"],"<Entries<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<EntriesMut<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<Idx as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<Idx as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<Idx as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/lib.rs\"))","std::hash::Hash"],"<Iter<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<IterMut<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"Arena::<T>::alloc":["alloc","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::alloc_with":["alloc_with","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::alloc_with_idx":["alloc_with_idx","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::apply_ordering":["apply_ordering","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::capacity":["capacity","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::entries":["entries","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::entries_mut":["entries_mut","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::get":["get","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::get_idx_at_index":["get_idx_at_index","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::get_mut":["get_mut","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::insert":["insert","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::iter":["iter","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::iter_mut":["iter_mut","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::len":["len","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::position":["position","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::remove":["remove","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::remove_index":["remove_index","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::retain":["retain","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::split_at":["split_at","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::swap":["swap","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::swap_index":["swap_index","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::swap_remove":["swap_remove","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::swap_remove_index":["swap_remove_index","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::to_vec":["to_vec","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::truncate":["truncate","Real(LocalPath(\"src/lib.rs\"))",""],"Arena::<T>::with_capacity":["with_capacity","Real(LocalPath(\"src/lib.rs\"))",""],"Idx::value":["value","Real(LocalPath(\"src/lib.rs\"))",""],"IdxInner::index":["index","Real(LocalPath(\"src/lib.rs\"))",""],"choose_second_member_of_tuple_mut":["choose_second_member_of_tuple_mut","Real(LocalPath(\"src/lib.rs\"))",""],"choose_second_member_of_tuple_ref":["choose_second_member_of_tuple_ref","Real(LocalPath(\"src/lib.rs\"))",""],"create_idx":["create_idx","Real(LocalPath(\"src/lib.rs\"))",""],"split::ArenaSplit::<'_, T>::get":["get","Real(LocalPath(\"src/split.rs\"))",""],"split::ArenaSplit::<'_, T>::get_mut":["get_mut","Real(LocalPath(\"src/split.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["Idx"],"std::cmp::Eq":["Idx"],"std::cmp::PartialEq":["Idx"],"std::convert::Into":["Arena"],"std::default::Default":["Arena"],"std::fmt::Debug":["Idx"],"std::hash::Hash":["Idx"],"std::iter::FromIterator":["Arena"],"std::iter::Iterator":["Entries","EntriesMut","Iter","IterMut"]},"type_to_def_path":{"Arena<T>":"Arena","Entries<'a, T>":"Entries","EntriesMut<'a, T>":"EntriesMut","Idx":"Idx","IdxInner":"IdxInner","Iter<'a, T>":"Iter","IterMut<'a, T>":"IterMut","split::ArenaSplit<'a, T>":"split::ArenaSplit"}}