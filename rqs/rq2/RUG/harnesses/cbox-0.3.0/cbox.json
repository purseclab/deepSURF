{"dependencies":{"<CBox<T> as std::borrow::Borrow<T>>::borrow":["CBox","DisposeRef"],"<CBox<T> as std::cmp::PartialEq<T>>::eq":["CBox","DisposeRef"],"<CBox<T> as std::ops::Deref>::deref":["CBox","DisposeRef"],"<CBox<T> as std::ops::DerefMut>::deref_mut":["CBox","DisposeRef"],"<CBox<str> as std::clone::Clone>::clone":["CBox","DisposeRef"],"<CBox<str> as std::convert::From<&'a str>>::from":["CBox","DisposeRef"],"<CBox<str> as std::fmt::Debug>::fmt":["CBox","DisposeRef","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<CBox<str> as std::fmt::Display>::fmt":["CBox","DisposeRef","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<CBox<str> as std::ops::Deref>::deref":["CBox","DisposeRef"],"<CSemiBox<'a, D> as std::borrow::Borrow<D>>::borrow":["CSemiBox","DisposeRef","std::marker::PhantomData"],"<CSemiBox<'a, D> as std::convert::From<*mut <D as DisposeRef>::RefTo>>::from":["CSemiBox","DisposeRef","std::marker::PhantomData"],"<CSemiBox<'a, D> as std::ops::Deref>::deref":["CSemiBox","DisposeRef","std::marker::PhantomData"],"<CSemiBox<'a, D> as std::ops::DerefMut>::deref_mut":["CSemiBox","DisposeRef","std::marker::PhantomData"],"<CSemiBox<'a, D> as std::ops::Drop>::drop":["CSemiBox","DisposeRef","std::marker::PhantomData"],"<CSemiBox<'a, T> as std::cmp::PartialEq<T>>::eq":["CSemiBox","DisposeRef","std::marker::PhantomData"],"<CSemiBox<'a, T> as std::fmt::Debug>::fmt":["CSemiBox","DisposeRef","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<CSemiBox<'a, T> as std::fmt::Display>::fmt":["CSemiBox","DisposeRef","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<CSemiBox<'a, str> as std::convert::From<&'a std::ffi::CStr>>::from":["CSemiBox","DisposeRef","std::ffi::CStr","std::marker::PhantomData"],"CBox":["CBox","DisposeRef"],"CBox::<D>::as_ptr":["CBox","DisposeRef"],"CBox::<D>::as_semi":["CBox","CSemiBox","DisposeRef","std::marker::PhantomData"],"CBox::<D>::as_semi_mut":["CBox","CSemiBox","DisposeRef","std::marker::PhantomData"],"CBox::<D>::new":["CBox","DisposeRef"],"CBox::<D>::unwrap":["CBox","DisposeRef"],"CSemiBox":["CSemiBox","DisposeRef","std::marker::PhantomData"],"CSemiBox::<'a, D>::as_ptr":["CSemiBox","DisposeRef","std::marker::PhantomData"],"CSemiBox::<'a, D>::new":["CSemiBox","DisposeRef","std::marker::PhantomData"],"CSemiBox::<'a, D>::unwrap":["CSemiBox","DisposeRef","std::marker::PhantomData"],"DisposeRef::dispose":[]},"glob_path_import":{},"self_to_fn":{"CBox":["impl Clone for CBox<str> {\n    fn clone(&self) -> CBox<str> {\n        unsafe {\n            let ptr = libc::malloc(self.len() as size_t + 1) as *mut c_char;\n            libc::strcpy(ptr, self.ptr);\n            CBox::new(ptr)\n        }\n    }\n}","impl fmt::Debug for CBox<str> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.write_str(self.deref())\n    }\n}","impl fmt::Display for CBox<str> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.write_str(self.deref())\n    }\n}","impl<'a, T> PartialEq<T> for CBox<T> where T:'a+DisposeRef+PartialEq, *mut T::RefTo:Into<&'a T> {\n    fn eq(&self, other: &T) -> bool {\n        unsafe {\n            mem::transmute::<_, &T>(self.ptr) == other\n        }\n    }\n}","impl<'a> Deref for CBox<str> {\n    type Target = str;\n    fn deref(&self) -> &str {\n        unsafe {\n            let text = CStr::from_ptr(self.ptr);\n            str::from_utf8_unchecked(text.to_bytes())\n        }\n    }\n}","impl<'a> From<&'a str> for CBox<str> {\n    /// Copy this text using malloc and strcpy.\n    fn from(text: &'a str) -> CBox<str> {\n        unsafe {\n            let cstr = CString::new(text).unwrap();\n            let ptr = libc::malloc(text.len() as size_t + 1) as *mut c_char;\n            libc::strcpy(ptr, cstr.as_ptr());\n            CBox::new(ptr)\n        }\n    }\n}","impl<D:?Sized> CBox<D> where D:DisposeRef {\n    #[inline(always)]\n    /// Wrap the pointer in a `CBox`.\n    pub fn new(ptr: *mut D::RefTo) -> Self {\n        CBox {\n            ptr: ptr\n        }\n    }\n    #[inline(always)]\n    /// Returns the internal pointer.\n    pub unsafe fn as_ptr(&self) -> *mut D::RefTo {\n        self.ptr\n    }\n    #[inline(always)]\n    /// Returns the internal pointer.\n    pub unsafe fn unwrap(self) -> *mut D::RefTo {\n        let ptr = self.ptr;\n        mem::forget(self);\n        ptr\n    }\n    /// Returns the box as a 'CSemiBox'.\n    pub fn as_semi<'a>(&'a self) -> &CSemiBox<'a, D> {\n        unsafe {\n            mem::transmute(self)\n        }\n    }\n    /// Returns the box as a 'CSemiBox'.\n    pub fn as_semi_mut<'a>(&'a mut self) -> &mut CSemiBox<'a, D> {\n        unsafe {\n            mem::transmute(self)\n        }\n    }\n}","impl<T> Borrow<T> for CBox<T> where T:DisposeRef {\n    fn borrow(&self) -> &T {\n        unsafe { mem::transmute(self.ptr) }\n    }\n}","impl<T> Deref for CBox<T> where T:DisposeRef {\n    type Target = T;\n    fn deref(&self) -> &T {\n        unsafe { mem::transmute(self.ptr) }\n    }\n}","impl<T> DerefMut for CBox<T> where T:DisposeRef {\n    fn deref_mut(&mut self) -> &mut T {\n        unsafe { mem::transmute(self.ptr) }\n    }\n}"],"CSemiBox":["impl<'a, D:?Sized> CSemiBox<'a, D> where D:DisposeRef+'a {\n    #[inline(always)]\n    /// Wrap the pointer in a `CSemiBox`\n    pub fn new(ptr: *mut D::RefTo) -> Self {\n        CSemiBox {\n            ptr: ptr,\n            marker: PhantomData\n        }\n    }\n    #[inline(always)]\n    /// Returns the internal pointer\n    pub unsafe fn as_ptr(&self) -> *mut D::RefTo {\n        self.ptr\n    }\n    #[inline(always)]\n    /// Returns the internal pointer\n    pub unsafe fn unwrap(self) -> *mut D::RefTo {\n        let ptr = self.ptr;\n        mem::forget(self);\n        ptr\n    }\n}","impl<'a, D:?Sized> Drop for CSemiBox<'a, D> where D:DisposeRef+'a {\n    #[inline(always)]\n    /// Run the destructor\n    fn drop(&mut self) {\n        unsafe { <D as DisposeRef>::dispose(self.ptr) }\n    }\n}","impl<'a, D:?Sized> From<*mut D::RefTo> for CSemiBox<'a, D> where D:DisposeRef+'a {\n    #[inline(always)]\n    fn from(ptr: *mut D::RefTo) -> Self {\n        CSemiBox::new(ptr)\n    }\n}","impl<'a, D> Borrow<D> for CSemiBox<'a, D> where D:DisposeRef+'a, *mut D::RefTo:Into<&'a D> {\n    fn borrow(&self) -> &D {\n        self.ptr.into()\n    }\n}","impl<'a, D> Deref for CSemiBox<'a, D> where D:DisposeRef+'a, *mut D::RefTo:Into<&'a D> {\n    type Target = D;\n    fn deref(&self) -> &D {\n        self.ptr.into()\n    }\n}","impl<'a, D> DerefMut for CSemiBox<'a, D> where D:DisposeRef+'a, *mut D::RefTo:Into<&'a D>, *mut D::RefTo:Into<&'a mut D> {\n    fn deref_mut(&mut self) -> &mut D {\n        self.ptr.into()\n    }\n}","impl<'a, T> PartialEq<T> for CSemiBox<'a, T> where T:'a+DisposeRef+PartialEq, *mut T::RefTo:Into<&'a T> {\n    fn eq(&self, other: &T) -> bool {\n        (self as &T).eq(other)\n    }\n}","impl<'a, T> fmt::Debug for CSemiBox<'a, T> where T:fmt::Debug+DisposeRef+'a, *mut T::RefTo:Into<&'a T> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(self as &T, fmt)\n    }\n}","impl<'a, T> fmt::Display for CSemiBox<'a, T> where T:fmt::Display+DisposeRef+'a, *mut T::RefTo:Into<&'a T> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(self as &T, fmt)\n    }\n}","impl<'a> From<&'a CStr> for CSemiBox<'a, str> {\n    fn from(text: &'a CStr) -> CSemiBox<'a, str> {\n        CSemiBox::new(text.as_ptr() as *mut c_char)\n    }\n}"]},"single_path_import":{},"srcs":{"<CBox<T> as std::borrow::Borrow<T>>::borrow":["fn borrow(&self) -> &T{\n        unsafe { mem::transmute(self.ptr) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CBox<T> as std::cmp::PartialEq<T>>::eq":["fn eq(&self, other: &T) -> bool{\n        unsafe {\n            mem::transmute::<_, &T>(self.ptr) == other\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CBox<T> as std::ops::Deref>::deref":["fn deref(&self) -> &T{\n        unsafe { mem::transmute(self.ptr) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CBox<T> as std::ops::DerefMut>::deref_mut":["fn deref_mut(&mut self) -> &mut T{\n        unsafe { mem::transmute(self.ptr) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CBox<str> as std::clone::Clone>::clone":["fn clone(&self) -> CBox<str>{\n        unsafe {\n            let ptr = libc::malloc(self.len() as size_t + 1) as *mut c_char;\n            libc::strcpy(ptr, self.ptr);\n            CBox::new(ptr)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CBox<str> as std::convert::From<&'a str>>::from":["/// Copy this text using malloc and strcpy.\nfn from(text: &'a str) -> CBox<str>{\n        unsafe {\n            let cstr = CString::new(text).unwrap();\n            let ptr = libc::malloc(text.len() as size_t + 1) as *mut c_char;\n            libc::strcpy(ptr, cstr.as_ptr());\n            CBox::new(ptr)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CBox<str> as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        fmt.write_str(self.deref())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CBox<str> as std::fmt::Display>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        fmt.write_str(self.deref())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CBox<str> as std::ops::Deref>::deref":["fn deref(&self) -> &str{\n        unsafe {\n            let text = CStr::from_ptr(self.ptr);\n            str::from_utf8_unchecked(text.to_bytes())\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CSemiBox<'a, D> as std::borrow::Borrow<D>>::borrow":["fn borrow(&self) -> &D{\n        self.ptr.into()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CSemiBox<'a, D> as std::convert::From<*mut <D as DisposeRef>::RefTo>>::from":["#[inline(always)]\nfn from(ptr: *mut D::RefTo) -> Self{\n        CSemiBox::new(ptr)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CSemiBox<'a, D> as std::ops::Deref>::deref":["fn deref(&self) -> &D{\n        self.ptr.into()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CSemiBox<'a, D> as std::ops::DerefMut>::deref_mut":["fn deref_mut(&mut self) -> &mut D{\n        self.ptr.into()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CSemiBox<'a, D> as std::ops::Drop>::drop":["#[inline(always)]\n/// Run the destructor\nfn drop(&mut self){\n        unsafe { <D as DisposeRef>::dispose(self.ptr) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CSemiBox<'a, T> as std::cmp::PartialEq<T>>::eq":["fn eq(&self, other: &T) -> bool{\n        (self as &T).eq(other)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CSemiBox<'a, T> as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Debug::fmt(self as &T, fmt)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CSemiBox<'a, T> as std::fmt::Display>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Display::fmt(self as &T, fmt)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CSemiBox<'a, str> as std::convert::From<&'a std::ffi::CStr>>::from":["fn from(text: &'a CStr) -> CSemiBox<'a, str>{\n        CSemiBox::new(text.as_ptr() as *mut c_char)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"CBox":["/// A wrapper for pointers made by C that are now completely owned by Rust, so\n/// they are not limited by any lifetimes.\n///\n/// This is necessary to allow owned and borrowed representations of C types\n/// to be represented by the same type as they are in C with little overhead.\npub struct CBox<D:?Sized> where D:DisposeRef {\n    ptr: *mut D::RefTo\n}","Real(LocalPath(\"src/lib.rs\"))"],"CBox::<D>::as_ptr":["#[inline(always)]\n/// Returns the internal pointer.\npub unsafe fn as_ptr(&self) -> *mut D::RefTo{\n        self.ptr\n    }","Real(LocalPath(\"src/lib.rs\"))"],"CBox::<D>::as_semi":["/// Returns the box as a 'CSemiBox'.\npub fn as_semi<'a>(&'a self) -> &CSemiBox<'a, D>{\n        unsafe {\n            mem::transmute(self)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"CBox::<D>::as_semi_mut":["/// Returns the box as a 'CSemiBox'.\npub fn as_semi_mut<'a>(&'a mut self) -> &mut CSemiBox<'a, D>{\n        unsafe {\n            mem::transmute(self)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"CBox::<D>::new":["#[inline(always)]\n/// Wrap the pointer in a `CBox`.\npub fn new(ptr: *mut D::RefTo) -> Self{\n        CBox {\n            ptr: ptr\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"CBox::<D>::unwrap":["#[inline(always)]\n/// Returns the internal pointer.\npub unsafe fn unwrap(self) -> *mut D::RefTo{\n        let ptr = self.ptr;\n        mem::forget(self);\n        ptr\n    }","Real(LocalPath(\"src/lib.rs\"))"],"CSemiBox":["/// A wrapper for pointers made by C that are now partially owned in Rust.\n///\n/// This is necessary to allow owned and borrowed representations of C types\n/// to be represented by the same type as they are in C with little overhead\npub struct CSemiBox<'a, D:?Sized> where D:DisposeRef+'a {\n    ptr: *mut D::RefTo,\n    marker: PhantomData<&'a ()>\n}","Real(LocalPath(\"src/lib.rs\"))"],"CSemiBox::<'a, D>::as_ptr":["#[inline(always)]\n/// Returns the internal pointer\npub unsafe fn as_ptr(&self) -> *mut D::RefTo{\n        self.ptr\n    }","Real(LocalPath(\"src/lib.rs\"))"],"CSemiBox::<'a, D>::new":["#[inline(always)]\n/// Wrap the pointer in a `CSemiBox`\npub fn new(ptr: *mut D::RefTo) -> Self{\n        CSemiBox {\n            ptr: ptr,\n            marker: PhantomData\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"CSemiBox::<'a, D>::unwrap":["#[inline(always)]\n/// Returns the internal pointer\npub unsafe fn unwrap(self) -> *mut D::RefTo{\n        let ptr = self.ptr;\n        mem::forget(self);\n        ptr\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DisposeRef":["/// Implemented by any type of which its reference represents a C pointer that can be disposed.\npub trait DisposeRef {\n    /// What a reference to this type represents as a C pointer.\n    type RefTo;\n    /// Destroy the contents at the pointer's location.\n    ///\n    /// This should run some variant of `libc::free(ptr)`\n    unsafe fn dispose(ptr: *mut Self::RefTo) {\n        free(ptr as *mut c_void);\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"DisposeRef::dispose":["/// Destroy the contents at the pointer's location.\n///\n/// This should run some variant of `libc::free(ptr)`\nunsafe fn dispose(ptr: *mut Self::RefTo){\n        free(ptr as *mut c_void);\n    }","Real(LocalPath(\"src/lib.rs\"))"]},"struct_constructor":{"&str":["deref"],"*mut <D as DisposeRef>::RefTo":["as_ptr","unwrap"],"CBox":["clone","from","new"],"CSemiBox":["from","new"],"bool":["eq"]},"struct_to_trait":{"CBox":["std::borrow::Borrow","std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::fmt::Display","std::ops::Deref","std::ops::DerefMut"],"CSemiBox":["std::borrow::Borrow","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::fmt::Display","std::ops::Deref","std::ops::DerefMut","std::ops::Drop"]},"targets":{"<CBox<T> as std::borrow::Borrow<T>>::borrow":["borrow","Real(LocalPath(\"src/lib.rs\"))","std::borrow::Borrow"],"<CBox<T> as std::cmp::PartialEq<T>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<CBox<T> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/lib.rs\"))","std::ops::Deref"],"<CBox<T> as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/lib.rs\"))","std::ops::DerefMut"],"<CBox<str> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","std::clone::Clone"],"<CBox<str> as std::convert::From<&'a str>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<CBox<str> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<CBox<str> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Display"],"<CBox<str> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/lib.rs\"))","std::ops::Deref"],"<CSemiBox<'a, D> as std::borrow::Borrow<D>>::borrow":["borrow","Real(LocalPath(\"src/lib.rs\"))","std::borrow::Borrow"],"<CSemiBox<'a, D> as std::convert::From<*mut <D as DisposeRef>::RefTo>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<CSemiBox<'a, D> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/lib.rs\"))","std::ops::Deref"],"<CSemiBox<'a, D> as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/lib.rs\"))","std::ops::DerefMut"],"<CSemiBox<'a, D> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","std::ops::Drop"],"<CSemiBox<'a, T> as std::cmp::PartialEq<T>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<CSemiBox<'a, T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<CSemiBox<'a, T> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Display"],"<CSemiBox<'a, str> as std::convert::From<&'a std::ffi::CStr>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"CBox::<D>::as_ptr":["as_ptr","Real(LocalPath(\"src/lib.rs\"))",""],"CBox::<D>::as_semi":["as_semi","Real(LocalPath(\"src/lib.rs\"))",""],"CBox::<D>::as_semi_mut":["as_semi_mut","Real(LocalPath(\"src/lib.rs\"))",""],"CBox::<D>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"CBox::<D>::unwrap":["unwrap","Real(LocalPath(\"src/lib.rs\"))",""],"CSemiBox::<'a, D>::as_ptr":["as_ptr","Real(LocalPath(\"src/lib.rs\"))",""],"CSemiBox::<'a, D>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"CSemiBox::<'a, D>::unwrap":["unwrap","Real(LocalPath(\"src/lib.rs\"))",""],"DisposeRef::dispose":["dispose","Real(LocalPath(\"src/lib.rs\"))",""]},"trait_to_struct":{"std::borrow::Borrow":["CBox","CSemiBox"],"std::clone::Clone":["CBox"],"std::cmp::PartialEq":["CBox","CSemiBox"],"std::convert::From":["CBox","CSemiBox"],"std::fmt::Debug":["CBox","CSemiBox"],"std::fmt::Display":["CBox","CSemiBox"],"std::ops::Deref":["CBox","CSemiBox"],"std::ops::DerefMut":["CBox","CSemiBox"],"std::ops::Drop":["CSemiBox"]},"type_to_def_path":{"CBox<D>":"CBox","CSemiBox<'a, D>":"CSemiBox"}}