{"dependencies":{"<Iter<'_, K, V> as core::iter::DoubleEndedIterator>::next_back":["Iter","core::marker::Sized","core::option::Option","core::slice::Iter"],"<Iter<'_, K, V> as core::iter::ExactSizeIterator>::len":["Iter","core::marker::Sized","core::slice::Iter"],"<Iter<'i, K, V> as core::iter::Iterator>::next":["Iter","core::marker::Sized","core::option::Option","core::slice::Iter"],"<IterMut<'_, K, V> as core::iter::DoubleEndedIterator>::next_back":["IterMut","core::marker::Sized","core::option::Option","core::slice::IterMut"],"<IterMut<'_, K, V> as core::iter::ExactSizeIterator>::len":["IterMut","core::marker::Sized","core::slice::IterMut"],"<IterMut<'a, K, V> as core::iter::Iterator>::next":["IterMut","core::marker::Sized","core::option::Option","core::slice::IterMut"],"<Map<K, V> as core::clone::Clone>::clone":["Map","compact::Vec","core::marker::Sized","core::ptr::NonNull"],"<Map<K, V> as core::cmp::PartialEq>::eq":["Map","compact::Vec","core::marker::Sized","core::ptr::NonNull"],"<Map<K, V> as core::fmt::Debug>::fmt":["Map","compact::Vec","core::fmt::Formatter","core::marker::Sized","core::ptr::NonNull","core::result::Result"],"<Map<K, V> as core::iter::FromIterator<(IK, IV)>>::from_iter":["Map","compact::Vec","core::iter::IntoIterator","core::marker::Sized","core::ptr::NonNull"],"<Map<K, V> as core::ops::Index<&Q>>::index":["Map","compact::Vec","core::marker::Sized","core::ptr::NonNull"],"<Node<K, V> as core::clone::Clone>::clone":["Node","core::cell::Cell","core::marker::Sized"],"<Node<K, V> as core::cmp::PartialEq>::eq":["Node","core::cell::Cell","core::marker::Sized"],"<Node<K, V> as core::fmt::Debug>::fmt":["Node","core::cell::Cell","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<compact::Vec<T> as core::clone::Clone>::clone":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"<compact::Vec<T> as core::cmp::PartialEq>::eq":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"<compact::Vec<T> as core::convert::From<alloc::vec::Vec<T>>>::from":["alloc::vec::Vec","compact::Vec","core::alloc::Allocator","core::marker::Sized","core::ptr::NonNull"],"<compact::Vec<T> as core::fmt::Debug>::fmt":["compact::Vec","core::fmt::Formatter","core::marker::Sized","core::ptr::NonNull","core::result::Result"],"<compact::Vec<T> as core::iter::FromIterator<T>>::from_iter":["compact::Vec","core::iter::IntoIterator","core::marker::Sized","core::ptr::NonNull"],"<compact::Vec<T> as core::iter::IntoIterator>::into_iter":["alloc::vec::IntoIter","compact::Vec","core::alloc::Allocator","core::marker::Sized","core::ptr::NonNull"],"<compact::Vec<T> as core::ops::Deref>::deref":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"<compact::Vec<T> as core::ops::DerefMut>::deref_mut":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"<compact::Vec<T> as core::ops::Drop>::drop":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"FindResult":["FindResult","core::marker::Sized","core::option::Option"],"Iter":["Iter","core::marker::Sized","core::slice::Iter"],"Iter::<'_, K, V>::empty":["Iter","core::marker::Sized","core::slice::Iter"],"IterMut":["IterMut","core::marker::Sized","core::slice::IterMut"],"IterMut::<'_, K, V>::empty":["IterMut","core::marker::Sized","core::slice::IterMut"],"Map":["Map","compact::Vec","core::marker::Sized","core::ptr::NonNull"],"Map::<K, V>::clear":["Map","compact::Vec","core::marker::Sized","core::ptr::NonNull"],"Map::<K, V>::contains_key":["Map","compact::Vec","core::borrow::Borrow","core::cmp::Eq","core::hash::Hash","core::marker::Sized","core::ptr::NonNull"],"Map::<K, V>::find":["FindResult","Map","compact::Vec","core::borrow::Borrow","core::cmp::Eq","core::marker::Sized","core::option::Option","core::ptr::NonNull"],"Map::<K, V>::get":["Map","compact::Vec","core::borrow::Borrow","core::cmp::Eq","core::hash::Hash","core::marker::Sized","core::option::Option","core::ptr::NonNull"],"Map::<K, V>::get_mut":["Map","compact::Vec","core::borrow::Borrow","core::cmp::Eq","core::hash::Hash","core::marker::Sized","core::option::Option","core::ptr::NonNull"],"Map::<K, V>::get_or_insert":["Map","compact::Vec","core::marker::Sized","core::ops::FnOnce","core::ptr::NonNull"],"Map::<K, V>::insert":["Map","compact::Vec","core::marker::Sized","core::option::Option","core::ptr::NonNull"],"Map::<K, V>::is_empty":["Map","compact::Vec","core::marker::Sized","core::ptr::NonNull"],"Map::<K, V>::iter":["Iter","Map","compact::Vec","core::marker::Sized","core::ptr::NonNull","core::slice::Iter"],"Map::<K, V>::iter_mut":["IterMut","Map","compact::Vec","core::marker::Sized","core::ptr::NonNull","core::slice::IterMut"],"Map::<K, V>::len":["Map","compact::Vec","core::marker::Sized","core::ptr::NonNull"],"Map::<K, V>::new":["Map","compact::Vec","core::marker::Sized","core::ptr::NonNull"],"Map::<K, V>::remove":["Map","compact::Vec","core::borrow::Borrow","core::cmp::Eq","core::hash::Hash","core::marker::Sized","core::option::Option","core::ptr::NonNull"],"Map::<K, V>::with_capacity":["Map","compact::Vec","core::marker::Sized","core::ptr::NonNull"],"Node":["Node","core::cell::Cell","core::marker::Sized"],"Node::<K, V>::new":["Node","core::cell::Cell","core::marker::Sized"],"compact::<impl core::convert::From<compact::Vec<T>> for alloc::vec::Vec<T>>::from":["alloc::vec::Vec","compact::Vec","core::alloc::Allocator","core::marker::Sized","core::ptr::NonNull"],"compact::Vec":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"compact::Vec::<T>::as_mut_ptr":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"compact::Vec::<T>::as_ptr":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"compact::Vec::<T>::capacity":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"compact::Vec::<T>::clear":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"compact::Vec::<T>::from_stdvec_unchecked":["alloc::vec::Vec","compact::Vec","core::alloc::Allocator","core::marker::Sized","core::ptr::NonNull"],"compact::Vec::<T>::len":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"compact::Vec::<T>::new":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"compact::Vec::<T>::parts":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"compact::Vec::<T>::pop":["compact::Vec","core::marker::Sized","core::option::Option","core::ptr::NonNull"],"compact::Vec::<T>::push":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"compact::Vec::<T>::remove":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"compact::Vec::<T>::set_len":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"compact::Vec::<T>::with":["compact::Vec","core::marker::Sized","core::ops::FnOnce","core::ptr::NonNull"],"compact::Vec::<T>::with_capacity":["compact::Vec","core::marker::Sized","core::ptr::NonNull"],"compact::pack":["core::marker::Sized","core::ptr::NonNull"],"compact::pack_unchecked":["core::marker::Sized","core::ptr::NonNull"],"hash_key":["core::hash::Hash","core::marker::Sized"]},"glob_path_import":{},"self_to_fn":{"Iter":["impl<'i, K, V> Iterator for Iter<'i, K, V> {\n    type Item = (&'i K, &'i V);\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(|node| (&node.key, &node.value))\n    }\n}","impl<K, V> DoubleEndedIterator for Iter<'_, K, V> {\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.inner.next_back().map(|node| (&node.key, &node.value))\n    }\n}","impl<K, V> ExactSizeIterator for Iter<'_, K, V> {\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}","impl<K, V> Iter<'_, K, V> {\n    /// Create an empty iterator that always returns `None`\n    pub fn empty() -> Self {\n        Iter {\n            inner: [].iter()\n        }\n    }\n}"],"IterMut":["impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n    type Item = (&'a K, &'a mut V);\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(|node| (&node.key, &mut node.value))\n    }\n}","impl<K, V> DoubleEndedIterator for IterMut<'_, K, V> {\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.inner.next_back().map(|node| (&node.key, &mut node.value))\n    }\n}","impl<K, V> ExactSizeIterator for IterMut<'_, K, V> {\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}","impl<K, V> IterMut<'_, K, V> {\n    /// Create an empty iterator that always returns `None`\n    pub fn empty() -> Self {\n        IterMut {\n            inner: [].iter_mut()\n        }\n    }\n}"],"Map":["Clone","Debug","impl<'json, IK, IV, K, V> FromIterator<(IK, IV)> for Map<K, V>\nwhere\n    IK: Into<K>,\n    IV: Into<V>,\n    K: Hash + Eq,\n{\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item=(IK, IV)>,\n    {\n        let iter = iter.into_iter();\n        let mut map = Map::with_capacity(iter.size_hint().0);\n\n        for (key, value) in iter {\n            map.insert(key.into(), value.into());\n        }\n\n        map\n    }\n}","impl<K, Q: ?Sized, V> Index<&Q> for Map<K, V>\nwhere\n    K: Eq + Hash + Borrow<Q>,\n    Q: Eq + Hash,\n{\n    type Output = V;\n\n    /// Returns a reference to the value corresponding to the supplied key.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the key is not present in the HashMap.\n    fn index(&self, key: &Q) -> &V {\n        self.get(key).expect(\"Key not found in Map\")\n    }\n}","impl<K, V> Map<K, V>\nwhere\n    K: Hash + Eq,\n{\n    /// Create a new `Map`.\n    #[inline]\n    pub fn new() -> Self {\n        Map {\n            store: Vec::new()\n        }\n    }\n\n    /// Create a `Map` with a given capacity\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Self {\n        Map {\n            store: Vec::with_capacity(capacity)\n        }\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not have this key present, `None` is returned.\n    ///\n    /// If the map did have this key present, the value is updated, and the old\n    /// value is returned. The key is not updated, though; this matters for\n    /// types that can be `==` without being identical.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ordnung::Map;\n    ///\n    /// let mut map = Map::new();\n    /// assert_eq!(map.insert(37, \"a\"), None);\n    /// assert_eq!(map.is_empty(), false);\n    ///\n    /// map.insert(37, \"b\");\n    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n    /// assert_eq!(map[&37], \"c\");\n    /// ```\n    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n        let hash = hash_key(&key);\n\n        match self.find(&key, hash) {\n            Hit(idx) => unsafe {\n                let slot = &mut self.store.get_unchecked_mut(idx).value;\n\n                Some(core::mem::replace(slot, value))\n            },\n            Miss(parent) => {\n                if let Some(parent) = parent {\n                    parent.set(NonZeroU32::new(self.store.len() as u32));\n                }\n\n                self.store.push(Node::new(key, value, hash));\n\n                None\n            },\n        }\n    }\n\n    /// Returns a reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but `Hash` and\n    /// `Eq` on the borrowed form must match those for the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ordnung::Map;\n    ///\n    /// let mut map = Map::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.get(&1), Some(&\"a\"));\n    /// assert_eq!(map.get(&2), None);\n    /// ```\n    pub fn get<Q>(&self, key: &Q) -> Option<&V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        let hash = hash_key(key);\n\n        match self.find(key, hash) {\n            Hit(idx) => Some(unsafe { &self.store.get_unchecked(idx).value }),\n            Miss(_) => None,\n        }\n    }\n\n    /// Returns `true` if the map contains a value for the specified key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but `Hash` and\n    /// `Eq` on the borrowed form must match those for the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ordnung::Map;\n    ///\n    /// let mut map = Map::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.contains_key(&1), true);\n    /// assert_eq!(map.contains_key(&2), false);\n    /// ```\n    pub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        let hash = hash_key(key);\n\n        match self.find(key, hash) {\n            Hit(_) => true,\n            Miss(_) => false,\n        }\n    }\n\n    /// Returns a mutable reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but Hash and Eq\n    /// on the borrowed form must match those for the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ordnung::Map;\n    ///\n    /// let mut map = Map::new();\n    /// map.insert(1, \"a\");\n    /// if let Some(x) = map.get_mut(&1) {\n    ///     *x = \"b\";\n    /// }\n    /// assert_eq!(map[&1], \"b\");\n    /// ```\n    pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        let hash = hash_key(key);\n\n        match self.find(key, hash) {\n            Hit(idx) => Some(unsafe { &mut self.store.get_unchecked_mut(idx).value }),\n            Miss(_) => None,\n        }\n    }\n\n    /// Get a mutable reference to entry at key. Inserts a new entry by\n    /// calling `F` if absent.\n    // TODO: Replace with entry API\n    pub fn get_or_insert<F>(&mut self, key: K, fill: F) -> &mut V\n    where\n        F: FnOnce() -> V,\n    {\n        let key = key.into();\n        let hash = hash_key(&key);\n\n        match self.find(&key, hash) {\n            Hit(idx) => &mut self.store[idx].value,\n            Miss(parent) => {\n                let idx = self.store.len();\n\n                if let Some(parent) = parent {\n                    parent.set(NonZeroU32::new(self.store.len() as u32));\n                }\n\n                self.store.push(Node::new(key, fill(), hash));\n\n                &mut self.store[idx].value\n            },\n        }\n    }\n\n    /// Removes a key from the map, returning the value at the key if the key\n    /// was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but `Hash` and\n    /// `Eq` on the borrowed form must match those for the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ordnung::Map;\n    ///\n    /// let mut map = Map::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.remove(&1), Some(\"a\"));\n    /// assert_eq!(map.remove(&1), None);\n    /// ```\n    pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        let hash = hash_key(key);\n\n        let index = match self.find(key, hash) {\n            Hit(idx) => idx,\n            Miss(_) => return None,\n        };\n\n        // Removing a node would screw the tree badly, it's easier to just\n        // recreate it.\n        let mut removed = None;\n        let capacity = self.store.len();\n        let old = mem::replace(&mut self.store, Vec::with_capacity(capacity));\n\n        for (i, Node { key, value, hash, .. }) in old.into_iter().enumerate() {\n            if i == index {\n                // Rust doesn't like us moving things from `node`, even if\n                // it is owned. Replace fixes that.\n                removed = Some(value);\n            } else {\n                // Faster than .insert() since we can avoid hashing\n                if let Miss(Some(parent)) = self.find(key.borrow(), hash) {\n                    parent.set(NonZeroU32::new(self.store.len() as u32));\n                }\n\n                self.store.push(Node::new(key, value, hash));\n            }\n        }\n\n        removed\n    }\n\n    /// Returns the number of elements in the map.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.store.len()\n    }\n\n    /// Returns `true` if the map contains no elements.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.store.is_empty()\n    }\n\n    /// Clears the map, removing all key-value pairs. Keeps the allocated memory for reuse.\n    #[inline]\n    pub fn clear(&mut self) {\n        self.store.clear();\n    }\n\n    #[inline]\n    fn find<Q: ?Sized>(&self, key: &Q, hash: u64) -> FindResult\n    where\n        K: Borrow<Q>,\n        Q: Eq,\n    {\n        if self.len() == 0 {\n            return Miss(None);\n        }\n\n        let mut idx = 0;\n\n        loop {\n            let node = unsafe { self.store.get_unchecked(idx) };\n\n            if hash == node.hash && key == node.key.borrow() {\n                return Hit(idx);\n            } else if hash < node.hash {\n                match node.left.get() {\n                    Some(i) => idx = i.get() as usize,\n                    None => return Miss(Some(&node.left)),\n                }\n            } else {\n                match node.right.get() {\n                    Some(i) => idx = i.get() as usize,\n                    None => return Miss(Some(&node.right)),\n                }\n            }\n        }\n    }\n\n    /// An iterator visiting all key-value pairs in insertion order.\n    /// The iterator element type is `(&K, &V)`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ordnung::Map;\n    ///\n    /// let mut map = Map::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// let entries: Vec<_> = map.iter().collect();\n    ///\n    /// assert_eq!(\n    ///     entries,\n    ///     &[\n    ///         (&\"a\", &1),\n    ///         (&\"b\", &2),\n    ///         (&\"c\", &3),\n    ///     ],\n    /// );\n    /// ```\n    #[inline]\n    pub fn iter(&self) -> Iter<K, V> {\n        Iter {\n            inner: self.store.iter()\n        }\n    }\n\n    /// An iterator visiting all key-value pairs in insertion order, with\n    /// mutable references to the values. The iterator element type is\n    /// (&K, &mut V).\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ordnung::Map;\n    ///\n    /// let mut map = Map::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// // Update all values\n    /// for (_, val) in map.iter_mut() {\n    ///     *val *= 2;\n    /// }\n    ///\n    /// // Check if values are doubled\n    /// let entries: Vec<_> = map.iter().collect();\n    ///\n    /// assert_eq!(\n    ///     entries,\n    ///     &[\n    ///         (&\"a\", &2),\n    ///         (&\"b\", &4),\n    ///         (&\"c\", &6),\n    ///     ],\n    /// );\n    /// ```\n    #[inline]\n    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n        IterMut {\n            inner: self.store.iter_mut()\n        }\n    }\n}","impl<K, V> PartialEq for Map<K, V>\nwhere\n    K: Hash + Eq,\n    V: PartialEq,\n{\n    fn eq(&self, other: &Self) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        // Faster than .get() since we can avoid hashing\n        for &Node { ref key, ref value, hash, .. } in self.store.iter() {\n            if let Hit(idx) = other.find(key, hash) {\n                if &other.store[idx].value == value {\n                    continue;\n                }\n            }\n\n            return false;\n        }\n\n        true\n    }\n}"],"Node":["Clone","impl<K, V> Node<K, V> {\n    #[inline]\n    const fn new(key: K, value: V, hash: u64) -> Self {\n        Node {\n            key,\n            hash,\n            value,\n            left: Cell::new(None),\n            right: Cell::new(None),\n        }\n    }\n}","impl<K, V> PartialEq for Node<K, V>\nwhere\n    K: PartialEq,\n    V: PartialEq,\n{\n    fn eq(&self, other: &Self) -> bool {\n        self.hash == other.hash &&\n        self.key == other.key &&\n        self.value == other.value\n    }\n}","impl<K, V> fmt::Debug for Node<K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&(&self.key, &self.value, self.left.get(), self.right.get()), f)\n    }\n}","unsafe impl<K: Sync, V: Sync> Sync for Node<K, V> {}"],"alloc::vec::Vec":["impl<T> From<Vec<T>> for StdVec<T> {\n    fn from(vec: Vec<T>) -> Self {\n        let mut vec = ManuallyDrop::new(vec);\n        let ptr = vec.as_mut_ptr();\n        let (len, cap) = vec.parts();\n\n        unsafe {\n            StdVec::from_raw_parts(ptr, len, cap)\n        }\n    }\n}"],"compact::Vec":["impl<T: Clone> Clone for Vec<T> {\n    fn clone(&self) -> Vec<T> {\n        Vec::from_stdvec_unchecked((&**self).to_vec())\n    }\n}","impl<T: PartialEq> PartialEq for Vec<T> {\n    fn eq(&self, other: &Vec<T>) -> bool {\n        self.deref() == other.deref()\n    }\n}","impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        (**self).fmt(f)\n    }\n}","impl<T> Deref for Vec<T> {\n    type Target = [T];\n\n    #[inline]\n    fn deref(&self) -> &[T] {\n        let (len, _) = self.parts();\n\n        unsafe {\n            &*slice_from_raw_parts(self.as_ptr() as *mut T, len)\n        }\n    }\n}","impl<T> DerefMut for Vec<T> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut [T] {\n        let (len, _) = self.parts();\n\n        unsafe {\n            &mut *slice_from_raw_parts_mut(self.as_mut_ptr() as *mut T, len)\n        }\n    }\n}","impl<T> From<StdVec<T>> for Vec<T> {\n    fn from(stdvec: StdVec<T>) -> Self {\n        let mut stdvec = ManuallyDrop::new(stdvec);\n\n        let ptr = stdvec.as_mut_ptr();\n        let len = stdvec.len();\n        let cap = stdvec.capacity();\n\n        Vec {\n            ptr: unsafe { pack(ptr, len, cap) },\n        }\n    }\n}","impl<T> FromIterator<T> for Vec<T> {\n    fn from_iter<I>(iter: I) -> Vec<T>\n    where\n        I: IntoIterator<Item = T>,\n    {\n        Self::from(StdVec::from_iter(iter))\n    }\n}","impl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    fn into_iter(self) -> IntoIter<T> {\n        StdVec::from(self).into_iter()\n    }\n}","impl<T> Vec<T> {\n    /// Constructs a new, empty Vec<T>.\n    ///\n    /// The vector will not allocate until elements are pushed onto it.\n    pub fn new() -> Self {\n        Self::from_stdvec_unchecked(StdVec::new())\n    }\n\n    /// Constructs a new, empty Vec<T> with the specified capacity.\n    ///\n    /// The vector will be able to hold exactly capacity elements without reallocating. If capacity is 0, the vector will not allocate.\n    pub fn with_capacity(capacity: usize) -> Self {\n        Self::from_stdvec_unchecked(StdVec::with_capacity(capacity))\n    }\n\n    /// Appends an element to the back of a collection.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the number of elements in the vector overflows a `u32`.\n    pub fn push(&mut self, val: T) {\n        let ptr = self.as_mut_ptr();\n        let (len, cap) = self.parts();\n\n        if len == cap {\n            let new_cap = match cap {\n                0 => 1,\n                n => n * 2,\n            };\n\n            if new_cap > MASK_LO {\n                panic!(\"compact Vec capacity out of bounds\");\n            }\n\n            // Create a new bigger buffer\n            let mut stdvec = ManuallyDrop::new(StdVec::with_capacity(new_cap));\n\n            unsafe {\n                // Copy contents\n                core::ptr::copy_nonoverlapping(ptr, stdvec.as_mut_ptr(), len);\n\n                // Drop old buffer, len 0 (we don't want to drop content)\n                core::mem::drop(StdVec::from_raw_parts(ptr, 0, cap));\n            }\n\n            self.ptr = unsafe { pack_unchecked(stdvec.as_mut_ptr(), len, stdvec.capacity()) }\n        }\n        unsafe { self.as_mut_ptr().add(len).write(val) }\n        self.set_len(len + 1);\n    }\n\n    /// Removes the last element from a vector and returns it, or `None` if it is empty.\n    pub fn pop(&mut self) -> Option<T> {\n        let len = self.len().checked_sub(1)?;\n\n        self.set_len(len);\n\n        Some(unsafe {\n            self.as_mut_ptr().add(len).read()\n        })\n    }\n\n    /// Clears the vector, removing all values.\n    ///\n    /// Note that this method has no effect on the allocated capacity of the vector.\n    pub fn clear(&mut self) {\n        self.with(move |v| v.clear())\n    }\n\n    /// Returns the number of elements in the vector.\n    pub fn len(&self) -> usize {\n        let (len, _) = self.parts();\n\n        len\n    }\n\n    /// Returns the number of elements the vector can hold without reallocating.\n    pub fn capacity(&self) -> usize {\n        let (_, cap) = self.parts();\n\n        cap\n    }\n\n    /// Removes and returns the element at position `index` within the vector,\n    /// shifting all elements after it to the left.\n    pub fn remove(&mut self, index: usize) -> T {\n        self.with(move |v| v.remove(index))\n    }\n\n    /// Returns a raw pointer to the vector's buffer.\n    #[inline]\n    pub const fn as_ptr(&self) -> *const T {\n        self.ptr.cast().as_ptr()\n    }\n\n    /// Returns an unsafe mutable pointer to the vector's buffer.\n    #[inline]\n    pub fn as_mut_ptr(&mut self) -> *mut T {\n        self.ptr.cast().as_ptr()\n    }\n\n    fn set_len(&mut self, len: usize) {\n        let (_, cap) = self.parts();\n\n        self.ptr = unsafe {\n            pack_unchecked(\n                self.as_mut_ptr(),\n                len,\n                cap,\n            )\n        };\n    }\n\n    #[inline]\n    fn parts(&self) -> (usize, usize) {\n        let parts = unsafe { &*(self.ptr.as_ptr() as *const [()]) }.len();\n\n        (parts & MASK_LO, (parts & MASK_HI) >> 32)\n    }\n\n    fn with<'a, R: 'a, F: FnOnce(&mut StdVec<T>) -> R>(&mut self, f: F) -> R {\n        let (len, cap) = self.parts();\n\n        let mut stdvec = unsafe {\n            StdVec::from_raw_parts(self.as_mut_ptr(), len, cap)\n        };\n\n        let r = f(&mut stdvec);\n\n        ManuallyDrop::new(core::mem::replace(self, Self::from_stdvec_unchecked(stdvec)));\n\n        r\n    }\n\n    fn from_stdvec_unchecked(stdvec: StdVec<T>) -> Self {\n        let mut stdvec = ManuallyDrop::new(stdvec);\n\n        let ptr = stdvec.as_mut_ptr();\n        let len = stdvec.len();\n        let cap = stdvec.capacity();\n\n        let ptr = slice_from_raw_parts_mut(\n            ptr,\n            len & MASK_LO | (cap & MASK_LO) << 32,\n        );\n\n        Vec {\n            ptr: unsafe { NonNull::new_unchecked(ptr) },\n        }\n    }\n}","impl<T> core::ops::Drop for Vec<T> {\n    fn drop(&mut self) {\n        let (len, cap) = self.parts();\n\n        unsafe {\n            StdVec::from_raw_parts(self.as_mut_ptr(), len, cap);\n        }\n    }\n}","unsafe impl<T: Send> Send for Vec<T> {}","unsafe impl<T: Sync> Sync for Vec<T> {}"]},"single_path_import":{"compact::Vec":"Vec"},"srcs":{"<Iter<'_, K, V> as core::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n        self.inner.next_back().map(|node| (&node.key, &node.value))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Iter<'_, K, V> as core::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        self.inner.len()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Iter<'i, K, V> as core::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        self.inner.next().map(|node| (&node.key, &node.value))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IterMut<'_, K, V> as core::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n        self.inner.next_back().map(|node| (&node.key, &mut node.value))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IterMut<'_, K, V> as core::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        self.inner.len()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IterMut<'a, K, V> as core::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        self.inner.next().map(|node| (&node.key, &mut node.value))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Map<K, V> as core::cmp::PartialEq>::eq":["fn eq(&self, other: &Self) -> bool{\n        if self.len() != other.len() {\n            return false;\n        }\n\n        // Faster than .get() since we can avoid hashing\n        for &Node { ref key, ref value, hash, .. } in self.store.iter() {\n            if let Hit(idx) = other.find(key, hash) {\n                if &other.store[idx].value == value {\n                    continue;\n                }\n            }\n\n            return false;\n        }\n\n        true\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Map<K, V> as core::iter::FromIterator<(IK, IV)>>::from_iter":["fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item=(IK, IV)>,{\n        let iter = iter.into_iter();\n        let mut map = Map::with_capacity(iter.size_hint().0);\n\n        for (key, value) in iter {\n            map.insert(key.into(), value.into());\n        }\n\n        map\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Map<K, V> as core::ops::Index<&Q>>::index":["/// Returns a reference to the value corresponding to the supplied key.\n///\n/// # Panics\n///\n/// Panics if the key is not present in the HashMap.\nfn index(&self, key: &Q) -> &V{\n        self.get(key).expect(\"Key not found in Map\")\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Node<K, V> as core::cmp::PartialEq>::eq":["fn eq(&self, other: &Self) -> bool{\n        self.hash == other.hash &&\n        self.key == other.key &&\n        self.value == other.value\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Node<K, V> as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Debug::fmt(&(&self.key, &self.value, self.left.get(), self.right.get()), f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<compact::Vec<T> as core::clone::Clone>::clone":["fn clone(&self) -> Vec<T>{\n        Vec::from_stdvec_unchecked((&**self).to_vec())\n    }","Real(LocalPath(\"src/compact.rs\"))"],"<compact::Vec<T> as core::cmp::PartialEq>::eq":["fn eq(&self, other: &Vec<T>) -> bool{\n        self.deref() == other.deref()\n    }","Real(LocalPath(\"src/compact.rs\"))"],"<compact::Vec<T> as core::convert::From<alloc::vec::Vec<T>>>::from":["fn from(stdvec: StdVec<T>) -> Self{\n        let mut stdvec = ManuallyDrop::new(stdvec);\n\n        let ptr = stdvec.as_mut_ptr();\n        let len = stdvec.len();\n        let cap = stdvec.capacity();\n\n        Vec {\n            ptr: unsafe { pack(ptr, len, cap) },\n        }\n    }","Real(LocalPath(\"src/compact.rs\"))"],"<compact::Vec<T> as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        (**self).fmt(f)\n    }","Real(LocalPath(\"src/compact.rs\"))"],"<compact::Vec<T> as core::iter::FromIterator<T>>::from_iter":["fn from_iter<I>(iter: I) -> Vec<T>\n    where\n        I: IntoIterator<Item = T>,{\n        Self::from(StdVec::from_iter(iter))\n    }","Real(LocalPath(\"src/compact.rs\"))"],"<compact::Vec<T> as core::iter::IntoIterator>::into_iter":["fn into_iter(self) -> IntoIter<T>{\n        StdVec::from(self).into_iter()\n    }","Real(LocalPath(\"src/compact.rs\"))"],"<compact::Vec<T> as core::ops::Deref>::deref":["#[inline]\nfn deref(&self) -> &[T]{\n        let (len, _) = self.parts();\n\n        unsafe {\n            &*slice_from_raw_parts(self.as_ptr() as *mut T, len)\n        }\n    }","Real(LocalPath(\"src/compact.rs\"))"],"<compact::Vec<T> as core::ops::DerefMut>::deref_mut":["#[inline]\nfn deref_mut(&mut self) -> &mut [T]{\n        let (len, _) = self.parts();\n\n        unsafe {\n            &mut *slice_from_raw_parts_mut(self.as_mut_ptr() as *mut T, len)\n        }\n    }","Real(LocalPath(\"src/compact.rs\"))"],"<compact::Vec<T> as core::ops::Drop>::drop":["fn drop(&mut self){\n        let (len, cap) = self.parts();\n\n        unsafe {\n            StdVec::from_raw_parts(self.as_mut_ptr(), len, cap);\n        }\n    }","Real(LocalPath(\"src/compact.rs\"))"],"FindResult":["enum FindResult<'find> {\n    Hit(usize),\n    Miss(Option<&'find Cell<Option<NonZeroU32>>>),\n}","Real(LocalPath(\"src/lib.rs\"))"],"Iter":["/// An iterator over the entries of a `Map`.\n///\n/// This struct is created by the [`iter`](./struct.Map.html#method.iter)\n/// method on [`Map`](./struct.Map.html). See its documentation for more.\npub struct Iter<'a, K, V> {\n    inner: slice::Iter<'a, Node<K, V>>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Iter::<'_, K, V>::empty":["/// Create an empty iterator that always returns `None`\npub fn empty() -> Self{\n        Iter {\n            inner: [].iter()\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"IterMut":["/// A mutable iterator over the entries of a `Map`.\n///\n/// This struct is created by the [`iter_mut`](./struct.Map.html#method.iter_mut)\n/// method on [`Map`](./struct.Map.html). See its documentation for more.\npub struct IterMut<'a, K, V> {\n    inner: slice::IterMut<'a, Node<K, V>>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"IterMut::<'_, K, V>::empty":["/// Create an empty iterator that always returns `None`\npub fn empty() -> Self{\n        IterMut {\n            inner: [].iter_mut()\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map":["/// A binary tree implementation of a string -> `JsonValue` map. You normally don't\n/// have to interact with instances of `Object`, much more likely you will be\n/// using the `JsonValue::Object` variant, which wraps around this struct.\npub struct Map<K, V> {\n    store: Vec<Node<K, V>>\n}","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::clear":["/// Clears the map, removing all key-value pairs. Keeps the allocated memory for reuse.\n#[inline]\npub fn clear(&mut self){\n        self.store.clear();\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::contains_key":["/// Returns `true` if the map contains a value for the specified key.\n///\n/// The key may be any borrowed form of the map's key type, but `Hash` and\n/// `Eq` on the borrowed form must match those for the key type.\n///\n/// # Examples\n///\n/// ```rust\n/// use ordnung::Map;\n///\n/// let mut map = Map::new();\n/// map.insert(1, \"a\");\n/// assert_eq!(map.contains_key(&1), true);\n/// assert_eq!(map.contains_key(&2), false);\n/// ```\npub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        let hash = hash_key(key);\n\n        match self.find(key, hash) {\n            Hit(_) => true,\n            Miss(_) => false,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::find":["#[inline]\nfn find<Q: ?Sized>(&self, key: &Q, hash: u64) -> FindResult\n    where\n        K: Borrow<Q>,\n        Q: Eq,{\n        if self.len() == 0 {\n            return Miss(None);\n        }\n\n        let mut idx = 0;\n\n        loop {\n            let node = unsafe { self.store.get_unchecked(idx) };\n\n            if hash == node.hash && key == node.key.borrow() {\n                return Hit(idx);\n            } else if hash < node.hash {\n                match node.left.get() {\n                    Some(i) => idx = i.get() as usize,\n                    None => return Miss(Some(&node.left)),\n                }\n            } else {\n                match node.right.get() {\n                    Some(i) => idx = i.get() as usize,\n                    None => return Miss(Some(&node.right)),\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::get":["/// Returns a reference to the value corresponding to the key.\n///\n/// The key may be any borrowed form of the map's key type, but `Hash` and\n/// `Eq` on the borrowed form must match those for the key type.\n///\n/// # Examples\n///\n/// ```rust\n/// use ordnung::Map;\n///\n/// let mut map = Map::new();\n/// map.insert(1, \"a\");\n/// assert_eq!(map.get(&1), Some(&\"a\"));\n/// assert_eq!(map.get(&2), None);\n/// ```\npub fn get<Q>(&self, key: &Q) -> Option<&V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        let hash = hash_key(key);\n\n        match self.find(key, hash) {\n            Hit(idx) => Some(unsafe { &self.store.get_unchecked(idx).value }),\n            Miss(_) => None,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::get_mut":["/// Returns a mutable reference to the value corresponding to the key.\n///\n/// The key may be any borrowed form of the map's key type, but Hash and Eq\n/// on the borrowed form must match those for the key type.\n///\n/// # Examples\n///\n/// ```rust\n/// use ordnung::Map;\n///\n/// let mut map = Map::new();\n/// map.insert(1, \"a\");\n/// if let Some(x) = map.get_mut(&1) {\n///     *x = \"b\";\n/// }\n/// assert_eq!(map[&1], \"b\");\n/// ```\npub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        let hash = hash_key(key);\n\n        match self.find(key, hash) {\n            Hit(idx) => Some(unsafe { &mut self.store.get_unchecked_mut(idx).value }),\n            Miss(_) => None,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::get_or_insert":["/// Get a mutable reference to entry at key. Inserts a new entry by\n/// calling `F` if absent.\npub fn get_or_insert<F>(&mut self, key: K, fill: F) -> &mut V\n    where\n        F: FnOnce() -> V,{\n        let key = key.into();\n        let hash = hash_key(&key);\n\n        match self.find(&key, hash) {\n            Hit(idx) => &mut self.store[idx].value,\n            Miss(parent) => {\n                let idx = self.store.len();\n\n                if let Some(parent) = parent {\n                    parent.set(NonZeroU32::new(self.store.len() as u32));\n                }\n\n                self.store.push(Node::new(key, fill(), hash));\n\n                &mut self.store[idx].value\n            },\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::insert":["/// Inserts a key-value pair into the map.\n///\n/// If the map did not have this key present, `None` is returned.\n///\n/// If the map did have this key present, the value is updated, and the old\n/// value is returned. The key is not updated, though; this matters for\n/// types that can be `==` without being identical.\n///\n/// # Examples\n///\n/// ```rust\n/// use ordnung::Map;\n///\n/// let mut map = Map::new();\n/// assert_eq!(map.insert(37, \"a\"), None);\n/// assert_eq!(map.is_empty(), false);\n///\n/// map.insert(37, \"b\");\n/// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n/// assert_eq!(map[&37], \"c\");\n/// ```\npub fn insert(&mut self, key: K, value: V) -> Option<V>{\n        let hash = hash_key(&key);\n\n        match self.find(&key, hash) {\n            Hit(idx) => unsafe {\n                let slot = &mut self.store.get_unchecked_mut(idx).value;\n\n                Some(core::mem::replace(slot, value))\n            },\n            Miss(parent) => {\n                if let Some(parent) = parent {\n                    parent.set(NonZeroU32::new(self.store.len() as u32));\n                }\n\n                self.store.push(Node::new(key, value, hash));\n\n                None\n            },\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::is_empty":["/// Returns `true` if the map contains no elements.\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.store.is_empty()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::iter":["/// An iterator visiting all key-value pairs in insertion order.\n/// The iterator element type is `(&K, &V)`.\n///\n/// # Examples\n///\n/// ```rust\n/// use ordnung::Map;\n///\n/// let mut map = Map::new();\n/// map.insert(\"a\", 1);\n/// map.insert(\"b\", 2);\n/// map.insert(\"c\", 3);\n///\n/// let entries: Vec<_> = map.iter().collect();\n///\n/// assert_eq!(\n///     entries,\n///     &[\n///         (&\"a\", &1),\n///         (&\"b\", &2),\n///         (&\"c\", &3),\n///     ],\n/// );\n/// ```\n#[inline]\npub fn iter(&self) -> Iter<K, V>{\n        Iter {\n            inner: self.store.iter()\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::iter_mut":["/// An iterator visiting all key-value pairs in insertion order, with\n/// mutable references to the values. The iterator element type is\n/// (&K, &mut V).\n///\n/// # Examples\n///\n/// ```rust\n/// use ordnung::Map;\n///\n/// let mut map = Map::new();\n/// map.insert(\"a\", 1);\n/// map.insert(\"b\", 2);\n/// map.insert(\"c\", 3);\n///\n/// // Update all values\n/// for (_, val) in map.iter_mut() {\n///     *val *= 2;\n/// }\n///\n/// // Check if values are doubled\n/// let entries: Vec<_> = map.iter().collect();\n///\n/// assert_eq!(\n///     entries,\n///     &[\n///         (&\"a\", &2),\n///         (&\"b\", &4),\n///         (&\"c\", &6),\n///     ],\n/// );\n/// ```\n#[inline]\npub fn iter_mut(&mut self) -> IterMut<K, V>{\n        IterMut {\n            inner: self.store.iter_mut()\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::len":["/// Returns the number of elements in the map.\n#[inline]\npub fn len(&self) -> usize{\n        self.store.len()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::new":["/// Create a new `Map`.\n#[inline]\npub fn new() -> Self{\n        Map {\n            store: Vec::new()\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::remove":["/// Removes a key from the map, returning the value at the key if the key\n/// was previously in the map.\n///\n/// The key may be any borrowed form of the map's key type, but `Hash` and\n/// `Eq` on the borrowed form must match those for the key type.\n///\n/// # Examples\n///\n/// ```rust\n/// use ordnung::Map;\n///\n/// let mut map = Map::new();\n/// map.insert(1, \"a\");\n/// assert_eq!(map.remove(&1), Some(\"a\"));\n/// assert_eq!(map.remove(&1), None);\n/// ```\npub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        let hash = hash_key(key);\n\n        let index = match self.find(key, hash) {\n            Hit(idx) => idx,\n            Miss(_) => return None,\n        };\n\n        // Removing a node would screw the tree badly, it's easier to just\n        // recreate it.\n        let mut removed = None;\n        let capacity = self.store.len();\n        let old = mem::replace(&mut self.store, Vec::with_capacity(capacity));\n\n        for (i, Node { key, value, hash, .. }) in old.into_iter().enumerate() {\n            if i == index {\n                // Rust doesn't like us moving things from `node`, even if\n                // it is owned. Replace fixes that.\n                removed = Some(value);\n            } else {\n                // Faster than .insert() since we can avoid hashing\n                if let Miss(Some(parent)) = self.find(key.borrow(), hash) {\n                    parent.set(NonZeroU32::new(self.store.len() as u32));\n                }\n\n                self.store.push(Node::new(key, value, hash));\n            }\n        }\n\n        removed\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Map::<K, V>::with_capacity":["/// Create a `Map` with a given capacity\n#[inline]\npub fn with_capacity(capacity: usize) -> Self{\n        Map {\n            store: Vec::with_capacity(capacity)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Node":["struct Node<K, V> {\n    // Key\n    pub key: K,\n\n    // Hash of the key\n    pub hash: u64,\n\n    // Value stored.\n    pub value: V,\n\n    // Store vector index pointing to the `Node` for which `hash` is smaller\n    // than that of this `Node`.\n    pub left: Cell<Option<NonZeroU32>>,\n\n    // Same as above but for `Node`s with hash larger than this one. If the\n    // hash is the same, but keys are different, the lookup will default\n    // to the right branch as well.\n    pub right: Cell<Option<NonZeroU32>>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Node::<K, V>::new":["#[inline]\nconst fn new(key: K, value: V, hash: u64) -> Self{\n        Node {\n            key,\n            hash,\n            value,\n            left: Cell::new(None),\n            right: Cell::new(None),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"compact::<impl core::convert::From<compact::Vec<T>> for alloc::vec::Vec<T>>::from":["fn from(vec: Vec<T>) -> Self{\n        let mut vec = ManuallyDrop::new(vec);\n        let ptr = vec.as_mut_ptr();\n        let (len, cap) = vec.parts();\n\n        unsafe {\n            StdVec::from_raw_parts(ptr, len, cap)\n        }\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec":["/// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\npub struct Vec<T> {\n    ptr: NonNull<[T]>,\n}","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::as_mut_ptr":["/// Returns an unsafe mutable pointer to the vector's buffer.\n#[inline]\npub fn as_mut_ptr(&mut self) -> *mut T{\n        self.ptr.cast().as_ptr()\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::as_ptr":["/// Returns a raw pointer to the vector's buffer.\n#[inline]\npub const fn as_ptr(&self) -> *const T{\n        self.ptr.cast().as_ptr()\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::capacity":["/// Returns the number of elements the vector can hold without reallocating.\npub fn capacity(&self) -> usize{\n        let (_, cap) = self.parts();\n\n        cap\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::clear":["/// Clears the vector, removing all values.\n///\n/// Note that this method has no effect on the allocated capacity of the vector.\npub fn clear(&mut self){\n        self.with(move |v| v.clear())\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::from_stdvec_unchecked":["fn from_stdvec_unchecked(stdvec: StdVec<T>) -> Self{\n        let mut stdvec = ManuallyDrop::new(stdvec);\n\n        let ptr = stdvec.as_mut_ptr();\n        let len = stdvec.len();\n        let cap = stdvec.capacity();\n\n        let ptr = slice_from_raw_parts_mut(\n            ptr,\n            len & MASK_LO | (cap & MASK_LO) << 32,\n        );\n\n        Vec {\n            ptr: unsafe { NonNull::new_unchecked(ptr) },\n        }\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::len":["/// Returns the number of elements in the vector.\npub fn len(&self) -> usize{\n        let (len, _) = self.parts();\n\n        len\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::new":["/// Constructs a new, empty Vec<T>.\n///\n/// The vector will not allocate until elements are pushed onto it.\npub fn new() -> Self{\n        Self::from_stdvec_unchecked(StdVec::new())\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::parts":["#[inline]\nfn parts(&self) -> (usize, usize){\n        let parts = unsafe { &*(self.ptr.as_ptr() as *const [()]) }.len();\n\n        (parts & MASK_LO, (parts & MASK_HI) >> 32)\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::pop":["/// Removes the last element from a vector and returns it, or `None` if it is empty.\npub fn pop(&mut self) -> Option<T>{\n        let len = self.len().checked_sub(1)?;\n\n        self.set_len(len);\n\n        Some(unsafe {\n            self.as_mut_ptr().add(len).read()\n        })\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::push":["/// Appends an element to the back of a collection.\n///\n/// # Panics\n///\n/// Panics if the number of elements in the vector overflows a `u32`.\npub fn push(&mut self, val: T){\n        let ptr = self.as_mut_ptr();\n        let (len, cap) = self.parts();\n\n        if len == cap {\n            let new_cap = match cap {\n                0 => 1,\n                n => n * 2,\n            };\n\n            if new_cap > MASK_LO {\n                panic!(\"compact Vec capacity out of bounds\");\n            }\n\n            // Create a new bigger buffer\n            let mut stdvec = ManuallyDrop::new(StdVec::with_capacity(new_cap));\n\n            unsafe {\n                // Copy contents\n                core::ptr::copy_nonoverlapping(ptr, stdvec.as_mut_ptr(), len);\n\n                // Drop old buffer, len 0 (we don't want to drop content)\n                core::mem::drop(StdVec::from_raw_parts(ptr, 0, cap));\n            }\n\n            self.ptr = unsafe { pack_unchecked(stdvec.as_mut_ptr(), len, stdvec.capacity()) }\n        }\n        unsafe { self.as_mut_ptr().add(len).write(val) }\n        self.set_len(len + 1);\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::remove":["/// Removes and returns the element at position `index` within the vector,\n/// shifting all elements after it to the left.\npub fn remove(&mut self, index: usize) -> T{\n        self.with(move |v| v.remove(index))\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::set_len":["fn set_len(&mut self, len: usize){\n        let (_, cap) = self.parts();\n\n        self.ptr = unsafe {\n            pack_unchecked(\n                self.as_mut_ptr(),\n                len,\n                cap,\n            )\n        };\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::with":["fn with<'a, R: 'a, F: FnOnce(&mut StdVec<T>) -> R>(&mut self, f: F) -> R{\n        let (len, cap) = self.parts();\n\n        let mut stdvec = unsafe {\n            StdVec::from_raw_parts(self.as_mut_ptr(), len, cap)\n        };\n\n        let r = f(&mut stdvec);\n\n        ManuallyDrop::new(core::mem::replace(self, Self::from_stdvec_unchecked(stdvec)));\n\n        r\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::Vec::<T>::with_capacity":["/// Constructs a new, empty Vec<T> with the specified capacity.\n///\n/// The vector will be able to hold exactly capacity elements without reallocating. If capacity is 0, the vector will not allocate.\npub fn with_capacity(capacity: usize) -> Self{\n        Self::from_stdvec_unchecked(StdVec::with_capacity(capacity))\n    }","Real(LocalPath(\"src/compact.rs\"))"],"compact::pack":["#[inline]\nunsafe fn pack<T>(ptr: *mut T, len: usize, capacity: usize) -> NonNull<[T]>{\n    if (capacity & MASK_HI) != 0 {\n        panic!(\"compact Vec capacity out of bounds\");\n    }\n\n    pack_unchecked(ptr, len, capacity)\n}","Real(LocalPath(\"src/compact.rs\"))"],"compact::pack_unchecked":["#[inline]\nunsafe fn pack_unchecked<T>(ptr: *mut T, len: usize, capacity: usize) -> NonNull<[T]>{\n    NonNull::new_unchecked(\n        slice_from_raw_parts_mut(\n            ptr as *mut T,\n            (len & MASK_LO) | ((capacity & MASK_LO) << 32)\n        )\n    )\n}","Real(LocalPath(\"src/compact.rs\"))"],"hash_key":["#[inline]\nfn hash_key<H: Hash>(hash: H) -> u64{\n    // let mut hasher = fnv::FnvHasher::default();\n    // let mut hasher = rustc_hash::FxHasher::default();\n    let mut hasher = ahash::AHasher::default();\n\n    hash.hash(&mut hasher);\n\n    hasher.finish()\n}","Real(LocalPath(\"src/lib.rs\"))"]},"struct_constructor":{"&[T]":["deref"],"&mut [T]":["deref_mut"],"(usize, usize)":["parts"],"FindResult":["find"],"Iter":["empty","iter"],"IterMut":["empty","iter_mut"],"Map":["clone","from_iter","new","with_capacity"],"Node":["clone","new"],"alloc::vec::IntoIter":["into_iter"],"alloc::vec::Vec":["from"],"bool":["contains_key","eq","is_empty"],"compact::Vec":["clone","from","from_iter","from_stdvec_unchecked","new","with_capacity"],"core::option::Option":["get","get_mut","insert","next","next_back","pop","remove"],"core::ptr::NonNull":["pack","pack_unchecked"],"core::result::Result":["fmt"],"u64":["hash_key"],"usize":["capacity","len"]},"struct_to_trait":{"Iter":["core::iter::DoubleEndedIterator","core::iter::ExactSizeIterator","core::iter::Iterator"],"IterMut":["core::iter::DoubleEndedIterator","core::iter::ExactSizeIterator","core::iter::Iterator"],"Map":["core::clone::Clone","core::cmp::PartialEq","core::fmt::Debug","core::iter::FromIterator","core::ops::Index"],"Node":["core::clone::Clone","core::cmp::PartialEq","core::fmt::Debug","core::marker::Sync"],"alloc::vec::Vec":["core::convert::From"],"compact::Vec":["core::clone::Clone","core::cmp::PartialEq","core::convert::From","core::fmt::Debug","core::iter::FromIterator","core::iter::IntoIterator","core::marker::Send","core::marker::Sync","core::ops::Deref","core::ops::DerefMut","core::ops::Drop"]},"targets":{"<Iter<'_, K, V> as core::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/lib.rs\"))","core::iter::DoubleEndedIterator"],"<Iter<'_, K, V> as core::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/lib.rs\"))","core::iter::ExactSizeIterator"],"<Iter<'i, K, V> as core::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","core::iter::Iterator"],"<IterMut<'_, K, V> as core::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/lib.rs\"))","core::iter::DoubleEndedIterator"],"<IterMut<'_, K, V> as core::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/lib.rs\"))","core::iter::ExactSizeIterator"],"<IterMut<'a, K, V> as core::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","core::iter::Iterator"],"<Map<K, V> as core::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","core::cmp::PartialEq"],"<Map<K, V> as core::iter::FromIterator<(IK, IV)>>::from_iter":["from_iter","Real(LocalPath(\"src/lib.rs\"))","core::iter::FromIterator"],"<Map<K, V> as core::ops::Index<&Q>>::index":["index","Real(LocalPath(\"src/lib.rs\"))","core::ops::Index"],"<Node<K, V> as core::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","core::cmp::PartialEq"],"<Node<K, V> as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Debug"],"<compact::Vec<T> as core::clone::Clone>::clone":["clone","Real(LocalPath(\"src/compact.rs\"))","core::clone::Clone"],"<compact::Vec<T> as core::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/compact.rs\"))","core::cmp::PartialEq"],"<compact::Vec<T> as core::convert::From<alloc::vec::Vec<T>>>::from":["from","Real(LocalPath(\"src/compact.rs\"))","core::convert::From"],"<compact::Vec<T> as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/compact.rs\"))","core::fmt::Debug"],"<compact::Vec<T> as core::iter::FromIterator<T>>::from_iter":["from_iter","Real(LocalPath(\"src/compact.rs\"))","core::iter::FromIterator"],"<compact::Vec<T> as core::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/compact.rs\"))","core::iter::IntoIterator"],"<compact::Vec<T> as core::ops::Deref>::deref":["deref","Real(LocalPath(\"src/compact.rs\"))","core::ops::Deref"],"<compact::Vec<T> as core::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/compact.rs\"))","core::ops::DerefMut"],"<compact::Vec<T> as core::ops::Drop>::drop":["drop","Real(LocalPath(\"src/compact.rs\"))","core::ops::Drop"],"Iter::<'_, K, V>::empty":["empty","Real(LocalPath(\"src/lib.rs\"))",""],"IterMut::<'_, K, V>::empty":["empty","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::clear":["clear","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::contains_key":["contains_key","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::find":["find","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::get":["get","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::get_mut":["get_mut","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::get_or_insert":["get_or_insert","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::insert":["insert","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::is_empty":["is_empty","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::iter":["iter","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::iter_mut":["iter_mut","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::len":["len","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::remove":["remove","Real(LocalPath(\"src/lib.rs\"))",""],"Map::<K, V>::with_capacity":["with_capacity","Real(LocalPath(\"src/lib.rs\"))",""],"Node::<K, V>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"compact::<impl core::convert::From<compact::Vec<T>> for alloc::vec::Vec<T>>::from":["from","Real(LocalPath(\"src/compact.rs\"))","core::convert::From"],"compact::Vec::<T>::as_mut_ptr":["as_mut_ptr","Real(LocalPath(\"src/compact.rs\"))",""],"compact::Vec::<T>::as_ptr":["as_ptr","Real(LocalPath(\"src/compact.rs\"))",""],"compact::Vec::<T>::capacity":["capacity","Real(LocalPath(\"src/compact.rs\"))",""],"compact::Vec::<T>::clear":["clear","Real(LocalPath(\"src/compact.rs\"))",""],"compact::Vec::<T>::from_stdvec_unchecked":["from_stdvec_unchecked","Real(LocalPath(\"src/compact.rs\"))",""],"compact::Vec::<T>::len":["len","Real(LocalPath(\"src/compact.rs\"))",""],"compact::Vec::<T>::new":["new","Real(LocalPath(\"src/compact.rs\"))",""],"compact::Vec::<T>::parts":["parts","Real(LocalPath(\"src/compact.rs\"))",""],"compact::Vec::<T>::pop":["pop","Real(LocalPath(\"src/compact.rs\"))",""],"compact::Vec::<T>::push":["push","Real(LocalPath(\"src/compact.rs\"))",""],"compact::Vec::<T>::remove":["remove","Real(LocalPath(\"src/compact.rs\"))",""],"compact::Vec::<T>::set_len":["set_len","Real(LocalPath(\"src/compact.rs\"))",""],"compact::Vec::<T>::with":["with","Real(LocalPath(\"src/compact.rs\"))",""],"compact::Vec::<T>::with_capacity":["with_capacity","Real(LocalPath(\"src/compact.rs\"))",""],"compact::pack":["pack","Real(LocalPath(\"src/compact.rs\"))",""],"compact::pack_unchecked":["pack_unchecked","Real(LocalPath(\"src/compact.rs\"))",""],"hash_key":["hash_key","Real(LocalPath(\"src/lib.rs\"))",""]},"trait_to_struct":{"core::clone::Clone":["Map","Node","compact::Vec"],"core::cmp::PartialEq":["Map","Node","compact::Vec"],"core::convert::From":["alloc::vec::Vec","compact::Vec"],"core::fmt::Debug":["Map","Node","compact::Vec"],"core::iter::DoubleEndedIterator":["Iter","IterMut"],"core::iter::ExactSizeIterator":["Iter","IterMut"],"core::iter::FromIterator":["Map","compact::Vec"],"core::iter::IntoIterator":["compact::Vec"],"core::iter::Iterator":["Iter","IterMut"],"core::marker::Send":["compact::Vec"],"core::marker::Sync":["Node","compact::Vec"],"core::ops::Deref":["compact::Vec"],"core::ops::DerefMut":["compact::Vec"],"core::ops::Drop":["compact::Vec"],"core::ops::Index":["Map"]},"type_to_def_path":{"FindResult<'find>":"FindResult","Iter<'a, K, V>":"Iter","IterMut<'a, K, V>":"IterMut","Map<K, V>":"Map","Node<K, V>":"Node","compact::Vec<T>":"compact::Vec"}}