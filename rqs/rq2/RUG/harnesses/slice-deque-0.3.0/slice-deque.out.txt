-----------------
src/mirrored/buffer.rs mirrored::buffer::no_required_allocation_units
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+mirrored::buffer::no_required_allocation_units(p0);
+crate::mirrored::buffer::no_required_allocation_units(p0);
+crate::mirrored::buffer::no_required_allocation_units(p0);
-----------------
src/mirrored/linux.rs mirrored::linux::memfd_create
deps:{}
candidates:{}
let mut p0 = 0i8; // None+*const i8
let mut p1 = 0u32; // None+u32
+mirrored::linux::memfd_create(p0, p1);
+crate::mirrored::linux::memfd_create(p0, p1);
+crate::mirrored::linux::memfd_create(p0, p1);
-----------------
src/mirrored/linux.rs mirrored::linux::allocation_granularity
deps:{}
candidates:{}
+mirrored::linux::allocation_granularity();
+crate::mirrored::linux::allocation_granularity();
+crate::mirrored::linux::allocation_granularity();
-----------------
src/mirrored/linux.rs mirrored::linux::errno
deps:{}
candidates:{}
+mirrored::linux::errno();
+crate::mirrored::linux::errno();
+crate::mirrored::linux::errno();
-----------------
src/mirrored/linux.rs mirrored::linux::allocate_mirrored
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+mirrored::linux::allocate_mirrored(p0);
+crate::mirrored::linux::allocate_mirrored(p0);
+crate::mirrored::linux::allocate_mirrored(p0);
-----------------
src/mirrored/linux.rs mirrored::linux::deallocate_mirrored
deps:{}
candidates:{}
let mut p0 = 0u8; // None+*mut u8
let mut p1 = 0usize; // None+usize
+mirrored::linux::deallocate_mirrored(p0, p1);
+crate::mirrored::linux::deallocate_mirrored(p0, p1);
+crate::mirrored::linux::deallocate_mirrored(p0, p1);
-----------------
src/mirrored/linux.rs mirrored::linux::print_error
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+mirrored::linux::print_error(&p0);
+crate::mirrored::linux::print_error(&p0);
+crate::mirrored::linux::print_error(&p0);
-----------------
src/lib.rs intrinsics::unlikely
deps:{"intrinsics::unlikely":{"T":["std::marker::Sized"]}}
candidates:{"intrinsics::unlikely":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+intrinsics::unlikely(p0);
+crate::intrinsics::unlikely(p0);
+crate::intrinsics::unlikely(p0);
-----------------
src/lib.rs intrinsics::assume
deps:{"intrinsics::assume":{"T":["std::marker::Sized"]}}
candidates:{"intrinsics::assume":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+intrinsics::assume(p0);
+crate::intrinsics::assume(p0);
+crate::intrinsics::assume(p0);
-----------------
src/lib.rs intrinsics::arith_offset
deps:{"intrinsics::arith_offset":{"T":["std::marker::Sized"]}}
candidates:{"intrinsics::arith_offset":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // *const T
let mut p1 = 0isize; // None+isize
+intrinsics::arith_offset(p0, p1);
+crate::intrinsics::arith_offset(p0, p1);
+crate::intrinsics::arith_offset(p0, p1);
-----------------
src/lib.rs in_bounds
deps:{"in_bounds":{"T":["std::marker::Sized"]}}
candidates:{"in_bounds":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T]
let mut p1 = MaybeUninit::uninit().assume_init(); // *mut T
+in_bounds(p0, p1);
+crate::in_bounds(p0, p1);
+crate::in_bounds(p0, p1);
-----------------
src/lib.rs nonnull_raw_slice
deps:{"nonnull_raw_slice":{"T":["std::marker::Sized"]}}
candidates:{"nonnull_raw_slice":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // *mut T
let mut p1 = 0usize; // None+usize
+nonnull_raw_slice(p0, p1);
+crate::nonnull_raw_slice(p0, p1);
+crate::nonnull_raw_slice(p0, p1);
-----------------
src/lib.rs from_iter_default
deps:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"Drain":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Sync"]},"DrainFilter":{"F":["std::ops::FnMut","std::marker::Sized","std::fmt::Debug"],"T":["std::marker::Sized","std::fmt::Debug"]},"IntoIter":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Send","std::marker::Sized","std::clone::Clone"]},"SliceDeque":{"T":["std::cmp::Eq","std::clone::Clone","std::default::Default","std::cmp::PartialOrd","std::marker::Sized","std::marker::Send","std::fmt::Debug","std::marker::Copy","std::hash::Hash","std::cmp::PartialEq","std::marker::Sync"]},"Splice":{"I":["std::fmt::Debug","std::marker::Sized","std::iter::Iterator"]},"from_iter_default":{"I":["std::marker::Sized","std::iter::Iterator"],"T":["std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"Drain":{"T":["<*mut T as std::fmt::Debug>","SliceDeque","IntoIter","Drain"]},"DrainFilter":{"T":["Splice","Drain","DrainFilter","SliceDeque","IntoIter","mirrored::AllocError","<*const T as std::fmt::Debug>"]},"IntoIter":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","SliceDeque","IntoIter"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>","std::string::String"]},"Splice":{"I":["DrainFilter","Splice","Drain","IntoIter"]},"from_iter_default":{"I":["DrainFilter","Splice","IntoIter","<&mut I as std::iter::Iterator>","Drain"],"T":["RUG_ANY"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+from_iter_default(p0);
+crate::from_iter_default(p0);
+crate::from_iter_default(p0);
-----------------
src/lib.rs from_elem
deps:{"<*mut T as std::marker::Sync>":{},"IntoIter":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized","std::marker::Sync","std::clone::Clone"]},"SliceDeque":{"T":["std::marker::Copy","std::marker::Sync","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::cmp::PartialOrd","std::default::Default","std::marker::Send","std::clone::Clone","std::cmp::Eq"]},"from_elem":{"T":["std::clone::Clone","std::marker::Sized"]},"mirrored::buffer::Buffer":{"T":["std::marker::Sync","std::marker::Send","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*mut T as std::marker::Sync>":{},"IntoIter":{"T":["IntoIter","<*mut T as std::marker::Sync>","SliceDeque"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::string::String","std::vec::Vec<T, A>"]},"from_elem":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","SliceDeque","mirrored::buffer::Buffer","IntoIter","std::clone::impls::<impl std::clone::Clone for *const T>"]},"mirrored::buffer::Buffer":{"T":["SliceDeque","std::clone::impls::<impl std::clone::Clone for *const T>","IntoIter","mirrored::buffer::Buffer"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0usize; // None+usize
+from_elem(p0, p1);
+crate::from_elem(p0, p1);
+crate::from_elem(p0, p1);
-----------------
src/lib.rs WrappingOffsetFrom::wrapping_offset_from_
deps:{"<*const T as WrappingOffsetFrom>":{},"WrappingOffsetFrom::wrapping_offset_from_":{"Self":["WrappingOffsetFrom"]}}
candidates:{"<*const T as WrappingOffsetFrom>":{},"WrappingOffsetFrom::wrapping_offset_from_":{"Self":["<*const T as WrappingOffsetFrom>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.wrapping_offset_from_(p1);
+WrappingOffsetFrom::wrapping_offset_from_(p0, p1);
+crate::WrappingOffsetFrom::wrapping_offset_from_(p0, p1);
+crate::WrappingOffsetFrom::wrapping_offset_from_(p0, p1);
-----------------
src/lib.rs SpecExtend::from_iter
deps:{"SpecExtend::from_iter":{"I":["std::marker::Sized"],"Self":["SpecExtend"],"T":["std::marker::Sized"]}}
candidates:{"SpecExtend::from_iter":{"I":["RUG_ANY"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+SpecExtend::from_iter(p0);
+crate::SpecExtend::from_iter(p0);
+crate::SpecExtend::from_iter(p0);
-----------------
src/lib.rs SpecExtend::spec_extend
deps:{"SpecExtend::spec_extend":{"I":["std::marker::Sized"],"Self":["SpecExtend"],"T":["std::marker::Sized"]}}
candidates:{"SpecExtend::spec_extend":{"I":["RUG_ANY"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.spec_extend(p1);
+SpecExtend::spec_extend(p0, p1);
+crate::SpecExtend::spec_extend(p0, p1);
+crate::SpecExtend::spec_extend(p0, p1);
-----------------
src/lib.rs ExtendWith::next
deps:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"ExtendElement":{"T":["std::marker::Sized","std::clone::Clone"]},"ExtendWith::next":{"Self":["ExtendWith"],"T":["std::marker::Sized"]},"IntoIter":{"T":["std::marker::Sized","std::marker::Send","std::marker::Sync","std::clone::Clone","std::fmt::Debug"]},"SliceDeque":{"T":["std::marker::Copy","std::fmt::Debug","std::default::Default","std::cmp::PartialEq","std::clone::Clone","std::cmp::PartialOrd","std::marker::Sync","std::cmp::Eq","std::marker::Send","std::hash::Hash","std::marker::Sized"]},"mirrored::buffer::Buffer":{"T":["std::clone::Clone","std::marker::Send","std::marker::Sync","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"ExtendElement":{"T":["IntoIter","mirrored::buffer::Buffer","std::clone::impls::<impl std::clone::Clone for *mut T>","SliceDeque"]},"ExtendWith::next":{"Self":["ExtendElement","ExtendDefault"],"T":["RUG_ANY"]},"IntoIter":{"T":["IntoIter","<*mut T as std::marker::Sync>","SliceDeque"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>","std::string::String"]},"mirrored::buffer::Buffer":{"T":["mirrored::buffer::Buffer","<*const T as std::marker::Send>","IntoIter","SliceDeque"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.next();
+ExtendWith::next(p0);
+crate::ExtendWith::next(p0);
+crate::ExtendWith::next(p0);
-----------------
src/lib.rs ExtendWith::last
deps:{"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"ExtendElement":{"T":["std::clone::Clone","std::marker::Sized"]},"ExtendWith::last":{"Self":["ExtendWith"],"T":["std::marker::Sized"]},"IntoIter":{"T":["std::marker::Sync","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::marker::Send"]},"SliceDeque":{"T":["std::marker::Sized","std::fmt::Debug","std::hash::Hash","std::cmp::PartialEq","std::cmp::Eq","std::marker::Copy","std::default::Default","std::marker::Send","std::marker::Sync","std::clone::Clone","std::cmp::PartialOrd"]},"mirrored::buffer::Buffer":{"T":["std::marker::Sized","std::marker::Send","std::marker::Sync","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"ExtendElement":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","mirrored::buffer::Buffer","SliceDeque","IntoIter"]},"ExtendWith::last":{"Self":["ExtendElement","ExtendDefault"],"T":["RUG_ANY"]},"IntoIter":{"T":["<*mut T as std::fmt::Debug>","IntoIter","SliceDeque"]},"SliceDeque":{"T":["std::vec::Vec<T, A>","std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>"]},"mirrored::buffer::Buffer":{"T":["IntoIter","mirrored::buffer::Buffer","SliceDeque","<*mut T as std::marker::Sync>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.last();
+ExtendWith::last(p0);
+crate::ExtendWith::last(p0);
+crate::ExtendWith::last(p0);
-----------------
src/lib.rs SpecFromElem::from_elem
deps:{"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<T as SpecFromElem>":{"T":["std::marker::Sized","std::clone::Clone"]},"IntoIter":{"T":["std::marker::Send","std::marker::Sync","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"SliceDeque":{"T":["std::marker::Sync","std::marker::Send","std::cmp::PartialEq","std::cmp::Eq","std::marker::Copy","std::default::Default","std::fmt::Debug","std::marker::Sized","std::hash::Hash","std::clone::Clone","std::cmp::PartialOrd"]},"SpecFromElem::from_elem":{"Self":["SpecFromElem","std::marker::Sized"]},"mirrored::buffer::Buffer":{"T":["std::marker::Sized","std::marker::Sync","std::clone::Clone","std::marker::Send"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<T as SpecFromElem>":{"T":["SliceDeque","std::clone::impls::<impl std::clone::Clone for &T>","mirrored::buffer::Buffer","std::clone::impls::<impl std::clone::Clone for &mut T>","IntoIter"]},"IntoIter":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","SliceDeque","IntoIter"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>","std::string::String"]},"SpecFromElem::from_elem":{"Self":["<T as SpecFromElem>"]},"mirrored::buffer::Buffer":{"T":["SliceDeque","IntoIter","mirrored::buffer::Buffer","<*const T as std::marker::Send>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+SpecFromElem::from_elem(p0, p1);
+crate::SpecFromElem::from_elem(p0, p1);
+crate::SpecFromElem::from_elem(p0, p1);
-----------------
src/macros.rs macros::TinyAsciiString::new
deps:{}
candidates:{}
+macros::TinyAsciiString::new();
+crate::macros::TinyAsciiString::new();
+<macros::TinyAsciiString>::new();
-----------------
src/macros.rs macros::TinyAsciiString::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // macros::TinyAsciiString
+p0.as_str();
+macros::TinyAsciiString::as_str(p0);
+crate::macros::TinyAsciiString::as_str(p0);
+<macros::TinyAsciiString>::as_str(p0);
-----------------
src/macros.rs <macros::TinyAsciiString as std::fmt::Write>::write_str
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // macros::TinyAsciiString
let mut p1 = "sample"; // None+&str
+p0.write_str(&p1);
+<macros::TinyAsciiString as std::fmt::Write>::write_str(p0, &p1);
+crate::<macros::TinyAsciiString as std::fmt::Write>::write_str(p0, &p1);
+<macros::TinyAsciiString>::write_str(p0, &p1);
-----------------
src/mirrored/buffer.rs mirrored::buffer::Buffer::<T>::len
deps:{"mirrored::buffer::Buffer::<T>::len":{"T":["std::marker::Sized"]}}
candidates:{"mirrored::buffer::Buffer::<T>::len":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // mirrored::buffer::Buffer<T>
+p0.len();
+mirrored::buffer::Buffer::<T>::len(p0);
+crate::mirrored::buffer::Buffer::<T>::len(p0);
+<mirrored::buffer::Buffer<T>>::len(p0);
-----------------
src/mirrored/buffer.rs mirrored::buffer::Buffer::<T>::is_empty
deps:{"mirrored::buffer::Buffer::<T>::is_empty":{"T":["std::marker::Sized"]}}
candidates:{"mirrored::buffer::Buffer::<T>::is_empty":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // mirrored::buffer::Buffer<T>
+p0.is_empty();
+mirrored::buffer::Buffer::<T>::is_empty(p0);
+crate::mirrored::buffer::Buffer::<T>::is_empty(p0);
+<mirrored::buffer::Buffer<T>>::is_empty(p0);
-----------------
src/mirrored/buffer.rs mirrored::buffer::Buffer::<T>::ptr
deps:{"mirrored::buffer::Buffer::<T>::ptr":{"T":["std::marker::Sized"]}}
candidates:{"mirrored::buffer::Buffer::<T>::ptr":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // mirrored::buffer::Buffer<T>
+p0.ptr();
+mirrored::buffer::Buffer::<T>::ptr(p0);
+crate::mirrored::buffer::Buffer::<T>::ptr(p0);
+<mirrored::buffer::Buffer<T>>::ptr(p0);
-----------------
src/mirrored/buffer.rs mirrored::buffer::Buffer::<T>::as_slice
deps:{"mirrored::buffer::Buffer::<T>::as_slice":{"T":["std::marker::Sized"]}}
candidates:{"mirrored::buffer::Buffer::<T>::as_slice":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // mirrored::buffer::Buffer<T>
+p0.as_slice();
+mirrored::buffer::Buffer::<T>::as_slice(p0);
+crate::mirrored::buffer::Buffer::<T>::as_slice(p0);
+<mirrored::buffer::Buffer<T>>::as_slice(p0);
-----------------
src/mirrored/buffer.rs mirrored::buffer::Buffer::<T>::as_mut_slice
deps:{"mirrored::buffer::Buffer::<T>::as_mut_slice":{"T":["std::marker::Sized"]}}
candidates:{"mirrored::buffer::Buffer::<T>::as_mut_slice":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // mirrored::buffer::Buffer<T>
+p0.as_mut_slice();
+mirrored::buffer::Buffer::<T>::as_mut_slice(p0);
+crate::mirrored::buffer::Buffer::<T>::as_mut_slice(p0);
+<mirrored::buffer::Buffer<T>>::as_mut_slice(p0);
-----------------
src/mirrored/buffer.rs mirrored::buffer::Buffer::<T>::get
deps:{"mirrored::buffer::Buffer::<T>::get":{"T":["std::marker::Sized"]}}
candidates:{"mirrored::buffer::Buffer::<T>::get":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // mirrored::buffer::Buffer<T>
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+mirrored::buffer::Buffer::<T>::get(p0, p1);
+crate::mirrored::buffer::Buffer::<T>::get(p0, p1);
+<mirrored::buffer::Buffer<T>>::get(p0, p1);
-----------------
src/mirrored/buffer.rs mirrored::buffer::Buffer::<T>::get_mut
deps:{"mirrored::buffer::Buffer::<T>::get_mut":{"T":["std::marker::Sized"]}}
candidates:{"mirrored::buffer::Buffer::<T>::get_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // mirrored::buffer::Buffer<T>
let mut p1 = 0usize; // None+usize
+p0.get_mut(p1);
+mirrored::buffer::Buffer::<T>::get_mut(p0, p1);
+crate::mirrored::buffer::Buffer::<T>::get_mut(p0, p1);
+<mirrored::buffer::Buffer<T>>::get_mut(p0, p1);
-----------------
src/mirrored/buffer.rs mirrored::buffer::Buffer::<T>::empty_len
deps:{"mirrored::buffer::Buffer::<T>::empty_len":{"T":["std::marker::Sized"]}}
candidates:{"mirrored::buffer::Buffer::<T>::empty_len":{"T":["RUG_ANY"]}}
+mirrored::buffer::Buffer::<T>::empty_len();
+crate::mirrored::buffer::Buffer::<T>::empty_len();
+<mirrored::buffer::Buffer<T>>::empty_len();
-----------------
src/mirrored/buffer.rs mirrored::buffer::Buffer::<T>::new
deps:{"mirrored::buffer::Buffer::<T>::new":{"T":["std::marker::Sized"]}}
candidates:{"mirrored::buffer::Buffer::<T>::new":{"T":["RUG_ANY"]}}
+mirrored::buffer::Buffer::<T>::new();
+crate::mirrored::buffer::Buffer::<T>::new();
+<mirrored::buffer::Buffer<T>>::new();
-----------------
src/mirrored/buffer.rs mirrored::buffer::Buffer::<T>::from_raw_parts
deps:{"mirrored::buffer::Buffer::<T>::from_raw_parts":{"T":["std::marker::Sized"]}}
candidates:{"mirrored::buffer::Buffer::<T>::from_raw_parts":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // *mut T
let mut p1 = 0usize; // None+usize
+mirrored::buffer::Buffer::<T>::from_raw_parts(p0, p1);
+crate::mirrored::buffer::Buffer::<T>::from_raw_parts(p0, p1);
+<mirrored::buffer::Buffer<T>>::from_raw_parts(p0, p1);
-----------------
src/mirrored/buffer.rs mirrored::buffer::Buffer::<T>::size_in_bytes
deps:{"mirrored::buffer::Buffer::<T>::size_in_bytes":{"T":["std::marker::Sized"]}}
candidates:{"mirrored::buffer::Buffer::<T>::size_in_bytes":{"T":["RUG_ANY"]}}
let mut p0 = 0usize; // None+usize
+mirrored::buffer::Buffer::<T>::size_in_bytes(p0);
+crate::mirrored::buffer::Buffer::<T>::size_in_bytes(p0);
+<mirrored::buffer::Buffer<T>>::size_in_bytes(p0);
-----------------
src/mirrored/buffer.rs mirrored::buffer::Buffer::<T>::uninitialized
deps:{"mirrored::buffer::Buffer::<T>::uninitialized":{"T":["std::marker::Sized"]}}
candidates:{"mirrored::buffer::Buffer::<T>::uninitialized":{"T":["RUG_ANY"]}}
let mut p0 = 0usize; // None+usize
+mirrored::buffer::Buffer::<T>::uninitialized(p0);
+crate::mirrored::buffer::Buffer::<T>::uninitialized(p0);
+<mirrored::buffer::Buffer<T>>::uninitialized(p0);
-----------------
src/mirrored/buffer.rs <mirrored::buffer::Buffer<T> as std::ops::Drop>::drop
deps:{"<mirrored::buffer::Buffer<T> as std::ops::Drop>::drop":{"T":["std::marker::Sized"]}}
candidates:{"<mirrored::buffer::Buffer<T> as std::ops::Drop>::drop":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // mirrored::buffer::Buffer<T>
+p0.drop();
+<mirrored::buffer::Buffer<T> as std::ops::Drop>::drop(p0);
+crate::<mirrored::buffer::Buffer<T> as std::ops::Drop>::drop(p0);
+<mirrored::buffer::Buffer<T>>::drop(p0);
-----------------
src/mirrored/buffer.rs <mirrored::buffer::Buffer<T> as std::clone::Clone>::clone
deps:{"<*const T as std::marker::Send>":{},"<mirrored::buffer::Buffer<T> as std::clone::Clone>::clone":{"T":["std::clone::Clone","std::marker::Sized"]},"IntoIter":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"SliceDeque":{"T":["std::hash::Hash","std::marker::Copy","std::cmp::PartialEq","std::default::Default","std::marker::Sync","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialOrd","std::clone::Clone","std::marker::Sized","std::marker::Send"]},"mirrored::buffer::Buffer":{"T":["std::marker::Sized","std::clone::Clone","std::marker::Send","std::marker::Sync"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::marker::Send>":{},"<mirrored::buffer::Buffer<T> as std::clone::Clone>::clone":{"T":["SliceDeque","mirrored::buffer::Buffer","IntoIter","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for *const T>"]},"IntoIter":{"T":["IntoIter","std::clone::impls::<impl std::clone::Clone for *mut T>","SliceDeque"]},"SliceDeque":{"T":["std::string::String","std::vec::Vec<T, A>","std::borrow::Cow<'a, std::ffi::OsStr>"]},"mirrored::buffer::Buffer":{"T":["IntoIter","SliceDeque","mirrored::buffer::Buffer","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // mirrored::buffer::Buffer<T>
+p0.clone();
+<mirrored::buffer::Buffer<T> as std::clone::Clone>::clone(p0);
+crate::<mirrored::buffer::Buffer<T> as std::clone::Clone>::clone(p0);
+<mirrored::buffer::Buffer<T>>::clone(p0);
-----------------
src/mirrored/buffer.rs <mirrored::buffer::Buffer<T> as std::default::Default>::default
deps:{"<mirrored::buffer::Buffer<T> as std::default::Default>::default":{"T":["std::marker::Sized"]}}
candidates:{"<mirrored::buffer::Buffer<T> as std::default::Default>::default":{"T":["RUG_ANY"]}}
+<mirrored::buffer::Buffer<T> as std::default::Default>::default();
+crate::<mirrored::buffer::Buffer<T> as std::default::Default>::default();
+<mirrored::buffer::Buffer<T>>::default();
-----------------
src/mirrored/mod.rs <mirrored::AllocError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // mirrored::AllocError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<mirrored::AllocError as std::fmt::Debug>::fmt(p0, p1);
+crate::<mirrored::AllocError as std::fmt::Debug>::fmt(p0, p1);
+<mirrored::AllocError>::fmt(p0, p1);
-----------------
src/lib.rs <*const T as WrappingOffsetFrom>::wrapping_offset_from_
deps:{"<*const T as WrappingOffsetFrom>::wrapping_offset_from_":{"T":["std::marker::Sized"]}}
candidates:{"<*const T as WrappingOffsetFrom>::wrapping_offset_from_":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // *const T
let mut p1 = MaybeUninit::uninit().assume_init(); // *const T
+p0.wrapping_offset_from_(p1);
+<*const T as WrappingOffsetFrom>::wrapping_offset_from_(p0, p1);
+crate::<*const T as WrappingOffsetFrom>::wrapping_offset_from_(p0, p1);
+<*const T>::wrapping_offset_from_(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::new
deps:{"SliceDeque::<T>::new":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::new":{"T":["RUG_ANY"]}}
+SliceDeque::<T>::new();
+crate::SliceDeque::<T>::new();
+<SliceDeque<T>>::new();
-----------------
src/lib.rs SliceDeque::<T>::from_raw_parts
deps:{"SliceDeque::<T>::from_raw_parts":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::from_raw_parts":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // *mut T
let mut p1 = 0usize; // None+usize
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // [T]
+SliceDeque::<T>::from_raw_parts(p0, p1, p2);
+crate::SliceDeque::<T>::from_raw_parts(p0, p1, p2);
+<SliceDeque<T>>::from_raw_parts(p0, p1, p2);
-----------------
src/lib.rs SliceDeque::<T>::with_capacity
deps:{"SliceDeque::<T>::with_capacity":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::with_capacity":{"T":["RUG_ANY"]}}
let mut p0 = 0usize; // None+usize
+SliceDeque::<T>::with_capacity(p0);
+crate::SliceDeque::<T>::with_capacity(p0);
+<SliceDeque<T>>::with_capacity(p0);
-----------------
src/lib.rs SliceDeque::<T>::capacity
deps:{"SliceDeque::<T>::capacity":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::capacity":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.capacity();
+SliceDeque::<T>::capacity(p0);
+crate::SliceDeque::<T>::capacity(p0);
+<SliceDeque<T>>::capacity(p0);
-----------------
src/lib.rs SliceDeque::<T>::len
deps:{"SliceDeque::<T>::len":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::len":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.len();
+SliceDeque::<T>::len(p0);
+crate::SliceDeque::<T>::len(p0);
+<SliceDeque<T>>::len(p0);
-----------------
src/lib.rs SliceDeque::<T>::is_full
deps:{"SliceDeque::<T>::is_full":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::is_full":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.is_full();
+SliceDeque::<T>::is_full(p0);
+crate::SliceDeque::<T>::is_full(p0);
+<SliceDeque<T>>::is_full(p0);
-----------------
src/lib.rs SliceDeque::<T>::as_slice
deps:{"SliceDeque::<T>::as_slice":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::as_slice":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.as_slice();
+SliceDeque::<T>::as_slice(p0);
+crate::SliceDeque::<T>::as_slice(p0);
+<SliceDeque<T>>::as_slice(p0);
-----------------
src/lib.rs SliceDeque::<T>::as_mut_slice
deps:{"SliceDeque::<T>::as_mut_slice":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::as_mut_slice":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.as_mut_slice();
+SliceDeque::<T>::as_mut_slice(p0);
+crate::SliceDeque::<T>::as_mut_slice(p0);
+<SliceDeque<T>>::as_mut_slice(p0);
-----------------
src/lib.rs SliceDeque::<T>::as_slices
deps:{"SliceDeque::<T>::as_slices":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::as_slices":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.as_slices();
+SliceDeque::<T>::as_slices(p0);
+crate::SliceDeque::<T>::as_slices(p0);
+<SliceDeque<T>>::as_slices(p0);
-----------------
src/lib.rs SliceDeque::<T>::as_mut_slices
deps:{"SliceDeque::<T>::as_mut_slices":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::as_mut_slices":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.as_mut_slices();
+SliceDeque::<T>::as_mut_slices(p0);
+crate::SliceDeque::<T>::as_mut_slices(p0);
+<SliceDeque<T>>::as_mut_slices(p0);
-----------------
src/lib.rs SliceDeque::<T>::tail_head_slice
deps:{"SliceDeque::<T>::tail_head_slice":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::tail_head_slice":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.tail_head_slice();
+SliceDeque::<T>::tail_head_slice(p0);
+crate::SliceDeque::<T>::tail_head_slice(p0);
+<SliceDeque<T>>::tail_head_slice(p0);
-----------------
src/lib.rs SliceDeque::<T>::try_reserve
deps:{"SliceDeque::<T>::try_reserve":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::try_reserve":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
+p0.try_reserve(p1);
+SliceDeque::<T>::try_reserve(p0, p1);
+crate::SliceDeque::<T>::try_reserve(p0, p1);
+<SliceDeque<T>>::try_reserve(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::reserve
deps:{"SliceDeque::<T>::reserve":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::reserve":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
+p0.reserve(p1);
+SliceDeque::<T>::reserve(p0, p1);
+crate::SliceDeque::<T>::reserve(p0, p1);
+<SliceDeque<T>>::reserve(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::reserve_capacity
deps:{"SliceDeque::<T>::reserve_capacity":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::reserve_capacity":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
+p0.reserve_capacity(p1);
+SliceDeque::<T>::reserve_capacity(p0, p1);
+crate::SliceDeque::<T>::reserve_capacity(p0, p1);
+<SliceDeque<T>>::reserve_capacity(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::reserve_exact
deps:{"SliceDeque::<T>::reserve_exact":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::reserve_exact":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
+p0.reserve_exact(p1);
+SliceDeque::<T>::reserve_exact(p0, p1);
+crate::SliceDeque::<T>::reserve_exact(p0, p1);
+<SliceDeque<T>>::reserve_exact(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::grow_policy
deps:{"SliceDeque::<T>::grow_policy":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::grow_policy":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
+p0.grow_policy(p1);
+SliceDeque::<T>::grow_policy(p0, p1);
+crate::SliceDeque::<T>::grow_policy(p0, p1);
+<SliceDeque<T>>::grow_policy(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::move_head_unchecked
deps:{"SliceDeque::<T>::move_head_unchecked":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::move_head_unchecked":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0isize; // None+isize
+p0.move_head_unchecked(p1);
+SliceDeque::<T>::move_head_unchecked(p0, p1);
+crate::SliceDeque::<T>::move_head_unchecked(p0, p1);
+<SliceDeque<T>>::move_head_unchecked(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::move_head
deps:{"SliceDeque::<T>::move_head":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::move_head":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0isize; // None+isize
+p0.move_head(p1);
+SliceDeque::<T>::move_head(p0, p1);
+crate::SliceDeque::<T>::move_head(p0, p1);
+<SliceDeque<T>>::move_head(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::move_tail_unchecked
deps:{"SliceDeque::<T>::move_tail_unchecked":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::move_tail_unchecked":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0isize; // None+isize
+p0.move_tail_unchecked(p1);
+SliceDeque::<T>::move_tail_unchecked(p0, p1);
+crate::SliceDeque::<T>::move_tail_unchecked(p0, p1);
+<SliceDeque<T>>::move_tail_unchecked(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::move_tail
deps:{"SliceDeque::<T>::move_tail":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::move_tail":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0isize; // None+isize
+p0.move_tail(p1);
+SliceDeque::<T>::move_tail(p0, p1);
+crate::SliceDeque::<T>::move_tail(p0, p1);
+<SliceDeque<T>>::move_tail(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::append_elements
deps:{"SliceDeque::<T>::append_elements":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::append_elements":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // *const [T]
+p0.append_elements(p1);
+SliceDeque::<T>::append_elements(p0, p1);
+crate::SliceDeque::<T>::append_elements(p0, p1);
+<SliceDeque<T>>::append_elements(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::steal_from_slice
deps:{"SliceDeque::<T>::steal_from_slice":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::steal_from_slice":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T]
+SliceDeque::<T>::steal_from_slice(p0);
+crate::SliceDeque::<T>::steal_from_slice(p0);
+<SliceDeque<T>>::steal_from_slice(p0);
-----------------
src/lib.rs SliceDeque::<T>::append
deps:{"SliceDeque::<T>::append":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::append":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.append(p1);
+SliceDeque::<T>::append(p0, p1);
+crate::SliceDeque::<T>::append(p0, p1);
+<SliceDeque<T>>::append(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::front
deps:{"SliceDeque::<T>::front":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::front":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.front();
+SliceDeque::<T>::front(p0);
+crate::SliceDeque::<T>::front(p0);
+<SliceDeque<T>>::front(p0);
-----------------
src/lib.rs SliceDeque::<T>::front_mut
deps:{"SliceDeque::<T>::front_mut":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::front_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.front_mut();
+SliceDeque::<T>::front_mut(p0);
+crate::SliceDeque::<T>::front_mut(p0);
+<SliceDeque<T>>::front_mut(p0);
-----------------
src/lib.rs SliceDeque::<T>::back
deps:{"SliceDeque::<T>::back":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::back":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.back();
+SliceDeque::<T>::back(p0);
+crate::SliceDeque::<T>::back(p0);
+<SliceDeque<T>>::back(p0);
-----------------
src/lib.rs SliceDeque::<T>::back_mut
deps:{"SliceDeque::<T>::back_mut":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::back_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.back_mut();
+SliceDeque::<T>::back_mut(p0);
+crate::SliceDeque::<T>::back_mut(p0);
+<SliceDeque<T>>::back_mut(p0);
-----------------
src/lib.rs SliceDeque::<T>::try_push_front
deps:{"SliceDeque::<T>::try_push_front":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::try_push_front":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.try_push_front(p1);
+SliceDeque::<T>::try_push_front(p0, p1);
+crate::SliceDeque::<T>::try_push_front(p0, p1);
+<SliceDeque<T>>::try_push_front(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::push_front
deps:{"SliceDeque::<T>::push_front":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::push_front":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.push_front(p1);
+SliceDeque::<T>::push_front(p0, p1);
+crate::SliceDeque::<T>::push_front(p0, p1);
+<SliceDeque<T>>::push_front(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::try_push_back
deps:{"SliceDeque::<T>::try_push_back":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::try_push_back":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.try_push_back(p1);
+SliceDeque::<T>::try_push_back(p0, p1);
+crate::SliceDeque::<T>::try_push_back(p0, p1);
+<SliceDeque<T>>::try_push_back(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::push_back
deps:{"SliceDeque::<T>::push_back":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::push_back":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.push_back(p1);
+SliceDeque::<T>::push_back(p0, p1);
+crate::SliceDeque::<T>::push_back(p0, p1);
+<SliceDeque<T>>::push_back(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::pop_front
deps:{"SliceDeque::<T>::pop_front":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::pop_front":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.pop_front();
+SliceDeque::<T>::pop_front(p0);
+crate::SliceDeque::<T>::pop_front(p0);
+<SliceDeque<T>>::pop_front(p0);
-----------------
src/lib.rs SliceDeque::<T>::pop_back
deps:{"SliceDeque::<T>::pop_back":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::pop_back":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.pop_back();
+SliceDeque::<T>::pop_back(p0);
+crate::SliceDeque::<T>::pop_back(p0);
+<SliceDeque<T>>::pop_back(p0);
-----------------
src/lib.rs SliceDeque::<T>::shrink_to_fit
deps:{"SliceDeque::<T>::shrink_to_fit":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::shrink_to_fit":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.shrink_to_fit();
+SliceDeque::<T>::shrink_to_fit(p0);
+crate::SliceDeque::<T>::shrink_to_fit(p0);
+<SliceDeque<T>>::shrink_to_fit(p0);
-----------------
src/lib.rs SliceDeque::<T>::truncate_back
deps:{"SliceDeque::<T>::truncate_back":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::truncate_back":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
+p0.truncate_back(p1);
+SliceDeque::<T>::truncate_back(p0, p1);
+crate::SliceDeque::<T>::truncate_back(p0, p1);
+<SliceDeque<T>>::truncate_back(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::truncate
deps:{"SliceDeque::<T>::truncate":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::truncate":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
+p0.truncate(p1);
+SliceDeque::<T>::truncate(p0, p1);
+crate::SliceDeque::<T>::truncate(p0, p1);
+<SliceDeque<T>>::truncate(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::truncate_front
deps:{"SliceDeque::<T>::truncate_front":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::truncate_front":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
+p0.truncate_front(p1);
+SliceDeque::<T>::truncate_front(p0, p1);
+crate::SliceDeque::<T>::truncate_front(p0, p1);
+<SliceDeque<T>>::truncate_front(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::drain
deps:{"SliceDeque::<T>::drain":{"R":["std::marker::Sized","std::ops::RangeBounds"],"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::drain":{"R":["std::ops::RangeInclusive<&T>","(std::collections::Bound<&'a T>, std::collections::Bound<&'a T>)","std::ops::RangeTo<&T>","std::ops::RangeFull","(std::collections::Bound<T>, std::collections::Bound<T>)","std::ops::RangeFrom<T>","std::ops::RangeTo<T>","std::ops::RangeToInclusive<&T>","std::ops::RangeInclusive<T>","std::ops::Range<T>","std::ops::RangeToInclusive<T>","std::ops::RangeFrom<&T>","std::ops::Range<&T>"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // R
+p0.drain(p1);
+SliceDeque::<T>::drain(p0, p1);
+crate::SliceDeque::<T>::drain(p0, p1);
+<SliceDeque<T>>::drain(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::clear
deps:{"SliceDeque::<T>::clear":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::clear":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.clear();
+SliceDeque::<T>::clear(p0);
+crate::SliceDeque::<T>::clear(p0);
+<SliceDeque<T>>::clear(p0);
-----------------
src/lib.rs SliceDeque::<T>::swap_remove_back
deps:{"SliceDeque::<T>::swap_remove_back":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::swap_remove_back":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
+p0.swap_remove_back(p1);
+SliceDeque::<T>::swap_remove_back(p0, p1);
+crate::SliceDeque::<T>::swap_remove_back(p0, p1);
+<SliceDeque<T>>::swap_remove_back(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::swap_remove_front
deps:{"SliceDeque::<T>::swap_remove_front":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::swap_remove_front":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
+p0.swap_remove_front(p1);
+SliceDeque::<T>::swap_remove_front(p0, p1);
+crate::SliceDeque::<T>::swap_remove_front(p0, p1);
+<SliceDeque<T>>::swap_remove_front(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::insert
deps:{"SliceDeque::<T>::insert":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::insert":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.insert(p1, p2);
+SliceDeque::<T>::insert(p0, p1, p2);
+crate::SliceDeque::<T>::insert(p0, p1, p2);
+<SliceDeque<T>>::insert(p0, p1, p2);
-----------------
src/lib.rs SliceDeque::<T>::remove
deps:{"SliceDeque::<T>::remove":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::remove":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
+p0.remove(p1);
+SliceDeque::<T>::remove(p0, p1);
+crate::SliceDeque::<T>::remove(p0, p1);
+<SliceDeque<T>>::remove(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::split_off
deps:{"SliceDeque::<T>::split_off":{"T":["std::marker::Sized"]}}
candidates:{"SliceDeque::<T>::split_off":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
+p0.split_off(p1);
+SliceDeque::<T>::split_off(p0, p1);
+crate::SliceDeque::<T>::split_off(p0, p1);
+<SliceDeque<T>>::split_off(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::retain
deps:{"SliceDeque::<T>::retain":{"F":["std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"SliceDeque::<T>::retain":{"F":["core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode"],"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.retain(p1);
+SliceDeque::<T>::retain(p0, p1);
+crate::SliceDeque::<T>::retain(p0, p1);
+<SliceDeque<T>>::retain(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::dedup_by_key
deps:{"SliceDeque::<T>::dedup_by_key":{"F":["std::ops::FnMut","std::marker::Sized"],"K":["std::marker::Sized","std::cmp::PartialEq"],"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"SliceDeque::<T>::dedup_by_key":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty"],"K":["i32","u64","i16","u8","bool","usize","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","char","i64","i8","u32","u16"],"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.dedup_by_key(p1);
+SliceDeque::<T>::dedup_by_key(p0, p1);
+crate::SliceDeque::<T>::dedup_by_key(p0, p1);
+<SliceDeque<T>>::dedup_by_key(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::dedup_by
deps:{"SliceDeque::<T>::dedup_by":{"F":["std::ops::FnMut","std::marker::Sized"],"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"SliceDeque::<T>::dedup_by":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr"],"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.dedup_by(p1);
+SliceDeque::<T>::dedup_by(p0, p1);
+crate::SliceDeque::<T>::dedup_by(p0, p1);
+<SliceDeque<T>>::dedup_by(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::extend_with
deps:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"ExtendElement":{"T":["std::clone::Clone","std::marker::Sized"]},"IntoIter":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::marker::Sync","std::marker::Send"]},"SliceDeque":{"T":["std::marker::Send","std::clone::Clone","std::marker::Sync","std::marker::Copy","std::default::Default","std::marker::Sized","std::hash::Hash","std::cmp::Eq","std::cmp::PartialOrd","std::fmt::Debug","std::cmp::PartialEq"]},"SliceDeque::<T>::extend_with":{"E":["std::marker::Sized","ExtendWith"],"T":["std::marker::Sized"]},"mirrored::buffer::Buffer":{"T":["std::marker::Sync","std::clone::Clone","std::marker::Sized","std::marker::Send"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"ExtendElement":{"T":["IntoIter","mirrored::buffer::Buffer","std::clone::impls::<impl std::clone::Clone for &T>","SliceDeque"]},"IntoIter":{"T":["IntoIter","SliceDeque","<*mut T as std::marker::Send>"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::string::String","std::vec::Vec<T, A>"]},"SliceDeque::<T>::extend_with":{"E":["ExtendElement","ExtendDefault"],"T":["RUG_ANY"]},"mirrored::buffer::Buffer":{"T":["<*const T as std::marker::Send>","mirrored::buffer::Buffer","SliceDeque","IntoIter"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+p0.extend_with(p1, p2);
+SliceDeque::<T>::extend_with(p0, p1, p2);
+crate::SliceDeque::<T>::extend_with(p0, p1, p2);
+<SliceDeque<T>>::extend_with(p0, p1, p2);
-----------------
src/lib.rs SliceDeque::<T>::extend_desugared
deps:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"Drain":{"T":["std::marker::Sized","std::marker::Sync","std::marker::Send","std::fmt::Debug"]},"DrainFilter":{"F":["std::marker::Sized","std::ops::FnMut","std::fmt::Debug"],"T":["std::fmt::Debug","std::marker::Sized"]},"IntoIter":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Sync","std::clone::Clone"]},"SliceDeque":{"T":["std::default::Default","std::cmp::Eq","std::marker::Send","std::hash::Hash","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sync","std::marker::Sized","std::cmp::PartialOrd","std::marker::Copy"]},"SliceDeque::<T>::extend_desugared":{"I":["std::marker::Sized","std::iter::Iterator"],"T":["std::marker::Sized"]},"Splice":{"I":["std::marker::Sized","std::iter::Iterator","std::fmt::Debug"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"Drain":{"T":["<*const T as std::marker::Send>","SliceDeque","Drain","IntoIter"]},"DrainFilter":{"T":["IntoIter","mirrored::AllocError","<*mut T as std::fmt::Debug>","Drain","Splice","DrainFilter","SliceDeque"]},"IntoIter":{"T":["SliceDeque","IntoIter","<*const T as std::fmt::Debug>"]},"SliceDeque":{"T":["std::vec::Vec<T, A>","std::borrow::Cow<'a, std::ffi::OsStr>","std::string::String"]},"SliceDeque::<T>::extend_desugared":{"I":["Drain","IntoIter","DrainFilter","Splice","<&mut I as std::iter::Iterator>"],"T":["RUG_ANY"]},"Splice":{"I":["Splice","Drain","IntoIter","DrainFilter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.extend_desugared(p1);
+SliceDeque::<T>::extend_desugared(p0, p1);
+crate::SliceDeque::<T>::extend_desugared(p0, p1);
+<SliceDeque<T>>::extend_desugared(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::splice
deps:{"<&'a SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"Drain":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Send","std::marker::Sized"]},"DrainFilter":{"F":["std::fmt::Debug","std::ops::FnMut","std::marker::Sized"],"T":["std::marker::Sized","std::fmt::Debug"]},"IntoIter":{"T":["std::marker::Sync","std::marker::Send","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"SliceDeque":{"T":["std::marker::Copy","std::marker::Sync","std::cmp::PartialOrd","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Send","std::marker::Sized"]},"SliceDeque::<T>::splice":{"I":["std::marker::Sized","std::iter::IntoIterator"],"R":["std::marker::Sized","std::ops::RangeBounds"],"T":["std::marker::Sized"]},"Splice":{"I":["std::fmt::Debug","std::marker::Sized","std::iter::Iterator"]}}
candidates:{"<&'a SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<I as std::iter::IntoIterator>":{"I":["IntoIter","DrainFilter","<&mut I as std::iter::Iterator>","Drain","Splice"]},"Drain":{"T":["Drain","<*mut T as std::marker::Send>","IntoIter","SliceDeque"]},"DrainFilter":{"T":["mirrored::AllocError","<*const T as std::fmt::Debug>","IntoIter","Splice","SliceDeque","DrainFilter","Drain"]},"IntoIter":{"T":["<*mut T as std::marker::Sync>","SliceDeque","IntoIter"]},"SliceDeque":{"T":["std::vec::Vec<T, A>","std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>"]},"SliceDeque::<T>::splice":{"I":["SliceDeque","<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>","<&'a SliceDeque<T> as std::iter::IntoIterator>"],"R":["std::ops::RangeFrom<&T>","std::ops::RangeInclusive<T>","std::ops::RangeFull","std::ops::RangeTo<T>","std::ops::RangeToInclusive<T>","std::ops::RangeTo<&T>","std::ops::RangeFrom<T>","(std::collections::Bound<T>, std::collections::Bound<T>)","(std::collections::Bound<&'a T>, std::collections::Bound<&'a T>)","std::ops::RangeInclusive<&T>","std::ops::Range<T>","std::ops::RangeToInclusive<&T>","std::ops::Range<&T>"],"T":["RUG_ANY"]},"Splice":{"I":["IntoIter","DrainFilter","Splice","Drain"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // R
let mut p2 = MaybeUninit::uninit().assume_init(); // I
+p0.splice(p1, p2);
+SliceDeque::<T>::splice(p0, p1, p2);
+crate::SliceDeque::<T>::splice(p0, p1, p2);
+<SliceDeque<T>>::splice(p0, p1, p2);
-----------------
src/lib.rs SliceDeque::<T>::drain_filter
deps:{"SliceDeque::<T>::drain_filter":{"F":["std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"SliceDeque::<T>::drain_filter":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"],"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.drain_filter(p1);
+SliceDeque::<T>::drain_filter(p0, p1);
+crate::SliceDeque::<T>::drain_filter(p0, p1);
+<SliceDeque<T>>::drain_filter(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::extend_from_slice
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"IntoIter":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Send","std::marker::Sized","std::marker::Sync"]},"SliceDeque":{"T":["std::marker::Copy","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send","std::cmp::PartialOrd","std::default::Default","std::clone::Clone","std::hash::Hash","std::cmp::Eq"]},"SliceDeque::<T>::extend_from_slice":{"T":["std::clone::Clone","std::marker::Sized"]},"mirrored::buffer::Buffer":{"T":["std::marker::Sync","std::marker::Sized","std::clone::Clone","std::marker::Send"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"IntoIter":{"T":["IntoIter","SliceDeque","<*const T as std::fmt::Debug>"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::string::String","std::vec::Vec<T, A>"]},"SliceDeque::<T>::extend_from_slice":{"T":["SliceDeque","IntoIter","mirrored::buffer::Buffer","std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for *const T>"]},"mirrored::buffer::Buffer":{"T":["SliceDeque","<*mut T as std::marker::Send>","mirrored::buffer::Buffer","IntoIter"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [T]
+p0.extend_from_slice(p1);
+SliceDeque::<T>::extend_from_slice(p0, p1);
+crate::SliceDeque::<T>::extend_from_slice(p0, p1);
+<SliceDeque<T>>::extend_from_slice(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::resize
deps:{"<*const T as std::marker::Sync>":{},"<*mut T as std::marker::Send>":{},"IntoIter":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send","std::clone::Clone"]},"SliceDeque":{"T":["std::marker::Sized","std::marker::Copy","std::marker::Sync","std::cmp::PartialOrd","std::clone::Clone","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Send","std::cmp::Eq","std::cmp::PartialEq"]},"SliceDeque::<T>::resize":{"T":["std::clone::Clone","std::marker::Sized"]},"mirrored::buffer::Buffer":{"T":["std::clone::Clone","std::marker::Sync","std::marker::Sized","std::marker::Send"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::marker::Sync>":{},"<*mut T as std::marker::Send>":{},"IntoIter":{"T":["IntoIter","SliceDeque","<*mut T as std::marker::Send>"]},"SliceDeque":{"T":["std::vec::Vec<T, A>","std::borrow::Cow<'a, std::ffi::OsStr>","std::string::String"]},"SliceDeque::<T>::resize":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","IntoIter","std::clone::impls::<impl std::clone::Clone for &mut T>","mirrored::buffer::Buffer","SliceDeque"]},"mirrored::buffer::Buffer":{"T":["<*mut T as std::marker::Send>","SliceDeque","IntoIter","mirrored::buffer::Buffer"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.resize(p1, p2);
+SliceDeque::<T>::resize(p0, p1, p2);
+crate::SliceDeque::<T>::resize(p0, p1, p2);
+<SliceDeque<T>>::resize(p0, p1, p2);
-----------------
src/lib.rs SliceDeque::<T>::resize_default
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"IntoIter":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"SliceDeque":{"T":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::Sync","std::default::Default","std::marker::Send","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::hash::Hash","std::cmp::PartialOrd"]},"SliceDeque::<T>::resize_default":{"T":["std::default::Default","std::marker::Sized"]},"mirrored::buffer::Buffer":{"T":["std::marker::Sized","std::clone::Clone","std::marker::Send","std::marker::Sync"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"IntoIter":{"T":["SliceDeque","IntoIter","<*const T as std::fmt::Debug>"]},"SliceDeque":{"T":["std::vec::Vec<T, A>","std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>"]},"SliceDeque::<T>::resize_default":{"T":["SliceDeque","mirrored::buffer::Buffer"]},"mirrored::buffer::Buffer":{"T":["IntoIter","std::clone::impls::<impl std::clone::Clone for *const T>","mirrored::buffer::Buffer","SliceDeque"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = 0usize; // None+usize
+p0.resize_default(p1);
+SliceDeque::<T>::resize_default(p0, p1);
+crate::SliceDeque::<T>::resize_default(p0, p1);
+<SliceDeque<T>>::resize_default(p0, p1);
-----------------
src/lib.rs SliceDeque::<T>::dedup
deps:{"SliceDeque::<T>::dedup":{"T":["std::marker::Sized","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"SliceDeque::<T>::dedup":{"T":["char","i16","usize","i64","u64","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u16","i8","u32","bool","i32","u8"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.dedup();
+SliceDeque::<T>::dedup(p0);
+crate::SliceDeque::<T>::dedup(p0);
+<SliceDeque<T>>::dedup(p0);
-----------------
src/lib.rs SliceDeque::<T>::remove_item
deps:{"SliceDeque::<T>::remove_item":{"T":["std::marker::Sized","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"SliceDeque::<T>::remove_item":{"T":["i32","u64","usize","i16","i64","i8","u16","bool","u8","char","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u32"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.remove_item(p1);
+SliceDeque::<T>::remove_item(p0, p1);
+crate::SliceDeque::<T>::remove_item(p0, p1);
+<SliceDeque<T>>::remove_item(p0, p1);
-----------------
src/lib.rs <SliceDeque<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<SliceDeque<T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"Drain":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sync","std::marker::Sized"]},"DrainFilter":{"F":["std::marker::Sized","std::ops::FnMut","std::fmt::Debug"],"T":["std::marker::Sized","std::fmt::Debug"]},"IntoIter":{"T":["std::marker::Sync","std::marker::Send","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"SliceDeque":{"T":["std::cmp::PartialEq","std::hash::Hash","std::marker::Sized","std::default::Default","std::marker::Send","std::marker::Copy","std::clone::Clone","std::marker::Sync","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::Eq"]},"Splice":{"I":["std::marker::Sized","std::iter::Iterator","std::fmt::Debug"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<SliceDeque<T> as std::fmt::Debug>::fmt":{"T":["mirrored::AllocError","Drain","SliceDeque","Splice","<&T as std::fmt::Debug>","IntoIter","<*const T as std::fmt::Debug>","DrainFilter"]},"Drain":{"T":["SliceDeque","<*mut T as std::fmt::Debug>","Drain","IntoIter"]},"DrainFilter":{"T":["Splice","Drain","<*mut T as std::fmt::Debug>","mirrored::AllocError","DrainFilter","SliceDeque","IntoIter"]},"IntoIter":{"T":["IntoIter","<*mut T as std::marker::Send>","SliceDeque"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>","std::string::String"]},"Splice":{"I":["Splice","Drain","DrainFilter","IntoIter"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<SliceDeque<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<SliceDeque<T> as std::fmt::Debug>::fmt(p0, p1);
+<SliceDeque<T>>::fmt(p0, p1);
-----------------
src/lib.rs <SliceDeque<T> as std::ops::Drop>::drop
deps:{"<SliceDeque<T> as std::ops::Drop>::drop":{"T":["std::marker::Sized"]}}
candidates:{"<SliceDeque<T> as std::ops::Drop>::drop":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.drop();
+<SliceDeque<T> as std::ops::Drop>::drop(p0);
+crate::<SliceDeque<T> as std::ops::Drop>::drop(p0);
+<SliceDeque<T>>::drop(p0);
-----------------
src/lib.rs <SliceDeque<T> as std::ops::Deref>::deref
deps:{"<SliceDeque<T> as std::ops::Deref>::deref":{"T":["std::marker::Sized"]}}
candidates:{"<SliceDeque<T> as std::ops::Deref>::deref":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.deref();
+<SliceDeque<T> as std::ops::Deref>::deref(p0);
+crate::<SliceDeque<T> as std::ops::Deref>::deref(p0);
+<SliceDeque<T>>::deref(p0);
-----------------
src/lib.rs <SliceDeque<T> as std::ops::DerefMut>::deref_mut
deps:{"<SliceDeque<T> as std::ops::DerefMut>::deref_mut":{"T":["std::marker::Sized"]}}
candidates:{"<SliceDeque<T> as std::ops::DerefMut>::deref_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.deref_mut();
+<SliceDeque<T> as std::ops::DerefMut>::deref_mut(p0);
+crate::<SliceDeque<T> as std::ops::DerefMut>::deref_mut(p0);
+<SliceDeque<T>>::deref_mut(p0);
-----------------
src/lib.rs <SliceDeque<T> as std::default::Default>::default
deps:{"<SliceDeque<T> as std::default::Default>::default":{"T":["std::marker::Sized"]}}
candidates:{"<SliceDeque<T> as std::default::Default>::default":{"T":["RUG_ANY"]}}
+<SliceDeque<T> as std::default::Default>::default();
+crate::<SliceDeque<T> as std::default::Default>::default();
+<SliceDeque<T>>::default();
-----------------
src/lib.rs <SliceDeque<T> as std::clone::Clone>::clone
deps:{"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<SliceDeque<T> as std::clone::Clone>::clone":{"T":["std::marker::Sized","std::clone::Clone"]},"IntoIter":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::clone::Clone","std::marker::Send"]},"SliceDeque":{"T":["std::cmp::PartialEq","std::marker::Sync","std::default::Default","std::hash::Hash","std::cmp::PartialOrd","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Copy","std::marker::Send"]},"mirrored::buffer::Buffer":{"T":["std::clone::Clone","std::marker::Send","std::marker::Sync","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<SliceDeque<T> as std::clone::Clone>::clone":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","SliceDeque","mirrored::buffer::Buffer","IntoIter"]},"IntoIter":{"T":["<*const T as std::marker::Send>","IntoIter","SliceDeque"]},"SliceDeque":{"T":["std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>"]},"mirrored::buffer::Buffer":{"T":["IntoIter","std::clone::impls::<impl std::clone::Clone for *const T>","SliceDeque","mirrored::buffer::Buffer"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.clone();
+<SliceDeque<T> as std::clone::Clone>::clone(p0);
+crate::<SliceDeque<T> as std::clone::Clone>::clone(p0);
+<SliceDeque<T>>::clone(p0);
-----------------
src/lib.rs <SliceDeque<T> as std::clone::Clone>::clone_from
deps:{"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<SliceDeque<T> as std::clone::Clone>::clone_from":{"T":["std::clone::Clone","std::marker::Sized"]},"IntoIter":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::clone::Clone"]},"SliceDeque":{"T":["std::hash::Hash","std::clone::Clone","std::cmp::Eq","std::default::Default","std::marker::Copy","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialOrd","std::marker::Send","std::marker::Sync"]},"mirrored::buffer::Buffer":{"T":["std::marker::Send","std::marker::Sized","std::marker::Sync","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<SliceDeque<T> as std::clone::Clone>::clone_from":{"T":["IntoIter","std::clone::impls::<impl std::clone::Clone for &T>","SliceDeque","mirrored::buffer::Buffer","std::clone::impls::<impl std::clone::Clone for *const T>"]},"IntoIter":{"T":["IntoIter","SliceDeque","<*const T as std::marker::Sync>"]},"SliceDeque":{"T":["std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>"]},"mirrored::buffer::Buffer":{"T":["IntoIter","SliceDeque","mirrored::buffer::Buffer","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.clone_from(p1);
+<SliceDeque<T> as std::clone::Clone>::clone_from(p0, p1);
+crate::<SliceDeque<T> as std::clone::Clone>::clone_from(p0, p1);
+<SliceDeque<T>>::clone_from(p0, p1);
-----------------
src/lib.rs <SliceDeque<T> as std::convert::From<&'a [T]>>::from
'a
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<SliceDeque<T> as std::convert::From<&'a [T]>>::from":{"T":["std::marker::Sized","std::clone::Clone"]},"IntoIter":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::clone::Clone","std::marker::Send"]},"SliceDeque":{"T":["std::default::Default","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::marker::Send","std::cmp::PartialOrd","std::clone::Clone","std::cmp::PartialEq","std::marker::Sync","std::hash::Hash","std::marker::Copy"]},"mirrored::buffer::Buffer":{"T":["std::marker::Send","std::clone::Clone","std::marker::Sized","std::marker::Sync"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<SliceDeque<T> as std::convert::From<&'a [T]>>::from":{"T":["SliceDeque","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *const T>","mirrored::buffer::Buffer","IntoIter"]},"IntoIter":{"T":["<*const T as std::fmt::Debug>","SliceDeque","IntoIter"]},"SliceDeque":{"T":["std::vec::Vec<T, A>","std::borrow::Cow<'a, std::ffi::OsStr>","std::string::String"]},"mirrored::buffer::Buffer":{"T":["mirrored::buffer::Buffer","<*mut T as std::marker::Sync>","IntoIter","SliceDeque"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T]
+<SliceDeque<T> as std::convert::From<&'a [T]>>::from(p0);
+crate::<SliceDeque<T> as std::convert::From<&'a [T]>>::from(p0);
+<SliceDeque<T>>::from(p0);
-----------------
src/lib.rs <SliceDeque<T> as std::convert::From<&'a mut [T]>>::from
'a
deps:{"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::marker::Send>":{},"<SliceDeque<T> as std::convert::From<&'a mut [T]>>::from":{"T":["std::marker::Sized","std::clone::Clone"]},"IntoIter":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"SliceDeque":{"T":["std::hash::Hash","std::cmp::PartialOrd","std::cmp::Eq","std::marker::Copy","std::cmp::PartialEq","std::default::Default","std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Sync","std::clone::Clone"]},"mirrored::buffer::Buffer":{"T":["std::marker::Sized","std::marker::Sync","std::marker::Send","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::marker::Send>":{},"<SliceDeque<T> as std::convert::From<&'a mut [T]>>::from":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","IntoIter","SliceDeque","mirrored::buffer::Buffer","std::clone::impls::<impl std::clone::Clone for *const T>"]},"IntoIter":{"T":["IntoIter","std::clone::impls::<impl std::clone::Clone for *mut T>","SliceDeque"]},"SliceDeque":{"T":["std::vec::Vec<T, A>","std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>"]},"mirrored::buffer::Buffer":{"T":["mirrored::buffer::Buffer","<*mut T as std::marker::Send>","IntoIter","SliceDeque"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // [T]
+<SliceDeque<T> as std::convert::From<&'a mut [T]>>::from(p0);
+crate::<SliceDeque<T> as std::convert::From<&'a mut [T]>>::from(p0);
+<SliceDeque<T>>::from(p0);
-----------------
src/lib.rs <SliceDeque<T> as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<SliceDeque<T> as std::hash::Hash>::hash":{"H":["std::marker::Sized","std::hash::Hasher"],"T":["std::hash::Hash","std::marker::Sized"]},"SliceDeque":{"T":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::default::Default","std::hash::Hash","std::cmp::Eq","std::marker::Send","std::marker::Copy","std::cmp::PartialOrd","std::marker::Sync"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<SliceDeque<T> as std::hash::Hash>::hash":{"H":["std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::hash::sip::Hasher<S>","std::hash::SipHasher13","<&mut H as std::hash::Hasher>"],"T":["SliceDeque","std::hash::impls::<impl std::hash::Hash for &mut T>","std::hash::impls::<impl std::hash::Hash for *mut T>"]},"SliceDeque":{"T":["std::vec::Vec<T, A>","std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<SliceDeque<T> as std::hash::Hash>::hash(p0, p1);
+crate::<SliceDeque<T> as std::hash::Hash>::hash(p0, p1);
+<SliceDeque<T>>::hash(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<SliceDeque<B>>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<SliceDeque<B>>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<SliceDeque<B>>>::eq":{"A":["bool","u32","i32","usize","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i64","u8","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u16","i16","char","i8","u64"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // SliceDeque<B>
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<SliceDeque<B>>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<SliceDeque<B>>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B]>>::eq":{"A":["i64","u32","u8","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","usize","i32","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u64","u16","bool","i16","i8","char"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b mut [B]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b mut [B]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b mut [B]>>::eq":{"A":["i8","usize","i16","u64","i32","i64","u16","u32","bool","char","u8","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b mut [B]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b mut [B]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<std::vec::Vec<B>>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<std::vec::Vec<B>>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<std::vec::Vec<B>>>::eq":{"A":["usize","i8","char","u64","i64","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u8","i32","bool","u32","i16","u16","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::vec::Vec<B>
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<std::vec::Vec<B>>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<std::vec::Vec<B>>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 0]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 0]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 0]>>::eq":{"A":["bool","u8","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u16","i64","u32","u64","i8","char","usize","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i32","i16"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 0]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 0]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 0]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 0]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 0]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 0]>>::eq":{"A":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i8","char","i16","u16","u64","i32","u32","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","usize","i64","bool","u8"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 0]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 0]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 0]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 1]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 1]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 1]>>::eq":{"A":["u8","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i32","i64","u32","i16","u16","bool","usize","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","char","u64","i8"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 1]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 1]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 1]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 1]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 1]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 1]>>::eq":{"A":["u64","bool","u32","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","usize","i8","i16","char","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i32","u16","i64","u8"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 1]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 1]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 1]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 2]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 2]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 2]>>::eq":{"A":["i32","i8","u16","i16","u8","usize","char","i64","u32","u64","bool","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 2]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 2]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 2]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 2]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 2]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 2]>>::eq":{"A":["i64","u8","char","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u32","u16","i16","i8","bool","u64","usize","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i32"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 2]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 2]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 2]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 3]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 3]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 3]>>::eq":{"A":["i64","u16","i16","char","i32","u32","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","bool","u8","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u64","i8","usize"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 3]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 3]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 3]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 3]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 3]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 3]>>::eq":{"A":["i64","u64","i32","u16","char","u8","u32","i8","usize","i16","bool","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 3]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 3]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 3]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 4]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 4]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 4]>>::eq":{"A":["bool","i8","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i32","char","u16","u8","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i64","u64","usize","i16","u32"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 4]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 4]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 4]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 4]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 4]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 4]>>::eq":{"A":["u32","i16","usize","i64","char","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i8","bool","i32","u16","u64","u8"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 4]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 4]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 4]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 5]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 5]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 5]>>::eq":{"A":["i32","i16","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u32","u16","char","u64","bool","i64","i8","u8","usize"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 5]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 5]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 5]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 5]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 5]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 5]>>::eq":{"A":["i8","u16","i32","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u64","i16","usize","u32","char","u8","bool","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i64"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 5]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 5]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 5]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 6]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 6]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 6]>>::eq":{"A":["i64","u16","i8","char","u8","i16","i32","u32","u64","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","bool","usize"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 6]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 6]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 6]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 6]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 6]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 6]>>::eq":{"A":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","usize","u16","u32","i32","i8","i16","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","char","i64","bool","u8","u64"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 6]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 6]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 6]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 7]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 7]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 7]>>::eq":{"A":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","bool","u32","u16","u64","i64","usize","u8","i16","char","i8","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i32"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 7]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 7]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 7]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 7]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 7]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 7]>>::eq":{"A":["u32","char","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i64","usize","i8","i16","bool","u8","u16","u64","i32","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 7]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 7]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 7]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 8]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 8]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 8]>>::eq":{"A":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u32","char","usize","u64","i16","bool","i8","u8","u16","i64","i32"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 8]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 8]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 8]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 8]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 8]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 8]>>::eq":{"A":["u64","u16","i16","u32","i32","char","u8","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","bool","i64","i8","usize"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 8]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 8]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 8]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 9]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 9]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 9]>>::eq":{"A":["i32","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i64","u32","u64","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u8","char","i8","usize","bool","i16","u16"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 9]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 9]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 9]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 9]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 9]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 9]>>::eq":{"A":["char","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u32","u8","u64","usize","i64","i8","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u16","i32","bool","i16"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 9]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 9]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 9]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 10]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 10]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 10]>>::eq":{"A":["i64","u8","char","i32","i16","i8","u16","bool","u32","usize","u64","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 10]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 10]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 10]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 10]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 10]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 10]>>::eq":{"A":["i64","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","char","i16","u8","bool","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i32","u64","usize","i8","u16","u32"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 10]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 10]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 10]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 11]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 11]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 11]>>::eq":{"A":["char","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i32","u64","usize","i8","bool","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i64","u16","u32","i16","u8"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 11]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 11]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 11]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 11]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 11]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 11]>>::eq":{"A":["u8","i16","u16","u32","u64","char","i32","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i8","usize","bool","i64"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 11]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 11]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 11]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 12]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 12]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 12]>>::eq":{"A":["i64","i32","u16","u32","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u64","bool","char","i8","i16","usize","u8","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 12]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 12]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 12]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 12]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 12]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 12]>>::eq":{"A":["u16","i8","u8","usize","i16","i32","u64","i64","u32","char","bool","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 12]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 12]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 12]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 13]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 13]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 13]>>::eq":{"A":["i32","u64","u32","bool","u8","i16","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","char","u16","usize","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i64","i8"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 13]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 13]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 13]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 13]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 13]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 13]>>::eq":{"A":["i16","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u32","u8","i8","i32","char","usize","u64","i64","bool","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u16"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 13]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 13]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 13]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 14]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 14]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 14]>>::eq":{"A":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","char","i8","u32","i16","i32","bool","u8","usize","u64","u16","i64","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 14]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 14]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 14]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 14]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 14]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 14]>>::eq":{"A":["i64","usize","u8","i32","bool","i8","u64","u32","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u16","i16","char","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 14]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 14]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 14]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 15]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 15]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 15]>>::eq":{"A":["u32","u8","u64","bool","char","usize","i64","i8","i16","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u16","i32"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 15]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 15]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 15]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 15]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 15]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 15]>>::eq":{"A":["usize","i8","u8","u16","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u32","bool","char","i16","i64","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u64","i32"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 15]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 15]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 15]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 16]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 16]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 16]>>::eq":{"A":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","usize","u8","i16","u64","i32","i8","u16","bool","char","i64","u32"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 16]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 16]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 16]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 16]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 16]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 16]>>::eq":{"A":["i16","i32","u32","bool","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u16","usize","u8","u64","char","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i8","i64"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 16]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 16]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 16]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 17]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 17]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 17]>>::eq":{"A":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i8","char","u32","i32","usize","u16","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i16","bool","u8","u64","i64"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 17]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 17]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 17]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 17]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 17]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 17]>>::eq":{"A":["i8","u32","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","usize","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i64","i32","u16","u8","bool","i16","u64","char"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 17]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 17]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 17]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 18]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 18]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 18]>>::eq":{"A":["i32","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u32","u8","i64","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","bool","char","i16","u64","usize","i8","u16"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 18]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 18]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 18]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 18]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 18]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 18]>>::eq":{"A":["u16","u8","i32","u32","usize","char","i16","bool","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i8","i64","u64","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 18]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 18]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 18]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 19]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 19]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 19]>>::eq":{"A":["i32","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","usize","u64","i64","u32","bool","u16","char","i8","i16","u8"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 19]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 19]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 19]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 19]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 19]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 19]>>::eq":{"A":["i8","u16","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u32","char","i64","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u64","i16","u8","usize","bool","i32"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 19]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 19]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 19]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 20]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 20]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 20]>>::eq":{"A":["u16","bool","u64","i32","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u32","i16","u8","i8","usize","i64","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","char"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 20]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 20]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 20]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 20]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 20]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 20]>>::eq":{"A":["u32","char","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","usize","u64","i16","i32","u8","i8","i64","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u16","bool"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 20]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 20]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 20]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 21]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 21]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 21]>>::eq":{"A":["u16","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i64","u64","i16","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","bool","char","u32","u8","i8","i32","usize"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 21]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 21]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 21]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 21]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 21]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 21]>>::eq":{"A":["u64","usize","bool","i32","u16","i16","u32","i8","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i64","u8","char"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 21]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 21]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 21]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 22]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 22]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 22]>>::eq":{"A":["u64","bool","i8","usize","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u16","i16","i64","i32","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u8","u32","char"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 22]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 22]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 22]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 22]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 22]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 22]>>::eq":{"A":["bool","char","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u8","i8","i16","i64","usize","u16","u64","u32","i32","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 22]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 22]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 22]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 23]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 23]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 23]>>::eq":{"A":["u32","u64","usize","u16","bool","i8","u8","i32","i64","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i16","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","char"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 23]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 23]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 23]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 23]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 23]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 23]>>::eq":{"A":["u64","i8","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","char","usize","i32","i16","u8","u32","bool","i64","u16","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 23]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 23]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 23]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 24]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 24]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 24]>>::eq":{"A":["i16","u16","u32","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u64","usize","bool","i64","char","u8","i32","i8"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 24]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 24]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 24]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 24]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 24]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 24]>>::eq":{"A":["i64","u8","usize","u16","i16","i32","u32","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u64","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i8","bool","char"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 24]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 24]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 24]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 25]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 25]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 25]>>::eq":{"A":["u32","char","u8","u16","i16","i32","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u64","bool","usize","i8","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i64"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 25]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 25]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 25]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 25]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 25]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 25]>>::eq":{"A":["u16","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","usize","i16","u8","i64","bool","i8","i32","u32","char","u64"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 25]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 25]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 25]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 26]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 26]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 26]>>::eq":{"A":["usize","u8","u32","char","i8","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","bool","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i16","i64","u64","u16","i32"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 26]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 26]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 26]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 26]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 26]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 26]>>::eq":{"A":["u32","char","u16","i8","i16","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u8","u64","usize","i64","i32","bool","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 26]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 26]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 26]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 27]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 27]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 27]>>::eq":{"A":["bool","u8","char","u64","u16","i16","usize","i64","i32","u32","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i8"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 27]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 27]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 27]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 27]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 27]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 27]>>::eq":{"A":["u32","i8","u16","i16","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u64","u8","usize","i32","i64","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","char","bool"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 27]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 27]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 27]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 28]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 28]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 28]>>::eq":{"A":["usize","i16","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i8","bool","u32","u64","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i64","u16","char","i32","u8"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 28]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 28]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 28]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 28]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 28]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 28]>>::eq":{"A":["u32","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u64","u8","u16","i16","usize","char","bool","i64","i8","i32"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 28]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 28]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 28]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 29]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 29]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 29]>>::eq":{"A":["u8","i64","i32","u16","bool","i16","u32","i8","usize","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","char","u64"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 29]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 29]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 29]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 29]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 29]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 29]>>::eq":{"A":["u32","i64","u16","i16","char","i32","bool","u8","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u64","usize","i8","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 29]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 29]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 29]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 30]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 30]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 30]>>::eq":{"A":["u8","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i16","i8","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u32","i64","i32","u64","bool","usize","char","u16"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 30]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 30]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 30]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 30]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 30]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 30]>>::eq":{"A":["i16","char","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","bool","usize","i64","i32","u8","i8","u16","u64","u32","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 30]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 30]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 30]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 31]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 31]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 31]>>::eq":{"A":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","i8","i16","i64","usize","u16","bool","char","i32","u64","u32","u8"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 31]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 31]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 31]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 31]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 31]>>::eq":{"A":["std::cmp::PartialEq","std::marker::Sized"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 31]>>::eq":{"A":["i32","u16","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","u32","usize","i64","i16","char","u8","u64","bool","i8","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 31]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 31]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 31]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<[B; 32]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 32]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<[B; 32]>>::eq":{"A":["i64","i16","bool","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","u64","char","u16","usize","i8","u32","u8","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","i32"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & MaybeUninit::uninit().assume_init(); // [B; 32]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<[B; 32]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<[B; 32]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<A> as std::cmp::PartialEq<&'b [B; 32]>>::eq
'a,'b
deps:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 32]>>::eq":{"A":["std::marker::Sized","std::cmp::PartialEq"],"B":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 32]>>::eq":{"A":["bool","u8","i64","u64","u16","u32","i32","i16","char","i8","usize","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"],"B":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<A>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [B; 32]
+p0.eq(p1);
+<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 32]>>::eq(p0, p1);
+crate::<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 32]>>::eq(p0, p1);
+<SliceDeque<A>>::eq(p0, p1);
-----------------
src/lib.rs <SliceDeque<T> as std::cmp::PartialOrd>::partial_cmp
deps:{"<SliceDeque<T> as std::cmp::PartialOrd>::partial_cmp":{"T":["std::marker::Sized","std::cmp::PartialOrd"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<SliceDeque<T> as std::cmp::PartialOrd>::partial_cmp":{"T":["char","i64","u16","bool","std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>","u32","i16","u64","i8","usize","i32","u8"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.partial_cmp(p1);
+<SliceDeque<T> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<SliceDeque<T> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<SliceDeque<T>>::partial_cmp(p0, p1);
-----------------
src/lib.rs <SliceDeque<T> as std::cmp::PartialOrd<&'a [T]>>::partial_cmp
'a
deps:{"<SliceDeque<T> as std::cmp::PartialOrd<&'a [T]>>::partial_cmp":{"T":["std::marker::Sized","std::cmp::PartialOrd"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<SliceDeque<T> as std::cmp::PartialOrd<&'a [T]>>::partial_cmp":{"T":["u16","std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>","bool","i16","usize","u64","u8","i32","char","i8","i64","u32"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = & & MaybeUninit::uninit().assume_init(); // [T]
+p0.partial_cmp(p1);
+<SliceDeque<T> as std::cmp::PartialOrd<&'a [T]>>::partial_cmp(p0, p1);
+crate::<SliceDeque<T> as std::cmp::PartialOrd<&'a [T]>>::partial_cmp(p0, p1);
+<SliceDeque<T>>::partial_cmp(p0, p1);
-----------------
src/lib.rs <Drain<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<Drain<'a, T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"Drain":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Send","std::marker::Sized"]},"DrainFilter":{"F":["std::fmt::Debug","std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized","std::fmt::Debug"]},"IntoIter":{"T":["std::clone::Clone","std::marker::Send","std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"SliceDeque":{"T":["std::cmp::PartialOrd","std::marker::Copy","std::cmp::PartialEq","std::marker::Send","std::hash::Hash","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::default::Default","std::marker::Sync"]},"Splice":{"I":["std::fmt::Debug","std::marker::Sized","std::iter::Iterator"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<Drain<'a, T> as std::fmt::Debug>::fmt":{"T":["SliceDeque","mirrored::AllocError","Drain","Splice","<*const T as std::fmt::Debug>","IntoIter","DrainFilter"]},"Drain":{"T":["IntoIter","<*mut T as std::marker::Send>","SliceDeque","Drain"]},"DrainFilter":{"T":["SliceDeque","IntoIter","DrainFilter","<&mut T as std::fmt::Debug>","Drain","Splice","mirrored::AllocError"]},"IntoIter":{"T":["IntoIter","<*const T as std::marker::Sync>","SliceDeque"]},"SliceDeque":{"T":["std::string::String","std::vec::Vec<T, A>","std::borrow::Cow<'a, std::ffi::OsStr>"]},"Splice":{"I":["IntoIter","Splice","Drain","DrainFilter"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Drain<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<Drain<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<Drain<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<Drain<'a, T>>::fmt(p0, p1);
-----------------
src/lib.rs <Drain<'a, T> as std::iter::Iterator>::next
'a
deps:{"<Drain<'a, T> as std::iter::Iterator>::next":{"T":["std::marker::Sized"]}}
candidates:{"<Drain<'a, T> as std::iter::Iterator>::next":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Drain<'a, T>
+p0.next();
+<Drain<'a, T> as std::iter::Iterator>::next(p0);
+crate::<Drain<'a, T> as std::iter::Iterator>::next(p0);
+<Drain<'a, T>>::next(p0);
-----------------
src/lib.rs <Drain<'a, T> as std::iter::Iterator>::size_hint
'a
deps:{"<Drain<'a, T> as std::iter::Iterator>::size_hint":{"T":["std::marker::Sized"]}}
candidates:{"<Drain<'a, T> as std::iter::Iterator>::size_hint":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Drain<'a, T>
+p0.size_hint();
+<Drain<'a, T> as std::iter::Iterator>::size_hint(p0);
+crate::<Drain<'a, T> as std::iter::Iterator>::size_hint(p0);
+<Drain<'a, T>>::size_hint(p0);
-----------------
src/lib.rs <Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{"<Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back":{"T":["std::marker::Sized"]}}
candidates:{"<Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Drain<'a, T>
+p0.next_back();
+<Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back(p0);
+<Drain<'a, T>>::next_back(p0);
-----------------
src/lib.rs <Drain<'a, T> as std::ops::Drop>::drop
'a
deps:{"<Drain<'a, T> as std::ops::Drop>::drop":{"T":["std::marker::Sized"]}}
candidates:{"<Drain<'a, T> as std::ops::Drop>::drop":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Drain<'a, T>
+p0.drop();
+<Drain<'a, T> as std::ops::Drop>::drop(p0);
+crate::<Drain<'a, T> as std::ops::Drop>::drop(p0);
+<Drain<'a, T>>::drop(p0);
-----------------
src/lib.rs <IntoIter<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<IntoIter<T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"Drain":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Sync"]},"DrainFilter":{"F":["std::marker::Sized","std::fmt::Debug","std::ops::FnMut"],"T":["std::marker::Sized","std::fmt::Debug"]},"IntoIter":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Send","std::clone::Clone","std::marker::Sync"]},"SliceDeque":{"T":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::marker::Sync","std::clone::Clone","std::default::Default","std::hash::Hash","std::marker::Copy","std::fmt::Debug","std::cmp::PartialOrd","std::marker::Send"]},"Splice":{"I":["std::iter::Iterator","std::fmt::Debug","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<IntoIter<T> as std::fmt::Debug>::fmt":{"T":["SliceDeque","IntoIter","<&T as std::fmt::Debug>","mirrored::AllocError","DrainFilter","Splice","Drain"]},"Drain":{"T":["<*mut T as std::marker::Send>","Drain","SliceDeque","IntoIter"]},"DrainFilter":{"T":["<&mut T as std::fmt::Debug>","IntoIter","SliceDeque","Drain","DrainFilter","mirrored::AllocError","Splice"]},"IntoIter":{"T":["<*const T as std::marker::Sync>","SliceDeque","IntoIter"]},"SliceDeque":{"T":["std::vec::Vec<T, A>","std::borrow::Cow<'a, std::ffi::OsStr>","std::string::String"]},"Splice":{"I":["Splice","DrainFilter","IntoIter","Drain"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // IntoIter<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<IntoIter<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<IntoIter<T> as std::fmt::Debug>::fmt(p0, p1);
+<IntoIter<T>>::fmt(p0, p1);
-----------------
src/lib.rs IntoIter::<T>::as_slice
deps:{"IntoIter::<T>::as_slice":{"T":["std::marker::Sized"]}}
candidates:{"IntoIter::<T>::as_slice":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // IntoIter<T>
+p0.as_slice();
+IntoIter::<T>::as_slice(p0);
+crate::IntoIter::<T>::as_slice(p0);
+<IntoIter<T>>::as_slice(p0);
-----------------
src/lib.rs IntoIter::<T>::as_mut_slice
deps:{"IntoIter::<T>::as_mut_slice":{"T":["std::marker::Sized"]}}
candidates:{"IntoIter::<T>::as_mut_slice":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // IntoIter<T>
+p0.as_mut_slice();
+IntoIter::<T>::as_mut_slice(p0);
+crate::IntoIter::<T>::as_mut_slice(p0);
+<IntoIter<T>>::as_mut_slice(p0);
-----------------
src/lib.rs <IntoIter<T> as std::iter::Iterator>::next
deps:{"<IntoIter<T> as std::iter::Iterator>::next":{"T":["std::marker::Sized"]}}
candidates:{"<IntoIter<T> as std::iter::Iterator>::next":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // IntoIter<T>
+p0.next();
+<IntoIter<T> as std::iter::Iterator>::next(p0);
+crate::<IntoIter<T> as std::iter::Iterator>::next(p0);
+<IntoIter<T>>::next(p0);
-----------------
src/lib.rs <IntoIter<T> as std::iter::Iterator>::size_hint
deps:{"<IntoIter<T> as std::iter::Iterator>::size_hint":{"T":["std::marker::Sized"]}}
candidates:{"<IntoIter<T> as std::iter::Iterator>::size_hint":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // IntoIter<T>
+p0.size_hint();
+<IntoIter<T> as std::iter::Iterator>::size_hint(p0);
+crate::<IntoIter<T> as std::iter::Iterator>::size_hint(p0);
+<IntoIter<T>>::size_hint(p0);
-----------------
src/lib.rs <IntoIter<T> as std::iter::Iterator>::count
deps:{"<IntoIter<T> as std::iter::Iterator>::count":{"T":["std::marker::Sized"]}}
candidates:{"<IntoIter<T> as std::iter::Iterator>::count":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // IntoIter<T>
+p0.count();
+<IntoIter<T> as std::iter::Iterator>::count(p0);
+crate::<IntoIter<T> as std::iter::Iterator>::count(p0);
+<IntoIter<T>>::count(p0);
-----------------
src/lib.rs <IntoIter<T> as std::iter::DoubleEndedIterator>::next_back
deps:{"<IntoIter<T> as std::iter::DoubleEndedIterator>::next_back":{"T":["std::marker::Sized"]}}
candidates:{"<IntoIter<T> as std::iter::DoubleEndedIterator>::next_back":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // IntoIter<T>
+p0.next_back();
+<IntoIter<T> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<IntoIter<T> as std::iter::DoubleEndedIterator>::next_back(p0);
+<IntoIter<T>>::next_back(p0);
-----------------
src/lib.rs <IntoIter<T> as std::clone::Clone>::clone
deps:{"<*const T as std::marker::Sync>":{},"<*mut T as std::marker::Send>":{},"<IntoIter<T> as std::clone::Clone>::clone":{"T":["std::marker::Sized","std::clone::Clone"]},"IntoIter":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"SliceDeque":{"T":["std::hash::Hash","std::marker::Sync","std::default::Default","std::cmp::PartialEq","std::marker::Copy","std::marker::Send","std::cmp::PartialOrd","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"mirrored::buffer::Buffer":{"T":["std::clone::Clone","std::marker::Send","std::marker::Sized","std::marker::Sync"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::marker::Sync>":{},"<*mut T as std::marker::Send>":{},"<IntoIter<T> as std::clone::Clone>::clone":{"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","mirrored::buffer::Buffer","IntoIter","SliceDeque"]},"IntoIter":{"T":["IntoIter","<*const T as std::marker::Sync>","SliceDeque"]},"SliceDeque":{"T":["std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>"]},"mirrored::buffer::Buffer":{"T":["SliceDeque","<*const T as std::marker::Sync>","mirrored::buffer::Buffer","IntoIter"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // IntoIter<T>
+p0.clone();
+<IntoIter<T> as std::clone::Clone>::clone(p0);
+crate::<IntoIter<T> as std::clone::Clone>::clone(p0);
+<IntoIter<T>>::clone(p0);
-----------------
src/lib.rs <IntoIter<T> as std::ops::Drop>::drop
deps:{"<IntoIter<T> as std::ops::Drop>::drop":{"T":["std::marker::Sized"]}}
candidates:{"<IntoIter<T> as std::ops::Drop>::drop":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // IntoIter<T>
+p0.drop();
+<IntoIter<T> as std::ops::Drop>::drop(p0);
+crate::<IntoIter<T> as std::ops::Drop>::drop(p0);
+<IntoIter<T>>::drop(p0);
-----------------
src/lib.rs <SliceDeque<T> as std::iter::IntoIterator>::into_iter
deps:{"<SliceDeque<T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<SliceDeque<T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.into_iter();
+<SliceDeque<T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<SliceDeque<T> as std::iter::IntoIterator>::into_iter(p0);
+<SliceDeque<T>>::into_iter(p0);
-----------------
src/lib.rs <&'a SliceDeque<T> as std::iter::IntoIterator>::into_iter
'a
deps:{"<&'a SliceDeque<T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<&'a SliceDeque<T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.into_iter();
+<&'a SliceDeque<T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a SliceDeque<T> as std::iter::IntoIterator>::into_iter(p0);
+<&'a SliceDeque<T>>::into_iter(p0);
-----------------
src/lib.rs <&'a mut SliceDeque<T> as std::iter::IntoIterator>::into_iter
'a
deps:{"<&'a mut SliceDeque<T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<&'a mut SliceDeque<T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.into_iter();
+<&'a mut SliceDeque<T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a mut SliceDeque<T> as std::iter::IntoIterator>::into_iter(p0);
+<&'a mut SliceDeque<T>>::into_iter(p0);
-----------------
src/lib.rs <SliceDeque<T> as std::iter::Extend<T>>::extend
deps:{"<&'a SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<SliceDeque<T> as std::iter::Extend<T>>::extend":{"I":["std::marker::Sized","std::iter::IntoIterator"],"T":["std::marker::Sized"]},"Drain":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Sync"]},"DrainFilter":{"F":["std::ops::FnMut","std::marker::Sized","std::fmt::Debug"],"T":["std::fmt::Debug","std::marker::Sized"]},"IntoIter":{"T":["std::marker::Send","std::marker::Sync","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"SliceDeque":{"T":["std::marker::Send","std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::clone::Clone","std::cmp::PartialOrd","std::default::Default","std::marker::Copy","std::cmp::PartialEq","std::hash::Hash","std::cmp::Eq"]},"Splice":{"I":["std::marker::Sized","std::iter::Iterator","std::fmt::Debug"]}}
candidates:{"<&'a SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<I as std::iter::IntoIterator>":{"I":["Drain","<&mut I as std::iter::Iterator>","Splice","DrainFilter","IntoIter"]},"<SliceDeque<T> as std::iter::Extend<T>>::extend":{"I":["<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>","SliceDeque","<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>"],"T":["RUG_ANY"]},"Drain":{"T":["IntoIter","Drain","SliceDeque","<*mut T as std::fmt::Debug>"]},"DrainFilter":{"T":["SliceDeque","<*mut T as std::fmt::Debug>","mirrored::AllocError","IntoIter","DrainFilter","Drain","Splice"]},"IntoIter":{"T":["IntoIter","SliceDeque","<*mut T as std::marker::Send>"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>","std::string::String"]},"Splice":{"I":["IntoIter","Splice","Drain","DrainFilter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.extend(p1);
+<SliceDeque<T> as std::iter::Extend<T>>::extend(p0, p1);
+crate::<SliceDeque<T> as std::iter::Extend<T>>::extend(p0, p1);
+<SliceDeque<T>>::extend(p0, p1);
-----------------
src/lib.rs <SliceDeque<T> as SpecExtend<T, I>>::from_iter
deps:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<SliceDeque<T> as SpecExtend<T, I>>::from_iter":{"I":["std::marker::Sized","std::iter::Iterator"],"T":["std::marker::Sized"]},"Drain":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Send","std::marker::Sized"]},"DrainFilter":{"F":["std::fmt::Debug","std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized","std::fmt::Debug"]},"IntoIter":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Send","std::clone::Clone","std::marker::Sized"]},"SliceDeque":{"T":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::cmp::PartialOrd","std::marker::Copy","std::fmt::Debug","std::marker::Sync","std::hash::Hash","std::marker::Sized","std::marker::Send","std::default::Default"]},"Splice":{"I":["std::marker::Sized","std::fmt::Debug","std::iter::Iterator"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<SliceDeque<T> as SpecExtend<T, I>>::from_iter":{"I":["Splice","Drain","IntoIter","DrainFilter","<&mut I as std::iter::Iterator>"],"T":["RUG_ANY"]},"Drain":{"T":["<*const T as std::fmt::Debug>","IntoIter","Drain","SliceDeque"]},"DrainFilter":{"T":["<&mut T as std::fmt::Debug>","DrainFilter","mirrored::AllocError","Splice","SliceDeque","IntoIter","Drain"]},"IntoIter":{"T":["SliceDeque","IntoIter","<*const T as std::marker::Sync>"]},"SliceDeque":{"T":["std::string::String","std::vec::Vec<T, A>","std::borrow::Cow<'a, std::ffi::OsStr>"]},"Splice":{"I":["Drain","Splice","IntoIter","DrainFilter"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<SliceDeque<T> as SpecExtend<T, I>>::from_iter(p0);
+crate::<SliceDeque<T> as SpecExtend<T, I>>::from_iter(p0);
+<SliceDeque<T>>::from_iter(p0);
-----------------
src/lib.rs <SliceDeque<T> as SpecExtend<T, I>>::spec_extend
deps:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<SliceDeque<T> as SpecExtend<T, I>>::spec_extend":{"I":["std::marker::Sized","std::iter::Iterator"],"T":["std::marker::Sized"]},"Drain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"DrainFilter":{"F":["std::ops::FnMut","std::fmt::Debug","std::marker::Sized"],"T":["std::marker::Sized","std::fmt::Debug"]},"IntoIter":{"T":["std::marker::Sized","std::marker::Sync","std::marker::Send","std::clone::Clone","std::fmt::Debug"]},"SliceDeque":{"T":["std::cmp::PartialEq","std::marker::Sized","std::marker::Send","std::marker::Copy","std::fmt::Debug","std::cmp::PartialOrd","std::default::Default","std::hash::Hash","std::marker::Sync","std::clone::Clone","std::cmp::Eq"]},"Splice":{"I":["std::fmt::Debug","std::marker::Sized","std::iter::Iterator"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<SliceDeque<T> as SpecExtend<T, I>>::spec_extend":{"I":["Drain","<&mut I as std::iter::Iterator>","DrainFilter","Splice","IntoIter"],"T":["RUG_ANY"]},"Drain":{"T":["<*mut T as std::marker::Sync>","IntoIter","SliceDeque","Drain"]},"DrainFilter":{"T":["<*const T as std::fmt::Debug>","Splice","IntoIter","Drain","DrainFilter","SliceDeque","mirrored::AllocError"]},"IntoIter":{"T":["SliceDeque","IntoIter","<*const T as std::fmt::Debug>"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>","std::string::String"]},"Splice":{"I":["IntoIter","Drain","Splice","DrainFilter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.spec_extend(p1);
+<SliceDeque<T> as SpecExtend<T, I>>::spec_extend(p0, p1);
+crate::<SliceDeque<T> as SpecExtend<T, I>>::spec_extend(p0, p1);
+<SliceDeque<T>>::spec_extend(p0, p1);
-----------------
src/lib.rs <SliceDeque<T> as SpecExtend<&'a T, I>>::from_iter
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<SliceDeque<T> as SpecExtend<&'a T, I>>::from_iter":{"I":["std::marker::Sized","std::iter::Iterator"],"T":["std::clone::Clone","std::marker::Sized"]},"Drain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Send","std::marker::Sync"]},"DrainFilter":{"F":["std::ops::FnMut","std::fmt::Debug","std::marker::Sized"],"T":["std::marker::Sized","std::fmt::Debug"]},"IntoIter":{"T":["std::clone::Clone","std::marker::Sync","std::marker::Sized","std::fmt::Debug","std::marker::Send"]},"SliceDeque":{"T":["std::marker::Sync","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::default::Default","std::fmt::Debug","std::hash::Hash","std::cmp::PartialEq","std::cmp::PartialOrd","std::marker::Copy","std::marker::Send"]},"Splice":{"I":["std::iter::Iterator","std::fmt::Debug","std::marker::Sized"]},"mirrored::buffer::Buffer":{"T":["std::marker::Sync","std::marker::Send","std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<SliceDeque<T> as SpecExtend<&'a T, I>>::from_iter":{"I":["DrainFilter","IntoIter","Drain","<&mut I as std::iter::Iterator>","Splice"],"T":["IntoIter","std::clone::impls::<impl std::clone::Clone for *const T>","SliceDeque","mirrored::buffer::Buffer"]},"Drain":{"T":["SliceDeque","Drain","IntoIter","<*mut T as std::fmt::Debug>"]},"DrainFilter":{"T":["mirrored::AllocError","<&mut T as std::fmt::Debug>","SliceDeque","Splice","DrainFilter","IntoIter","Drain"]},"IntoIter":{"T":["<*mut T as std::fmt::Debug>","SliceDeque","IntoIter"]},"SliceDeque":{"T":["std::vec::Vec<T, A>","std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>"]},"Splice":{"I":["Splice","DrainFilter","IntoIter","Drain"]},"mirrored::buffer::Buffer":{"T":["SliceDeque","IntoIter","mirrored::buffer::Buffer","<*mut T as std::marker::Send>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<SliceDeque<T> as SpecExtend<&'a T, I>>::from_iter(p0);
+crate::<SliceDeque<T> as SpecExtend<&'a T, I>>::from_iter(p0);
+<SliceDeque<T>>::from_iter(p0);
-----------------
src/lib.rs <SliceDeque<T> as SpecExtend<&'a T, I>>::spec_extend
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<SliceDeque<T> as SpecExtend<&'a T, I>>::spec_extend":{"I":["std::marker::Sized","std::iter::Iterator"],"T":["std::marker::Sized","std::clone::Clone"]},"Drain":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sync","std::marker::Sized"]},"DrainFilter":{"F":["std::marker::Sized","std::ops::FnMut","std::fmt::Debug"],"T":["std::fmt::Debug","std::marker::Sized"]},"IntoIter":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"SliceDeque":{"T":["std::clone::Clone","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Send","std::cmp::Eq","std::cmp::PartialEq","std::marker::Copy","std::hash::Hash","std::default::Default","std::marker::Sync","std::marker::Sized"]},"Splice":{"I":["std::fmt::Debug","std::iter::Iterator","std::marker::Sized"]},"mirrored::buffer::Buffer":{"T":["std::clone::Clone","std::marker::Sync","std::marker::Send","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<SliceDeque<T> as SpecExtend<&'a T, I>>::spec_extend":{"I":["<&mut I as std::iter::Iterator>","IntoIter","Drain","Splice","DrainFilter"],"T":["std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","mirrored::buffer::Buffer","IntoIter","SliceDeque"]},"Drain":{"T":["IntoIter","Drain","SliceDeque","<*const T as std::marker::Sync>"]},"DrainFilter":{"T":["SliceDeque","Splice","mirrored::AllocError","Drain","IntoIter","DrainFilter","<*const T as std::fmt::Debug>"]},"IntoIter":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","IntoIter","SliceDeque"]},"SliceDeque":{"T":["std::string::String","std::vec::Vec<T, A>","std::borrow::Cow<'a, std::ffi::OsStr>"]},"Splice":{"I":["Drain","DrainFilter","IntoIter","Splice"]},"mirrored::buffer::Buffer":{"T":["mirrored::buffer::Buffer","<*mut T as std::marker::Send>","SliceDeque","IntoIter"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.spec_extend(p1);
+<SliceDeque<T> as SpecExtend<&'a T, I>>::spec_extend(p0, p1);
+crate::<SliceDeque<T> as SpecExtend<&'a T, I>>::spec_extend(p0, p1);
+<SliceDeque<T>>::spec_extend(p0, p1);
-----------------
src/lib.rs <SliceDeque<T> as std::iter::FromIterator<T>>::from_iter
deps:{"<&'a SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<SliceDeque<T> as std::iter::FromIterator<T>>::from_iter":{"I":["std::marker::Sized","std::iter::IntoIterator"],"T":["std::marker::Sized"]},"Drain":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized","std::marker::Send"]},"DrainFilter":{"F":["std::fmt::Debug","std::ops::FnMut","std::marker::Sized"],"T":["std::fmt::Debug","std::marker::Sized"]},"IntoIter":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized","std::marker::Send","std::clone::Clone"]},"SliceDeque":{"T":["std::marker::Sync","std::hash::Hash","std::cmp::PartialOrd","std::marker::Copy","std::cmp::Eq","std::marker::Sized","std::marker::Send","std::fmt::Debug","std::default::Default","std::clone::Clone","std::cmp::PartialEq"]},"Splice":{"I":["std::marker::Sized","std::fmt::Debug","std::iter::Iterator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<&'a SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<I as std::iter::IntoIterator>":{"I":["<&mut I as std::iter::Iterator>","IntoIter","DrainFilter","Splice","Drain"]},"<SliceDeque<T> as std::iter::FromIterator<T>>::from_iter":{"I":["SliceDeque","<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>","<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>"],"T":["RUG_ANY"]},"Drain":{"T":["SliceDeque","<*mut T as std::marker::Sync>","Drain","IntoIter"]},"DrainFilter":{"T":["IntoIter","Splice","Drain","DrainFilter","SliceDeque","<*mut T as std::fmt::Debug>","mirrored::AllocError"]},"IntoIter":{"T":["<*mut T as std::marker::Send>","IntoIter","SliceDeque"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>","std::string::String"]},"Splice":{"I":["IntoIter","Drain","DrainFilter","Splice"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<SliceDeque<T> as std::iter::FromIterator<T>>::from_iter(p0);
+crate::<SliceDeque<T> as std::iter::FromIterator<T>>::from_iter(p0);
+<SliceDeque<T>>::from_iter(p0);
-----------------
src/lib.rs <ExtendElement<T> as ExtendWith<T>>::next
deps:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"<ExtendElement<T> as ExtendWith<T>>::next":{"T":["std::marker::Sized","std::clone::Clone"]},"IntoIter":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::marker::Send","std::marker::Sync"]},"SliceDeque":{"T":["std::marker::Sized","std::fmt::Debug","std::hash::Hash","std::clone::Clone","std::default::Default","std::cmp::Eq","std::cmp::PartialOrd","std::marker::Send","std::cmp::PartialEq","std::marker::Copy","std::marker::Sync"]},"mirrored::buffer::Buffer":{"T":["std::clone::Clone","std::marker::Send","std::marker::Sync","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"<ExtendElement<T> as ExtendWith<T>>::next":{"T":["mirrored::buffer::Buffer","IntoIter","std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for *mut T>","SliceDeque"]},"IntoIter":{"T":["<*mut T as std::marker::Send>","IntoIter","SliceDeque"]},"SliceDeque":{"T":["std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>"]},"mirrored::buffer::Buffer":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","IntoIter","SliceDeque","mirrored::buffer::Buffer"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ExtendElement<T>
+p0.next();
+<ExtendElement<T> as ExtendWith<T>>::next(p0);
+crate::<ExtendElement<T> as ExtendWith<T>>::next(p0);
+<ExtendElement<T>>::next(p0);
-----------------
src/lib.rs <ExtendElement<T> as ExtendWith<T>>::last
deps:{"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::marker::Sync>":{},"<ExtendElement<T> as ExtendWith<T>>::last":{"T":["std::clone::Clone","std::marker::Sized"]},"IntoIter":{"T":["std::marker::Sized","std::marker::Send","std::marker::Sync","std::clone::Clone","std::fmt::Debug"]},"SliceDeque":{"T":["std::default::Default","std::cmp::PartialEq","std::marker::Send","std::marker::Sync","std::fmt::Debug","std::hash::Hash","std::cmp::Eq","std::cmp::PartialOrd","std::marker::Copy","std::marker::Sized","std::clone::Clone"]},"mirrored::buffer::Buffer":{"T":["std::marker::Send","std::marker::Sync","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::marker::Sync>":{},"<ExtendElement<T> as ExtendWith<T>>::last":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","SliceDeque","mirrored::buffer::Buffer","std::clone::impls::<impl std::clone::Clone for &mut T>","IntoIter"]},"IntoIter":{"T":["SliceDeque","IntoIter","<*const T as std::marker::Sync>"]},"SliceDeque":{"T":["std::vec::Vec<T, A>","std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>"]},"mirrored::buffer::Buffer":{"T":["IntoIter","std::clone::impls::<impl std::clone::Clone for *mut T>","SliceDeque","mirrored::buffer::Buffer"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ExtendElement<T>
+p0.last();
+<ExtendElement<T> as ExtendWith<T>>::last(p0);
+crate::<ExtendElement<T> as ExtendWith<T>>::last(p0);
+<ExtendElement<T>>::last(p0);
-----------------
src/lib.rs <ExtendDefault as ExtendWith<T>>::next
deps:{"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<ExtendDefault as ExtendWith<T>>::next":{"T":["std::default::Default","std::marker::Sized"]},"IntoIter":{"T":["std::clone::Clone","std::marker::Sync","std::fmt::Debug","std::marker::Send","std::marker::Sized"]},"SliceDeque":{"T":["std::cmp::PartialOrd","std::marker::Sync","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Copy","std::marker::Send","std::hash::Hash","std::cmp::Eq","std::default::Default"]},"mirrored::buffer::Buffer":{"T":["std::clone::Clone","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<ExtendDefault as ExtendWith<T>>::next":{"T":["mirrored::buffer::Buffer","SliceDeque"]},"IntoIter":{"T":["SliceDeque","<*mut T as std::fmt::Debug>","IntoIter"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>","std::string::String"]},"mirrored::buffer::Buffer":{"T":["mirrored::buffer::Buffer","<*mut T as std::marker::Sync>","IntoIter","SliceDeque"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ExtendDefault
+p0.next();
+<ExtendDefault as ExtendWith<T>>::next(p0);
+crate::<ExtendDefault as ExtendWith<T>>::next(p0);
+<ExtendDefault>::next(p0);
-----------------
src/lib.rs <ExtendDefault as ExtendWith<T>>::last
deps:{"<*const T as std::marker::Sync>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<ExtendDefault as ExtendWith<T>>::last":{"T":["std::marker::Sized","std::default::Default"]},"IntoIter":{"T":["std::marker::Sync","std::marker::Sized","std::clone::Clone","std::marker::Send","std::fmt::Debug"]},"SliceDeque":{"T":["std::marker::Sync","std::cmp::PartialOrd","std::cmp::Eq","std::marker::Copy","std::clone::Clone","std::marker::Send","std::cmp::PartialEq","std::hash::Hash","std::marker::Sized","std::default::Default","std::fmt::Debug"]},"mirrored::buffer::Buffer":{"T":["std::clone::Clone","std::marker::Send","std::marker::Sized","std::marker::Sync"]}}
candidates:{"<*const T as std::marker::Sync>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<ExtendDefault as ExtendWith<T>>::last":{"T":["mirrored::buffer::Buffer","SliceDeque"]},"IntoIter":{"T":["SliceDeque","IntoIter","<*mut T as std::marker::Send>"]},"SliceDeque":{"T":["std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>"]},"mirrored::buffer::Buffer":{"T":["<*mut T as std::marker::Sync>","SliceDeque","mirrored::buffer::Buffer","IntoIter"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ExtendDefault
+p0.last();
+<ExtendDefault as ExtendWith<T>>::last(p0);
+crate::<ExtendDefault as ExtendWith<T>>::last(p0);
+<ExtendDefault>::last(p0);
-----------------
src/lib.rs <T as SpecFromElem>::from_elem
deps:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<T as SpecFromElem>::from_elem":{"T":["std::clone::Clone","std::marker::Sized"]},"IntoIter":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug","std::clone::Clone","std::marker::Sync"]},"SliceDeque":{"T":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::hash::Hash","std::cmp::Eq","std::cmp::PartialOrd","std::marker::Sync","std::default::Default","std::fmt::Debug","std::marker::Send","std::marker::Copy"]},"mirrored::buffer::Buffer":{"T":["std::clone::Clone","std::marker::Sized","std::marker::Send","std::marker::Sync"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<T as SpecFromElem>::from_elem":{"T":["SliceDeque","IntoIter","mirrored::buffer::Buffer","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for &T>"]},"IntoIter":{"T":["<*mut T as std::marker::Sync>","IntoIter","SliceDeque"]},"SliceDeque":{"T":["std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>"]},"mirrored::buffer::Buffer":{"T":["<*const T as std::marker::Send>","mirrored::buffer::Buffer","SliceDeque","IntoIter"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0usize; // None+usize
+<T as SpecFromElem>::from_elem(p0, p1);
+crate::<T as SpecFromElem>::from_elem(p0, p1);
+<T>::from_elem(p0, p1);
-----------------
src/lib.rs <SliceDeque<T> as std::iter::Extend<&'a T>>::extend
'a
deps:{"<&'a SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<SliceDeque<T> as std::iter::Extend<&'a T>>::extend":{"I":["std::marker::Sized","std::iter::IntoIterator"],"T":["std::marker::Copy","std::marker::Sized"]},"Drain":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized","std::marker::Sync"]},"DrainFilter":{"F":["std::fmt::Debug","std::ops::FnMut","std::marker::Sized"],"T":["std::fmt::Debug","std::marker::Sized"]},"IntoIter":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug","std::clone::Clone","std::marker::Sync"]},"SliceDeque":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized","std::hash::Hash","std::cmp::Eq","std::marker::Copy","std::cmp::PartialOrd","std::clone::Clone","std::marker::Send","std::cmp::PartialEq","std::default::Default"]},"Splice":{"I":["std::marker::Sized","std::fmt::Debug","std::iter::Iterator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
candidates:{"<&'a SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut SliceDeque<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["<&mut I as std::iter::Iterator>","DrainFilter","Splice","IntoIter","Drain"]},"<SliceDeque<T> as std::iter::Extend<&'a T>>::extend":{"I":["SliceDeque","<&'a std::option::Option<T> as std::iter::IntoIterator>","<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>"],"T":["i16","u8","std::marker::copy_impls::<impl std::marker::Copy for *mut T>","i8","u64","bool","u16","i32","u32","usize","i64","char"]},"Drain":{"T":["Drain","<*mut T as std::fmt::Debug>","SliceDeque","IntoIter"]},"DrainFilter":{"T":["mirrored::AllocError","<&mut T as std::fmt::Debug>","DrainFilter","IntoIter","Splice","Drain","SliceDeque"]},"IntoIter":{"T":["IntoIter","SliceDeque","std::clone::impls::<impl std::clone::Clone for *const T>"]},"SliceDeque":{"T":["std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>"]},"Splice":{"I":["Splice","IntoIter","DrainFilter","Drain"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for &T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.extend(p1);
+<SliceDeque<T> as std::iter::Extend<&'a T>>::extend(p0, p1);
+crate::<SliceDeque<T> as std::iter::Extend<&'a T>>::extend(p0, p1);
+<SliceDeque<T>>::extend(p0, p1);
-----------------
src/lib.rs <Splice<'a, I> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<Splice<'a, I> as std::fmt::Debug>::fmt":{"<I as std::iter::Iterator>::Item":["std::fmt::Debug"],"I":["std::marker::Sized","std::iter::Iterator","std::fmt::Debug"]},"Drain":{"T":["std::marker::Sync","std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"DrainFilter":{"F":["std::fmt::Debug","std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized","std::fmt::Debug"]},"IntoIter":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"SliceDeque":{"T":["std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::hash::Hash","std::fmt::Debug","std::marker::Sync","std::cmp::PartialOrd","std::marker::Copy","std::marker::Send","std::marker::Sized","std::cmp::Eq"]},"Splice":{"I":["std::fmt::Debug","std::marker::Sized","std::iter::Iterator"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<Splice<'a, I> as std::fmt::Debug>::fmt":{"<I as std::iter::Iterator>::Item":["Splice","IntoIter","DrainFilter","Drain","SliceDeque","<*mut T as std::fmt::Debug>","mirrored::AllocError"],"I":["DrainFilter","Drain","IntoIter","Splice"]},"Drain":{"T":["SliceDeque","Drain","IntoIter","<*mut T as std::fmt::Debug>"]},"DrainFilter":{"T":["mirrored::AllocError","SliceDeque","IntoIter","Drain","<&T as std::fmt::Debug>","DrainFilter","Splice"]},"IntoIter":{"T":["<*mut T as std::marker::Sync>","SliceDeque","IntoIter"]},"SliceDeque":{"T":["std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>"]},"Splice":{"I":["Splice","DrainFilter","Drain","IntoIter"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Splice<'a, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<Splice<'a, I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<Splice<'a, I> as std::fmt::Debug>::fmt(p0, p1);
+<Splice<'a, I>>::fmt(p0, p1);
-----------------
src/lib.rs <Splice<'a, I> as std::iter::Iterator>::next
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<Splice<'a, I> as std::iter::Iterator>::next":{"I":["std::marker::Sized","std::iter::Iterator"]},"Drain":{"T":["std::marker::Sync","std::marker::Send","std::marker::Sized","std::fmt::Debug"]},"DrainFilter":{"F":["std::marker::Sized","std::ops::FnMut","std::fmt::Debug"],"T":["std::marker::Sized","std::fmt::Debug"]},"IntoIter":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sync","std::marker::Sized","std::clone::Clone"]},"SliceDeque":{"T":["std::cmp::Eq","std::default::Default","std::hash::Hash","std::cmp::PartialOrd","std::marker::Copy","std::marker::Send","std::clone::Clone","std::marker::Sized","std::marker::Sync","std::cmp::PartialEq","std::fmt::Debug"]},"Splice":{"I":["std::marker::Sized","std::iter::Iterator","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<Splice<'a, I> as std::iter::Iterator>::next":{"I":["<&mut I as std::iter::Iterator>","Drain","Splice","IntoIter","DrainFilter"]},"Drain":{"T":["SliceDeque","Drain","<*mut T as std::marker::Sync>","IntoIter"]},"DrainFilter":{"T":["IntoIter","Drain","SliceDeque","Splice","DrainFilter","mirrored::AllocError","<*const T as std::fmt::Debug>"]},"IntoIter":{"T":["SliceDeque","IntoIter","<*mut T as std::marker::Send>"]},"SliceDeque":{"T":["std::vec::Vec<T, A>","std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>"]},"Splice":{"I":["Drain","Splice","DrainFilter","IntoIter"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Splice<'a, I>
+p0.next();
+<Splice<'a, I> as std::iter::Iterator>::next(p0);
+crate::<Splice<'a, I> as std::iter::Iterator>::next(p0);
+<Splice<'a, I>>::next(p0);
-----------------
src/lib.rs <Splice<'a, I> as std::iter::Iterator>::size_hint
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<Splice<'a, I> as std::iter::Iterator>::size_hint":{"I":["std::marker::Sized","std::iter::Iterator"]},"Drain":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug","std::marker::Sync"]},"DrainFilter":{"F":["std::fmt::Debug","std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized","std::fmt::Debug"]},"IntoIter":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Send","std::marker::Sync","std::clone::Clone"]},"SliceDeque":{"T":["std::default::Default","std::marker::Copy","std::marker::Send","std::marker::Sized","std::marker::Sync","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::hash::Hash","std::cmp::Eq","std::cmp::PartialOrd"]},"Splice":{"I":["std::fmt::Debug","std::marker::Sized","std::iter::Iterator"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<Splice<'a, I> as std::iter::Iterator>::size_hint":{"I":["Splice","<&mut I as std::iter::Iterator>","Drain","IntoIter","DrainFilter"]},"Drain":{"T":["SliceDeque","Drain","IntoIter","<*const T as std::marker::Send>"]},"DrainFilter":{"T":["<*const T as std::fmt::Debug>","SliceDeque","Splice","mirrored::AllocError","DrainFilter","IntoIter","Drain"]},"IntoIter":{"T":["<*mut T as std::fmt::Debug>","SliceDeque","IntoIter"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>","std::string::String"]},"Splice":{"I":["DrainFilter","IntoIter","Splice","Drain"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Splice<'a, I>
+p0.size_hint();
+<Splice<'a, I> as std::iter::Iterator>::size_hint(p0);
+crate::<Splice<'a, I> as std::iter::Iterator>::size_hint(p0);
+<Splice<'a, I>>::size_hint(p0);
-----------------
src/lib.rs <Splice<'a, I> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<Splice<'a, I> as std::iter::DoubleEndedIterator>::next_back":{"I":["std::iter::Iterator","std::marker::Sized"]},"Drain":{"T":["std::marker::Send","std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"DrainFilter":{"F":["std::marker::Sized","std::ops::FnMut","std::fmt::Debug"],"T":["std::marker::Sized","std::fmt::Debug"]},"IntoIter":{"T":["std::marker::Send","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"SliceDeque":{"T":["std::cmp::Eq","std::marker::Sized","std::default::Default","std::fmt::Debug","std::cmp::PartialOrd","std::clone::Clone","std::hash::Hash","std::marker::Send","std::marker::Sync","std::cmp::PartialEq","std::marker::Copy"]},"Splice":{"I":["std::iter::Iterator","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<Splice<'a, I> as std::iter::DoubleEndedIterator>::next_back":{"I":["Splice","DrainFilter","Drain","<&mut I as std::iter::Iterator>","IntoIter"]},"Drain":{"T":["IntoIter","Drain","<*const T as std::marker::Send>","SliceDeque"]},"DrainFilter":{"T":["<&T as std::fmt::Debug>","SliceDeque","IntoIter","DrainFilter","mirrored::AllocError","Splice","Drain"]},"IntoIter":{"T":["<*mut T as std::marker::Send>","IntoIter","SliceDeque"]},"SliceDeque":{"T":["std::vec::Vec<T, A>","std::borrow::Cow<'a, std::ffi::OsStr>","std::string::String"]},"Splice":{"I":["Splice","Drain","DrainFilter","IntoIter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Splice<'a, I>
+p0.next_back();
+<Splice<'a, I> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<Splice<'a, I> as std::iter::DoubleEndedIterator>::next_back(p0);
+<Splice<'a, I>>::next_back(p0);
-----------------
src/lib.rs <Splice<'a, I> as std::ops::Drop>::drop
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<Splice<'a, I> as std::ops::Drop>::drop":{"I":["std::iter::Iterator","std::marker::Sized"]},"Drain":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"DrainFilter":{"F":["std::marker::Sized","std::fmt::Debug","std::ops::FnMut"],"T":["std::fmt::Debug","std::marker::Sized"]},"IntoIter":{"T":["std::marker::Sized","std::clone::Clone","std::marker::Send","std::marker::Sync","std::fmt::Debug"]},"SliceDeque":{"T":["std::marker::Sync","std::hash::Hash","std::default::Default","std::marker::Send","std::marker::Sized","std::cmp::Eq","std::marker::Copy","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::PartialOrd"]},"Splice":{"I":["std::fmt::Debug","std::marker::Sized","std::iter::Iterator"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<Splice<'a, I> as std::ops::Drop>::drop":{"I":["<&mut I as std::iter::Iterator>","IntoIter","Splice","Drain","DrainFilter"]},"Drain":{"T":["<*mut T as std::marker::Send>","Drain","SliceDeque","IntoIter"]},"DrainFilter":{"T":["mirrored::AllocError","DrainFilter","Splice","IntoIter","SliceDeque","<&T as std::fmt::Debug>","Drain"]},"IntoIter":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","SliceDeque","IntoIter"]},"SliceDeque":{"T":["std::string::String","std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>"]},"Splice":{"I":["Drain","Splice","IntoIter","DrainFilter"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Splice<'a, I>
+p0.drop();
+<Splice<'a, I> as std::ops::Drop>::drop(p0);
+crate::<Splice<'a, I> as std::ops::Drop>::drop(p0);
+<Splice<'a, I>>::drop(p0);
-----------------
src/lib.rs Drain::<'a, T>::fill
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"Drain":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sync","std::marker::Sized"]},"Drain::<'a, T>::fill":{"I":["std::iter::Iterator","std::marker::Sized"],"T":["std::marker::Sized"]},"DrainFilter":{"F":["std::ops::FnMut","std::marker::Sized","std::fmt::Debug"],"T":["std::marker::Sized","std::fmt::Debug"]},"IntoIter":{"T":["std::clone::Clone","std::marker::Send","std::marker::Sync","std::marker::Sized","std::fmt::Debug"]},"SliceDeque":{"T":["std::clone::Clone","std::default::Default","std::cmp::Eq","std::cmp::PartialOrd","std::marker::Copy","std::cmp::PartialEq","std::marker::Send","std::marker::Sync","std::hash::Hash","std::marker::Sized","std::fmt::Debug"]},"Splice":{"I":["std::marker::Sized","std::iter::Iterator","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"Drain":{"T":["IntoIter","SliceDeque","<*mut T as std::marker::Send>","Drain"]},"Drain::<'a, T>::fill":{"I":["Splice","Drain","DrainFilter","IntoIter","<&mut I as std::iter::Iterator>"],"T":["RUG_ANY"]},"DrainFilter":{"T":["Drain","Splice","IntoIter","DrainFilter","mirrored::AllocError","SliceDeque","<&T as std::fmt::Debug>"]},"IntoIter":{"T":["std::clone::impls::<impl std::clone::Clone for *const T>","IntoIter","SliceDeque"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::vec::Vec<T, A>","std::string::String"]},"Splice":{"I":["Drain","DrainFilter","Splice","IntoIter"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Drain<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // I
+p0.fill(p1);
+Drain::<'a, T>::fill(p0, p1);
+crate::Drain::<'a, T>::fill(p0, p1);
+<Drain<'a, T>>::fill(p0, p1);
-----------------
src/lib.rs Drain::<'a, T>::move_tail_unchecked
'a
deps:{"Drain::<'a, T>::move_tail_unchecked":{"T":["std::marker::Sized"]}}
candidates:{"Drain::<'a, T>::move_tail_unchecked":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Drain<'a, T>
let mut p1 = 0usize; // None+usize
+p0.move_tail_unchecked(p1);
+Drain::<'a, T>::move_tail_unchecked(p0, p1);
+crate::Drain::<'a, T>::move_tail_unchecked(p0, p1);
+<Drain<'a, T>>::move_tail_unchecked(p0, p1);
-----------------
src/lib.rs <DrainFilter<'a, T, F> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<DrainFilter<'a, T, F> as std::fmt::Debug>::fmt":{"F":["std::ops::FnMut","std::marker::Sized","std::fmt::Debug"],"T":["std::marker::Sized","std::fmt::Debug"]},"Drain":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized","std::marker::Send"]},"DrainFilter":{"F":["std::marker::Sized","std::fmt::Debug","std::ops::FnMut"],"T":["std::fmt::Debug","std::marker::Sized"]},"IntoIter":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Send","std::clone::Clone","std::marker::Sync"]},"SliceDeque":{"T":["std::hash::Hash","std::marker::Send","std::clone::Clone","std::fmt::Debug","std::marker::Sync","std::cmp::Eq","std::cmp::PartialEq","std::cmp::PartialOrd","std::marker::Sized","std::default::Default","std::marker::Copy"]},"Splice":{"I":["std::marker::Sized","std::iter::Iterator","std::fmt::Debug"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<DrainFilter<'a, T, F> as std::fmt::Debug>::fmt":{"T":["IntoIter","Drain","mirrored::AllocError","Splice","<*const T as std::fmt::Debug>","DrainFilter","SliceDeque"]},"Drain":{"T":["Drain","<*mut T as std::marker::Send>","SliceDeque","IntoIter"]},"DrainFilter":{"T":["SliceDeque","IntoIter","DrainFilter","mirrored::AllocError","Drain","Splice","<*const T as std::fmt::Debug>"]},"IntoIter":{"T":["IntoIter","<*mut T as std::fmt::Debug>","SliceDeque"]},"SliceDeque":{"T":["std::borrow::Cow<'a, std::ffi::OsStr>","std::string::String","std::vec::Vec<T, A>"]},"Splice":{"I":["Drain","Splice","DrainFilter","IntoIter"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // DrainFilter<'a, T, F>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<DrainFilter<'a, T, F> as std::fmt::Debug>::fmt(p0, p1);
+crate::<DrainFilter<'a, T, F> as std::fmt::Debug>::fmt(p0, p1);
+<DrainFilter<'a, T, F>>::fmt(p0, p1);
-----------------
src/lib.rs <DrainFilter<'a, T, F> as std::iter::Iterator>::next
'a
deps:{"<DrainFilter<'a, T, F> as std::iter::Iterator>::next":{"F":["std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<DrainFilter<'a, T, F> as std::iter::Iterator>::next":{"F":["core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty"],"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DrainFilter<'a, T, F>
+p0.next();
+<DrainFilter<'a, T, F> as std::iter::Iterator>::next(p0);
+crate::<DrainFilter<'a, T, F> as std::iter::Iterator>::next(p0);
+<DrainFilter<'a, T, F>>::next(p0);
-----------------
src/lib.rs <DrainFilter<'a, T, F> as std::iter::Iterator>::size_hint
'a
deps:{"<DrainFilter<'a, T, F> as std::iter::Iterator>::size_hint":{"F":["std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<DrainFilter<'a, T, F> as std::iter::Iterator>::size_hint":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"],"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // DrainFilter<'a, T, F>
+p0.size_hint();
+<DrainFilter<'a, T, F> as std::iter::Iterator>::size_hint(p0);
+crate::<DrainFilter<'a, T, F> as std::iter::Iterator>::size_hint(p0);
+<DrainFilter<'a, T, F>>::size_hint(p0);
-----------------
src/lib.rs <DrainFilter<'a, T, F> as std::ops::Drop>::drop
'a
deps:{"<DrainFilter<'a, T, F> as std::ops::Drop>::drop":{"F":["std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<DrainFilter<'a, T, F> as std::ops::Drop>::drop":{"F":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"],"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DrainFilter<'a, T, F>
+p0.drop();
+<DrainFilter<'a, T, F> as std::ops::Drop>::drop(p0);
+crate::<DrainFilter<'a, T, F> as std::ops::Drop>::drop(p0);
+<DrainFilter<'a, T, F>>::drop(p0);
-----------------
src/lib.rs <SliceDeque<T> as std::convert::AsRef<[T]>>::as_ref
deps:{"<SliceDeque<T> as std::convert::AsRef<[T]>>::as_ref":{"T":["std::marker::Sized"]}}
candidates:{"<SliceDeque<T> as std::convert::AsRef<[T]>>::as_ref":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.as_ref();
+<SliceDeque<T> as std::convert::AsRef<[T]>>::as_ref(p0);
+crate::<SliceDeque<T> as std::convert::AsRef<[T]>>::as_ref(p0);
+<SliceDeque<T>>::as_ref(p0);
-----------------
src/lib.rs <SliceDeque<T> as std::convert::AsMut<[T]>>::as_mut
deps:{"<SliceDeque<T> as std::convert::AsMut<[T]>>::as_mut":{"T":["std::marker::Sized"]}}
candidates:{"<SliceDeque<T> as std::convert::AsMut<[T]>>::as_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // SliceDeque<T>
+p0.as_mut();
+<SliceDeque<T> as std::convert::AsMut<[T]>>::as_mut(p0);
+crate::<SliceDeque<T> as std::convert::AsMut<[T]>>::as_mut(p0);
+<SliceDeque<T>>::as_mut(p0);