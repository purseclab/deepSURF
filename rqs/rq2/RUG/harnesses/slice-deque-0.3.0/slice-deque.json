{"dependencies":{"<&'a SliceDeque<T> as std::iter::IntoIterator>::into_iter":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"<&'a mut SliceDeque<T> as std::iter::IntoIterator>::into_iter":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull","std::slice::IterMut"],"<*const T as WrappingOffsetFrom>::wrapping_offset_from_":["std::marker::Sized","std::option::Option"],"<Drain<'a, T> as std::fmt::Debug>::fmt":["Drain","std::fmt::Formatter","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::slice::Iter"],"<Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back":["Drain","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<Drain<'a, T> as std::iter::Iterator>::next":["Drain","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<Drain<'a, T> as std::iter::Iterator>::size_hint":["Drain","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<Drain<'a, T> as std::ops::Drop>::drop":["Drain","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"<DrainFilter<'a, T, F> as std::fmt::Debug>::fmt":["DrainFilter","SliceDeque","mirrored::buffer::Buffer","std::fmt::Formatter","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","std::result::Result"],"<DrainFilter<'a, T, F> as std::iter::Iterator>::next":["DrainFilter","SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ops::FnMut","std::option::Option","std::ptr::NonNull"],"<DrainFilter<'a, T, F> as std::iter::Iterator>::size_hint":["DrainFilter","SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ops::FnMut","std::option::Option","std::ptr::NonNull"],"<DrainFilter<'a, T, F> as std::ops::Drop>::drop":["DrainFilter","SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"<ExtendDefault as ExtendWith<T>>::last":["ExtendDefault"],"<ExtendDefault as ExtendWith<T>>::next":["ExtendDefault"],"<ExtendElement<T> as ExtendWith<T>>::last":["ExtendElement","std::marker::Sized"],"<ExtendElement<T> as ExtendWith<T>>::next":["ExtendElement","std::marker::Sized"],"<IntoIter<T> as std::clone::Clone>::clone":["IntoIter","std::marker::Sized","std::ptr::NonNull"],"<IntoIter<T> as std::fmt::Debug>::fmt":["IntoIter","std::fmt::Formatter","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"<IntoIter<T> as std::iter::DoubleEndedIterator>::next_back":["IntoIter","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<IntoIter<T> as std::iter::Iterator>::count":["IntoIter","std::marker::Sized","std::ptr::NonNull"],"<IntoIter<T> as std::iter::Iterator>::next":["IntoIter","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<IntoIter<T> as std::iter::Iterator>::size_hint":["IntoIter","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<IntoIter<T> as std::ops::Drop>::drop":["IntoIter","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 0]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 10]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 11]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 12]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 13]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 14]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 15]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 16]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 17]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 18]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 19]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 1]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 20]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 21]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 22]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 23]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 24]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 25]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 26]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 27]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 28]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 29]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 2]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 30]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 31]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 32]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 3]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 4]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 5]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 6]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 7]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 8]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 9]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<&'b mut [B]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<SliceDeque<B>>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 0]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 10]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 11]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 12]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 13]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 14]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 15]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 16]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 17]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 18]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 19]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 1]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 20]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 21]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 22]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 23]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 24]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 25]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 26]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 27]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 28]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 29]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 2]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 30]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 31]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 32]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 3]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 4]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 5]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 6]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 7]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 8]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 9]>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<A> as std::cmp::PartialEq<std::vec::Vec<B>>>::eq":["SliceDeque","mirrored::buffer::Buffer","std::alloc::Allocator","std::marker::Sized","std::ptr::NonNull","std::vec::Vec"],"<SliceDeque<T> as SpecExtend<&'a T, I>>::from_iter":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as SpecExtend<&'a T, I>>::spec_extend":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as SpecExtend<T, I>>::from_iter":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as SpecExtend<T, I>>::spec_extend":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::clone::Clone>::clone":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::clone::Clone>::clone_from":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::cmp::PartialOrd<&'a [T]>>::partial_cmp":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<SliceDeque<T> as std::cmp::PartialOrd>::partial_cmp":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"<SliceDeque<T> as std::convert::AsMut<[T]>>::as_mut":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::convert::AsRef<[T]>>::as_ref":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::convert::From<&'a [T]>>::from":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::convert::From<&'a mut [T]>>::from":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::default::Default>::default":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::fmt::Debug>::fmt":["SliceDeque","mirrored::buffer::Buffer","std::fmt::Formatter","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"<SliceDeque<T> as std::hash::Hash>::hash":["SliceDeque","mirrored::buffer::Buffer","std::hash::Hasher","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::iter::Extend<&'a T>>::extend":["SliceDeque","mirrored::buffer::Buffer","std::iter::IntoIterator","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::iter::Extend<T>>::extend":["SliceDeque","mirrored::buffer::Buffer","std::iter::IntoIterator","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::iter::FromIterator<T>>::from_iter":["SliceDeque","mirrored::buffer::Buffer","std::iter::IntoIterator","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::iter::IntoIterator>::into_iter":["IntoIter","SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::ops::Deref>::deref":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::ops::DerefMut>::deref_mut":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<SliceDeque<T> as std::ops::Drop>::drop":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<Splice<'a, I> as std::fmt::Debug>::fmt":["Drain","Splice","std::fmt::Formatter","std::iter::Iterator","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::slice::Iter"],"<Splice<'a, I> as std::iter::DoubleEndedIterator>::next_back":["Drain","Splice","std::iter::Iterator","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<Splice<'a, I> as std::iter::Iterator>::next":["Drain","Splice","std::iter::Iterator","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<Splice<'a, I> as std::iter::Iterator>::size_hint":["Drain","Splice","std::iter::Iterator","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<Splice<'a, I> as std::ops::Drop>::drop":["Drain","Splice","std::iter::Iterator","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"<T as SpecFromElem>::from_elem":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<macros::TinyAsciiString as std::fmt::Write>::write_str":["macros::TinyAsciiString","std::marker::Sized","std::result::Result"],"<mirrored::AllocError as std::fmt::Debug>::fmt":["mirrored::AllocError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<mirrored::buffer::Buffer<T> as std::clone::Clone>::clone":["mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<mirrored::buffer::Buffer<T> as std::default::Default>::default":["mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"<mirrored::buffer::Buffer<T> as std::ops::Drop>::drop":["mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"Drain":["Drain","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"Drain::<'a, T>::fill":["Drain","std::iter::Iterator","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"Drain::<'a, T>::move_tail_unchecked":["Drain","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"DrainFilter":["DrainFilter","SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"ExtendDefault":["ExtendDefault"],"ExtendElement":["ExtendElement","std::marker::Sized"],"ExtendWith::last":[],"ExtendWith::next":[],"IntoIter":["IntoIter","std::marker::Sized","std::ptr::NonNull"],"IntoIter::<T>::as_mut_slice":["IntoIter","std::marker::Sized","std::ptr::NonNull"],"IntoIter::<T>::as_slice":["IntoIter","std::marker::Sized","std::ptr::NonNull"],"SliceDeque":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::append":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::append_elements":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::as_mut_slice":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::as_mut_slices":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::as_slice":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::as_slices":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::back":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"SliceDeque::<T>::back_mut":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"SliceDeque::<T>::capacity":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::clear":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::dedup":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::dedup_by":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"SliceDeque::<T>::dedup_by_key":["SliceDeque","mirrored::buffer::Buffer","std::cmp::PartialEq","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"SliceDeque::<T>::drain":["Drain","SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ops::RangeBounds","std::ptr::NonNull","std::slice::Iter"],"SliceDeque::<T>::drain_filter":["DrainFilter","SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"SliceDeque::<T>::extend_desugared":["Drain","SliceDeque","mirrored::buffer::Buffer","std::iter::Iterator","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"SliceDeque::<T>::extend_from_slice":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::extend_with":["ExtendDefault","ExtendWith","SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::from_raw_parts":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::front":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"SliceDeque::<T>::front_mut":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"SliceDeque::<T>::grow_policy":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::insert":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::is_full":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::len":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::move_head":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::move_head_unchecked":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::move_tail":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::move_tail_unchecked":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::new":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::pop_back":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"SliceDeque::<T>::pop_front":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"SliceDeque::<T>::push_back":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::push_front":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::remove":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::remove_item":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"SliceDeque::<T>::reserve":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::reserve_capacity":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"SliceDeque::<T>::reserve_exact":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::resize":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::resize_default":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::retain":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull"],"SliceDeque::<T>::shrink_to_fit":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::splice":["Drain","SliceDeque","Splice","mirrored::buffer::Buffer","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","std::ops::RangeBounds","std::ptr::NonNull","std::slice::Iter"],"SliceDeque::<T>::split_off":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::steal_from_slice":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::swap_remove_back":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"SliceDeque::<T>::swap_remove_front":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"SliceDeque::<T>::tail_head_slice":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::truncate":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::truncate_back":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::truncate_front":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SliceDeque::<T>::try_push_back":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"SliceDeque::<T>::try_push_front":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"SliceDeque::<T>::try_reserve":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull","std::result::Result"],"SliceDeque::<T>::with_capacity":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"SpecExtend::from_iter":[],"SpecExtend::spec_extend":[],"SpecFromElem::from_elem":["SliceDeque","mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"Splice":["Drain","Splice","std::iter::Iterator","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"WrappingOffsetFrom::wrapping_offset_from_":["std::marker::Sized","std::option::Option"],"from_elem":["IntoIter","SliceDeque","mirrored::buffer::Buffer","std::clone::Clone","std::marker::Sized","std::ptr::NonNull"],"from_iter_default":["Drain","SliceDeque","mirrored::buffer::Buffer","std::iter::Iterator","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"in_bounds":["std::marker::Sized"],"intrinsics::arith_offset":["std::marker::Sized"],"intrinsics::assume":["std::marker::Sized"],"intrinsics::unlikely":["std::marker::Sized"],"macros::TinyAsciiString":["macros::TinyAsciiString"],"macros::TinyAsciiString::as_str":["macros::TinyAsciiString"],"macros::TinyAsciiString::new":["macros::TinyAsciiString"],"mirrored::AllocError":["mirrored::AllocError"],"mirrored::buffer::Buffer":["mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"mirrored::buffer::Buffer::<T>::as_mut_slice":["mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"mirrored::buffer::Buffer::<T>::as_slice":["mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"mirrored::buffer::Buffer::<T>::empty_len":[],"mirrored::buffer::Buffer::<T>::from_raw_parts":["mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"mirrored::buffer::Buffer::<T>::get":["mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"mirrored::buffer::Buffer::<T>::get_mut":["mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"mirrored::buffer::Buffer::<T>::is_empty":["mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"mirrored::buffer::Buffer::<T>::len":["mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"mirrored::buffer::Buffer::<T>::new":["mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"mirrored::buffer::Buffer::<T>::ptr":["mirrored::buffer::Buffer","std::marker::Sized","std::ptr::NonNull"],"mirrored::buffer::Buffer::<T>::size_in_bytes":[],"mirrored::buffer::Buffer::<T>::uninitialized":["std::marker::Sized","std::result::Result"],"mirrored::buffer::no_required_allocation_units":[],"mirrored::linux::allocate_mirrored":["std::marker::Sized","std::result::Result"],"mirrored::linux::allocation_granularity":[],"mirrored::linux::deallocate_mirrored":[],"mirrored::linux::errno":[],"mirrored::linux::memfd_create":[],"mirrored::linux::print_error":[],"nonnull_raw_slice":["std::marker::Sized","std::ptr::NonNull"]},"glob_path_import":{},"self_to_fn":{"<T as SpecFromElem>::T":["impl<T: Clone> SpecFromElem for T {\n    #[cfg(feature = \"unstable\")]\n    default fn from_elem(elem: Self, n: usize) -> SliceDeque<Self> {\n        let mut v = SliceDeque::with_capacity(n);\n        v.extend_with(n, ExtendElement(elem));\n        v\n    }\n\n    #[cfg(not(feature = \"unstable\"))]\n    fn from_elem(elem: Self, n: usize) -> SliceDeque<Self> {\n        let mut v = SliceDeque::with_capacity(n);\n        v.extend_with(n, ExtendElement(elem));\n        v\n    }\n}"],"Drain":["impl<'a, T: 'a + fmt::Debug> fmt::Debug for Drain<'a, T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n    }\n}","impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n        self.iter\n            .next_back()\n            .map(|elt| unsafe { ptr::read(elt as *const _) })\n    }\n}","impl<'a, T> Drain<'a, T> {\n    /// The range from `self.deq.tail` to `self.tail()_start` contains elements\n    /// that have been moved out.\n    /// Fill that range as much as possible with new elements from the\n    /// `replace_with` iterator. Return whether we filled the entire\n    /// range. (`replace_with.next()` didnâ€™t return `None`.)\n    unsafe fn fill<I: Iterator<Item = T>>(\n        &mut self, replace_with: &mut I,\n    ) -> bool {\n        let deq = self.deq.as_mut();\n        let range_start = deq.len();\n        let range_end = self.tail_start;\n        let range_slice = slice::from_raw_parts_mut(\n            deq.as_mut_ptr().add(range_start),\n            range_end - range_start,\n        );\n\n        for place in range_slice {\n            if let Some(new_item) = replace_with.next() {\n                ptr::write(place, new_item);\n                deq.move_tail_unchecked(1);\n            } else {\n                return false;\n            }\n        }\n        true\n    }\n\n    /// Make room for inserting more elements before the tail.\n    unsafe fn move_tail_unchecked(&mut self, extra_capacity: usize) {\n        let deq = self.deq.as_mut();\n        let used_capacity = self.tail_start + self.tail_len;\n        deq.reserve_capacity(used_capacity + extra_capacity)\n            .expect(\"oom\");\n\n        let new_tail_start = self.tail_start + extra_capacity;\n        let src = deq.as_ptr().add(self.tail_start);\n        let dst = deq.as_mut_ptr().add(new_tail_start);\n        ptr::copy(src, dst, self.tail_len);\n        self.tail_start = new_tail_start;\n    }\n}","impl<'a, T> Drop for Drain<'a, T> {\n    #[inline]\n    fn drop(&mut self) {\n        // exhaust self first\n        self.for_each(|_| {});\n\n        if self.tail_len > 0 {\n            unsafe {\n                let source_deq = self.deq.as_mut();\n                // memmove back untouched tail, update to new length\n                let start = source_deq.len();\n                let tail = self.tail_start;\n                let src = source_deq.as_ptr().add(tail);\n                let dst = source_deq.as_mut_ptr().add(start);\n                ptr::copy(src, dst, self.tail_len);\n                source_deq.move_tail_unchecked(self.tail_len as isize);\n            }\n        }\n    }\n}","impl<'a, T> Iterator for Drain<'a, T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        self.iter\n            .next()\n            .map(|elt| unsafe { ptr::read(elt as *const _) })\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}","unsafe impl<'a, T: Send> Send for Drain<'a, T> {}","unsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}"],"DrainFilter":["Debug","impl<'a, T, F> Drop for DrainFilter<'a, T, F>\nwhere\n    F: FnMut(&mut T) -> bool,\n{\n    fn drop(&mut self) {\n        for _ in self.by_ref() {}\n        \n        unsafe {\n            let v = slice::from_raw_parts_mut(\n                self.deq.as_mut_ptr(),\n                self.old_len,\n            );\n            //println!(\"{:?}\", v);\n            let new_len = self.old_len - self.del;\n            self.deq.move_tail_unchecked(new_len as isize);\n            let v = slice::from_raw_parts_mut(\n                self.deq.as_mut_ptr(),\n                self.old_len,\n            );\n        }\n    }\n}","impl<'a, T, F> Iterator for DrainFilter<'a, T, F>\nwhere\n    F: FnMut(&mut T) -> bool,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n        unsafe {\n            while self.idx != self.old_len {\n                let i = self.idx;\n                self.idx += 1;\n                let v = slice::from_raw_parts_mut(\n                    self.deq.as_mut_ptr(),\n                    self.old_len,\n                );\n                if (self.pred)(&mut v[i]) {\n                    self.del += 1;\n                    return Some(ptr::read(&v[i]));\n                } else if self.del > 0 {\n                    let del = self.del;\n                    let src: *const T = &v[i];\n                    let dst: *mut T = &mut v[i - del];\n                    // This is safe because self.deq has length 0\n                    // thus its elements will not have Drop::drop\n                    // called on them in the event of a panic.\n                    ptr::copy_nonoverlapping(src, dst, 1);\n                }\n            }\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        println!(\"Now\");\n        (0, Some(self.old_len - self.idx))\n    }\n}"],"ExtendDefault":["impl<T: Default> ExtendWith<T> for ExtendDefault {\n    fn next(&self) -> T {\n        Default::default()\n    }\n    fn last(self) -> T {\n        Default::default()\n    }\n}"],"ExtendElement":["impl<T: Clone> ExtendWith<T> for ExtendElement<T> {\n    fn next(&self) -> T {\n        self.0.clone()\n    }\n    fn last(self) -> T {\n        self.0\n    }\n}"],"IntoIter":["impl<T: Clone> Clone for IntoIter<T> {\n    #[inline]\n    fn clone(&self) -> Self {\n        let mut deq = SliceDeque::<T>::with_capacity(self.size_hint().0);\n        unsafe {\n            deq.append_elements(self.as_slice());\n        }\n        deq.into_iter()\n    }\n}","impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n    }\n}","impl<T> DoubleEndedIterator for IntoIter<T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n        unsafe {\n            if self.end == self.ptr {\n                None\n            } else if mem::size_of::<T>() == 0 {\n                // See above for why 'ptr.offset' isn't used\n                self.end = intrinsics::arith_offset(self.end as *const i8, -1)\n                    as *mut T;\n\n                // Use a non-null pointer value\n                // (self.end might be null because of wrapping)\n                Some(ptr::read(1 as *mut T))\n            } else {\n                self.end = self.end.offset(-1);\n\n                Some(ptr::read(self.end))\n            }\n        }\n    }\n}","impl<T> Drop for IntoIter<T> {\n    #[inline]\n    fn drop(&mut self) {\n        // destroy the remaining elements\n        for _x in self.by_ref() {}\n\n        // Buffer handles deallocation\n        let _ =\n            unsafe { Buffer::from_raw_parts(self.buf.as_ptr(), 2 * self.cap) };\n    }\n}","impl<T> IntoIter<T> {\n    /// Returns the element slice\n    #[cfg(feature = \"unstable\")]\n    #[allow(clippy::option_unwrap_used)]\n    #[inline]\n    fn elems(&mut self) -> &mut [T] {\n        unsafe {\n            slice::from_raw_parts_mut(\n                self.ptr as *mut _,\n                (self.end as usize - self.ptr as usize) / mem::size_of::<T>(),\n            )\n        }\n    }\n\n    /// Returns the remaining items of this iterator as a slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq!['a', 'b', 'c'];\n    /// let mut into_iter = deq.into_iter();\n    /// assert_eq!(into_iter.as_slice(), ['a', 'b', 'c']);\n    /// let _ = into_iter.next().unwrap();\n    /// assert_eq!(into_iter.as_slice(), ['b', 'c']);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn as_slice(&self) -> &[T] {\n        unsafe { slice::from_raw_parts(self.ptr, self.size_hint().0) }\n    }\n\n    /// Returns the remaining items of this iterator as a mutable slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq!['a', 'b', 'c'];\n    /// let mut into_iter = deq.into_iter();\n    /// assert_eq!(into_iter.as_slice(), ['a', 'b', 'c']);\n    /// into_iter.as_mut_slice()[2] = 'z';\n    /// assert_eq!(into_iter.next().unwrap(), 'a');\n    /// assert_eq!(into_iter.next().unwrap(), 'b');\n    /// assert_eq!(into_iter.next().unwrap(), 'z');\n    /// # }\n    /// ```\n    #[inline]\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\n        unsafe {\n            slice::from_raw_parts_mut(self.ptr as *mut T, self.size_hint().0)\n        }\n    }\n}","impl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        unsafe {\n            if self.ptr as *const _ == self.end {\n                None\n            } else if mem::size_of::<T>() == 0 {\n                // purposefully don't use 'ptr.offset' because for\n                // deques with 0-size elements this would return the\n                // same pointer.\n                self.ptr = intrinsics::arith_offset(self.ptr as *const i8, 1)\n                    as *mut T;\n\n                // Use a non-null pointer value\n                // (self.ptr might be null because of wrapping)\n                Some(ptr::read(1 as *mut T))\n            } else {\n                let old = self.ptr;\n                self.ptr = self.ptr.add(1);\n\n                Some(ptr::read(old))\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let exact = match self.ptr.wrapping_offset_from_(self.end) {\n            Some(x) => x as usize,\n            None => (self.end as usize).wrapping_sub(self.ptr as usize),\n        };\n        (exact, Some(exact))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.size_hint().0\n    }\n}","unsafe impl<T: Send> Send for IntoIter<T> {}","unsafe impl<T: Sync> Sync for IntoIter<T> {}"],"SliceDeque":["impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs\n        where\n            A: PartialEq<B>,\n        {\n            #[inline]\n            fn eq(&self, other: &$Rhs) -> bool {\n                self[..] == other[..]\n            }\n        }","impl<'a, T: 'a + Copy> Extend<&'a T> for SliceDeque<T> {\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n        self.spec_extend(iter.into_iter())\n    }\n}","impl<'a, T: 'a, I> SpecExtend<&'a T, I> for SliceDeque<T>\nwhere\n    I: Iterator<Item = &'a T>,\n    T: Clone,\n{\n    fn from_iter(iterator: I) -> Self {\n        SpecExtend::from_iter(iterator.cloned())\n    }\n\n    fn spec_extend(&mut self, iterator: I) {\n        self.spec_extend(iterator.cloned())\n    }\n}","impl<'a, T: Clone> From<&'a [T]> for SliceDeque<T> {\n    #[inline]\n    fn from(s: &'a [T]) -> Self {\n        let mut new = Self::with_capacity(s.len());\n        for i in s {\n            new.push_back(i.clone());\n        }\n        new\n    }\n}","impl<'a, T: Clone> From<&'a mut [T]> for SliceDeque<T> {\n    #[inline]\n    fn from(s: &'a mut [T]) -> Self {\n        let mut new = Self::with_capacity(s.len());\n        for i in s {\n            new.push_back(i.clone());\n        }\n        new\n    }\n}","impl<'a, T: PartialOrd> PartialOrd<&'a [T]> for SliceDeque<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &&'a [T]) -> Option<cmp::Ordering> {\n        PartialOrd::partial_cmp(&**self, other)\n    }\n}","impl<T, I> SpecExtend<T, I> for SliceDeque<T>\nwhere\n    I: Iterator<Item = T>,\n{\n    #[cfg(feature = \"unstable\")]\n    default fn from_iter(iterator: I) -> Self {\n        from_iter_default(iterator)\n    }\n\n    #[cfg(feature = \"unstable\")]\n    default fn spec_extend(&mut self, iter: I) {\n        self.extend_desugared(iter)\n    }\n\n    #[cfg(not(feature = \"unstable\"))]\n    fn from_iter(iterator: I) -> Self {\n        from_iter_default(iterator)\n    }\n\n    #[cfg(not(feature = \"unstable\"))]\n    fn spec_extend(&mut self, iter: I) {\n        self.extend_desugared(iter)\n    }\n}","impl<T: Clone> Clone for SliceDeque<T> {\n    #[inline]\n    fn clone(&self) -> Self {\n        let mut new = Self::with_capacity(self.len());\n        for i in self.iter() {\n            new.push_back(i.clone());\n        }\n        new\n    }\n    #[inline]\n    fn clone_from(&mut self, other: &Self) {\n        self.clear();\n        for i in other.iter() {\n            self.push_back(i.clone());\n        }\n    }\n}","impl<T: Default> SliceDeque<T> {\n    /// Resizes the `SliceDeque` in-place so that `len` is equal to `new_len`.\n    ///\n    /// If `new_len` is greater than `len`, the `SliceDeque` is extended by the\n    /// difference, with each additional slot filled with `Default::default()`.\n    /// If `new_len` is less than `len`, the `SliceDeque` is simply truncated.\n    ///\n    /// This method uses `Default` to create new values on every push. If\n    /// you'd rather `Clone` a given value, use [`resize`].\n    ///\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![1, 2, 3];\n    /// deq.resize_default(5);\n    /// assert_eq!(deq, [1, 2, 3, 0, 0]);\n    ///\n    /// deq.resize_default(2);\n    /// assert_eq!(deq, [1, 2]);\n    /// # }\n    /// ```\n    ///\n    /// [`resize`]: #method.resize\n    #[inline]\n    pub fn resize_default(&mut self, new_len: usize) {\n        let len = self.len();\n\n        if new_len > len {\n            self.extend_with(new_len - len, ExtendDefault);\n        } else {\n            self.truncate(new_len);\n        }\n    }\n}","impl<T: Eq> Eq for SliceDeque<T> {}","impl<T: PartialEq> SliceDeque<T> {\n    /// Removes consecutive repeated elements in the deque.\n    ///\n    /// If the deque is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![1, 2, 2, 3, 2];\n    ///\n    /// deq.dedup();\n    /// assert_eq!(deq, [1, 2, 3, 2]);\n    ///\n    /// deq.sort();\n    /// assert_eq!(deq, [1, 2, 2, 3]);\n    ///\n    /// deq.dedup();\n    /// assert_eq!(deq, [1, 2, 3]);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn dedup(&mut self) {\n        self.dedup_by(|a, b| a == b)\n    }\n\n    /// Removes the first instance of `item` from the deque if the item exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![1, 2, 3, 1];\n    ///\n    /// deq.remove_item(&1);\n    /// assert_eq!(deq, &[2, 3, 1]);\n    /// deq.remove_item(&1);\n    /// assert_eq!(deq, &[2, 3]);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn remove_item(&mut self, item: &T) -> Option<T> {\n        let pos = match self.iter().position(|x| *x == *item) {\n            Some(x) => x,\n            None => return None,\n        };\n        Some(self.remove(pos))\n    }\n}","impl<T: PartialOrd> PartialOrd for SliceDeque<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n        PartialOrd::partial_cmp(&**self, &**other)\n    }\n}","impl<T: fmt::Debug> fmt::Debug for SliceDeque<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        write!(f, \"{:?}\", self.as_slice())\n        /*\n         write!(\n             f,\n             // TODO: \"SliceDeque({:?})\",\n             \"SliceDeque(len: {}, cap: {}, head: {}, tail: {}, elems: {:?})\",\n             self.len(),\n             self.capacity(),\n             self.head(),\n             self.tail(),\n             self.as_slice()\n         )\n        */\n    }\n}","impl<T: hash::Hash> hash::Hash for SliceDeque<T> {\n    #[inline]\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        hash::Hash::hash(&**self, state)\n    }\n}","impl<T> Default for SliceDeque<T> {\n    #[inline]\n    fn default() -> Self {\n        Self::new()\n    }\n}","impl<T> Drop for SliceDeque<T> {\n    //#[inline]\n    fn drop(&mut self) {\n        // In Rust, if Drop::drop panics, the value must be leaked,\n        // therefore we don't need to make sure that we handle that case\n        // here:\n        unsafe {\n            // use drop for [T]\n            println!(\"One\");\n            ptr::drop_in_place(&mut self[..]);\n        }\n        // Buffer handles deallocation\n    }\n}","impl<T> Extend<T> for SliceDeque<T> {\n    #[inline]\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n        <Self as SpecExtend<T, I::IntoIter>>::spec_extend(\n            self,\n            iter.into_iter(),\n        )\n    }\n}","impl<T> IntoIterator for SliceDeque<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Creates a consuming iterator, that is, one that moves each value out of\n    /// the deque (from start to end). The deque cannot be used after calling\n    /// this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![\"a\".to_string(), \"b\".to_string()];\n    /// let expected = [\"a\".to_string(), \"b\".to_string()];\n    /// for (i, s) in deq.into_iter().enumerate() {\n    ///     // s has type String, not &String\n    ///     println!(\"{}\", s);\n    ///     assert_eq!(s, expected[i]);\n    /// }\n    /// # }\n    /// ```\n    #[inline]\n    fn into_iter(self) -> IntoIter<T> {\n        unsafe {\n            let buf_ptr = self.buf.ptr();\n            intrinsics::assume(!buf_ptr.is_null());\n            let begin = self.as_ptr();\n            let end = if mem::size_of::<T>() == 0 {\n                intrinsics::arith_offset(begin as *const i8, self.len() as _)\n                    as *const _\n            } else {\n                begin.add(self.len())\n            };\n            assert!(begin as usize <= end as usize);\n            let it = IntoIter {\n                buf: NonNull::new_unchecked(buf_ptr),\n                cap: self.capacity(),\n                ptr: begin,\n                end,\n            };\n            debug_assert_eq!(self.len(), it.size_hint().0);\n            #[allow(clippy::mem_forget)]\n            mem::forget(self);\n            it\n        }\n    }\n}","impl<T> SliceDeque<T>\nwhere\n    T: Clone,\n{\n    /// Clones and appends all elements in a slice to the `SliceDeque`.\n    ///\n    /// Iterates over the slice `other`, clones each element, and then appends\n    /// it to this `SliceDeque`. The `other` slice is traversed in-order.\n    ///\n    /// Note that this function is same as `extend` except that it is\n    /// specialized to work with slices instead. If and when Rust gets\n    /// specialization this function will likely be deprecated (but still\n    /// available).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::new();\n    /// deq.push_back(1);\n    /// deq.extend_from_slice(&[2, 3, 4]);\n    /// assert_eq!(deq, [1, 2, 3, 4]);\n    /// ```\n    #[inline]\n    pub fn extend_from_slice(&mut self, other: &[T]) {\n        #[cfg(feature = \"unstable\")]\n        {\n            self.spec_extend(other.iter())\n        }\n        #[cfg(not(feature = \"unstable\"))]\n        {\n            self.reserve(other.len());\n            unsafe {\n                let len = self.len();\n                self.move_tail_unchecked(other.len() as isize);\n                self.get_unchecked_mut(len..).clone_from_slice(other);\n            }\n        }\n    }\n\n    /// Modifies the `SliceDeque` in-place so that `len()` is equal to\n    /// `new_len`, either by removing excess elements or by appending clones of\n    /// `value` to the back.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![5, 10, 15];\n    /// assert_eq!(deq, [5, 10, 15]);\n    ///\n    /// deq.resize(2, 0);\n    /// assert_eq!(deq, [5, 10]);\n    ///\n    /// deq.resize(5, 20);\n    /// assert_eq!(deq, [5, 10, 20, 20, 20]);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn resize(&mut self, new_len: usize, value: T) {\n        let len = self.len();\n\n        if new_len > len {\n            self.reserve(new_len - len);\n            while self.len() < new_len {\n                self.push_back(value.clone());\n            }\n        } else {\n            self.truncate(new_len);\n        }\n        debug_assert!(self.len() == new_len);\n    }\n}","impl<T> SliceDeque<T> {\n    /// Creates a new empty deque.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use slice_deque::SliceDeque;\n    /// let deq = SliceDeque::new();\n    /// # let o: SliceDeque<u32> = deq;\n    /// ```\n    #[inline]\n    pub fn new() -> Self {\n        unsafe {\n            let buf = Buffer::new();\n            Self {\n                elems_: nonnull_raw_slice(buf.ptr(), 0),\n                buf,\n            }\n        }\n    }\n\n    /// Creates a SliceDeque from its raw components.\n    ///\n    /// The `ptr` must be a pointer to the beginning of the memory buffer from\n    /// another `SliceDeque`, `capacity` the capacity of this `SliceDeque`, and\n    /// `elems` the elements of this `SliceDeque`.\n    #[inline]\n    pub unsafe fn from_raw_parts(\n        ptr: *mut T, capacity: usize, elems: &mut [T],\n    ) -> Self {\n        let begin = elems.as_mut_ptr();\n        debug_assert!(in_bounds(slice::from_raw_parts(ptr, capacity), begin));\n        debug_assert!(elems.len() < capacity);\n\n        Self {\n            elems_: NonNull::new_unchecked(elems),\n            buf: Buffer::from_raw_parts(ptr, capacity * 2),\n        }\n    }\n\n    /// Create an empty deque with capacity to hold `n` elements.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use slice_deque::SliceDeque;\n    /// let deq = SliceDeque::with_capacity(10);\n    /// # let o: SliceDeque<u32> = deq;\n    /// ```\n    #[inline]\n    pub fn with_capacity(n: usize) -> Self {\n        unsafe {\n            let buf = Buffer::uninitialized(2 * n).unwrap_or_else(|e| {\n                let s = tiny_str!(\n                    \"failed to allocate a buffer with capacity \\\"{}\\\" due to \\\"{:?}\\\"\",\n                    n, e\n                );\n                panic!(\"{}\", s.as_str())\n            });\n            Self {\n                elems_: nonnull_raw_slice(buf.ptr(), 0),\n                buf,\n            }\n        }\n    }\n\n    /// Returns the number of elements that the deque can hold without\n    /// reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use slice_deque::SliceDeque;\n    /// let deq = SliceDeque::with_capacity(10);\n    /// assert!(deq.capacity() >= 10);\n    /// # let o: SliceDeque<u32> = deq;\n    /// ```\n    #[inline]\n    pub fn capacity(&self) -> usize {\n        // Note: the buffer length is not necessarily a power of two\n        // debug_assert!(self.buf.len() % 2 == 0);\n        self.buf.len() / 2\n    }\n\n    /// Number of elements in the ring buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::with_capacity(10);\n    /// assert!(deq.len() == 0);\n    /// deq.push_back(3);\n    /// assert!(deq.len() == 1);\n    /// ```\n    #[inline]\n    pub fn len(&self) -> usize {\n        let l = self.as_slice().len();\n        debug_assert!(l <= self.capacity());\n        l\n    }\n\n    /// Is the ring buffer full ?\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::with_capacity(10);\n    /// assert!(!deq.is_full());\n    /// # let o: SliceDeque<u32> = deq;\n    /// ```\n    #[inline]\n    pub fn is_full(&self) -> bool {\n        self.len() == self.capacity()\n    }\n\n    /// Extracts a slice containing the entire deque.\n    #[inline]\n    pub fn as_slice(&self) -> &[T] {\n        unsafe { self.elems_.as_ref() }\n    }\n\n    /// Extracts a mutable slice containing the entire deque.\n    #[inline]\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\n        unsafe { self.elems_.as_mut() }\n    }\n\n    /// Returns a pair of slices, where the first slice contains the contents\n    /// of the deque and the second one is empty.\n    #[inline]\n    pub fn as_slices(&self) -> (&[T], &[T]) {\n        unsafe {\n            let left = self.as_slice();\n            let right =\n                slice::from_raw_parts(usize::max_value() as *const _, 0);\n            (left, right)\n        }\n    }\n\n    /// Returns a pair of slices, where the first slice contains the contents\n    /// of the deque and the second one is empty.\n    #[inline]\n    pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n        unsafe {\n            let left = self.as_mut_slice();\n            let right =\n                slice::from_raw_parts_mut(usize::max_value() as *mut _, 0);\n            (left, right)\n        }\n    }\n\n    /// Returns the slice of uninitialized memory between the `tail` and the\n    /// `begin`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # fn main() {\n    /// let mut d = sdeq![1, 2, 3];\n    /// let cap = d.capacity();\n    /// let len = d.len();\n    /// unsafe {\n    ///     {\n    ///         // This slice contains the uninitialized elements in\n    ///         // the deque:\n    ///         let mut s = d.tail_head_slice();\n    ///         assert_eq!(s.len(), cap - len);\n    ///         // We can write to them and for example bump the tail of\n    ///         // the deque:\n    ///         s[0] = 4;\n    ///         s[1] = 5;\n    ///     }\n    ///     d.move_tail(2);\n    /// }\n    /// assert_eq!(d, sdeq![1, 2, 3, 4, 5]);\n    /// # }\n    /// ```\n    pub unsafe fn tail_head_slice(&mut self) -> &mut [T] {\n        let ptr = self.as_mut_slice().as_mut_ptr().add(self.len());\n        slice::from_raw_parts_mut(ptr, self.capacity() - self.len())\n    }\n\n    /// Attempts to reserve capacity for inserting at least `additional`\n    /// elements without reallocating. Does nothing if the capacity is already\n    /// sufficient.\n    ///\n    /// The collection always reserves memory in multiples of the page size.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    #[inline]\n    pub fn try_reserve(\n        &mut self, additional: usize,\n    ) -> Result<(), AllocError> {\n        let old_len = self.len();\n        let new_cap = self.grow_policy(additional);\n        self.reserve_capacity(new_cap)?;\n        debug_assert!(self.capacity() >= old_len + additional);\n        Ok(())\n    }\n\n    /// Reserves capacity for inserting at least `additional` elements without\n    /// reallocating. Does nothing if the capacity is already sufficient.\n    ///\n    /// The collection always reserves memory in multiples of the page size.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize` or on OOM.\n    #[inline]\n    pub fn reserve(&mut self, additional: usize) {\n        self.try_reserve(additional).unwrap();\n    }\n\n    /// Attempts to reserve capacity for `new_capacity` elements. Does nothing\n    /// if the capacity is already sufficient.\n    #[inline]\n    fn reserve_capacity(\n        &mut self, new_capacity: usize,\n    ) -> Result<(), AllocError> {\n        unsafe {\n            if new_capacity <= self.capacity() {\n                return Ok(());\n            }\n\n            let mut new_buffer = Buffer::uninitialized(2 * new_capacity)?;\n            debug_assert!(new_buffer.len() >= 2 * new_capacity);\n\n            let len = self.len();\n            // Move the elements from the current buffer\n            // to the beginning of the new buffer:\n            {\n                let from_ptr = self.as_mut_ptr();\n                let to_ptr = new_buffer.as_mut_slice().as_mut_ptr();\n                crate::ptr::copy_nonoverlapping(from_ptr, to_ptr, len);\n            }\n\n            // Exchange buffers\n            crate::mem::swap(&mut self.buf, &mut new_buffer);\n\n            // Correct the slice - we copied to the\n            // beginning of the of the new buffer:\n            self.elems_ = nonnull_raw_slice(self.buf.ptr(), len);\n            Ok(())\n        }\n    }\n\n    /// Reserves the minimum capacity for exactly `additional` more elements to\n    /// be inserted in the given `SliceDeq<T>`. After calling `reserve_exact`,\n    /// capacity will be greater than or equal to `self.len() + additional`.\n    /// Does nothing if the capacity is already sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it\n    /// requests. Therefore capacity can not be relied upon to be precisely\n    /// minimal. Prefer `reserve` if future insertions are expected.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # fn main() {\n    /// let mut deq = sdeq![1];\n    /// deq.reserve_exact(10);\n    /// assert!(deq.capacity() >= 11);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn reserve_exact(&mut self, additional: usize) {\n        let old_len = self.len();\n        let new_cap = old_len.checked_add(additional).expect(\"overflow\");\n        self.reserve_capacity(new_cap).unwrap();\n        debug_assert!(self.capacity() >= old_len + additional);\n    }\n\n    /// Growth policy of the deque. The capacity is going to be a multiple of\n    /// the page-size anyways, so we just double capacity when needed.\n    #[inline]\n    fn grow_policy(&self, additional: usize) -> usize {\n        let cur_cap = self.capacity();\n        let old_len = self.len();\n        let req_cap = old_len.checked_add(additional).expect(\"overflow\");\n        if req_cap > cur_cap {\n            let dbl_cap = cur_cap.saturating_mul(2);\n            cmp::max(req_cap, dbl_cap)\n        } else {\n            req_cap\n        }\n    }\n\n    /// Moves the deque head by `x`.\n    ///\n    /// # Panics\n    ///\n    /// If the head wraps over the tail the behavior is undefined, that is,\n    /// if `x` is out-of-range `[-(capacity() - len()), len()]`.\n    ///\n    /// If `-C debug-assertions=1` violating this pre-condition `panic!`s.\n    ///\n    /// # Unsafe\n    ///\n    /// It does not `drop` nor initialize elements, it just moves where the\n    /// tail of the deque points to within the allocated buffer.\n    #[inline]\n    pub unsafe fn move_head_unchecked(&mut self, x: isize) {\n        let cap = self.capacity();\n        let len = self.len();\n        // Make sure that the begin does not wrap over the end:\n        debug_assert!(x >= -((cap - len) as isize));\n        debug_assert!(x <= len as isize);\n\n        // Obtain the begin of the slice and offset it by x:\n        let mut new_begin = self.as_mut_ptr().offset(x) as usize;\n\n        // Compute the boundaries of the first and second memory regions:\n        let first_region_begin = self.buf.ptr() as usize;\n        let region_size = Buffer::<T>::size_in_bytes(self.buf.len()) / 2;\n        debug_assert!(cap * mem::size_of::<T>() <= region_size);\n        let second_region_begin = first_region_begin + region_size;\n\n        // If the new begin is not inside the first memory region, we shift it\n        // by the region size into it:\n        if new_begin < first_region_begin {\n            new_begin += region_size;\n        } else if new_begin >= second_region_begin {\n            // Should be within the second region:\n            debug_assert!(new_begin < second_region_begin + region_size);\n            new_begin -= region_size;\n        }\n        debug_assert!(new_begin >= first_region_begin);\n        debug_assert!(new_begin < second_region_begin);\n\n        // The new begin is now in the first memory region:\n        let new_begin = new_begin as *mut T;\n        debug_assert!(in_bounds(\n            slice::from_raw_parts(self.buf.ptr() as *mut u8, region_size),\n            new_begin as *mut u8\n        ));\n\n        let new_len = len as isize - x;\n        debug_assert!(\n            new_len >= 0,\n            \"len = {}, x = {}, new_len = {}\",\n            len,\n            x,\n            new_len\n        );\n        debug_assert!(new_len <= cap as isize);\n        self.elems_ = nonnull_raw_slice(new_begin, new_len as usize);\n    }\n\n    /// Moves the deque head by `x`.\n    ///\n    /// # Panics\n    ///\n    /// If the `head` wraps over the `tail`, that is, if `x` is out-of-range\n    /// `[-(capacity() - len()), len()]`.\n    ///\n    /// # Unsafe\n    ///\n    /// It does not `drop` nor initialize elements, it just moves where the\n    /// tail of the deque points to within the allocated buffer.\n    #[inline]\n    pub unsafe fn move_head(&mut self, x: isize) {\n        assert!(\n            x >= -((self.capacity() - self.len()) as isize)\n                && x <= self.len() as isize\n        );\n        self.move_head_unchecked(x)\n    }\n\n    /// Moves the deque tail by `x`.\n    ///\n    /// # Panics\n    ///\n    /// If the `tail` wraps over the `head` the behavior is undefined, that is,\n    /// if `x` is out-of-range `[-len(), capacity() - len()]`.\n    ///\n    /// If `-C debug-assertions=1` violating this pre-condition `panic!`s.\n    ///\n    /// # Unsafe\n    ///\n    /// It does not `drop` nor initialize elements, it just moves where the\n    /// tail of the deque points to within the allocated buffer.\n    #[inline]\n    pub unsafe fn move_tail_unchecked(&mut self, x: isize) {\n        // Make sure that the end does not wrap over the begin:\n        let len = self.len();\n        let cap = self.capacity();\n        debug_assert!(x >= -(len as isize));\n        debug_assert!(x <= (cap - len) as isize);\n\n        let new_len = len as isize + x;\n        debug_assert!(new_len >= 0);\n        debug_assert!(new_len <= cap as isize);\n\n        self.elems_ = nonnull_raw_slice(self.as_mut_ptr(), new_len as usize);\n    }\n\n    /// Moves the deque tail by `x`.\n    ///\n    /// # Panics\n    ///\n    /// If the `tail` wraps over the `head`, that is, if `x` is out-of-range\n    /// `[-len(), capacity() - len()]`.\n    ///\n    /// # Unsafe\n    ///\n    /// It does not `drop` nor initialize elements, it just moves where the\n    /// tail of the deque points to within the allocated buffer.\n    #[inline]\n    pub unsafe fn move_tail(&mut self, x: isize) {\n        assert!(\n            x >= -(self.len() as isize)\n                && x <= (self.capacity() - self.len()) as isize\n        );\n        self.move_tail_unchecked(x);\n    }\n\n    /// Appends elements to `self` from `other`.\n    #[inline]\n    unsafe fn append_elements(&mut self, other: *const [T]) {\n        let count = (*other).len();\n        self.reserve(count);\n        let len = self.len();\n        ptr::copy_nonoverlapping(\n            other as *const T,\n            self.get_unchecked_mut(len),\n            count,\n        );\n        self.move_tail_unchecked(count as isize);\n    }\n\n    /// Steal the elements from the slice `s`. You should `mem::forget` the\n    /// slice afterwards.\n    pub unsafe fn steal_from_slice(s: &[T]) -> Self {\n        let mut deq = Self::new();\n        deq.append_elements(s as *const _);\n        deq\n    }\n\n    /// Moves all the elements of `other` into `Self`, leaving `other` empty.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the number of elements in the deque overflows a `isize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![1, 2, 3];\n    /// let mut deq2 = sdeq![4, 5, 6];\n    /// deq.append(&mut deq2);\n    /// assert_eq!(deq, [1, 2, 3, 4, 5, 6]);\n    /// assert_eq!(deq2, []);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn append(&mut self, other: &mut Self) {\n        unsafe {\n            self.append_elements(other.as_slice() as _);\n            other.elems_ = nonnull_raw_slice(other.buf.ptr(), 0);\n        }\n    }\n\n    /// Provides a reference to the first element, or `None` if the deque is\n    /// empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::new();\n    /// assert_eq!(deq.front(), None);\n    ///\n    /// deq.push_back(1);\n    /// deq.push_back(2);\n    /// assert_eq!(deq.front(), Some(&1));\n    /// deq.push_front(3);\n    /// assert_eq!(deq.front(), Some(&3));\n    /// ```\n    #[inline]\n    pub fn front(&self) -> Option<&T> {\n        self.get(0)\n    }\n\n    /// Provides a mutable reference to the first element, or `None` if the\n    /// deque is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::new();\n    /// assert_eq!(deq.front(), None);\n    ///\n    /// deq.push_back(1);\n    /// deq.push_back(2);\n    /// assert_eq!(deq.front(), Some(&1));\n    /// (*deq.front_mut().unwrap()) = 3;\n    /// assert_eq!(deq.front(), Some(&3));\n    /// ```\n    #[inline]\n    pub fn front_mut(&mut self) -> Option<&mut T> {\n        self.get_mut(0)\n    }\n\n    /// Provides a reference to the last element, or `None` if the deque is\n    /// empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::new();\n    /// assert_eq!(deq.back(), None);\n    ///\n    /// deq.push_back(1);\n    /// deq.push_back(2);\n    /// assert_eq!(deq.back(), Some(&2));\n    /// deq.push_front(3);\n    /// assert_eq!(deq.back(), Some(&2));\n    /// ```\n    #[inline]\n    pub fn back(&self) -> Option<&T> {\n        let last_idx = self.len().wrapping_sub(1);\n        self.get(last_idx)\n    }\n\n    /// Provides a mutable reference to the last element, or `None` if the\n    /// deque is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::new();\n    /// assert_eq!(deq.front(), None);\n    ///\n    /// deq.push_back(1);\n    /// deq.push_back(2);\n    /// assert_eq!(deq.back(), Some(&2));\n    /// (*deq.back_mut().unwrap()) = 3;\n    /// assert_eq!(deq.back(), Some(&3));\n    /// ```\n    #[inline]\n    pub fn back_mut(&mut self) -> Option<&mut T> {\n        let last_idx = self.len().wrapping_sub(1);\n        self.get_mut(last_idx)\n    }\n\n    /// Attempts to prepend `value` to the deque.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::new();\n    /// deq.try_push_front(1).unwrap();\n    /// deq.try_push_front(2).unwrap();\n    /// assert_eq!(deq.front(), Some(&2));\n    /// ```\n    #[inline]\n    pub fn try_push_front(&mut self, value: T) -> Result<(), (T, AllocError)> {\n        unsafe {\n            if intrinsics::unlikely(self.is_full()) {\n                if let Err(e) = self.try_reserve(1) {\n                    return Err((value, e));\n                }\n            }\n\n            self.move_head_unchecked(-1);\n            ptr::write(self.get_mut(0).unwrap(), value);\n            Ok(())\n        }\n    }\n\n    /// Prepends `value` to the deque.\n    ///\n    /// # Panics\n    ///\n    /// On OOM.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::new();\n    /// deq.push_front(1);\n    /// deq.push_front(2);\n    /// assert_eq!(deq.front(), Some(&2));\n    /// ```\n    #[inline]\n    pub fn push_front(&mut self, value: T) {\n        if let Err(e) = self.try_push_front(value) {\n            panic!(\"{:?}\", e.1);\n        }\n    }\n\n    /// Attempts to appends `value` to the deque.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::new();\n    /// deq.try_push_back(1).unwrap();\n    /// deq.try_push_back(3).unwrap();\n    /// assert_eq!(deq.back(), Some(&3));\n    /// ```\n    #[inline]\n    pub fn try_push_back(&mut self, value: T) -> Result<(), (T, AllocError)> {\n        unsafe {\n            if intrinsics::unlikely(self.is_full()) {\n                if let Err(e) = self.try_reserve(1) {\n                    return Err((value, e));\n                }\n            }\n            self.move_tail_unchecked(1);\n            let len = self.len();\n            ptr::write(self.get_mut(len - 1).unwrap(), value);\n            Ok(())\n        }\n    }\n\n    /// Appends `value` to the deque.\n    ///\n    /// # Panics\n    ///\n    /// On OOM.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::new();\n    /// deq.push_back(1);\n    /// deq.push_back(3);\n    /// assert_eq!(deq.back(), Some(&3));\n    /// ```\n    #[inline]\n    pub fn push_back(&mut self, value: T) {\n        if let Err(e) = self.try_push_back(value) {\n            panic!(\"{:?}\", e.1);\n        }\n    }\n\n    /// Removes the first element and returns it, or `None` if the deque is\n    /// empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::new();\n    /// assert_eq!(deq.pop_front(), None);\n    ///\n    /// deq.push_back(1);\n    /// deq.push_back(2);\n    ///\n    /// assert_eq!(deq.pop_front(), Some(1));\n    /// assert_eq!(deq.pop_front(), Some(2));\n    /// assert_eq!(deq.pop_front(), None);\n    /// ```\n    #[inline]\n    pub fn pop_front(&mut self) -> Option<T> {\n        unsafe {\n            let v = match self.get_mut(0) {\n                None => return None,\n                Some(v) => ptr::read(v),\n            };\n            self.move_head_unchecked(1);\n            Some(v)\n        }\n    }\n\n    /// Removes the last element from the deque and returns it, or `None` if it\n    /// is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::new();\n    /// assert_eq!(deq.pop_back(), None);\n    ///\n    /// deq.push_back(1);\n    /// deq.push_back(3);\n    ///\n    /// assert_eq!(deq.pop_back(), Some(3));\n    /// assert_eq!(deq.pop_back(), Some(1));\n    /// assert_eq!(deq.pop_back(), None);\n    /// ```\n    #[inline]\n    pub fn pop_back(&mut self) -> Option<T> {\n        unsafe {\n            let len = self.len();\n            let v = match self.get_mut(len.wrapping_sub(1)) {\n                None => return None,\n                Some(v) => ptr::read(v),\n            };\n            self.move_tail_unchecked(-1);\n            Some(v)\n        }\n    }\n\n    /// Shrinks the capacity of the deque as much as possible.\n    ///\n    /// It will drop down as close as possible to the length, but because\n    /// `SliceDeque` allocates memory in multiples of the page size the deque\n    /// might still have capacity for inserting new elements without\n    /// reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::with_capacity(15);\n    /// deq.extend(0..4);\n    /// assert!(deq.capacity() >= 15);\n    /// deq.shrink_to_fit();\n    /// assert!(deq.capacity() >= 4);\n    /// # let o: SliceDeque<u32> = deq;\n    /// ```\n    #[inline]\n    pub fn shrink_to_fit(&mut self) {\n        if unsafe { intrinsics::unlikely(self.is_empty()) } {\n            return;\n        }\n\n        // FIXME: we should compute the capacity and only allocate a shrunk\n        // deque if that's worth it.\n        let mut new_sdeq = Self::with_capacity(self.len());\n        if new_sdeq.capacity() < self.capacity() {\n            unsafe {\n                crate::ptr::copy_nonoverlapping(\n                    self.as_mut_ptr(),\n                    new_sdeq.as_mut_ptr(),\n                    self.len(),\n                );\n                new_sdeq.elems_ =\n                    nonnull_raw_slice(new_sdeq.buf.ptr(), self.len());\n                mem::swap(self, &mut new_sdeq);\n            }\n        }\n    }\n\n    /// Shortens the deque by removing excess elements from the back.\n    ///\n    /// If `len` is greater than the SliceDeque's current length, this has no\n    /// effect.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![5, 10, 15];\n    /// assert_eq!(deq, [5, 10, 15]);\n    /// deq.truncate_back(1);\n    /// assert_eq!(deq, [5]);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn truncate_back(&mut self, len: usize) {\n        unsafe {\n            if len >= self.len() {\n                return;\n            }\n\n            let diff = self.len() - len;\n            let s = &mut self[len..] as *mut [_];\n            // decrement tail before the drop_in_place(), so a panic on\n            // Drop doesn't re-drop the just-failed value.\n            self.move_tail(-(diff as isize));\n            ptr::drop_in_place(&mut *s);\n            debug_assert_eq!(self.len(), len);\n        }\n    }\n\n    /// Shortens the deque by removing excess elements from the back.\n    ///\n    /// If `len` is greater than the SliceDeque's current length, this has no\n    /// effect. See `truncate_back` for examples.\n    #[inline]\n    pub fn truncate(&mut self, len: usize) {\n        self.truncate_back(len);\n    }\n\n    /// Shortens the deque by removing excess elements from the front.\n    ///\n    /// If `len` is greater than the SliceDeque's current length, this has no\n    /// effect.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![5, 10, 15];\n    /// assert_eq!(deq, [5, 10, 15]);\n    /// deq.truncate_front(1);\n    /// assert_eq!(deq, [15]);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn truncate_front(&mut self, len: usize) {\n        unsafe {\n            if len >= self.len() {\n                return;\n            }\n\n            let diff = self.len() - len;\n            let s = &mut self[..diff] as *mut [_];\n            // increment head before the drop_in_place(), so a panic on\n            // Drop doesn't re-drop the just-failed value.\n            self.move_head(diff as isize);\n            ptr::drop_in_place(&mut *s);\n            debug_assert_eq!(self.len(), len);\n        }\n    }\n\n    /// Creates a draining iterator that removes the specified range in the\n    /// deque and yields the removed items.\n    ///\n    /// Note 1: The element range is removed even if the iterator is only\n    /// partially consumed or not consumed at all.\n    ///\n    /// Note 2: It is unspecified how many elements are removed from the deque\n    /// if the `Drain` value is leaked.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the deque.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![1, 2, 3];\n    /// let u: Vec<_> = deq.drain(1..).collect();\n    /// assert_eq!(deq, &[1]);\n    /// assert_eq!(u, &[2, 3]);\n    ///\n    /// // A full range clears the deque\n    /// deq.drain(..);\n    /// assert_eq!(deq, &[]);\n    /// # }\n    /// ```\n    #[inline]\n    #[allow(clippy::needless_pass_by_value)]\n    pub fn drain<R>(&mut self, range: R) -> Drain<T>\n    where\n        R: ops::RangeBounds<usize>,\n    {\n        use ops::Bound::{Excluded, Included, Unbounded};\n        // Memory safety\n        //\n        // When the Drain is first created, it shortens the length of\n        // the source deque to make sure no uninitalized or moved-from\n        // elements are accessible at all if the Drain's destructor\n        // never gets to run.\n        //\n        // Drain will ptr::read out the values to remove.\n        // When finished, remaining tail of the deque is copied back to cover\n        // the hole, and the deque length is restored to the new length.\n        //\n        let len = self.len();\n        let start = match range.start_bound() {\n            Included(&n) => n,\n            Excluded(&n) => n + 1,\n            Unbounded => 0,\n        };\n        let end = match range.end_bound() {\n            Included(&n) => n + 1,\n            Excluded(&n) => n,\n            Unbounded => len,\n        };\n        assert!(start <= end);\n        assert!(end <= len);\n\n        unsafe {\n            // set self.deq length's to start, to be safe in case Drain is\n            // leaked\n            self.elems_ = nonnull_raw_slice(self.as_mut_ptr(), start);\n            // Use the borrow in the IterMut to indicate borrowing behavior of\n            // the whole Drain iterator (like &mut T).\n            let range_slice = slice::from_raw_parts_mut(\n                if mem::size_of::<T>() == 0 {\n                    intrinsics::arith_offset(\n                        self.as_mut_ptr() as *mut i8,\n                        start as _,\n                    ) as *mut _\n                } else {\n                    self.as_mut_ptr().add(start)\n                },\n                end - start,\n            );\n            Drain {\n                tail_start: end,\n                tail_len: len - end,\n                iter: range_slice.iter(),\n                deq: NonNull::from(self),\n            }\n        }\n    }\n\n    /// Removes all values from the deque.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![1];\n    /// assert!(!deq.is_empty());\n    /// deq.clear();\n    /// assert!(deq.is_empty());\n    /// # }\n    /// ```\n    #[inline]\n    pub fn clear(&mut self) {\n        self.truncate(0);\n    }\n\n    /// Removes the element at `index` and return it in `O(1)` by swapping the\n    /// last element into its place.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::new();\n    /// assert_eq!(deq.swap_remove_back(0), None);\n    /// deq.extend(1..4);\n    /// assert_eq!(deq, [1, 2, 3]);\n    ///\n    /// assert_eq!(deq.swap_remove_back(0), Some(1));\n    /// assert_eq!(deq, [3, 2]);\n    /// ```\n    #[inline]\n    pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n        let len = self.len();\n        if self.is_empty() {\n            None\n        } else {\n            self.swap(index, len - 1);\n            self.pop_back()\n        }\n    }\n\n    /// Removes the element at `index` and returns it in `O(1)` by swapping the\n    /// first element into its place.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slice_deque::SliceDeque;\n    /// let mut deq = SliceDeque::new();\n    /// assert_eq!(deq.swap_remove_front(0), None);\n    /// deq.extend(1..4);\n    /// assert_eq!(deq, [1, 2, 3]);\n    ///\n    /// assert_eq!(deq.swap_remove_front(2), Some(3));\n    /// assert_eq!(deq, [2, 1]);\n    /// ```\n    #[inline]\n    pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n        if self.is_empty() {\n            None\n        } else {\n            self.swap(index, 0);\n            self.pop_front()\n        }\n    }\n\n    /// Inserts an `element` at `index` within the deque, shifting all elements\n    /// with indices greater than or equal to `index` towards the back.\n    ///\n    /// Element at index 0 is the front of the queue.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index` is greater than deque's length\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq!['a', 'b', 'c'];\n    /// assert_eq!(deq, &['a', 'b', 'c']);\n    ///\n    /// deq.insert(1, 'd');\n    /// assert_eq!(deq, &['a', 'd', 'b', 'c']);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn insert(&mut self, index: usize, element: T) {\n        unsafe {\n            let len = self.len();\n            assert!(index <= len);\n\n            if intrinsics::unlikely(self.is_full()) {\n                self.reserve(1);\n                // TODO: when the deque needs to grow, reserve should\n                // copy the memory to the new storage leaving a whole\n                // at the index where the new elements are to be inserted\n                // to avoid having to copy the memory again\n            }\n\n            let p = if index > self.len() / 2 {\n                let p = self.as_mut_ptr().add(index);\n                // Shift elements towards the back\n                ptr::copy(p, p.add(1), len - index);\n                self.move_tail_unchecked(1);\n                p\n            } else {\n                // Shift elements towards the front\n                self.move_head_unchecked(-1);\n                let p = self.as_mut_ptr().add(index);\n                ptr::copy(p, p.sub(1), index);\n                p\n            };\n            ptr::write(p, element); // Overwritte\n        }\n    }\n\n    /// Removes and returns the element at position `index` within the deque.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index` is out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![1, 2, 3, 4, 5];\n    /// assert_eq!(deq.remove(1), 2);\n    /// assert_eq!(deq, [1, 3, 4, 5]);\n    /// # }\n    /// ```\n    #[inline]\n    #[allow(clippy::shadow_unrelated)] // FIXME: bug in clippy due to ptr\n    pub fn remove(&mut self, index: usize) -> T {\n        let len = self.len();\n        assert!(index < len);\n        unsafe {\n            // copy element at pointer:\n            let ptr = self.as_mut_ptr().add(index);\n            let ret = ptr::read(ptr);\n            if index > self.len() / 2 {\n                // If the index is close to the back, shift elements from the\n                // back towards the front\n                ptr::copy(ptr.add(1), ptr, len - index - 1);\n                self.move_tail_unchecked(-1);\n            } else {\n                // If the index is close to the front, shift elements from the\n                // front towards the back\n                let ptr = self.as_mut_ptr();\n                ptr::copy(ptr, ptr.add(1), index);\n                self.move_head_unchecked(1);\n            }\n\n            ret\n        }\n    }\n\n    /// Splits the collection into two at the given index.\n    ///\n    /// Returns a newly allocated `Self`. `self` contains elements `[0, at)`,\n    /// and the returned `Self` contains elements `[at, len)`.\n    ///\n    /// Note that the capacity of `self` does not change.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `at > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![1, 2, 3];\n    /// let deq2 = deq.split_off(1);\n    /// assert_eq!(deq, [1]);\n    /// assert_eq!(deq2, [2, 3]);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn split_off(&mut self, at: usize) -> Self {\n        assert!(at <= self.len(), \"`at` out of bounds\");\n\n        let other_len = self.len() - at;\n        let mut other = Self::with_capacity(other_len);\n\n        unsafe {\n            self.move_tail_unchecked(-(other_len as isize));\n            other.move_tail_unchecked(other_len as isize);\n\n            ptr::copy_nonoverlapping(\n                self.as_ptr().add(at),\n                other.as_mut_ptr(),\n                other.len(),\n            );\n        }\n        other\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// That is, remove all elements `e` such that `f(&e)` returns `false`.\n    /// This method operates in place and preserves the order of the\n    /// retained elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![1, 2, 3, 4];\n    /// deq.retain(|&x| x % 2 == 0);\n    /// assert_eq!(deq, [2, 4]);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> bool,\n    {\n        let len = self.len();\n        let mut del = 0;\n        {\n            let v = &mut **self;\n\n            for i in 0..len {\n                if !f(&v[i]) {\n                    del += 1;\n                } else if del > 0 {\n                    v.swap(i - del, i);\n                }\n            }\n        }\n        if del > 0 {\n            self.truncate(len - del);\n        }\n    }\n\n    /// Removes all but the first of consecutive elements in the deque that\n    /// resolve to the same key.\n    ///\n    /// If the deque is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![10, 20, 21, 30, 20];\n    ///\n    /// deq.dedup_by_key(|i| *i / 10);\n    /// assert_eq!(deq, [10, 20, 30, 20]);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn dedup_by_key<F, K>(&mut self, mut key: F)\n    where\n        F: FnMut(&mut T) -> K,\n        K: PartialEq,\n    {\n        self.dedup_by(|a, b| key(a) == key(b))\n    }\n\n    /// Removes all but the first of consecutive elements in the deque\n    /// satisfying a given equality relation.\n    ///\n    /// The `same_bucket` function is passed references to two elements from\n    /// the deque, and returns `true` if the elements compare equal, or\n    /// `false` if they do not. The elements are passed in opposite order\n    /// from their order in the deque, so if `same_bucket(a, b)` returns\n    /// `true`, `a` is removed.\n    ///\n    /// If the deque is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n    ///\n    /// deq.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n    ///\n    /// assert_eq!(deq, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn dedup_by<F>(&mut self, mut same_bucket: F)\n    where\n        F: FnMut(&mut T, &mut T) -> bool,\n    {\n        unsafe {\n            // Although we have a mutable reference to `self`, we cannot make\n            // *arbitrary* changes. The `same_bucket` calls could panic, so we\n            // must ensure that the deque is in a valid state at all time.\n            //\n            // The way that we handle this is by using swaps; we iterate\n            // over all the elements, swapping as we go so that at the end\n            // the elements we wish to keep are in the front, and those we\n            // wish to reject are at the back. We can then truncate the\n            // deque. This operation is still O(n).\n            //\n            // Example: We start in this state, where `r` represents \"next\n            // read\" and `w` represents \"next_write`.\n            //\n            //           r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //           w\n            //\n            // Comparing self[r] against self[w-1], this is not a duplicate, so\n            // we swap self[r] and self[w] (no effect as r==w) and then\n            // increment both r and w, leaving us with:\n            //\n            //               r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //               w\n            //\n            // Comparing self[r] against self[w-1], this value is a duplicate,\n            // so we increment `r` but leave everything else unchanged:\n            //\n            //                   r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //               w\n            //\n            // Comparing self[r] against self[w-1], this is not a duplicate,\n            // so swap self[r] and self[w] and advance r and w:\n            //\n            //                       r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //                   w\n            //\n            // Not a duplicate, repeat:\n            //\n            //                           r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n            //     +---+---+---+---+---+---+\n            //                       w\n            //\n            // Duplicate, advance r. End of deque. Truncate to w.\n\n            let ln = self.len();\n            if intrinsics::unlikely(ln <= 1) {\n                return;\n            }\n\n            // Avoid bounds checks by using raw pointers.\n            let p = self.as_mut_ptr();\n            let mut r: usize = 1;\n            let mut w: usize = 1;\n\n            while r < ln {\n                let p_r = p.add(r);\n                let p_wm1 = p.add(w - 1);\n                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n                    if r != w {\n                        let p_w = p_wm1.add(1);\n                        mem::swap(&mut *p_r, &mut *p_w);\n                    }\n                    w += 1;\n                }\n                r += 1;\n            }\n\n            self.truncate(w);\n        }\n    }\n\n    /// Extend the `SliceDeque` by `n` values, using the given generator.\n    #[inline]\n    fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, value: E) {\n        self.reserve(n);\n\n        unsafe {\n            let mut ptr = self.as_mut_ptr().add(self.len());\n\n            // Write all elements except the last one\n            for _ in 1..n {\n                ptr::write(ptr, value.next());\n                ptr = ptr.add(1);\n                // Increment the length in every step in case next() panics\n                self.move_tail_unchecked(1);\n            }\n\n            if n > 0 {\n                // We can write the last element directly without cloning\n                // needlessly\n                ptr::write(ptr, value.last());\n                self.move_tail_unchecked(1);\n            }\n\n            // len set by scope guard\n        }\n    }\n\n    /// Extend for a general iterator.\n    ///\n    /// This function should be the moral equivalent of:\n    ///\n    /// >  for item in iterator {\n    /// >      self.push_back(item);\n    /// >  }\n    #[inline]\n    fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n        #[allow(clippy::while_let_on_iterator)]\n        while let Some(element) = iterator.next() {\n            let len = self.len();\n            let cap = self.capacity();\n            if len == cap {\n                let (lower, upper) = iterator.size_hint();\n                let additional_cap = if let Some(upper) = upper {\n                    upper\n                } else {\n                    lower\n                }\n                .checked_add(1)\n                .expect(\"overflow\");\n                self.reserve(additional_cap);\n            }\n            debug_assert!(self.len() < self.capacity());\n            unsafe {\n                ptr::write(self.get_unchecked_mut(len), element);\n                // NB can't overflow since we would have had to alloc the\n                // address space\n                self.move_tail_unchecked(1);\n            }\n        }\n    }\n\n    /// Creates a splicing iterator that replaces the specified range in the\n    /// deque with the given `replace_with` iterator and yields the\n    /// removed items. `replace_with` does not need to be the same length\n    /// as `range`.\n    ///\n    /// Note 1: The element range is removed even if the iterator is not\n    /// consumed until the end.\n    ///\n    /// Note 2: It is unspecified how many elements are removed from the deque,\n    /// if the `Splice` value is leaked.\n    ///\n    /// Note 3: The input iterator `replace_with` is only consumed\n    /// when the `Splice` value is dropped.\n    ///\n    /// Note 4: This is optimal if:\n    ///\n    /// * The tail (elements in the deque after `range`) is empty,\n    /// * or `replace_with` yields fewer elements than `range`â€™s length\n    /// * or the lower bound of its `size_hint()` is exact.\n    ///\n    /// Otherwise, a temporary deque is allocated and the tail is moved twice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the deque.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut deq = sdeq![1, 2, 3];\n    /// let new = [7, 8];\n    /// let u: SliceDeque<_> = deq.splice(..2, new.iter().cloned()).collect();\n    /// assert_eq!(deq, &[7, 8, 3]);\n    /// assert_eq!(u, &[1, 2]);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn splice<R, I>(\n        &mut self, range: R, replace_with: I,\n    ) -> Splice<I::IntoIter>\n    where\n        R: ops::RangeBounds<usize>,\n        I: IntoIterator<Item = T>,\n    {\n        Splice {\n            drain: self.drain(range),\n            replace_with: replace_with.into_iter(),\n        }\n    }\n\n    /// Creates an iterator which uses a closure to determine if an element\n    /// should be removed.\n    ///\n    /// If the closure returns `true`, then the element is removed and yielded.\n    /// If the closure returns `false`, it will try again, and call the closure\n    /// on the next element, seeing if it passes the test.\n    ///\n    /// Using this method is equivalent to the following code:\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// # let some_predicate = |x: &mut i32| { *x == 2 || *x == 3 || *x == 6\n    /// # };\n    /// let mut deq = SliceDeque::new();\n    /// deq.extend(1..7);\n    /// let mut i = 0;\n    /// while i != deq.len() {\n    ///     if some_predicate(&mut deq[i]) {\n    ///         let val = deq.remove(i);\n    ///     // your code here\n    ///     } else {\n    ///         i += 1;\n    ///     }\n    /// }\n    /// # let mut expected = sdeq![1, 4, 5];\n    /// # assert_eq!(deq, expected);\n    /// # }\n    /// ```\n    ///\n    /// But `drain_filter` is easier to use. `drain_filter` is also more\n    /// efficient, because it can backshift the elements of the deque in\n    /// bulk.\n    ///\n    /// Note that `drain_filter` also lets you mutate every element in the\n    /// filter closure, regardless of whether you choose to keep or remove\n    /// it.\n    ///\n    ///\n    /// # Examples\n    ///\n    /// Splitting a deque into evens and odds, reusing the original allocation:\n    ///\n    /// ```\n    /// # #[macro_use] extern crate slice_deque;\n    /// # use slice_deque::SliceDeque;\n    /// # fn main() {\n    /// let mut numbers = sdeq![1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15];\n    ///\n    /// let evens = numbers\n    ///     .drain_filter(|x| *x % 2 == 0)\n    ///     .collect::<SliceDeque<_>>();\n    /// let odds = numbers;\n    ///\n    /// assert_eq!(sdeq![2, 4, 6, 8, 14], evens);\n    /// assert_eq!(odds, sdeq![1, 3, 5, 9, 11, 13, 15]);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<T, F>\n    where\n        F: FnMut(&mut T) -> bool,\n    {\n        let old_len = self.len();\n\n        // Guard against us getting leaked (leak amplification)\n        unsafe {\n            self.move_tail_unchecked(-(old_len as isize));\n        }\n\n        DrainFilter {\n            deq: self,\n            idx: 0,\n            del: 0,\n            old_len,\n            pred: filter,\n        }\n    }\n}","impl<T> convert::AsMut<[T]> for SliceDeque<T> {\n    fn as_mut(&mut self) -> &mut [T] {\n        &mut *self\n    }\n}","impl<T> convert::AsRef<[T]> for SliceDeque<T> {\n    fn as_ref(&self) -> &[T] {\n        &*self\n    }\n}","impl<T> iter::FromIterator<T> for SliceDeque<T> {\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n        <Self as SpecExtend<T, I::IntoIter>>::from_iter(iter.into_iter())\n    }\n}","impl<T> ops::Deref for SliceDeque<T> {\n    type Target = [T];\n    #[inline]\n    fn deref(&self) -> &Self::Target {\n        self.as_slice()\n    }\n}","impl<T> ops::DerefMut for SliceDeque<T> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        self.as_mut_slice()\n    }\n}","unsafe impl<T> Send for SliceDeque<T> where T: Send {}","unsafe impl<T> Sync for SliceDeque<T> where T: Sync {}"],"Splice":["Debug","impl<'a, I: Iterator> DoubleEndedIterator for Splice<'a, I> {\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.drain.next_back()\n    }\n}","impl<'a, I: Iterator> Drop for Splice<'a, I> {\n    fn drop(&mut self) {\n        // exhaust drain first\n        while let Some(_) = self.drain.next() {}\n\n        unsafe {\n            if self.drain.tail_len == 0 {\n                self.drain.deq.as_mut().extend(self.replace_with.by_ref());\n                return;\n            }\n\n            // First fill the range left by drain().\n            if !self.drain.fill(&mut self.replace_with) {\n                return;\n            }\n\n            // There may be more elements. Use the lower bound as an estimate.\n            // FIXME: Is the upper bound a better guess? Or something else?\n            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n            if lower_bound > 0 {\n                self.drain.move_tail_unchecked(lower_bound);\n                if !self.drain.fill(&mut self.replace_with) {\n                    return;\n                }\n            }\n\n            // Collect any remaining elements.\n            // This is a zero-length deque which does not allocate if\n            // `lower_bound` was exact.\n            let mut collected = self\n                .replace_with\n                .by_ref()\n                .collect::<SliceDeque<I::Item>>()\n                .into_iter();\n            // Now we have an exact count.\n            if collected.size_hint().0 > 0 {\n                self.drain.move_tail_unchecked(collected.size_hint().0);\n                let filled = self.drain.fill(&mut collected);\n                debug_assert!(filled);\n                debug_assert_eq!(collected.size_hint().0, 0);\n            }\n        }\n        // Let `Drain::drop` move the tail back if necessary and restore\n        // `deq.tail`.\n    }\n}","impl<'a, I: Iterator> Iterator for Splice<'a, I> {\n    type Item = I::Item;\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.drain.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.drain.size_hint()\n    }\n}"],"macros::TinyAsciiString":["impl TinyAsciiString {\n    /// Creates a new string initialized to zero.\n    pub fn new() -> Self {\n        Self { buf: [0_u8; 512] }\n    }\n    /// Converts the Tiny Ascii String to an UTF-8 string (unchecked).\n    pub unsafe fn as_str(&self) -> &str {\n        crate::str::from_utf8_unchecked(&self.buf)\n    }\n}","impl crate::fmt::Write for TinyAsciiString {\n    fn write_str(&mut self, s: &str) -> Result<(), crate::fmt::Error> {\n        for (idx, b) in s.bytes().enumerate() {\n            if let Some(v) = self.buf.get_mut(idx) {\n                *v = b;\n            } else {\n                return Err(crate::fmt::Error);\n            }\n        }\n        Ok(())\n    }\n}"],"mirrored::AllocError":["impl crate::fmt::Debug for AllocError {\n    fn fmt(&self, f: &mut crate::fmt::Formatter) -> crate::fmt::Result {\n        match self {\n            AllocError::Oom => write!(f, \"out-of-memory\"),\n            AllocError::Other => write!(f, \"other (not out-of-memory)\"),\n        }\n    }\n}"],"mirrored::buffer::Buffer":["impl<T> Buffer<T> {\n    /// Number of elements in the buffer.\n    pub fn len(&self) -> usize {\n        self.len\n    }\n\n    /// Is the buffer empty?\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Pointer to the first element in the buffer.\n    pub unsafe fn ptr(&self) -> *mut T {\n        self.ptr.as_ptr()\n    }\n\n    /// Interprets contents as a slice.\n    ///\n    /// Warning: Some memory might be uninitialized.\n    pub unsafe fn as_slice(&self) -> &[T] {\n        slice::from_raw_parts(self.ptr.as_ptr(), self.len())\n    }\n\n    /// Interprets contents as a mut slice.\n    ///\n    /// Warning: Some memory might be uninitialized.\n    pub unsafe fn as_mut_slice(&mut self) -> &mut [T] {\n        slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len())\n    }\n\n    /// Interprets content as a slice and access the `i`-th element.\n    ///\n    /// Warning: The memory of the `i`-th element might be uninitialized.\n    pub unsafe fn get(&self, i: usize) -> &T {\n        &self.as_slice()[i]\n    }\n\n    /// Interprets content as a mut slice and access the `i`-th element.\n    ///\n    /// Warning: The memory of the `i`-th element might be uninitialized.\n    pub unsafe fn get_mut(&mut self, i: usize) -> &mut T {\n        &mut self.as_mut_slice()[i]\n    }\n\n    fn empty_len() -> usize {\n        if mem::size_of::<T>() == 0 {\n            isize::max_value() as usize * 2\n        } else {\n            0\n        }\n    }\n\n    /// Creates a new empty `Buffer`.\n    pub fn new() -> Self {\n        // Here `ptr` is initialized to a magic value but `len == 0`\n        // will ensure that it is never dereferenced in this state.\n        Self {\n            ptr: NonNull::dangling(),\n            len: Self::empty_len(),\n        }\n    }\n\n    /// Creates a new empty `Buffer` from a `ptr` and a `len`.\n    ///\n    /// # Panics\n    ///\n    /// If `ptr` is null.\n    pub unsafe fn from_raw_parts(ptr: *mut T, len: usize) -> Self {\n        assert!(len % 2 == 0);\n        assert!(!ptr.is_null());\n        if mem::size_of::<T>() == 0 {\n            debug_assert_eq!(len, Self::empty_len());\n        }\n        Self {\n            ptr: NonNull::new_unchecked(ptr),\n            len,\n        }\n    }\n\n    /// Total number of bytes in the buffer.\n    pub fn size_in_bytes(len: usize) -> usize {\n        let v = no_required_allocation_units(len * mem::size_of::<T>())\n            * allocation_granularity();\n        debug_assert!(\n            v >= len * mem::size_of::<T>(),\n            \"len: {}, so<T>: {}, v: {}\",\n            len,\n            mem::size_of::<T>(),\n            v\n        );\n        v\n    }\n\n    /// Create a mirrored buffer containing `len` `T`s where the first half of\n    /// the buffer is mirrored into the second half.\n    pub fn uninitialized(len: usize) -> Result<Self, AllocError> {\n        // Zero-sized types:\n        if mem::size_of::<T>() == 0 {\n            return Ok(Self {\n                ptr: NonNull::dangling(),\n                len: Self::empty_len(),\n            });\n        }\n        // The alignment requirements of `T` must be smaller than the\n        // allocation granularity.\n        assert!(mem::align_of::<T>() <= allocation_granularity());\n        // To split the buffer in two halfs the number of elements must be a\n        // multiple of two, and greater than zero to be able to mirror\n        // something.\n        if len == 0 {\n            return Ok(Self::new());\n        }\n        assert!(len % 2 == 0);\n\n        // How much memory we need:\n        let alloc_size = Self::size_in_bytes(len);\n        debug_assert!(alloc_size > 0);\n        debug_assert!(alloc_size % 2 == 0);\n        debug_assert!(alloc_size % allocation_granularity() == 0);\n        debug_assert!(alloc_size >= len * mem::size_of::<T>());\n\n        let ptr = allocate_mirrored(alloc_size)?;\n        Ok(Self {\n            ptr: unsafe { NonNull::new_unchecked(ptr as *mut T) },\n            len: alloc_size / mem::size_of::<T>(),\n            // Note: len is not a multiple of two: debug_assert!(len % 2 == 0);\n        })\n    }\n}","impl<T> Clone for Buffer<T>\nwhere\n    T: Clone,\n{\n    fn clone(&self) -> Self {\n        unsafe {\n            let mid = self.len() / 2;\n            let mut c = Self::uninitialized(self.len())\n                .expect(\"allocating a new mirrored buffer failed\");\n            let (from, _) = self.as_slice().split_at(mid);\n            {\n                let (to, _) = c.as_mut_slice().split_at_mut(mid);\n                to[..mid].clone_from_slice(&from[..mid]);\n            }\n            c\n        }\n    }\n}","impl<T> Default for Buffer<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}","impl<T> Drop for Buffer<T> {\n    fn drop(&mut self) {\n        if mem::size_of::<T>() == 0 {\n            debug_assert_eq!(self.len, Self::empty_len());\n            return;\n        }\n        if self.is_empty() {\n            return;\n        }\n\n        let buffer_size_in_bytes = Self::size_in_bytes(self.len());\n        let first_half_ptr = self.ptr.as_ptr() as *mut u8;\n        unsafe { deallocate_mirrored(first_half_ptr, buffer_size_in_bytes) };\n    }\n}","unsafe impl<T> Send for Buffer<T> where T: Send {}","unsafe impl<T> Sync for Buffer<T> where T: Sync {}"]},"single_path_import":{"mirrored::AllocError":"AllocError","mirrored::buffer::Buffer":"Buffer","std::mem::forget":"forget"},"srcs":{"<&'a SliceDeque<T> as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> slice::Iter<'a, T>{\n        self.iter()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a mut SliceDeque<T> as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> slice::IterMut<'a, T>{\n        self.iter_mut()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<*const T as WrappingOffsetFrom>::wrapping_offset_from_":["#[inline(always)]\nfn wrapping_offset_from_(self, other: Self) -> Option<isize>\n    where\n        T: Sized,{\n        let size = mem::size_of::<T>();\n        if size == 0 {\n            None\n        } else {\n            let diff = (other as isize).wrapping_sub(self as isize);\n            Some(diff / size as isize)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<T>{\n        self.iter\n            .next_back()\n            .map(|elt| unsafe { ptr::read(elt as *const _) })\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<T>{\n        self.iter\n            .next()\n            .map(|elt| unsafe { ptr::read(elt as *const _) })\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as std::ops::Drop>::drop":["#[inline]\nfn drop(&mut self){\n        // exhaust self first\n        self.for_each(|_| {});\n\n        if self.tail_len > 0 {\n            unsafe {\n                let source_deq = self.deq.as_mut();\n                // memmove back untouched tail, update to new length\n                let start = source_deq.len();\n                let tail = self.tail_start;\n                let src = source_deq.as_ptr().add(tail);\n                let dst = source_deq.as_mut_ptr().add(start);\n                ptr::copy(src, dst, self.tail_len);\n                source_deq.move_tail_unchecked(self.tail_len as isize);\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DrainFilter<'a, T, F> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<T>{\n        unsafe {\n            while self.idx != self.old_len {\n                let i = self.idx;\n                self.idx += 1;\n                let v = slice::from_raw_parts_mut(\n                    self.deq.as_mut_ptr(),\n                    self.old_len,\n                );\n                if (self.pred)(&mut v[i]) {\n                    self.del += 1;\n                    return Some(ptr::read(&v[i]));\n                } else if self.del > 0 {\n                    let del = self.del;\n                    let src: *const T = &v[i];\n                    let dst: *mut T = &mut v[i - del];\n                    // This is safe because self.deq has length 0\n                    // thus its elements will not have Drop::drop\n                    // called on them in the event of a panic.\n                    ptr::copy_nonoverlapping(src, dst, 1);\n                }\n            }\n            None\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DrainFilter<'a, T, F> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        println!(\"Now\");\n        (0, Some(self.old_len - self.idx))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DrainFilter<'a, T, F> as std::ops::Drop>::drop":["fn drop(&mut self){\n        for _ in self.by_ref() {}\n        \n        unsafe {\n            let v = slice::from_raw_parts_mut(\n                self.deq.as_mut_ptr(),\n                self.old_len,\n            );\n            //println!(\"{:?}\", v);\n            let new_len = self.old_len - self.del;\n            self.deq.move_tail_unchecked(new_len as isize);\n            let v = slice::from_raw_parts_mut(\n                self.deq.as_mut_ptr(),\n                self.old_len,\n            );\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<ExtendDefault as ExtendWith<T>>::last":["fn last(self) -> T{\n        Default::default()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<ExtendDefault as ExtendWith<T>>::next":["fn next(&self) -> T{\n        Default::default()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<ExtendElement<T> as ExtendWith<T>>::last":["fn last(self) -> T{\n        self.0\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<ExtendElement<T> as ExtendWith<T>>::next":["fn next(&self) -> T{\n        self.0.clone()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<T> as std::clone::Clone>::clone":["#[inline]\nfn clone(&self) -> Self{\n        let mut deq = SliceDeque::<T>::with_capacity(self.size_hint().0);\n        unsafe {\n            deq.append_elements(self.as_slice());\n        }\n        deq.into_iter()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<T> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<T>{\n        unsafe {\n            if self.end == self.ptr {\n                None\n            } else if mem::size_of::<T>() == 0 {\n                // See above for why 'ptr.offset' isn't used\n                self.end = intrinsics::arith_offset(self.end as *const i8, -1)\n                    as *mut T;\n\n                // Use a non-null pointer value\n                // (self.end might be null because of wrapping)\n                Some(ptr::read(1 as *mut T))\n            } else {\n                self.end = self.end.offset(-1);\n\n                Some(ptr::read(self.end))\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<T> as std::iter::Iterator>::count":["#[inline]\nfn count(self) -> usize{\n        self.size_hint().0\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<T> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<T>{\n        unsafe {\n            if self.ptr as *const _ == self.end {\n                None\n            } else if mem::size_of::<T>() == 0 {\n                // purposefully don't use 'ptr.offset' because for\n                // deques with 0-size elements this would return the\n                // same pointer.\n                self.ptr = intrinsics::arith_offset(self.ptr as *const i8, 1)\n                    as *mut T;\n\n                // Use a non-null pointer value\n                // (self.ptr might be null because of wrapping)\n                Some(ptr::read(1 as *mut T))\n            } else {\n                let old = self.ptr;\n                self.ptr = self.ptr.add(1);\n\n                Some(ptr::read(old))\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<T> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        let exact = match self.ptr.wrapping_offset_from_(self.end) {\n            Some(x) => x as usize,\n            None => (self.end as usize).wrapping_sub(self.ptr as usize),\n        };\n        (exact, Some(exact))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<T> as std::ops::Drop>::drop":["#[inline]\nfn drop(&mut self){\n        // destroy the remaining elements\n        for _x in self.by_ref() {}\n\n        // Buffer handles deallocation\n        let _ =\n            unsafe { Buffer::from_raw_parts(self.buf.as_ptr(), 2 * self.cap) };\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 0]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 10]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 11]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 12]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 13]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 14]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 15]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 16]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 17]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 18]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 19]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 1]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 20]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 21]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 22]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 23]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 24]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 25]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 26]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 27]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 28]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 29]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 2]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 30]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 31]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 32]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 3]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 4]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 5]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 6]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 7]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 8]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 9]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<&'b mut [B]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<SliceDeque<B>>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 0]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 10]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 11]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 12]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 13]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 14]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 15]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 16]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 17]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 18]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 19]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 1]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 20]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 21]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 22]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 23]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 24]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 25]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 26]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 27]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 28]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 29]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 2]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 30]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 31]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 32]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 3]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 4]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 5]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 6]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 7]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 8]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 9]>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<A> as std::cmp::PartialEq<std::vec::Vec<B>>>::eq":["#[inline]\nfn eq(&self, other: &$Rhs) -> bool{\n                self[..] == other[..]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as SpecExtend<&'a T, I>>::from_iter":["fn from_iter(iterator: I) -> Self{\n        SpecExtend::from_iter(iterator.cloned())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as SpecExtend<&'a T, I>>::spec_extend":["fn spec_extend(&mut self, iterator: I){\n        self.spec_extend(iterator.cloned())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as SpecExtend<T, I>>::from_iter":["#[cfg(not(feature = \"unstable\"))]\nfn from_iter(iterator: I) -> Self{\n        from_iter_default(iterator)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as SpecExtend<T, I>>::spec_extend":["#[cfg(not(feature = \"unstable\"))]\nfn spec_extend(&mut self, iter: I){\n        self.extend_desugared(iter)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::clone::Clone>::clone":["#[inline]\nfn clone(&self) -> Self{\n        let mut new = Self::with_capacity(self.len());\n        for i in self.iter() {\n            new.push_back(i.clone());\n        }\n        new\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::clone::Clone>::clone_from":["#[inline]\nfn clone_from(&mut self, other: &Self){\n        self.clear();\n        for i in other.iter() {\n            self.push_back(i.clone());\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::cmp::PartialOrd<&'a [T]>>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &&'a [T]) -> Option<cmp::Ordering>{\n        PartialOrd::partial_cmp(&**self, other)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::cmp::PartialOrd>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering>{\n        PartialOrd::partial_cmp(&**self, &**other)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::convert::AsMut<[T]>>::as_mut":["fn as_mut(&mut self) -> &mut [T]{\n        &mut *self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::convert::AsRef<[T]>>::as_ref":["fn as_ref(&self) -> &[T]{\n        &*self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::convert::From<&'a [T]>>::from":["#[inline]\nfn from(s: &'a [T]) -> Self{\n        let mut new = Self::with_capacity(s.len());\n        for i in s {\n            new.push_back(i.clone());\n        }\n        new\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::convert::From<&'a mut [T]>>::from":["#[inline]\nfn from(s: &'a mut [T]) -> Self{\n        let mut new = Self::with_capacity(s.len());\n        for i in s {\n            new.push_back(i.clone());\n        }\n        new\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::default::Default>::default":["#[inline]\nfn default() -> Self{\n        Self::new()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error>{\n        write!(f, \"{:?}\", self.as_slice())\n        /*\n         write!(\n             f,\n             // TODO: \"SliceDeque({:?})\",\n             \"SliceDeque(len: {}, cap: {}, head: {}, tail: {}, elems: {:?})\",\n             self.len(),\n             self.capacity(),\n             self.head(),\n             self.tail(),\n             self.as_slice()\n         )\n        */\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::hash::Hash>::hash":["#[inline]\nfn hash<H: hash::Hasher>(&self, state: &mut H){\n        hash::Hash::hash(&**self, state)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::iter::Extend<&'a T>>::extend":["fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I){\n        self.spec_extend(iter.into_iter())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::iter::Extend<T>>::extend":["#[inline]\nfn extend<I: IntoIterator<Item = T>>(&mut self, iter: I){\n        <Self as SpecExtend<T, I::IntoIter>>::spec_extend(\n            self,\n            iter.into_iter(),\n        )\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::iter::FromIterator<T>>::from_iter":["fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self{\n        <Self as SpecExtend<T, I::IntoIter>>::from_iter(iter.into_iter())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::iter::IntoIterator>::into_iter":["/// Creates a consuming iterator, that is, one that moves each value out of\n/// the deque (from start to end). The deque cannot be used after calling\n/// this.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![\"a\".to_string(), \"b\".to_string()];\n/// let expected = [\"a\".to_string(), \"b\".to_string()];\n/// for (i, s) in deq.into_iter().enumerate() {\n///     // s has type String, not &String\n///     println!(\"{}\", s);\n///     assert_eq!(s, expected[i]);\n/// }\n/// # }\n/// ```\n#[inline]\nfn into_iter(self) -> IntoIter<T>{\n        unsafe {\n            let buf_ptr = self.buf.ptr();\n            intrinsics::assume(!buf_ptr.is_null());\n            let begin = self.as_ptr();\n            let end = if mem::size_of::<T>() == 0 {\n                intrinsics::arith_offset(begin as *const i8, self.len() as _)\n                    as *const _\n            } else {\n                begin.add(self.len())\n            };\n            assert!(begin as usize <= end as usize);\n            let it = IntoIter {\n                buf: NonNull::new_unchecked(buf_ptr),\n                cap: self.capacity(),\n                ptr: begin,\n                end,\n            };\n            debug_assert_eq!(self.len(), it.size_hint().0);\n            #[allow(clippy::mem_forget)]\n            mem::forget(self);\n            it\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::ops::Deref>::deref":["#[inline]\nfn deref(&self) -> &Self::Target{\n        self.as_slice()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::ops::DerefMut>::deref_mut":["#[inline]\nfn deref_mut(&mut self) -> &mut Self::Target{\n        self.as_mut_slice()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SliceDeque<T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        // In Rust, if Drop::drop panics, the value must be leaked,\n        // therefore we don't need to make sure that we handle that case\n        // here:\n        unsafe {\n            // use drop for [T]\n            println!(\"One\");\n            ptr::drop_in_place(&mut self[..]);\n        }\n        // Buffer handles deallocation\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Splice<'a, I> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n        self.drain.next_back()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Splice<'a, I> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        self.drain.next()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Splice<'a, I> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.drain.size_hint()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Splice<'a, I> as std::ops::Drop>::drop":["fn drop(&mut self){\n        // exhaust drain first\n        while let Some(_) = self.drain.next() {}\n\n        unsafe {\n            if self.drain.tail_len == 0 {\n                self.drain.deq.as_mut().extend(self.replace_with.by_ref());\n                return;\n            }\n\n            // First fill the range left by drain().\n            if !self.drain.fill(&mut self.replace_with) {\n                return;\n            }\n\n            // There may be more elements. Use the lower bound as an estimate.\n            // FIXME: Is the upper bound a better guess? Or something else?\n            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n            if lower_bound > 0 {\n                self.drain.move_tail_unchecked(lower_bound);\n                if !self.drain.fill(&mut self.replace_with) {\n                    return;\n                }\n            }\n\n            // Collect any remaining elements.\n            // This is a zero-length deque which does not allocate if\n            // `lower_bound` was exact.\n            let mut collected = self\n                .replace_with\n                .by_ref()\n                .collect::<SliceDeque<I::Item>>()\n                .into_iter();\n            // Now we have an exact count.\n            if collected.size_hint().0 > 0 {\n                self.drain.move_tail_unchecked(collected.size_hint().0);\n                let filled = self.drain.fill(&mut collected);\n                debug_assert!(filled);\n                debug_assert_eq!(collected.size_hint().0, 0);\n            }\n        }\n        // Let `Drain::drop` move the tail back if necessary and restore\n        // `deq.tail`.\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<T as SpecFromElem>::from_elem":["#[cfg(not(feature = \"unstable\"))]\nfn from_elem(elem: Self, n: usize) -> SliceDeque<Self>{\n        let mut v = SliceDeque::with_capacity(n);\n        v.extend_with(n, ExtendElement(elem));\n        v\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<macros::TinyAsciiString as std::fmt::Write>::write_str":["fn write_str(&mut self, s: &str) -> Result<(), crate::fmt::Error>{\n        for (idx, b) in s.bytes().enumerate() {\n            if let Some(v) = self.buf.get_mut(idx) {\n                *v = b;\n            } else {\n                return Err(crate::fmt::Error);\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/macros.rs\"))"],"<mirrored::AllocError as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut crate::fmt::Formatter) -> crate::fmt::Result{\n        match self {\n            AllocError::Oom => write!(f, \"out-of-memory\"),\n            AllocError::Other => write!(f, \"other (not out-of-memory)\"),\n        }\n    }","Real(LocalPath(\"src/mirrored/mod.rs\"))"],"<mirrored::buffer::Buffer<T> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        unsafe {\n            let mid = self.len() / 2;\n            let mut c = Self::uninitialized(self.len())\n                .expect(\"allocating a new mirrored buffer failed\");\n            let (from, _) = self.as_slice().split_at(mid);\n            {\n                let (to, _) = c.as_mut_slice().split_at_mut(mid);\n                to[..mid].clone_from_slice(&from[..mid]);\n            }\n            c\n        }\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"<mirrored::buffer::Buffer<T> as std::default::Default>::default":["fn default() -> Self{\n        Self::new()\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"<mirrored::buffer::Buffer<T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        if mem::size_of::<T>() == 0 {\n            debug_assert_eq!(self.len, Self::empty_len());\n            return;\n        }\n        if self.is_empty() {\n            return;\n        }\n\n        let buffer_size_in_bytes = Self::size_in_bytes(self.len());\n        let first_half_ptr = self.ptr.as_ptr() as *mut u8;\n        unsafe { deallocate_mirrored(first_half_ptr, buffer_size_in_bytes) };\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"Drain":["/// A draining iterator for `SliceDeque<T>`.\n///\n/// This `struct` is created by the [`drain`] method on [`SliceDeque`].\n///\n/// [`drain`]: struct.SliceDeque.html#method.drain\n/// [`SliceDeque`]: struct.SliceDeque.html\npub struct Drain<'a, T: 'a> {\n    /// Index of tail to preserve\n    tail_start: usize,\n    /// Length of tail\n    tail_len: usize,\n    /// Current remaining range to remove\n    iter: slice::Iter<'a, T>,\n    /// A shared mutable pointer to the deque (with shared ownership).\n    deq: NonNull<SliceDeque<T>>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Drain::<'a, T>::fill":["/// The range from `self.deq.tail` to `self.tail()_start` contains elements\n/// that have been moved out.\n/// Fill that range as much as possible with new elements from the\n/// `replace_with` iterator. Return whether we filled the entire\n/// range. (`replace_with.next()` didnâ€™t return `None`.)\nunsafe fn fill<I: Iterator<Item = T>>(\n        &mut self, replace_with: &mut I,\n    ) -> bool{\n        let deq = self.deq.as_mut();\n        let range_start = deq.len();\n        let range_end = self.tail_start;\n        let range_slice = slice::from_raw_parts_mut(\n            deq.as_mut_ptr().add(range_start),\n            range_end - range_start,\n        );\n\n        for place in range_slice {\n            if let Some(new_item) = replace_with.next() {\n                ptr::write(place, new_item);\n                deq.move_tail_unchecked(1);\n            } else {\n                return false;\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Drain::<'a, T>::move_tail_unchecked":["/// Make room for inserting more elements before the tail.\nunsafe fn move_tail_unchecked(&mut self, extra_capacity: usize){\n        let deq = self.deq.as_mut();\n        let used_capacity = self.tail_start + self.tail_len;\n        deq.reserve_capacity(used_capacity + extra_capacity)\n            .expect(\"oom\");\n\n        let new_tail_start = self.tail_start + extra_capacity;\n        let src = deq.as_ptr().add(self.tail_start);\n        let dst = deq.as_mut_ptr().add(new_tail_start);\n        ptr::copy(src, dst, self.tail_len);\n        self.tail_start = new_tail_start;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DrainFilter":["/// An iterator produced by calling `drain_filter` on `SliceDeque`.\npub struct DrainFilter<'a, T: 'a, F>\nwhere\n    F: FnMut(&mut T) -> bool,\n{\n    /// TODO: docs\n    deq: &'a mut SliceDeque<T>,\n    /// TODO: docs\n    idx: usize,\n    /// TODO: docs\n    del: usize,\n    /// TODO: docs\n    old_len: usize,\n    /// TODO: docs\n    pred: F,\n}","Real(LocalPath(\"src/lib.rs\"))"],"ExtendDefault":["/// TODO: docs\nstruct ExtendDefault;","Real(LocalPath(\"src/lib.rs\"))"],"ExtendElement":["/// TODO: docs\nstruct ExtendElement<T>(T);","Real(LocalPath(\"src/lib.rs\"))"],"ExtendWith":["/// This code generalises `extend_with_{element,default}`.\ntrait ExtendWith<T> {\n    /// TODO: docs\n    fn next(&self) -> T;\n    /// TODO: docs\n    fn last(self) -> T;\n}","Real(LocalPath(\"src/lib.rs\"))"],"IntoIter":["/// An iterator that moves out of a deque.\n///\n/// This `struct` is created by the `into_iter` method on\n/// [`SliceDeque`][`SliceDeque`] (provided by the [`IntoIterator`] trait).\n///\n/// [`SliceDeque`]: struct.SliceDeque.html\n/// [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\npub struct IntoIter<T> {\n    /// NonNull pointer to the buffer\n    buf: NonNull<T>,\n    /// Capacity of the buffer.\n    cap: usize,\n    /// Pointer to the first element.\n    ptr: *const T,\n    /// Pointer to one-past-the-end.\n    end: *const T,\n}","Real(LocalPath(\"src/lib.rs\"))"],"IntoIter::<T>::as_mut_slice":["/// Returns the remaining items of this iterator as a mutable slice.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq!['a', 'b', 'c'];\n/// let mut into_iter = deq.into_iter();\n/// assert_eq!(into_iter.as_slice(), ['a', 'b', 'c']);\n/// into_iter.as_mut_slice()[2] = 'z';\n/// assert_eq!(into_iter.next().unwrap(), 'a');\n/// assert_eq!(into_iter.next().unwrap(), 'b');\n/// assert_eq!(into_iter.next().unwrap(), 'z');\n/// # }\n/// ```\n#[inline]\npub fn as_mut_slice(&mut self) -> &mut [T]{\n        unsafe {\n            slice::from_raw_parts_mut(self.ptr as *mut T, self.size_hint().0)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"IntoIter::<T>::as_slice":["/// Returns the remaining items of this iterator as a slice.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq!['a', 'b', 'c'];\n/// let mut into_iter = deq.into_iter();\n/// assert_eq!(into_iter.as_slice(), ['a', 'b', 'c']);\n/// let _ = into_iter.next().unwrap();\n/// assert_eq!(into_iter.as_slice(), ['b', 'c']);\n/// # }\n/// ```\n#[inline]\npub fn as_slice(&self) -> &[T]{\n        unsafe { slice::from_raw_parts(self.ptr, self.size_hint().0) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque":["/// A double-ended queue that derefs into a slice.\n///\n/// It is implemented with a growable virtual ring buffer.\npub struct SliceDeque<T> {\n    /// Elements in the queue.\n    elems_: NonNull<[T]>,\n    /// Mirrored memory buffer.\n    buf: Buffer<T>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::append":["/// Moves all the elements of `other` into `Self`, leaving `other` empty.\n///\n/// # Panics\n///\n/// Panics if the number of elements in the deque overflows a `isize`.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![1, 2, 3];\n/// let mut deq2 = sdeq![4, 5, 6];\n/// deq.append(&mut deq2);\n/// assert_eq!(deq, [1, 2, 3, 4, 5, 6]);\n/// assert_eq!(deq2, []);\n/// # }\n/// ```\n#[inline]\npub fn append(&mut self, other: &mut Self){\n        unsafe {\n            self.append_elements(other.as_slice() as _);\n            other.elems_ = nonnull_raw_slice(other.buf.ptr(), 0);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::append_elements":["/// Appends elements to `self` from `other`.\n#[inline]\nunsafe fn append_elements(&mut self, other: *const [T]){\n        let count = (*other).len();\n        self.reserve(count);\n        let len = self.len();\n        ptr::copy_nonoverlapping(\n            other as *const T,\n            self.get_unchecked_mut(len),\n            count,\n        );\n        self.move_tail_unchecked(count as isize);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::as_mut_slice":["/// Extracts a mutable slice containing the entire deque.\n#[inline]\npub fn as_mut_slice(&mut self) -> &mut [T]{\n        unsafe { self.elems_.as_mut() }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::as_mut_slices":["/// Returns a pair of slices, where the first slice contains the contents\n/// of the deque and the second one is empty.\n#[inline]\npub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]){\n        unsafe {\n            let left = self.as_mut_slice();\n            let right =\n                slice::from_raw_parts_mut(usize::max_value() as *mut _, 0);\n            (left, right)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::as_slice":["/// Extracts a slice containing the entire deque.\n#[inline]\npub fn as_slice(&self) -> &[T]{\n        unsafe { self.elems_.as_ref() }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::as_slices":["/// Returns a pair of slices, where the first slice contains the contents\n/// of the deque and the second one is empty.\n#[inline]\npub fn as_slices(&self) -> (&[T], &[T]){\n        unsafe {\n            let left = self.as_slice();\n            let right =\n                slice::from_raw_parts(usize::max_value() as *const _, 0);\n            (left, right)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::back":["/// Provides a reference to the last element, or `None` if the deque is\n/// empty.\n///\n/// # Examples\n///\n/// ```\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::new();\n/// assert_eq!(deq.back(), None);\n///\n/// deq.push_back(1);\n/// deq.push_back(2);\n/// assert_eq!(deq.back(), Some(&2));\n/// deq.push_front(3);\n/// assert_eq!(deq.back(), Some(&2));\n/// ```\n#[inline]\npub fn back(&self) -> Option<&T>{\n        let last_idx = self.len().wrapping_sub(1);\n        self.get(last_idx)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::back_mut":["/// Provides a mutable reference to the last element, or `None` if the\n/// deque is empty.\n///\n/// # Examples\n///\n/// ```\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::new();\n/// assert_eq!(deq.front(), None);\n///\n/// deq.push_back(1);\n/// deq.push_back(2);\n/// assert_eq!(deq.back(), Some(&2));\n/// (*deq.back_mut().unwrap()) = 3;\n/// assert_eq!(deq.back(), Some(&3));\n/// ```\n#[inline]\npub fn back_mut(&mut self) -> Option<&mut T>{\n        let last_idx = self.len().wrapping_sub(1);\n        self.get_mut(last_idx)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::capacity":["/// Returns the number of elements that the deque can hold without\n/// reallocating.\n///\n/// # Examples\n///\n/// ```rust\n/// # use slice_deque::SliceDeque;\n/// let deq = SliceDeque::with_capacity(10);\n/// assert!(deq.capacity() >= 10);\n/// # let o: SliceDeque<u32> = deq;\n/// ```\n#[inline]\npub fn capacity(&self) -> usize{\n        // Note: the buffer length is not necessarily a power of two\n        // debug_assert!(self.buf.len() % 2 == 0);\n        self.buf.len() / 2\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::clear":["/// Removes all values from the deque.\n///\n/// # Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![1];\n/// assert!(!deq.is_empty());\n/// deq.clear();\n/// assert!(deq.is_empty());\n/// # }\n/// ```\n#[inline]\npub fn clear(&mut self){\n        self.truncate(0);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::dedup":["/// Removes consecutive repeated elements in the deque.\n///\n/// If the deque is sorted, this removes all duplicates.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![1, 2, 2, 3, 2];\n///\n/// deq.dedup();\n/// assert_eq!(deq, [1, 2, 3, 2]);\n///\n/// deq.sort();\n/// assert_eq!(deq, [1, 2, 2, 3]);\n///\n/// deq.dedup();\n/// assert_eq!(deq, [1, 2, 3]);\n/// # }\n/// ```\n#[inline]\npub fn dedup(&mut self){\n        self.dedup_by(|a, b| a == b)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::dedup_by":["/// Removes all but the first of consecutive elements in the deque\n/// satisfying a given equality relation.\n///\n/// The `same_bucket` function is passed references to two elements from\n/// the deque, and returns `true` if the elements compare equal, or\n/// `false` if they do not. The elements are passed in opposite order\n/// from their order in the deque, so if `same_bucket(a, b)` returns\n/// `true`, `a` is removed.\n///\n/// If the deque is sorted, this removes all duplicates.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n///\n/// deq.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n///\n/// assert_eq!(deq, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n/// # }\n/// ```\n#[inline]\npub fn dedup_by<F>(&mut self, mut same_bucket: F)\n    where\n        F: FnMut(&mut T, &mut T) -> bool,{\n        unsafe {\n            // Although we have a mutable reference to `self`, we cannot make\n            // *arbitrary* changes. The `same_bucket` calls could panic, so we\n            // must ensure that the deque is in a valid state at all time.\n            //\n            // The way that we handle this is by using swaps; we iterate\n            // over all the elements, swapping as we go so that at the end\n            // the elements we wish to keep are in the front, and those we\n            // wish to reject are at the back. We can then truncate the\n            // deque. This operation is still O(n).\n            //\n            // Example: We start in this state, where `r` represents \"next\n            // read\" and `w` represents \"next_write`.\n            //\n            //           r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //           w\n            //\n            // Comparing self[r] against self[w-1], this is not a duplicate, so\n            // we swap self[r] and self[w] (no effect as r==w) and then\n            // increment both r and w, leaving us with:\n            //\n            //               r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //               w\n            //\n            // Comparing self[r] against self[w-1], this value is a duplicate,\n            // so we increment `r` but leave everything else unchanged:\n            //\n            //                   r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //               w\n            //\n            // Comparing self[r] against self[w-1], this is not a duplicate,\n            // so swap self[r] and self[w] and advance r and w:\n            //\n            //                       r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //                   w\n            //\n            // Not a duplicate, repeat:\n            //\n            //                           r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n            //     +---+---+---+---+---+---+\n            //                       w\n            //\n            // Duplicate, advance r. End of deque. Truncate to w.\n\n            let ln = self.len();\n            if intrinsics::unlikely(ln <= 1) {\n                return;\n            }\n\n            // Avoid bounds checks by using raw pointers.\n            let p = self.as_mut_ptr();\n            let mut r: usize = 1;\n            let mut w: usize = 1;\n\n            while r < ln {\n                let p_r = p.add(r);\n                let p_wm1 = p.add(w - 1);\n                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n                    if r != w {\n                        let p_w = p_wm1.add(1);\n                        mem::swap(&mut *p_r, &mut *p_w);\n                    }\n                    w += 1;\n                }\n                r += 1;\n            }\n\n            self.truncate(w);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::dedup_by_key":["/// Removes all but the first of consecutive elements in the deque that\n/// resolve to the same key.\n///\n/// If the deque is sorted, this removes all duplicates.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![10, 20, 21, 30, 20];\n///\n/// deq.dedup_by_key(|i| *i / 10);\n/// assert_eq!(deq, [10, 20, 30, 20]);\n/// # }\n/// ```\n#[inline]\npub fn dedup_by_key<F, K>(&mut self, mut key: F)\n    where\n        F: FnMut(&mut T) -> K,\n        K: PartialEq,{\n        self.dedup_by(|a, b| key(a) == key(b))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::drain":["/// Creates a draining iterator that removes the specified range in the\n/// deque and yields the removed items.\n///\n/// Note 1: The element range is removed even if the iterator is only\n/// partially consumed or not consumed at all.\n///\n/// Note 2: It is unspecified how many elements are removed from the deque\n/// if the `Drain` value is leaked.\n///\n/// # Panics\n///\n/// Panics if the starting point is greater than the end point or if\n/// the end point is greater than the length of the deque.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![1, 2, 3];\n/// let u: Vec<_> = deq.drain(1..).collect();\n/// assert_eq!(deq, &[1]);\n/// assert_eq!(u, &[2, 3]);\n///\n/// // A full range clears the deque\n/// deq.drain(..);\n/// assert_eq!(deq, &[]);\n/// # }\n/// ```\n#[inline]\n#[allow(clippy::needless_pass_by_value)]\npub fn drain<R>(&mut self, range: R) -> Drain<T>\n    where\n        R: ops::RangeBounds<usize>,{\n        use ops::Bound::{Excluded, Included, Unbounded};\n        // Memory safety\n        //\n        // When the Drain is first created, it shortens the length of\n        // the source deque to make sure no uninitalized or moved-from\n        // elements are accessible at all if the Drain's destructor\n        // never gets to run.\n        //\n        // Drain will ptr::read out the values to remove.\n        // When finished, remaining tail of the deque is copied back to cover\n        // the hole, and the deque length is restored to the new length.\n        //\n        let len = self.len();\n        let start = match range.start_bound() {\n            Included(&n) => n,\n            Excluded(&n) => n + 1,\n            Unbounded => 0,\n        };\n        let end = match range.end_bound() {\n            Included(&n) => n + 1,\n            Excluded(&n) => n,\n            Unbounded => len,\n        };\n        assert!(start <= end);\n        assert!(end <= len);\n\n        unsafe {\n            // set self.deq length's to start, to be safe in case Drain is\n            // leaked\n            self.elems_ = nonnull_raw_slice(self.as_mut_ptr(), start);\n            // Use the borrow in the IterMut to indicate borrowing behavior of\n            // the whole Drain iterator (like &mut T).\n            let range_slice = slice::from_raw_parts_mut(\n                if mem::size_of::<T>() == 0 {\n                    intrinsics::arith_offset(\n                        self.as_mut_ptr() as *mut i8,\n                        start as _,\n                    ) as *mut _\n                } else {\n                    self.as_mut_ptr().add(start)\n                },\n                end - start,\n            );\n            Drain {\n                tail_start: end,\n                tail_len: len - end,\n                iter: range_slice.iter(),\n                deq: NonNull::from(self),\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::drain_filter":["/// Creates an iterator which uses a closure to determine if an element\n/// should be removed.\n///\n/// If the closure returns `true`, then the element is removed and yielded.\n/// If the closure returns `false`, it will try again, and call the closure\n/// on the next element, seeing if it passes the test.\n///\n/// Using this method is equivalent to the following code:\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// # let some_predicate = |x: &mut i32| { *x == 2 || *x == 3 || *x == 6\n/// # };\n/// let mut deq = SliceDeque::new();\n/// deq.extend(1..7);\n/// let mut i = 0;\n/// while i != deq.len() {\n///     if some_predicate(&mut deq[i]) {\n///         let val = deq.remove(i);\n///     // your code here\n///     } else {\n///         i += 1;\n///     }\n/// }\n/// # let mut expected = sdeq![1, 4, 5];\n/// # assert_eq!(deq, expected);\n/// # }\n/// ```\n///\n/// But `drain_filter` is easier to use. `drain_filter` is also more\n/// efficient, because it can backshift the elements of the deque in\n/// bulk.\n///\n/// Note that `drain_filter` also lets you mutate every element in the\n/// filter closure, regardless of whether you choose to keep or remove\n/// it.\n///\n///\n/// # Examples\n///\n/// Splitting a deque into evens and odds, reusing the original allocation:\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut numbers = sdeq![1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15];\n///\n/// let evens = numbers\n///     .drain_filter(|x| *x % 2 == 0)\n///     .collect::<SliceDeque<_>>();\n/// let odds = numbers;\n///\n/// assert_eq!(sdeq![2, 4, 6, 8, 14], evens);\n/// assert_eq!(odds, sdeq![1, 3, 5, 9, 11, 13, 15]);\n/// # }\n/// ```\n#[inline]\npub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<T, F>\n    where\n        F: FnMut(&mut T) -> bool,{\n        let old_len = self.len();\n\n        // Guard against us getting leaked (leak amplification)\n        unsafe {\n            self.move_tail_unchecked(-(old_len as isize));\n        }\n\n        DrainFilter {\n            deq: self,\n            idx: 0,\n            del: 0,\n            old_len,\n            pred: filter,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::extend_desugared":["/// Extend for a general iterator.\n///\n/// This function should be the moral equivalent of:\n///\n/// >  for item in iterator {\n/// >      self.push_back(item);\n/// >  }\n#[inline]\nfn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I){\n        #[allow(clippy::while_let_on_iterator)]\n        while let Some(element) = iterator.next() {\n            let len = self.len();\n            let cap = self.capacity();\n            if len == cap {\n                let (lower, upper) = iterator.size_hint();\n                let additional_cap = if let Some(upper) = upper {\n                    upper\n                } else {\n                    lower\n                }\n                .checked_add(1)\n                .expect(\"overflow\");\n                self.reserve(additional_cap);\n            }\n            debug_assert!(self.len() < self.capacity());\n            unsafe {\n                ptr::write(self.get_unchecked_mut(len), element);\n                // NB can't overflow since we would have had to alloc the\n                // address space\n                self.move_tail_unchecked(1);\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::extend_from_slice":["/// Clones and appends all elements in a slice to the `SliceDeque`.\n///\n/// Iterates over the slice `other`, clones each element, and then appends\n/// it to this `SliceDeque`. The `other` slice is traversed in-order.\n///\n/// Note that this function is same as `extend` except that it is\n/// specialized to work with slices instead. If and when Rust gets\n/// specialization this function will likely be deprecated (but still\n/// available).\n///\n/// # Examples\n///\n/// ```\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::new();\n/// deq.push_back(1);\n/// deq.extend_from_slice(&[2, 3, 4]);\n/// assert_eq!(deq, [1, 2, 3, 4]);\n/// ```\n#[inline]\npub fn extend_from_slice(&mut self, other: &[T]){\n        #[cfg(feature = \"unstable\")]\n        {\n            self.spec_extend(other.iter())\n        }\n        #[cfg(not(feature = \"unstable\"))]\n        {\n            self.reserve(other.len());\n            unsafe {\n                let len = self.len();\n                self.move_tail_unchecked(other.len() as isize);\n                self.get_unchecked_mut(len..).clone_from_slice(other);\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::extend_with":["/// Extend the `SliceDeque` by `n` values, using the given generator.\n#[inline]\nfn extend_with<E: ExtendWith<T>>(&mut self, n: usize, value: E){\n        self.reserve(n);\n\n        unsafe {\n            let mut ptr = self.as_mut_ptr().add(self.len());\n\n            // Write all elements except the last one\n            for _ in 1..n {\n                ptr::write(ptr, value.next());\n                ptr = ptr.add(1);\n                // Increment the length in every step in case next() panics\n                self.move_tail_unchecked(1);\n            }\n\n            if n > 0 {\n                // We can write the last element directly without cloning\n                // needlessly\n                ptr::write(ptr, value.last());\n                self.move_tail_unchecked(1);\n            }\n\n            // len set by scope guard\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::from_raw_parts":["/// Creates a SliceDeque from its raw components.\n///\n/// The `ptr` must be a pointer to the beginning of the memory buffer from\n/// another `SliceDeque`, `capacity` the capacity of this `SliceDeque`, and\n/// `elems` the elements of this `SliceDeque`.\n#[inline]\npub unsafe fn from_raw_parts(\n        ptr: *mut T, capacity: usize, elems: &mut [T],\n    ) -> Self{\n        let begin = elems.as_mut_ptr();\n        debug_assert!(in_bounds(slice::from_raw_parts(ptr, capacity), begin));\n        debug_assert!(elems.len() < capacity);\n\n        Self {\n            elems_: NonNull::new_unchecked(elems),\n            buf: Buffer::from_raw_parts(ptr, capacity * 2),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::front":["/// Provides a reference to the first element, or `None` if the deque is\n/// empty.\n///\n/// # Examples\n///\n/// ```\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::new();\n/// assert_eq!(deq.front(), None);\n///\n/// deq.push_back(1);\n/// deq.push_back(2);\n/// assert_eq!(deq.front(), Some(&1));\n/// deq.push_front(3);\n/// assert_eq!(deq.front(), Some(&3));\n/// ```\n#[inline]\npub fn front(&self) -> Option<&T>{\n        self.get(0)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::front_mut":["/// Provides a mutable reference to the first element, or `None` if the\n/// deque is empty.\n///\n/// # Examples\n///\n/// ```\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::new();\n/// assert_eq!(deq.front(), None);\n///\n/// deq.push_back(1);\n/// deq.push_back(2);\n/// assert_eq!(deq.front(), Some(&1));\n/// (*deq.front_mut().unwrap()) = 3;\n/// assert_eq!(deq.front(), Some(&3));\n/// ```\n#[inline]\npub fn front_mut(&mut self) -> Option<&mut T>{\n        self.get_mut(0)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::grow_policy":["/// Growth policy of the deque. The capacity is going to be a multiple of\n/// the page-size anyways, so we just double capacity when needed.\n#[inline]\nfn grow_policy(&self, additional: usize) -> usize{\n        let cur_cap = self.capacity();\n        let old_len = self.len();\n        let req_cap = old_len.checked_add(additional).expect(\"overflow\");\n        if req_cap > cur_cap {\n            let dbl_cap = cur_cap.saturating_mul(2);\n            cmp::max(req_cap, dbl_cap)\n        } else {\n            req_cap\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::insert":["/// Inserts an `element` at `index` within the deque, shifting all elements\n/// with indices greater than or equal to `index` towards the back.\n///\n/// Element at index 0 is the front of the queue.\n///\n/// # Panics\n///\n/// Panics if `index` is greater than deque's length\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq!['a', 'b', 'c'];\n/// assert_eq!(deq, &['a', 'b', 'c']);\n///\n/// deq.insert(1, 'd');\n/// assert_eq!(deq, &['a', 'd', 'b', 'c']);\n/// # }\n/// ```\n#[inline]\npub fn insert(&mut self, index: usize, element: T){\n        unsafe {\n            let len = self.len();\n            assert!(index <= len);\n\n            if intrinsics::unlikely(self.is_full()) {\n                self.reserve(1);\n                // TODO: when the deque needs to grow, reserve should\n                // copy the memory to the new storage leaving a whole\n                // at the index where the new elements are to be inserted\n                // to avoid having to copy the memory again\n            }\n\n            let p = if index > self.len() / 2 {\n                let p = self.as_mut_ptr().add(index);\n                // Shift elements towards the back\n                ptr::copy(p, p.add(1), len - index);\n                self.move_tail_unchecked(1);\n                p\n            } else {\n                // Shift elements towards the front\n                self.move_head_unchecked(-1);\n                let p = self.as_mut_ptr().add(index);\n                ptr::copy(p, p.sub(1), index);\n                p\n            };\n            ptr::write(p, element); // Overwritte\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::is_full":["/// Is the ring buffer full ?\n///\n/// # Examples\n///\n/// ```rust\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::with_capacity(10);\n/// assert!(!deq.is_full());\n/// # let o: SliceDeque<u32> = deq;\n/// ```\n#[inline]\npub fn is_full(&self) -> bool{\n        self.len() == self.capacity()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::len":["/// Number of elements in the ring buffer.\n///\n/// # Examples\n///\n/// ```rust\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::with_capacity(10);\n/// assert!(deq.len() == 0);\n/// deq.push_back(3);\n/// assert!(deq.len() == 1);\n/// ```\n#[inline]\npub fn len(&self) -> usize{\n        let l = self.as_slice().len();\n        debug_assert!(l <= self.capacity());\n        l\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::move_head":["/// Moves the deque head by `x`.\n///\n/// # Panics\n///\n/// If the `head` wraps over the `tail`, that is, if `x` is out-of-range\n/// `[-(capacity() - len()), len()]`.\n///\n/// # Unsafe\n///\n/// It does not `drop` nor initialize elements, it just moves where the\n/// tail of the deque points to within the allocated buffer.\n#[inline]\npub unsafe fn move_head(&mut self, x: isize){\n        assert!(\n            x >= -((self.capacity() - self.len()) as isize)\n                && x <= self.len() as isize\n        );\n        self.move_head_unchecked(x)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::move_head_unchecked":["/// Moves the deque head by `x`.\n///\n/// # Panics\n///\n/// If the head wraps over the tail the behavior is undefined, that is,\n/// if `x` is out-of-range `[-(capacity() - len()), len()]`.\n///\n/// If `-C debug-assertions=1` violating this pre-condition `panic!`s.\n///\n/// # Unsafe\n///\n/// It does not `drop` nor initialize elements, it just moves where the\n/// tail of the deque points to within the allocated buffer.\n#[inline]\npub unsafe fn move_head_unchecked(&mut self, x: isize){\n        let cap = self.capacity();\n        let len = self.len();\n        // Make sure that the begin does not wrap over the end:\n        debug_assert!(x >= -((cap - len) as isize));\n        debug_assert!(x <= len as isize);\n\n        // Obtain the begin of the slice and offset it by x:\n        let mut new_begin = self.as_mut_ptr().offset(x) as usize;\n\n        // Compute the boundaries of the first and second memory regions:\n        let first_region_begin = self.buf.ptr() as usize;\n        let region_size = Buffer::<T>::size_in_bytes(self.buf.len()) / 2;\n        debug_assert!(cap * mem::size_of::<T>() <= region_size);\n        let second_region_begin = first_region_begin + region_size;\n\n        // If the new begin is not inside the first memory region, we shift it\n        // by the region size into it:\n        if new_begin < first_region_begin {\n            new_begin += region_size;\n        } else if new_begin >= second_region_begin {\n            // Should be within the second region:\n            debug_assert!(new_begin < second_region_begin + region_size);\n            new_begin -= region_size;\n        }\n        debug_assert!(new_begin >= first_region_begin);\n        debug_assert!(new_begin < second_region_begin);\n\n        // The new begin is now in the first memory region:\n        let new_begin = new_begin as *mut T;\n        debug_assert!(in_bounds(\n            slice::from_raw_parts(self.buf.ptr() as *mut u8, region_size),\n            new_begin as *mut u8\n        ));\n\n        let new_len = len as isize - x;\n        debug_assert!(\n            new_len >= 0,\n            \"len = {}, x = {}, new_len = {}\",\n            len,\n            x,\n            new_len\n        );\n        debug_assert!(new_len <= cap as isize);\n        self.elems_ = nonnull_raw_slice(new_begin, new_len as usize);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::move_tail":["/// Moves the deque tail by `x`.\n///\n/// # Panics\n///\n/// If the `tail` wraps over the `head`, that is, if `x` is out-of-range\n/// `[-len(), capacity() - len()]`.\n///\n/// # Unsafe\n///\n/// It does not `drop` nor initialize elements, it just moves where the\n/// tail of the deque points to within the allocated buffer.\n#[inline]\npub unsafe fn move_tail(&mut self, x: isize){\n        assert!(\n            x >= -(self.len() as isize)\n                && x <= (self.capacity() - self.len()) as isize\n        );\n        self.move_tail_unchecked(x);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::move_tail_unchecked":["/// Moves the deque tail by `x`.\n///\n/// # Panics\n///\n/// If the `tail` wraps over the `head` the behavior is undefined, that is,\n/// if `x` is out-of-range `[-len(), capacity() - len()]`.\n///\n/// If `-C debug-assertions=1` violating this pre-condition `panic!`s.\n///\n/// # Unsafe\n///\n/// It does not `drop` nor initialize elements, it just moves where the\n/// tail of the deque points to within the allocated buffer.\n#[inline]\npub unsafe fn move_tail_unchecked(&mut self, x: isize){\n        // Make sure that the end does not wrap over the begin:\n        let len = self.len();\n        let cap = self.capacity();\n        debug_assert!(x >= -(len as isize));\n        debug_assert!(x <= (cap - len) as isize);\n\n        let new_len = len as isize + x;\n        debug_assert!(new_len >= 0);\n        debug_assert!(new_len <= cap as isize);\n\n        self.elems_ = nonnull_raw_slice(self.as_mut_ptr(), new_len as usize);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::new":["/// Creates a new empty deque.\n///\n/// # Examples\n///\n/// ```rust\n/// # use slice_deque::SliceDeque;\n/// let deq = SliceDeque::new();\n/// # let o: SliceDeque<u32> = deq;\n/// ```\n#[inline]\npub fn new() -> Self{\n        unsafe {\n            let buf = Buffer::new();\n            Self {\n                elems_: nonnull_raw_slice(buf.ptr(), 0),\n                buf,\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::pop_back":["/// Removes the last element from the deque and returns it, or `None` if it\n/// is empty.\n///\n/// # Examples\n///\n/// ```\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::new();\n/// assert_eq!(deq.pop_back(), None);\n///\n/// deq.push_back(1);\n/// deq.push_back(3);\n///\n/// assert_eq!(deq.pop_back(), Some(3));\n/// assert_eq!(deq.pop_back(), Some(1));\n/// assert_eq!(deq.pop_back(), None);\n/// ```\n#[inline]\npub fn pop_back(&mut self) -> Option<T>{\n        unsafe {\n            let len = self.len();\n            let v = match self.get_mut(len.wrapping_sub(1)) {\n                None => return None,\n                Some(v) => ptr::read(v),\n            };\n            self.move_tail_unchecked(-1);\n            Some(v)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::pop_front":["/// Removes the first element and returns it, or `None` if the deque is\n/// empty.\n///\n/// # Examples\n///\n/// ```\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::new();\n/// assert_eq!(deq.pop_front(), None);\n///\n/// deq.push_back(1);\n/// deq.push_back(2);\n///\n/// assert_eq!(deq.pop_front(), Some(1));\n/// assert_eq!(deq.pop_front(), Some(2));\n/// assert_eq!(deq.pop_front(), None);\n/// ```\n#[inline]\npub fn pop_front(&mut self) -> Option<T>{\n        unsafe {\n            let v = match self.get_mut(0) {\n                None => return None,\n                Some(v) => ptr::read(v),\n            };\n            self.move_head_unchecked(1);\n            Some(v)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::push_back":["/// Appends `value` to the deque.\n///\n/// # Panics\n///\n/// On OOM.\n///\n/// # Examples\n///\n/// ```rust\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::new();\n/// deq.push_back(1);\n/// deq.push_back(3);\n/// assert_eq!(deq.back(), Some(&3));\n/// ```\n#[inline]\npub fn push_back(&mut self, value: T){\n        if let Err(e) = self.try_push_back(value) {\n            panic!(\"{:?}\", e.1);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::push_front":["/// Prepends `value` to the deque.\n///\n/// # Panics\n///\n/// On OOM.\n///\n/// # Examples\n///\n/// ```rust\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::new();\n/// deq.push_front(1);\n/// deq.push_front(2);\n/// assert_eq!(deq.front(), Some(&2));\n/// ```\n#[inline]\npub fn push_front(&mut self, value: T){\n        if let Err(e) = self.try_push_front(value) {\n            panic!(\"{:?}\", e.1);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::remove":["/// Removes and returns the element at position `index` within the deque.\n///\n/// # Panics\n///\n/// Panics if `index` is out of bounds.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![1, 2, 3, 4, 5];\n/// assert_eq!(deq.remove(1), 2);\n/// assert_eq!(deq, [1, 3, 4, 5]);\n/// # }\n/// ```\n#[inline]\n#[allow(clippy::shadow_unrelated)]\npub fn remove(&mut self, index: usize) -> T{\n        let len = self.len();\n        assert!(index < len);\n        unsafe {\n            // copy element at pointer:\n            let ptr = self.as_mut_ptr().add(index);\n            let ret = ptr::read(ptr);\n            if index > self.len() / 2 {\n                // If the index is close to the back, shift elements from the\n                // back towards the front\n                ptr::copy(ptr.add(1), ptr, len - index - 1);\n                self.move_tail_unchecked(-1);\n            } else {\n                // If the index is close to the front, shift elements from the\n                // front towards the back\n                let ptr = self.as_mut_ptr();\n                ptr::copy(ptr, ptr.add(1), index);\n                self.move_head_unchecked(1);\n            }\n\n            ret\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::remove_item":["/// Removes the first instance of `item` from the deque if the item exists.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![1, 2, 3, 1];\n///\n/// deq.remove_item(&1);\n/// assert_eq!(deq, &[2, 3, 1]);\n/// deq.remove_item(&1);\n/// assert_eq!(deq, &[2, 3]);\n/// # }\n/// ```\n#[inline]\npub fn remove_item(&mut self, item: &T) -> Option<T>{\n        let pos = match self.iter().position(|x| *x == *item) {\n            Some(x) => x,\n            None => return None,\n        };\n        Some(self.remove(pos))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::reserve":["/// Reserves capacity for inserting at least `additional` elements without\n/// reallocating. Does nothing if the capacity is already sufficient.\n///\n/// The collection always reserves memory in multiples of the page size.\n///\n/// # Panics\n///\n/// Panics if the new capacity overflows `usize` or on OOM.\n#[inline]\npub fn reserve(&mut self, additional: usize){\n        self.try_reserve(additional).unwrap();\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::reserve_capacity":["/// Attempts to reserve capacity for `new_capacity` elements. Does nothing\n/// if the capacity is already sufficient.\n#[inline]\nfn reserve_capacity(\n        &mut self, new_capacity: usize,\n    ) -> Result<(), AllocError>{\n        unsafe {\n            if new_capacity <= self.capacity() {\n                return Ok(());\n            }\n\n            let mut new_buffer = Buffer::uninitialized(2 * new_capacity)?;\n            debug_assert!(new_buffer.len() >= 2 * new_capacity);\n\n            let len = self.len();\n            // Move the elements from the current buffer\n            // to the beginning of the new buffer:\n            {\n                let from_ptr = self.as_mut_ptr();\n                let to_ptr = new_buffer.as_mut_slice().as_mut_ptr();\n                crate::ptr::copy_nonoverlapping(from_ptr, to_ptr, len);\n            }\n\n            // Exchange buffers\n            crate::mem::swap(&mut self.buf, &mut new_buffer);\n\n            // Correct the slice - we copied to the\n            // beginning of the of the new buffer:\n            self.elems_ = nonnull_raw_slice(self.buf.ptr(), len);\n            Ok(())\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::reserve_exact":["/// Reserves the minimum capacity for exactly `additional` more elements to\n/// be inserted in the given `SliceDeq<T>`. After calling `reserve_exact`,\n/// capacity will be greater than or equal to `self.len() + additional`.\n/// Does nothing if the capacity is already sufficient.\n///\n/// Note that the allocator may give the collection more space than it\n/// requests. Therefore capacity can not be relied upon to be precisely\n/// minimal. Prefer `reserve` if future insertions are expected.\n///\n/// # Panics\n///\n/// Panics if the new capacity overflows `usize`.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # fn main() {\n/// let mut deq = sdeq![1];\n/// deq.reserve_exact(10);\n/// assert!(deq.capacity() >= 11);\n/// # }\n/// ```\n#[inline]\npub fn reserve_exact(&mut self, additional: usize){\n        let old_len = self.len();\n        let new_cap = old_len.checked_add(additional).expect(\"overflow\");\n        self.reserve_capacity(new_cap).unwrap();\n        debug_assert!(self.capacity() >= old_len + additional);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::resize":["/// Modifies the `SliceDeque` in-place so that `len()` is equal to\n/// `new_len`, either by removing excess elements or by appending clones of\n/// `value` to the back.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![5, 10, 15];\n/// assert_eq!(deq, [5, 10, 15]);\n///\n/// deq.resize(2, 0);\n/// assert_eq!(deq, [5, 10]);\n///\n/// deq.resize(5, 20);\n/// assert_eq!(deq, [5, 10, 20, 20, 20]);\n/// # }\n/// ```\n#[inline]\npub fn resize(&mut self, new_len: usize, value: T){\n        let len = self.len();\n\n        if new_len > len {\n            self.reserve(new_len - len);\n            while self.len() < new_len {\n                self.push_back(value.clone());\n            }\n        } else {\n            self.truncate(new_len);\n        }\n        debug_assert!(self.len() == new_len);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::resize_default":["/// Resizes the `SliceDeque` in-place so that `len` is equal to `new_len`.\n///\n/// If `new_len` is greater than `len`, the `SliceDeque` is extended by the\n/// difference, with each additional slot filled with `Default::default()`.\n/// If `new_len` is less than `len`, the `SliceDeque` is simply truncated.\n///\n/// This method uses `Default` to create new values on every push. If\n/// you'd rather `Clone` a given value, use [`resize`].\n///\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![1, 2, 3];\n/// deq.resize_default(5);\n/// assert_eq!(deq, [1, 2, 3, 0, 0]);\n///\n/// deq.resize_default(2);\n/// assert_eq!(deq, [1, 2]);\n/// # }\n/// ```\n///\n/// [`resize`]: #method.resize\n#[inline]\npub fn resize_default(&mut self, new_len: usize){\n        let len = self.len();\n\n        if new_len > len {\n            self.extend_with(new_len - len, ExtendDefault);\n        } else {\n            self.truncate(new_len);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::retain":["/// Retains only the elements specified by the predicate.\n///\n/// That is, remove all elements `e` such that `f(&e)` returns `false`.\n/// This method operates in place and preserves the order of the\n/// retained elements.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![1, 2, 3, 4];\n/// deq.retain(|&x| x % 2 == 0);\n/// assert_eq!(deq, [2, 4]);\n/// # }\n/// ```\n#[inline]\npub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> bool,{\n        let len = self.len();\n        let mut del = 0;\n        {\n            let v = &mut **self;\n\n            for i in 0..len {\n                if !f(&v[i]) {\n                    del += 1;\n                } else if del > 0 {\n                    v.swap(i - del, i);\n                }\n            }\n        }\n        if del > 0 {\n            self.truncate(len - del);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::shrink_to_fit":["/// Shrinks the capacity of the deque as much as possible.\n///\n/// It will drop down as close as possible to the length, but because\n/// `SliceDeque` allocates memory in multiples of the page size the deque\n/// might still have capacity for inserting new elements without\n/// reallocating.\n///\n/// # Examples\n///\n/// ```rust\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::with_capacity(15);\n/// deq.extend(0..4);\n/// assert!(deq.capacity() >= 15);\n/// deq.shrink_to_fit();\n/// assert!(deq.capacity() >= 4);\n/// # let o: SliceDeque<u32> = deq;\n/// ```\n#[inline]\npub fn shrink_to_fit(&mut self){\n        if unsafe { intrinsics::unlikely(self.is_empty()) } {\n            return;\n        }\n\n        // FIXME: we should compute the capacity and only allocate a shrunk\n        // deque if that's worth it.\n        let mut new_sdeq = Self::with_capacity(self.len());\n        if new_sdeq.capacity() < self.capacity() {\n            unsafe {\n                crate::ptr::copy_nonoverlapping(\n                    self.as_mut_ptr(),\n                    new_sdeq.as_mut_ptr(),\n                    self.len(),\n                );\n                new_sdeq.elems_ =\n                    nonnull_raw_slice(new_sdeq.buf.ptr(), self.len());\n                mem::swap(self, &mut new_sdeq);\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::splice":["/// Creates a splicing iterator that replaces the specified range in the\n/// deque with the given `replace_with` iterator and yields the\n/// removed items. `replace_with` does not need to be the same length\n/// as `range`.\n///\n/// Note 1: The element range is removed even if the iterator is not\n/// consumed until the end.\n///\n/// Note 2: It is unspecified how many elements are removed from the deque,\n/// if the `Splice` value is leaked.\n///\n/// Note 3: The input iterator `replace_with` is only consumed\n/// when the `Splice` value is dropped.\n///\n/// Note 4: This is optimal if:\n///\n/// * The tail (elements in the deque after `range`) is empty,\n/// * or `replace_with` yields fewer elements than `range`â€™s length\n/// * or the lower bound of its `size_hint()` is exact.\n///\n/// Otherwise, a temporary deque is allocated and the tail is moved twice.\n///\n/// # Panics\n///\n/// Panics if the starting point is greater than the end point or if\n/// the end point is greater than the length of the deque.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![1, 2, 3];\n/// let new = [7, 8];\n/// let u: SliceDeque<_> = deq.splice(..2, new.iter().cloned()).collect();\n/// assert_eq!(deq, &[7, 8, 3]);\n/// assert_eq!(u, &[1, 2]);\n/// # }\n/// ```\n#[inline]\npub fn splice<R, I>(\n        &mut self, range: R, replace_with: I,\n    ) -> Splice<I::IntoIter>\n    where\n        R: ops::RangeBounds<usize>,\n        I: IntoIterator<Item = T>,{\n        Splice {\n            drain: self.drain(range),\n            replace_with: replace_with.into_iter(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::split_off":["/// Splits the collection into two at the given index.\n///\n/// Returns a newly allocated `Self`. `self` contains elements `[0, at)`,\n/// and the returned `Self` contains elements `[at, len)`.\n///\n/// Note that the capacity of `self` does not change.\n///\n/// # Panics\n///\n/// Panics if `at > len`.\n///\n/// # Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![1, 2, 3];\n/// let deq2 = deq.split_off(1);\n/// assert_eq!(deq, [1]);\n/// assert_eq!(deq2, [2, 3]);\n/// # }\n/// ```\n#[inline]\npub fn split_off(&mut self, at: usize) -> Self{\n        assert!(at <= self.len(), \"`at` out of bounds\");\n\n        let other_len = self.len() - at;\n        let mut other = Self::with_capacity(other_len);\n\n        unsafe {\n            self.move_tail_unchecked(-(other_len as isize));\n            other.move_tail_unchecked(other_len as isize);\n\n            ptr::copy_nonoverlapping(\n                self.as_ptr().add(at),\n                other.as_mut_ptr(),\n                other.len(),\n            );\n        }\n        other\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::steal_from_slice":["/// Steal the elements from the slice `s`. You should `mem::forget` the\n/// slice afterwards.\npub unsafe fn steal_from_slice(s: &[T]) -> Self{\n        let mut deq = Self::new();\n        deq.append_elements(s as *const _);\n        deq\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::swap_remove_back":["/// Removes the element at `index` and return it in `O(1)` by swapping the\n/// last element into its place.\n///\n/// # Examples\n///\n/// ```rust\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::new();\n/// assert_eq!(deq.swap_remove_back(0), None);\n/// deq.extend(1..4);\n/// assert_eq!(deq, [1, 2, 3]);\n///\n/// assert_eq!(deq.swap_remove_back(0), Some(1));\n/// assert_eq!(deq, [3, 2]);\n/// ```\n#[inline]\npub fn swap_remove_back(&mut self, index: usize) -> Option<T>{\n        let len = self.len();\n        if self.is_empty() {\n            None\n        } else {\n            self.swap(index, len - 1);\n            self.pop_back()\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::swap_remove_front":["/// Removes the element at `index` and returns it in `O(1)` by swapping the\n/// first element into its place.\n///\n/// # Examples\n///\n/// ```\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::new();\n/// assert_eq!(deq.swap_remove_front(0), None);\n/// deq.extend(1..4);\n/// assert_eq!(deq, [1, 2, 3]);\n///\n/// assert_eq!(deq.swap_remove_front(2), Some(3));\n/// assert_eq!(deq, [2, 1]);\n/// ```\n#[inline]\npub fn swap_remove_front(&mut self, index: usize) -> Option<T>{\n        if self.is_empty() {\n            None\n        } else {\n            self.swap(index, 0);\n            self.pop_front()\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::tail_head_slice":["/// Returns the slice of uninitialized memory between the `tail` and the\n/// `begin`.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate slice_deque;\n/// # fn main() {\n/// let mut d = sdeq![1, 2, 3];\n/// let cap = d.capacity();\n/// let len = d.len();\n/// unsafe {\n///     {\n///         // This slice contains the uninitialized elements in\n///         // the deque:\n///         let mut s = d.tail_head_slice();\n///         assert_eq!(s.len(), cap - len);\n///         // We can write to them and for example bump the tail of\n///         // the deque:\n///         s[0] = 4;\n///         s[1] = 5;\n///     }\n///     d.move_tail(2);\n/// }\n/// assert_eq!(d, sdeq![1, 2, 3, 4, 5]);\n/// # }\n/// ```\npub unsafe fn tail_head_slice(&mut self) -> &mut [T]{\n        let ptr = self.as_mut_slice().as_mut_ptr().add(self.len());\n        slice::from_raw_parts_mut(ptr, self.capacity() - self.len())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::truncate":["/// Shortens the deque by removing excess elements from the back.\n///\n/// If `len` is greater than the SliceDeque's current length, this has no\n/// effect. See `truncate_back` for examples.\n#[inline]\npub fn truncate(&mut self, len: usize){\n        self.truncate_back(len);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::truncate_back":["/// Shortens the deque by removing excess elements from the back.\n///\n/// If `len` is greater than the SliceDeque's current length, this has no\n/// effect.\n///\n/// # Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![5, 10, 15];\n/// assert_eq!(deq, [5, 10, 15]);\n/// deq.truncate_back(1);\n/// assert_eq!(deq, [5]);\n/// # }\n/// ```\n#[inline]\npub fn truncate_back(&mut self, len: usize){\n        unsafe {\n            if len >= self.len() {\n                return;\n            }\n\n            let diff = self.len() - len;\n            let s = &mut self[len..] as *mut [_];\n            // decrement tail before the drop_in_place(), so a panic on\n            // Drop doesn't re-drop the just-failed value.\n            self.move_tail(-(diff as isize));\n            ptr::drop_in_place(&mut *s);\n            debug_assert_eq!(self.len(), len);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::truncate_front":["/// Shortens the deque by removing excess elements from the front.\n///\n/// If `len` is greater than the SliceDeque's current length, this has no\n/// effect.\n///\n/// # Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate slice_deque;\n/// # use slice_deque::SliceDeque;\n/// # fn main() {\n/// let mut deq = sdeq![5, 10, 15];\n/// assert_eq!(deq, [5, 10, 15]);\n/// deq.truncate_front(1);\n/// assert_eq!(deq, [15]);\n/// # }\n/// ```\n#[inline]\npub fn truncate_front(&mut self, len: usize){\n        unsafe {\n            if len >= self.len() {\n                return;\n            }\n\n            let diff = self.len() - len;\n            let s = &mut self[..diff] as *mut [_];\n            // increment head before the drop_in_place(), so a panic on\n            // Drop doesn't re-drop the just-failed value.\n            self.move_head(diff as isize);\n            ptr::drop_in_place(&mut *s);\n            debug_assert_eq!(self.len(), len);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::try_push_back":["/// Attempts to appends `value` to the deque.\n///\n/// # Examples\n///\n/// ```rust\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::new();\n/// deq.try_push_back(1).unwrap();\n/// deq.try_push_back(3).unwrap();\n/// assert_eq!(deq.back(), Some(&3));\n/// ```\n#[inline]\npub fn try_push_back(&mut self, value: T) -> Result<(), (T, AllocError)>{\n        unsafe {\n            if intrinsics::unlikely(self.is_full()) {\n                if let Err(e) = self.try_reserve(1) {\n                    return Err((value, e));\n                }\n            }\n            self.move_tail_unchecked(1);\n            let len = self.len();\n            ptr::write(self.get_mut(len - 1).unwrap(), value);\n            Ok(())\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::try_push_front":["/// Attempts to prepend `value` to the deque.\n///\n/// # Examples\n///\n/// ```rust\n/// # use slice_deque::SliceDeque;\n/// let mut deq = SliceDeque::new();\n/// deq.try_push_front(1).unwrap();\n/// deq.try_push_front(2).unwrap();\n/// assert_eq!(deq.front(), Some(&2));\n/// ```\n#[inline]\npub fn try_push_front(&mut self, value: T) -> Result<(), (T, AllocError)>{\n        unsafe {\n            if intrinsics::unlikely(self.is_full()) {\n                if let Err(e) = self.try_reserve(1) {\n                    return Err((value, e));\n                }\n            }\n\n            self.move_head_unchecked(-1);\n            ptr::write(self.get_mut(0).unwrap(), value);\n            Ok(())\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::try_reserve":["/// Attempts to reserve capacity for inserting at least `additional`\n/// elements without reallocating. Does nothing if the capacity is already\n/// sufficient.\n///\n/// The collection always reserves memory in multiples of the page size.\n///\n/// # Panics\n///\n/// Panics if the new capacity overflows `usize`.\n#[inline]\npub fn try_reserve(\n        &mut self, additional: usize,\n    ) -> Result<(), AllocError>{\n        let old_len = self.len();\n        let new_cap = self.grow_policy(additional);\n        self.reserve_capacity(new_cap)?;\n        debug_assert!(self.capacity() >= old_len + additional);\n        Ok(())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SliceDeque::<T>::with_capacity":["/// Create an empty deque with capacity to hold `n` elements.\n///\n/// # Examples\n///\n/// ```rust\n/// # use slice_deque::SliceDeque;\n/// let deq = SliceDeque::with_capacity(10);\n/// # let o: SliceDeque<u32> = deq;\n/// ```\n#[inline]\npub fn with_capacity(n: usize) -> Self{\n        unsafe {\n            let buf = Buffer::uninitialized(2 * n).unwrap_or_else(|e| {\n                let s = tiny_str!(\n                    \"failed to allocate a buffer with capacity \\\"{}\\\" due to \\\"{:?}\\\"\",\n                    n, e\n                );\n                panic!(\"{}\", s.as_str())\n            });\n            Self {\n                elems_: nonnull_raw_slice(buf.ptr(), 0),\n                buf,\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SpecExtend":["/// Specialization trait used for `SliceDeque::from_iter` and\n/// `SliceDeque::extend`.\ntrait SpecExtend<T, I> {\n    /// Specialization for `SliceDeque::from_iter`.\n    fn from_iter(iter: I) -> Self;\n    /// Specialization for `SliceDeque::extend`.\n    fn spec_extend(&mut self, iter: I);\n}","Real(LocalPath(\"src/lib.rs\"))"],"SpecFromElem":["/// Specialization trait used for `SliceDeque::from_elem`.\ntrait SpecFromElem: Sized {\n    /// TODO: docs\n    fn from_elem(elem: Self, n: usize) -> SliceDeque<Self>;\n}","Real(LocalPath(\"src/lib.rs\"))"],"Splice":["/// A splicing iterator for `SliceDeque`.\n///\n/// This struct is created by the [`splice()`] method on [`SliceDeque`]. See\n/// its documentation for more.\n///\n/// [`splice()`]: struct.SliceDeque.html#method.splice\n/// [`SliceDeque`]: struct.SliceDeque.html\npub struct Splice<'a, I: Iterator + 'a> {\n    /// TODO: docs\n    drain: Drain<'a, I::Item>,\n    /// TODO: docs\n    replace_with: I,\n}","Real(LocalPath(\"src/lib.rs\"))"],"WrappingOffsetFrom":["/// Stable implementation of `.wrapping_offset_from` for pointers.\ntrait WrappingOffsetFrom {\n    /// Stable implementation of `.wrapping_offset_from` for pointers.\n    fn wrapping_offset_from_(self, other: Self) -> Option<isize>;\n}","Real(LocalPath(\"src/lib.rs\"))"],"from_elem":["/// TODO: docs\n/// FIXME: not used, this should be used by the sdeq! macro? Remove this maybe.\n#[doc(hidden)]\npub fn from_elem<T: Clone>(elem: T, n: usize) -> SliceDeque<T>{\n    <T as SpecFromElem>::from_elem(elem, n)\n}","Real(LocalPath(\"src/lib.rs\"))"],"from_iter_default":["/// Default implementation of `SpecExtend::from_iter`.\n#[inline(always)]\nfn from_iter_default<T, I: Iterator<Item = T>>(\n    mut iterator: I,\n) -> SliceDeque<T>{\n    // Unroll the first iteration, as the deque is going to be\n    // expanded on this iteration in every case when the iterable is not\n    // empty, but the loop in extend_desugared() is not going to see the\n    // deque being full in the few subsequent loop iterations.\n    // So we get better branch prediction.\n    let mut deque = match iterator.next() {\n        None => return SliceDeque::<T>::new(),\n        Some(element) => {\n            let (lower, _) = iterator.size_hint();\n            let mut deque =\n                SliceDeque::<T>::with_capacity(lower.saturating_add(1));\n            unsafe {\n                ptr::write(deque.get_unchecked_mut(0), element);\n                deque.move_tail_unchecked(1);\n            }\n            deque\n        }\n    };\n    <SliceDeque<T> as SpecExtend<T, I>>::spec_extend(&mut deque, iterator);\n    deque\n}","Real(LocalPath(\"src/lib.rs\"))"],"in_bounds":["/// Is `p` in bounds of `s` ?\n///\n/// Does it point to an element of `s` ? That is, one past the end of `s` is\n/// not in bounds.\nfn in_bounds<T>(s: &[T], p: *mut T) -> bool{\n    let p = p as usize;\n    let s_begin = s.as_ptr() as usize;\n    let s_end = s_begin + mem::size_of::<T>() * s.len();\n    s_begin <= p && p < s_end\n}","Real(LocalPath(\"src/lib.rs\"))"],"intrinsics::arith_offset":["/// Like `core::intrinsics::arith_offset` but doing pointer to integer\n/// conversions.\n#[inline(always)]\npub unsafe fn arith_offset<T>(dst: *const T, offset: isize) -> *const T{\n        let r = if offset >= 0 {\n            (dst as usize).wrapping_add(offset as usize)\n        } else {\n            (dst as usize).wrapping_sub((-offset) as usize)\n        };\n        r as *const T\n    }","Real(LocalPath(\"src/lib.rs\"))"],"intrinsics::assume":["/// Like `core::intrinsics::assume` but does nothing.\n#[inline(always)]\npub unsafe fn assume<T>(x: T) -> T{\n        x\n    }","Real(LocalPath(\"src/lib.rs\"))"],"intrinsics::unlikely":["/// Like `core::intrinsics::unlikely` but does nothing.\n#[inline(always)]\npub unsafe fn unlikely<T>(x: T) -> T{\n        x\n    }","Real(LocalPath(\"src/lib.rs\"))"],"macros::TinyAsciiString":["/// Small Ascii String. Used to write errors in `no_std` environments.\npub struct TinyAsciiString {\n    /// A buffer for the ascii string\n    buf: [u8; 512],\n}","Real(LocalPath(\"src/macros.rs\"))"],"macros::TinyAsciiString::as_str":["/// Converts the Tiny Ascii String to an UTF-8 string (unchecked).\npub unsafe fn as_str(&self) -> &str{\n        crate::str::from_utf8_unchecked(&self.buf)\n    }","Real(LocalPath(\"src/macros.rs\"))"],"macros::TinyAsciiString::new":["/// Creates a new string initialized to zero.\npub fn new() -> Self{\n        Self { buf: [0_u8; 512] }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"mirrored::AllocError":["/// Allocation error.\npub enum AllocError {\n    /// The system is Out-of-memory.\n    Oom,\n    /// Other allocation errors (not out-of-memory).\n    ///\n    /// Race conditions, exhausted file descriptors, etc.\n    Other,\n}","Real(LocalPath(\"src/mirrored/mod.rs\"))"],"mirrored::buffer::Buffer":["/// Mirrored memory buffer of length `len`.\n///\n/// The buffer elements in range `[0, len/2)` are mirrored into the range\n/// `[len/2, len)`.\npub struct Buffer<T> {\n    /// Pointer to the first element in the buffer.\n    ptr: NonNull<T>,\n    /// Length of the buffer:\n    ///\n    /// * it is NOT always a multiple of 2\n    /// * the elements in range `[0, len/2)` are mirrored into the range\n    /// `[len/2, len)`.\n    len: usize,\n}","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::buffer::Buffer::<T>::as_mut_slice":["/// Interprets contents as a mut slice.\n///\n/// Warning: Some memory might be uninitialized.\npub unsafe fn as_mut_slice(&mut self) -> &mut [T]{\n        slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len())\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::buffer::Buffer::<T>::as_slice":["/// Interprets contents as a slice.\n///\n/// Warning: Some memory might be uninitialized.\npub unsafe fn as_slice(&self) -> &[T]{\n        slice::from_raw_parts(self.ptr.as_ptr(), self.len())\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::buffer::Buffer::<T>::empty_len":["fn empty_len() -> usize{\n        if mem::size_of::<T>() == 0 {\n            isize::max_value() as usize * 2\n        } else {\n            0\n        }\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::buffer::Buffer::<T>::from_raw_parts":["/// Creates a new empty `Buffer` from a `ptr` and a `len`.\n///\n/// # Panics\n///\n/// If `ptr` is null.\npub unsafe fn from_raw_parts(ptr: *mut T, len: usize) -> Self{\n        assert!(len % 2 == 0);\n        assert!(!ptr.is_null());\n        if mem::size_of::<T>() == 0 {\n            debug_assert_eq!(len, Self::empty_len());\n        }\n        Self {\n            ptr: NonNull::new_unchecked(ptr),\n            len,\n        }\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::buffer::Buffer::<T>::get":["/// Interprets content as a slice and access the `i`-th element.\n///\n/// Warning: The memory of the `i`-th element might be uninitialized.\npub unsafe fn get(&self, i: usize) -> &T{\n        &self.as_slice()[i]\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::buffer::Buffer::<T>::get_mut":["/// Interprets content as a mut slice and access the `i`-th element.\n///\n/// Warning: The memory of the `i`-th element might be uninitialized.\npub unsafe fn get_mut(&mut self, i: usize) -> &mut T{\n        &mut self.as_mut_slice()[i]\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::buffer::Buffer::<T>::is_empty":["/// Is the buffer empty?\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::buffer::Buffer::<T>::len":["/// Number of elements in the buffer.\npub fn len(&self) -> usize{\n        self.len\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::buffer::Buffer::<T>::new":["/// Creates a new empty `Buffer`.\npub fn new() -> Self{\n        // Here `ptr` is initialized to a magic value but `len == 0`\n        // will ensure that it is never dereferenced in this state.\n        Self {\n            ptr: NonNull::dangling(),\n            len: Self::empty_len(),\n        }\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::buffer::Buffer::<T>::ptr":["/// Pointer to the first element in the buffer.\npub unsafe fn ptr(&self) -> *mut T{\n        self.ptr.as_ptr()\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::buffer::Buffer::<T>::size_in_bytes":["/// Total number of bytes in the buffer.\npub fn size_in_bytes(len: usize) -> usize{\n        let v = no_required_allocation_units(len * mem::size_of::<T>())\n            * allocation_granularity();\n        debug_assert!(\n            v >= len * mem::size_of::<T>(),\n            \"len: {}, so<T>: {}, v: {}\",\n            len,\n            mem::size_of::<T>(),\n            v\n        );\n        v\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::buffer::Buffer::<T>::uninitialized":["/// Create a mirrored buffer containing `len` `T`s where the first half of\n/// the buffer is mirrored into the second half.\npub fn uninitialized(len: usize) -> Result<Self, AllocError>{\n        // Zero-sized types:\n        if mem::size_of::<T>() == 0 {\n            return Ok(Self {\n                ptr: NonNull::dangling(),\n                len: Self::empty_len(),\n            });\n        }\n        // The alignment requirements of `T` must be smaller than the\n        // allocation granularity.\n        assert!(mem::align_of::<T>() <= allocation_granularity());\n        // To split the buffer in two halfs the number of elements must be a\n        // multiple of two, and greater than zero to be able to mirror\n        // something.\n        if len == 0 {\n            return Ok(Self::new());\n        }\n        assert!(len % 2 == 0);\n\n        // How much memory we need:\n        let alloc_size = Self::size_in_bytes(len);\n        debug_assert!(alloc_size > 0);\n        debug_assert!(alloc_size % 2 == 0);\n        debug_assert!(alloc_size % allocation_granularity() == 0);\n        debug_assert!(alloc_size >= len * mem::size_of::<T>());\n\n        let ptr = allocate_mirrored(alloc_size)?;\n        Ok(Self {\n            ptr: unsafe { NonNull::new_unchecked(ptr as *mut T) },\n            len: alloc_size / mem::size_of::<T>(),\n            // Note: len is not a multiple of two: debug_assert!(len % 2 == 0);\n        })\n    }","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::buffer::no_required_allocation_units":["/// Number of required memory allocation units to hold `bytes`.\nfn no_required_allocation_units(bytes: usize) -> usize{\n    let ag = allocation_granularity();\n    let r = ((bytes + ag - 1) / ag).max(1);\n    let r = if r % 2 == 0 { r } else { r + 1 };\n    debug_assert!(r * ag >= bytes);\n    debug_assert!(r % 2 == 0);\n    r\n}","Real(LocalPath(\"src/mirrored/buffer.rs\"))"],"mirrored::linux::allocate_mirrored":["/// Allocates an uninitialzied buffer that holds `size` bytes, where\n/// the bytes in range `[0, size / 2)` are mirrored into the bytes in\n/// range `[size / 2, size)`.\n///\n/// On Linux the algorithm is as follows:\n///\n/// * 1. Allocate a memory-mapped file containing `size / 2` bytes.\n/// * 2. Map the file into `size` bytes of virtual memory.\n/// * 3. Map the file into the last `size / 2` bytes of the virtual memory\n/// region      obtained in step 2.\n///\n/// This algorithm doesn't have any races.\n///\n/// # Panics\n///\n/// If `size` is zero or `size / 2` is not a multiple of the\n/// allocation granularity.\npub fn allocate_mirrored(size: usize) -> Result<*mut u8, AllocError>{\n    unsafe {\n        let half_size = size / 2;\n        assert!(size != 0);\n        assert!(half_size % allocation_granularity() == 0);\n\n        // create temporary file\n        let mut fname = *b\"/tmp/slice_deque_fileXXXXXX\\0\";\n        let mut fd: c_long =\n            memfd_create(fname.as_mut_ptr() as *mut c_char, 0);\n        if fd == -1 && errno() == ENOSYS {\n            // memfd_create is not implemented, use mkstemp instead:\n            fd = c_long::from(mkstemp(fname.as_mut_ptr() as *mut c_char));\n        }\n        if fd == -1 {\n            print_error(\"memfd_create failed\");\n            return Err(AllocError::Other);\n        }\n        let fd = fd as c_int;\n        if ftruncate(fd, half_size as off_t) == -1 {\n            print_error(\"ftruncate failed\");\n            if close(fd) == -1 {\n                print_error(\"@ftruncate: close failed\");\n            }\n            return Err(AllocError::Oom);\n        };\n\n        // mmap memory\n        let ptr = mmap(\n            ptr::null_mut(),\n            size,\n            PROT_READ | PROT_WRITE,\n            MAP_SHARED,\n            fd,\n            0,\n        );\n        if ptr == MAP_FAILED {\n            print_error(\"@first: mmap failed\");\n            if close(fd) == -1 {\n                print_error(\"@first: close failed\");\n            }\n            return Err(AllocError::Oom);\n        }\n\n        let ptr2 = mmap(\n            (ptr as *mut u8).offset(half_size as isize) as *mut c_void,\n            half_size,\n            PROT_READ | PROT_WRITE,\n            MAP_SHARED | MAP_FIXED,\n            fd,\n            0,\n        );\n        if ptr2 == MAP_FAILED {\n            print_error(\"@second: mmap failed\");\n            if munmap(ptr, size as size_t) == -1 {\n                print_error(\"@second: munmap failed\");\n            }\n            if close(fd) == -1 {\n                print_error(\"@second: close failed\");\n            }\n            return Err(AllocError::Other);\n        }\n\n        if close(fd) == -1 {\n            print_error(\"@success: close failed\");\n        }\n        Ok(ptr as *mut u8)\n    }\n}","Real(LocalPath(\"src/mirrored/linux.rs\"))"],"mirrored::linux::allocation_granularity":["/// Returns the size of a memory allocation unit.\n///\n/// In Linux-like systems this equals the page-size.\npub fn allocation_granularity() -> usize{\n    unsafe { sysconf(_SC_PAGESIZE) as usize }\n}","Real(LocalPath(\"src/mirrored/linux.rs\"))"],"mirrored::linux::deallocate_mirrored":["/// Deallocates the mirrored memory region at `ptr` of `size` bytes.\n///\n/// # Unsafe\n///\n/// `ptr` must have been obtained from a call to `allocate_mirrored(size)`,\n/// otherwise the behavior is undefined.\n///\n/// # Panics\n///\n/// If `size` is zero or `size / 2` is not a multiple of the\n/// allocation granularity, or `ptr` is null.\npub unsafe fn deallocate_mirrored(ptr: *mut u8, size: usize){\n    assert!(!ptr.is_null());\n    assert!(size != 0);\n    assert!(size % allocation_granularity() == 0);\n    if munmap(ptr as *mut c_void, size as size_t) == -1 {\n        print_error(\"deallocate munmap failed\");\n    }\n}","Real(LocalPath(\"src/mirrored/linux.rs\"))"],"mirrored::linux::errno":["/// Reads `errno`.\nfn errno() -> c_int{\n    #[cfg(not(target_os = \"android\"))]\n    unsafe {\n        *__errno_location()\n    }\n    #[cfg(target_os = \"android\")]\n    unsafe {\n        *__errno()\n    }\n}","Real(LocalPath(\"src/mirrored/linux.rs\"))"],"mirrored::linux::memfd_create":["/// [`memfd_create`] - create an anonymous file\n///\n/// [`memfd_create`]: http://man7.org/linux/man-pages/man2/memfd_create.2.html\nfn memfd_create(name: *const c_char, flags: c_uint) -> c_long{\n    unsafe { syscall(SYS_memfd_create, name, flags) }\n}","Real(LocalPath(\"src/mirrored/linux.rs\"))"],"mirrored::linux::print_error":["/// Prints last os error at `location`.\n#[cfg(all(debug_assertions, feature = \"use_std\"))]\nfn print_error(location: &str){\n    eprintln!(\n        \"Error at {}: {}\",\n        location,\n        ::std::io::Error::last_os_error()\n    );\n}","Real(LocalPath(\"src/mirrored/linux.rs\"))"],"nonnull_raw_slice":["unsafe fn nonnull_raw_slice<T>(ptr: *mut T, len: usize) -> NonNull<[T]>{\n    NonNull::new_unchecked(slice::from_raw_parts_mut(ptr, len))\n}","Real(LocalPath(\"src/lib.rs\"))"]},"struct_constructor":{"&<SliceDeque<T> as std::ops::Deref>::Target":["deref"],"&[T]":["as_ref","as_slice"],"&mut <SliceDeque<T> as std::ops::Deref>::Target":["deref_mut"],"&mut [T]":["as_mut","as_mut_slice","tail_head_slice"],"&str":["as_str"],"(&[T], &[T])":["as_slices"],"(&mut [T], &mut [T])":["as_mut_slices"],"(usize, std::option::Option<usize>)":["size_hint"],"*mut u8":["allocate_mirrored"],"<Splice<'a, I> as std::iter::Iterator>::Item":["next","next_back"],"Drain":["drain"],"DrainFilter":["drain_filter"],"IntoIter":["clone","into_iter"],"SliceDeque":["clone","default","from","from_elem","from_iter","from_iter_default","from_raw_parts","new","split_off","steal_from_slice","with_capacity"],"Splice":["splice"],"bool":["eq","fill","in_bounds","is_empty","is_full"],"i32":["errno"],"i64":["memfd_create"],"isize":["wrapping_offset_from_"],"macros::TinyAsciiString":["new"],"mirrored::buffer::Buffer":["clone","default","from_raw_parts","new","uninitialized"],"std::cmp::Ordering":["partial_cmp"],"std::ptr::NonNull":["nonnull_raw_slice"],"std::slice::Iter":["into_iter"],"std::slice::IterMut":["into_iter"],"usize":["allocation_granularity","capacity","count","empty_len","len"]},"struct_to_trait":{"<T as SpecFromElem>::T":["SpecFromElem"],"Drain":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync","std::ops::Drop"],"DrainFilter":["std::fmt::Debug","std::iter::Iterator","std::ops::Drop"],"ExtendDefault":["ExtendWith"],"ExtendElement":["ExtendWith"],"IntoIter":["std::clone::Clone","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator","std::marker::Send","std::marker::Sync","std::ops::Drop"],"SliceDeque":["SpecExtend","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsMut","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::marker::Send","std::marker::Sync","std::ops::Deref","std::ops::DerefMut","std::ops::Drop"],"Splice":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator","std::ops::Drop"],"macros::TinyAsciiString":["std::fmt::Write"],"mirrored::AllocError":["std::fmt::Debug"],"mirrored::buffer::Buffer":["std::clone::Clone","std::default::Default","std::marker::Send","std::marker::Sync","std::ops::Drop"]},"targets":{"<&'a SliceDeque<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<&'a mut SliceDeque<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<*const T as WrappingOffsetFrom>::wrapping_offset_from_":["wrapping_offset_from_","Real(LocalPath(\"src/lib.rs\"))","WrappingOffsetFrom"],"<Drain<'a, T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/lib.rs\"))","std::iter::DoubleEndedIterator"],"<Drain<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<Drain<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<Drain<'a, T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","std::ops::Drop"],"<DrainFilter<'a, T, F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<DrainFilter<'a, T, F> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<DrainFilter<'a, T, F> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","std::ops::Drop"],"<ExtendDefault as ExtendWith<T>>::last":["last","Real(LocalPath(\"src/lib.rs\"))","ExtendWith"],"<ExtendDefault as ExtendWith<T>>::next":["next","Real(LocalPath(\"src/lib.rs\"))","ExtendWith"],"<ExtendElement<T> as ExtendWith<T>>::last":["last","Real(LocalPath(\"src/lib.rs\"))","ExtendWith"],"<ExtendElement<T> as ExtendWith<T>>::next":["next","Real(LocalPath(\"src/lib.rs\"))","ExtendWith"],"<IntoIter<T> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","std::clone::Clone"],"<IntoIter<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<IntoIter<T> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/lib.rs\"))","std::iter::DoubleEndedIterator"],"<IntoIter<T> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<IntoIter<T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<IntoIter<T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<IntoIter<T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","std::ops::Drop"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 0]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 10]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 11]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 12]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 13]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 14]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 15]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 16]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 17]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 18]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 19]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 1]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 20]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 21]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 22]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 23]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 24]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 25]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 26]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 27]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 28]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 29]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 2]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 30]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 31]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 32]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 3]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 4]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 5]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 6]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 7]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 8]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B; 9]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b [B]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<&'b mut [B]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<SliceDeque<B>>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 0]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 10]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 11]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 12]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 13]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 14]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 15]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 16]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 17]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 18]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 19]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 1]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 20]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 21]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 22]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 23]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 24]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 25]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 26]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 27]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 28]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 29]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 2]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 30]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 31]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 32]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 3]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 4]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 5]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 6]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 7]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 8]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<[B; 9]>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<A> as std::cmp::PartialEq<std::vec::Vec<B>>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<SliceDeque<T> as SpecExtend<&'a T, I>>::from_iter":["from_iter","Real(LocalPath(\"src/lib.rs\"))","SpecExtend"],"<SliceDeque<T> as SpecExtend<&'a T, I>>::spec_extend":["spec_extend","Real(LocalPath(\"src/lib.rs\"))","SpecExtend"],"<SliceDeque<T> as SpecExtend<T, I>>::from_iter":["from_iter","Real(LocalPath(\"src/lib.rs\"))","SpecExtend"],"<SliceDeque<T> as SpecExtend<T, I>>::spec_extend":["spec_extend","Real(LocalPath(\"src/lib.rs\"))","SpecExtend"],"<SliceDeque<T> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","std::clone::Clone"],"<SliceDeque<T> as std::clone::Clone>::clone_from":["clone_from","Real(LocalPath(\"src/lib.rs\"))","std::clone::Clone"],"<SliceDeque<T> as std::cmp::PartialOrd<&'a [T]>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialOrd"],"<SliceDeque<T> as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialOrd"],"<SliceDeque<T> as std::convert::AsMut<[T]>>::as_mut":["as_mut","Real(LocalPath(\"src/lib.rs\"))","std::convert::AsMut"],"<SliceDeque<T> as std::convert::AsRef<[T]>>::as_ref":["as_ref","Real(LocalPath(\"src/lib.rs\"))","std::convert::AsRef"],"<SliceDeque<T> as std::convert::From<&'a [T]>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<SliceDeque<T> as std::convert::From<&'a mut [T]>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<SliceDeque<T> as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<SliceDeque<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<SliceDeque<T> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/lib.rs\"))","std::hash::Hash"],"<SliceDeque<T> as std::iter::Extend<&'a T>>::extend":["extend","Real(LocalPath(\"src/lib.rs\"))","std::iter::Extend"],"<SliceDeque<T> as std::iter::Extend<T>>::extend":["extend","Real(LocalPath(\"src/lib.rs\"))","std::iter::Extend"],"<SliceDeque<T> as std::iter::FromIterator<T>>::from_iter":["from_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::FromIterator"],"<SliceDeque<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<SliceDeque<T> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/lib.rs\"))","std::ops::Deref"],"<SliceDeque<T> as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/lib.rs\"))","std::ops::DerefMut"],"<SliceDeque<T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","std::ops::Drop"],"<Splice<'a, I> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/lib.rs\"))","std::iter::DoubleEndedIterator"],"<Splice<'a, I> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<Splice<'a, I> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<Splice<'a, I> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","std::ops::Drop"],"<T as SpecFromElem>::from_elem":["from_elem","Real(LocalPath(\"src/lib.rs\"))","SpecFromElem"],"<macros::TinyAsciiString as std::fmt::Write>::write_str":["write_str","Real(LocalPath(\"src/macros.rs\"))","std::fmt::Write"],"<mirrored::AllocError as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/mirrored/mod.rs\"))","std::fmt::Debug"],"<mirrored::buffer::Buffer<T> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/mirrored/buffer.rs\"))","std::clone::Clone"],"<mirrored::buffer::Buffer<T> as std::default::Default>::default":["default","Real(LocalPath(\"src/mirrored/buffer.rs\"))","std::default::Default"],"<mirrored::buffer::Buffer<T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/mirrored/buffer.rs\"))","std::ops::Drop"],"Drain::<'a, T>::fill":["fill","Real(LocalPath(\"src/lib.rs\"))",""],"Drain::<'a, T>::move_tail_unchecked":["move_tail_unchecked","Real(LocalPath(\"src/lib.rs\"))",""],"IntoIter::<T>::as_mut_slice":["as_mut_slice","Real(LocalPath(\"src/lib.rs\"))",""],"IntoIter::<T>::as_slice":["as_slice","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::append":["append","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::append_elements":["append_elements","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::as_mut_slice":["as_mut_slice","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::as_mut_slices":["as_mut_slices","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::as_slice":["as_slice","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::as_slices":["as_slices","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::back":["back","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::back_mut":["back_mut","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::capacity":["capacity","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::clear":["clear","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::dedup":["dedup","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::dedup_by":["dedup_by","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::dedup_by_key":["dedup_by_key","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::drain":["drain","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::drain_filter":["drain_filter","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::extend_desugared":["extend_desugared","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::extend_from_slice":["extend_from_slice","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::extend_with":["extend_with","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::from_raw_parts":["from_raw_parts","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::front":["front","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::front_mut":["front_mut","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::grow_policy":["grow_policy","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::insert":["insert","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::is_full":["is_full","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::len":["len","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::move_head":["move_head","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::move_head_unchecked":["move_head_unchecked","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::move_tail":["move_tail","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::move_tail_unchecked":["move_tail_unchecked","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::pop_back":["pop_back","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::pop_front":["pop_front","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::push_back":["push_back","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::push_front":["push_front","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::remove":["remove","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::remove_item":["remove_item","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::reserve":["reserve","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::reserve_capacity":["reserve_capacity","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::reserve_exact":["reserve_exact","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::resize":["resize","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::resize_default":["resize_default","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::retain":["retain","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::shrink_to_fit":["shrink_to_fit","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::splice":["splice","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::split_off":["split_off","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::steal_from_slice":["steal_from_slice","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::swap_remove_back":["swap_remove_back","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::swap_remove_front":["swap_remove_front","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::tail_head_slice":["tail_head_slice","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::truncate":["truncate","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::truncate_back":["truncate_back","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::truncate_front":["truncate_front","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::try_push_back":["try_push_back","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::try_push_front":["try_push_front","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::try_reserve":["try_reserve","Real(LocalPath(\"src/lib.rs\"))",""],"SliceDeque::<T>::with_capacity":["with_capacity","Real(LocalPath(\"src/lib.rs\"))",""],"from_elem":["from_elem","Real(LocalPath(\"src/lib.rs\"))",""],"from_iter_default":["from_iter_default","Real(LocalPath(\"src/lib.rs\"))",""],"in_bounds":["in_bounds","Real(LocalPath(\"src/lib.rs\"))",""],"intrinsics::arith_offset":["arith_offset","Real(LocalPath(\"src/lib.rs\"))",""],"intrinsics::assume":["assume","Real(LocalPath(\"src/lib.rs\"))",""],"intrinsics::unlikely":["unlikely","Real(LocalPath(\"src/lib.rs\"))",""],"macros::TinyAsciiString::as_str":["as_str","Real(LocalPath(\"src/macros.rs\"))",""],"macros::TinyAsciiString::new":["new","Real(LocalPath(\"src/macros.rs\"))",""],"mirrored::buffer::Buffer::<T>::as_mut_slice":["as_mut_slice","Real(LocalPath(\"src/mirrored/buffer.rs\"))",""],"mirrored::buffer::Buffer::<T>::as_slice":["as_slice","Real(LocalPath(\"src/mirrored/buffer.rs\"))",""],"mirrored::buffer::Buffer::<T>::empty_len":["empty_len","Real(LocalPath(\"src/mirrored/buffer.rs\"))",""],"mirrored::buffer::Buffer::<T>::from_raw_parts":["from_raw_parts","Real(LocalPath(\"src/mirrored/buffer.rs\"))",""],"mirrored::buffer::Buffer::<T>::get":["get","Real(LocalPath(\"src/mirrored/buffer.rs\"))",""],"mirrored::buffer::Buffer::<T>::get_mut":["get_mut","Real(LocalPath(\"src/mirrored/buffer.rs\"))",""],"mirrored::buffer::Buffer::<T>::is_empty":["is_empty","Real(LocalPath(\"src/mirrored/buffer.rs\"))",""],"mirrored::buffer::Buffer::<T>::len":["len","Real(LocalPath(\"src/mirrored/buffer.rs\"))",""],"mirrored::buffer::Buffer::<T>::new":["new","Real(LocalPath(\"src/mirrored/buffer.rs\"))",""],"mirrored::buffer::Buffer::<T>::ptr":["ptr","Real(LocalPath(\"src/mirrored/buffer.rs\"))",""],"mirrored::buffer::Buffer::<T>::size_in_bytes":["size_in_bytes","Real(LocalPath(\"src/mirrored/buffer.rs\"))",""],"mirrored::buffer::Buffer::<T>::uninitialized":["uninitialized","Real(LocalPath(\"src/mirrored/buffer.rs\"))",""],"mirrored::buffer::no_required_allocation_units":["no_required_allocation_units","Real(LocalPath(\"src/mirrored/buffer.rs\"))",""],"mirrored::linux::allocate_mirrored":["allocate_mirrored","Real(LocalPath(\"src/mirrored/linux.rs\"))",""],"mirrored::linux::allocation_granularity":["allocation_granularity","Real(LocalPath(\"src/mirrored/linux.rs\"))",""],"mirrored::linux::deallocate_mirrored":["deallocate_mirrored","Real(LocalPath(\"src/mirrored/linux.rs\"))",""],"mirrored::linux::errno":["errno","Real(LocalPath(\"src/mirrored/linux.rs\"))",""],"mirrored::linux::memfd_create":["memfd_create","Real(LocalPath(\"src/mirrored/linux.rs\"))",""],"mirrored::linux::print_error":["print_error","Real(LocalPath(\"src/mirrored/linux.rs\"))",""],"nonnull_raw_slice":["nonnull_raw_slice","Real(LocalPath(\"src/lib.rs\"))",""]},"trait_to_struct":{"ExtendWith":["ExtendDefault","ExtendElement"],"SpecExtend":["SliceDeque"],"SpecFromElem":["<T as SpecFromElem>::T"],"std::clone::Clone":["IntoIter","SliceDeque","mirrored::buffer::Buffer"],"std::cmp::Eq":["SliceDeque"],"std::cmp::PartialEq":["SliceDeque"],"std::cmp::PartialOrd":["SliceDeque"],"std::convert::AsMut":["SliceDeque"],"std::convert::AsRef":["SliceDeque"],"std::convert::From":["SliceDeque"],"std::default::Default":["SliceDeque","mirrored::buffer::Buffer"],"std::fmt::Debug":["Drain","DrainFilter","IntoIter","SliceDeque","Splice","mirrored::AllocError"],"std::fmt::Write":["macros::TinyAsciiString"],"std::hash::Hash":["SliceDeque"],"std::iter::DoubleEndedIterator":["Drain","IntoIter","Splice"],"std::iter::Extend":["SliceDeque"],"std::iter::FromIterator":["SliceDeque"],"std::iter::IntoIterator":["SliceDeque"],"std::iter::Iterator":["Drain","DrainFilter","IntoIter","Splice"],"std::marker::Send":["Drain","IntoIter","SliceDeque","mirrored::buffer::Buffer"],"std::marker::Sync":["Drain","IntoIter","SliceDeque","mirrored::buffer::Buffer"],"std::ops::Deref":["SliceDeque"],"std::ops::DerefMut":["SliceDeque"],"std::ops::Drop":["Drain","DrainFilter","IntoIter","SliceDeque","Splice","mirrored::buffer::Buffer"]},"type_to_def_path":{"Drain<'a, T>":"Drain","DrainFilter<'a, T, F>":"DrainFilter","ExtendDefault":"ExtendDefault","ExtendElement<T>":"ExtendElement","IntoIter<T>":"IntoIter","SliceDeque<T>":"SliceDeque","Splice<'a, I>":"Splice","macros::TinyAsciiString":"macros::TinyAsciiString","mirrored::AllocError":"mirrored::AllocError","mirrored::buffer::Buffer<T>":"mirrored::buffer::Buffer"}}