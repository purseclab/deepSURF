{"dependencies":{"<&'a StackVec<A> as std::iter::IntoIterator>::into_iter":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<&'a mut StackVec<A> as std::iter::IntoIterator>::into_iter":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<*const T as PointerMethods>::padd":[],"<*mut T as PointerMethods>::padd":[],"<Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back":["Drain","std::marker::Sized","std::option::Option","std::slice::IterMut"],"<Drain<'a, T> as std::iter::Iterator>::next":["Drain","std::marker::Sized","std::option::Option","std::slice::IterMut"],"<Drain<'a, T> as std::iter::Iterator>::size_hint":["Drain","std::marker::Sized","std::option::Option","std::slice::IterMut"],"<Drain<'a, T> as std::ops::Drop>::drop":["Drain","std::marker::Sized","std::slice::IterMut"],"<IntoIter<A> as std::iter::DoubleEndedIterator>::next_back":["Array","IntoIter","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"<IntoIter<A> as std::iter::Iterator>::next":["Array","IntoIter","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"<IntoIter<A> as std::iter::Iterator>::size_hint":["Array","IntoIter","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"<IntoIter<A> as std::ops::Drop>::drop":["Array","IntoIter","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<SetLenOnDrop<'a> as std::ops::Drop>::drop":["SetLenOnDrop"],"<StackVec<A> as ExtendFromSlice<<A as Array>::Item>>::extend_from_slice":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as VecLike<<A as Array>::Item>>::pop":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"<StackVec<A> as VecLike<<A as Array>::Item>>::push":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::borrow::Borrow<[<A as Array>::Item]>>::borrow":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::borrow::BorrowMut<[<A as Array>::Item]>>::borrow_mut":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::clone::Clone>::clone":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::cmp::Ord>::cmp":["Array","StackVec","std::cmp::Ordering","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::cmp::PartialEq<StackVec<B>>>::eq":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::cmp::PartialEq<StackVec<B>>>::ne":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::cmp::PartialOrd>::partial_cmp":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"<StackVec<A> as std::convert::AsMut<[<A as Array>::Item]>>::as_mut":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::convert::AsRef<[<A as Array>::Item]>>::as_ref":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::convert::From<&'a [<A as Array>::Item]>>::from":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::convert::From<A>>::from":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::convert::From<std::vec::Vec<<A as Array>::Item>>>::from":["Array","StackVec","std::alloc::Allocator","std::marker::Sized","std::mem::ManuallyDrop","std::vec::Vec"],"<StackVec<A> as std::default::Default>::default":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::fmt::Debug>::fmt":["Array","StackVec","std::fmt::Formatter","std::marker::Sized","std::mem::ManuallyDrop","std::result::Result"],"<StackVec<A> as std::hash::Hash>::hash":["Array","StackVec","std::hash::Hasher","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::io::Write>::flush":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::result::Result"],"<StackVec<A> as std::io::Write>::write":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::result::Result"],"<StackVec<A> as std::io::Write>::write_all":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::result::Result"],"<StackVec<A> as std::iter::Extend<<A as Array>::Item>>::extend":["Array","StackVec","std::iter::IntoIterator","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::iter::FromIterator<<A as Array>::Item>>::from_iter":["Array","StackVec","std::iter::IntoIterator","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::iter::IntoIterator>::into_iter":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::ops::Deref>::deref":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::ops::DerefMut>::deref_mut":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::ops::Drop>::drop":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::ops::Index<std::ops::Range<usize>>>::index":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range"],"<StackVec<A> as std::ops::Index<std::ops::RangeFrom<usize>>>::index":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeFrom"],"<StackVec<A> as std::ops::Index<std::ops::RangeFull>>::index":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeFull"],"<StackVec<A> as std::ops::Index<std::ops::RangeInclusive<usize>>>::index":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeInclusive"],"<StackVec<A> as std::ops::Index<std::ops::RangeTo<usize>>>::index":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeTo"],"<StackVec<A> as std::ops::Index<std::ops::RangeToInclusive<usize>>>::index":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeToInclusive"],"<StackVec<A> as std::ops::Index<usize>>::index":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<StackVec<A> as std::ops::IndexMut<std::ops::Range<usize>>>::index_mut":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeFrom<usize>>>::index_mut":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeFrom"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeFull>>::index_mut":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeFull"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeInclusive<usize>>>::index_mut":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeInclusive"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeTo<usize>>>::index_mut":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeTo"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeToInclusive<usize>>>::index_mut":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeToInclusive"],"<StackVec<A> as std::ops::IndexMut<usize>>::index_mut":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"<[T; 0] as Array>::ptr":[],"<[T; 0] as Array>::ptr_mut":[],"<[T; 0] as Array>::size":[],"<[T; 1024] as Array>::ptr":[],"<[T; 1024] as Array>::ptr_mut":[],"<[T; 1024] as Array>::size":[],"<[T; 1048576] as Array>::ptr":[],"<[T; 1048576] as Array>::ptr_mut":[],"<[T; 1048576] as Array>::size":[],"<[T; 10] as Array>::ptr":[],"<[T; 10] as Array>::ptr_mut":[],"<[T; 10] as Array>::size":[],"<[T; 11] as Array>::ptr":[],"<[T; 11] as Array>::ptr_mut":[],"<[T; 11] as Array>::size":[],"<[T; 128] as Array>::ptr":[],"<[T; 128] as Array>::ptr_mut":[],"<[T; 128] as Array>::size":[],"<[T; 12] as Array>::ptr":[],"<[T; 12] as Array>::ptr_mut":[],"<[T; 12] as Array>::size":[],"<[T; 131072] as Array>::ptr":[],"<[T; 131072] as Array>::ptr_mut":[],"<[T; 131072] as Array>::size":[],"<[T; 13] as Array>::ptr":[],"<[T; 13] as Array>::ptr_mut":[],"<[T; 13] as Array>::size":[],"<[T; 14] as Array>::ptr":[],"<[T; 14] as Array>::ptr_mut":[],"<[T; 14] as Array>::size":[],"<[T; 15] as Array>::ptr":[],"<[T; 15] as Array>::ptr_mut":[],"<[T; 15] as Array>::size":[],"<[T; 16384] as Array>::ptr":[],"<[T; 16384] as Array>::ptr_mut":[],"<[T; 16384] as Array>::size":[],"<[T; 16] as Array>::ptr":[],"<[T; 16] as Array>::ptr_mut":[],"<[T; 16] as Array>::size":[],"<[T; 1] as Array>::ptr":[],"<[T; 1] as Array>::ptr_mut":[],"<[T; 1] as Array>::size":[],"<[T; 2048] as Array>::ptr":[],"<[T; 2048] as Array>::ptr_mut":[],"<[T; 2048] as Array>::size":[],"<[T; 20] as Array>::ptr":[],"<[T; 20] as Array>::ptr_mut":[],"<[T; 20] as Array>::size":[],"<[T; 24] as Array>::ptr":[],"<[T; 24] as Array>::ptr_mut":[],"<[T; 24] as Array>::size":[],"<[T; 256] as Array>::ptr":[],"<[T; 256] as Array>::ptr_mut":[],"<[T; 256] as Array>::size":[],"<[T; 262144] as Array>::ptr":[],"<[T; 262144] as Array>::ptr_mut":[],"<[T; 262144] as Array>::size":[],"<[T; 2] as Array>::ptr":[],"<[T; 2] as Array>::ptr_mut":[],"<[T; 2] as Array>::size":[],"<[T; 32768] as Array>::ptr":[],"<[T; 32768] as Array>::ptr_mut":[],"<[T; 32768] as Array>::size":[],"<[T; 32] as Array>::ptr":[],"<[T; 32] as Array>::ptr_mut":[],"<[T; 32] as Array>::size":[],"<[T; 36] as Array>::ptr":[],"<[T; 36] as Array>::ptr_mut":[],"<[T; 36] as Array>::size":[],"<[T; 3] as Array>::ptr":[],"<[T; 3] as Array>::ptr_mut":[],"<[T; 3] as Array>::size":[],"<[T; 4096] as Array>::ptr":[],"<[T; 4096] as Array>::ptr_mut":[],"<[T; 4096] as Array>::size":[],"<[T; 4] as Array>::ptr":[],"<[T; 4] as Array>::ptr_mut":[],"<[T; 4] as Array>::size":[],"<[T; 512] as Array>::ptr":[],"<[T; 512] as Array>::ptr_mut":[],"<[T; 512] as Array>::size":[],"<[T; 524288] as Array>::ptr":[],"<[T; 524288] as Array>::ptr_mut":[],"<[T; 524288] as Array>::size":[],"<[T; 5] as Array>::ptr":[],"<[T; 5] as Array>::ptr_mut":[],"<[T; 5] as Array>::size":[],"<[T; 64] as Array>::ptr":[],"<[T; 64] as Array>::ptr_mut":[],"<[T; 64] as Array>::size":[],"<[T; 65536] as Array>::ptr":[],"<[T; 65536] as Array>::ptr_mut":[],"<[T; 65536] as Array>::size":[],"<[T; 6] as Array>::ptr":[],"<[T; 6] as Array>::ptr_mut":[],"<[T; 6] as Array>::size":[],"<[T; 7] as Array>::ptr":[],"<[T; 7] as Array>::ptr_mut":[],"<[T; 7] as Array>::size":[],"<[T; 8192] as Array>::ptr":[],"<[T; 8192] as Array>::ptr_mut":[],"<[T; 8192] as Array>::size":[],"<[T; 8] as Array>::ptr":[],"<[T; 8] as Array>::ptr_mut":[],"<[T; 8] as Array>::size":[],"<[T; 9] as Array>::ptr":[],"<[T; 9] as Array>::ptr_mut":[],"<[T; 9] as Array>::size":[],"<std::vec::Vec<T> as ExtendFromSlice<T>>::extend_from_slice":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<std::vec::Vec<T> as VecLike<T>>::pop":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<std::vec::Vec<T> as VecLike<T>>::push":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Array::ptr":[],"Array::ptr_mut":[],"Array::size":[],"Drain":["Drain","std::marker::Sized","std::slice::IterMut"],"ExtendFromSlice::extend_from_slice":[],"IntoIter":["Array","IntoIter","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"PointerMethods::padd":[],"SetLenOnDrop":["SetLenOnDrop"],"SetLenOnDrop::<'a>::increment_len":["SetLenOnDrop"],"SetLenOnDrop::<'a>::new":["SetLenOnDrop"],"StackVec":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::as_mut_slice":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::as_slice":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::capacity":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::clear":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::dedup":["Array","StackVec","std::cmp::PartialEq","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::dedup_by":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::FnMut"],"StackVec::<A>::dedup_by_key":["Array","StackVec","std::cmp::PartialEq","std::marker::Sized","std::mem::ManuallyDrop","std::ops::FnMut"],"StackVec::<A>::drain":["Array","Drain","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::slice::IterMut"],"StackVec::<A>::extend_from_slice":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::from_buf":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::from_buf_and_len":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::from_buf_and_len_unchecked":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::from_elem":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::from_slice":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::from_vec":["Array","StackVec","std::alloc::Allocator","std::marker::Sized","std::mem::ManuallyDrop","std::vec::Vec"],"StackVec::<A>::from_vec_unchecked":["Array","StackVec","std::alloc::Allocator","std::marker::Sized","std::mem::ManuallyDrop","std::vec::Vec"],"StackVec::<A>::insert":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::insert_from_slice":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::insert_many":["Array","StackVec","std::iter::IntoIterator","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::into_inner":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::result::Result"],"StackVec::<A>::into_vec":["Array","StackVec","std::alloc::Allocator","std::marker::Sized","std::mem::ManuallyDrop","std::vec::Vec"],"StackVec::<A>::is_empty":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::len":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::new":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::pop":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"StackVec::<A>::push":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::remove":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::resize":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::retain":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop","std::ops::FnMut"],"StackVec::<A>::set_len":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::swap_remove":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"StackVec::<A>::truncate":["Array","StackVec","std::marker::Sized","std::mem::ManuallyDrop"],"VecLike::pop":["std::marker::Sized","std::option::Option"],"VecLike::push":[]},"glob_path_import":{},"self_to_fn":{"Drain":["impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back().map(|reference| unsafe { ptr::read(reference) })\n    }\n}","impl<'a, T: 'a> Drop for Drain<'a,T> {\n    fn drop(&mut self) {\n        // Destroy the remaining elements.\n        for _ in self.by_ref() {}\n    }\n}","impl<'a, T: 'a> Iterator for Drain<'a,T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        self.iter.next().map(|reference| unsafe { ptr::read(reference) })\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}","impl<'a, T> ExactSizeIterator for Drain<'a, T> { }"],"IntoIter":["impl<A: Array> DoubleEndedIterator for IntoIter<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A::Item> {\n        if self.current == self.end {\n            None\n        }\n        else {\n            unsafe {\n                self.end -= 1;\n                Some(ptr::read(self.data.as_ptr().padd(self.end)))\n            }\n        }\n    }\n}","impl<A: Array> Drop for IntoIter<A> {\n    fn drop(&mut self) {\n        for _ in self {\n        }\n    }\n}","impl<A: Array> ExactSizeIterator for IntoIter<A> {\n}","impl<A: Array> Iterator for IntoIter<A> {\n    type Item = A::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<A::Item> {\n        if self.current == self.end {\n            None\n        }\n        else {\n            unsafe {\n                let current = self.current;\n                self.current += 1;\n                Some(ptr::read(self.data.as_ptr().padd(current)))\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let size = self.end - self.current;\n        (size, Some(size))\n    }\n}"],"SetLenOnDrop":["impl<'a> Drop for SetLenOnDrop<'a> {\n    #[inline]\n    fn drop(&mut self) {\n        *self.len = self.local_len;\n    }\n}","impl<'a> SetLenOnDrop<'a> {\n    #[inline]\n    fn new(len: &'a mut usize) -> Self {\n        SetLenOnDrop { local_len: *len, len: len }\n    }\n\n    #[inline]\n    fn increment_len(&mut self, increment: usize) {\n        self.local_len += increment;\n    }\n}"],"StackVec":["impl<'a, A: Array> From<&'a [A::Item]> for StackVec<A> where A::Item: Clone {\n    #[inline]\n    fn from(slice: &'a [A::Item]) -> StackVec<A> {\n        slice.into_iter().cloned().collect()\n    }\n}","impl<A: Array, B: Array> PartialEq<StackVec<B>> for StackVec<A>\n    where A::Item: PartialEq<B::Item>\n{\n    #[inline]\n    fn eq(&self, other: &StackVec<B>) -> bool {\n        self[..] == other[..]\n    }\n\n    #[inline]\n    fn ne(&self, other: &StackVec<B>) -> bool {\n        self[..] != other[..]\n    }\n}","impl<A: Array<Item = u8>> io::Write for StackVec<A> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.extend_from_slice(buf);\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.extend_from_slice(buf);\n        Ok(())\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}","impl<A: Array> AsMut<[A::Item]> for StackVec<A> {\n    #[inline]\n    fn as_mut(&mut self) -> &mut [A::Item] {\n        self\n    }\n}","impl<A: Array> AsRef<[A::Item]> for StackVec<A> {\n    #[inline]\n    fn as_ref(&self) -> &[A::Item] {\n        self\n    }\n}","impl<A: Array> Borrow<[A::Item]> for StackVec<A> {\n    #[inline]\n    fn borrow(&self) -> &[A::Item] {\n        self\n    }\n}","impl<A: Array> BorrowMut<[A::Item]> for StackVec<A> {\n    #[inline]\n    fn borrow_mut(&mut self) -> &mut [A::Item] {\n        self\n    }\n}","impl<A: Array> Clone for StackVec<A> where A::Item: Clone {\n    fn clone(&self) -> StackVec<A> {\n        let mut new_vector = StackVec::new();\n        for element in self.iter() {\n            new_vector.push(element.clone())\n        }\n        new_vector\n    }\n}","impl<A: Array> Default for StackVec<A> {\n    #[inline]\n    fn default() -> StackVec<A> {\n        StackVec::new()\n    }\n}","impl<A: Array> Drop for StackVec<A> {\n    fn drop(&mut self) {\n        unsafe {\n            ptr::drop_in_place(&mut self[..]);\n        }\n    }\n}","impl<A: Array> Eq for StackVec<A> where A::Item: Eq {\n}","impl<A: Array> Extend<A::Item> for StackVec<A> {\n    fn extend<I: iter::IntoIterator<Item=A::Item>>(&mut self, iterable: I) {\n        let mut iter = iterable.into_iter();\n        let (lower_bound, upper_bound) = iter.size_hint();\n        let upper_bound = upper_bound.expect(\"iterable must provide upper bound.\");\n        assert!(self.len() + upper_bound <= self.capacity());\n\n        unsafe {\n            let len = self.len();\n            let ptr = self.as_mut_ptr().padd(len);\n            let mut count = 0;\n            while count < lower_bound {\n                if let Some(out) = iter.next() {\n                    ptr::write(ptr.padd(count), out);\n                    count += 1;\n                } else {\n                    break;\n                }\n            }\n            self.set_len(len + count);\n        }\n\n        for elem in iter {\n            self.push(elem);\n        }\n    }\n}","impl<A: Array> ExtendFromSlice<A::Item> for StackVec<A> where A::Item: Copy {\n    fn extend_from_slice(&mut self, other: &[A::Item]) {\n        StackVec::extend_from_slice(self, other)\n    }\n}","impl<A: Array> From<A> for StackVec<A> {\n    #[inline]\n    fn from(array: A) -> StackVec<A> {\n        StackVec::from_buf(array)\n    }\n}","impl<A: Array> From<Vec<A::Item>> for StackVec<A> {\n    #[inline]\n    fn from(vec: Vec<A::Item>) -> StackVec<A> {\n        StackVec::from_vec(vec)\n    }\n}","impl<A: Array> IntoIterator for StackVec<A> {\n    type IntoIter = IntoIter<A>;\n    type Item = A::Item;\n    fn into_iter(mut self) -> Self::IntoIter {\n        unsafe {\n            // Set StackVec len to zero as `IntoIter` drop handles dropping of the elements\n            let len = self.len();\n            self.set_len(0);\n            IntoIter {\n                data: self,\n                current: 0,\n                end: len,\n            }\n        }\n    }\n}","impl<A: Array> Ord for StackVec<A> where A::Item: Ord {\n    #[inline]\n    fn cmp(&self, other: &StackVec<A>) -> cmp::Ordering {\n        Ord::cmp(&**self, &**other)\n    }\n}","impl<A: Array> PartialOrd for StackVec<A> where A::Item: PartialOrd {\n    #[inline]\n    fn partial_cmp(&self, other: &StackVec<A>) -> Option<cmp::Ordering> {\n        PartialOrd::partial_cmp(&**self, &**other)\n    }\n}","impl<A: Array> StackVec<A> where A::Item: Clone {\n    /// Resizes the vector so that its length is equal to `len`.\n    ///\n    /// If `len` is less than the current length, the vector simply truncated.\n    ///\n    /// If `len` is greater than the current length, `value` is appended to the\n    /// vector until its length equals `len`.\n    pub fn resize(&mut self, len: usize, value: A::Item) {\n        assert!(len <= self.capacity());\n        let old_len = self.len();\n        if len > old_len {\n            self.extend(iter::repeat(value).take(len - old_len));\n        } else {\n            self.truncate(len);\n        }\n    }\n\n    /// Creates a `StackVec` with `n` copies of `elem`.\n    /// ```\n    /// use stackvector::StackVec;\n    ///\n    /// let v = StackVec::<[char; 128]>::from_elem('d', 2);\n    /// assert_eq!(v, StackVec::from_buf(['d', 'd']));\n    /// ```\n    pub fn from_elem(elem: A::Item, n: usize) -> Self {\n        assert!(n <= A::size());\n        let mut v = StackVec::<A>::new();\n        unsafe {\n            let ptr = v.as_mut_ptr();\n            let mut local_len = SetLenOnDrop::new(&mut v.length);\n            for i in 0..n as isize {\n                ptr::write(ptr.offset(i), elem.clone());\n                local_len.increment_len(1);\n            }\n        }\n        v\n    }\n}","impl<A: Array> StackVec<A> where A::Item: Copy {\n    /// Copy the elements from a slice into a new `StackVec`.\n    ///\n    /// For slices of `Copy` types, this is more efficient than `StackVec::from(slice)`.\n    pub fn from_slice(slice: &[A::Item]) -> Self {\n        assert!(slice.len() <= A::size());\n        StackVec {\n            length: slice.len(),\n            data: unsafe {\n                let mut data: A = mem::uninitialized();\n                ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), slice.len());\n                mem::ManuallyDrop::new(data)\n            }\n        }\n    }\n\n    /// Copy elements from a slice into the vector at position `index`, shifting any following\n    /// elements toward the back.\n    ///\n    /// For slices of `Copy` types, this is more efficient than `insert`.\n    pub fn insert_from_slice(&mut self, index: usize, slice: &[A::Item]) {\n        assert!(index <= self.len() && self.len() + slice.len() <= self.capacity());\n        unsafe {\n            let len = self.len();\n            let slice_ptr = slice.as_ptr();\n            let ptr = self.as_mut_ptr().padd(index);\n            ptr::copy(ptr, ptr.padd(slice.len()), len - index);\n            ptr::copy_nonoverlapping(slice_ptr, ptr, slice.len());\n            self.set_len(len + slice.len());\n        }\n    }\n\n    /// Copy elements from a slice and append them to the vector.\n    ///\n    /// For slices of `Copy` types, this is more efficient than `extend`.\n    #[inline]\n    pub fn extend_from_slice(&mut self, slice: &[A::Item]) {\n        let len = self.len();\n        self.insert_from_slice(len, slice);\n    }\n}","impl<A: Array> StackVec<A> {\n    /// Construct an empty vector\n    #[inline]\n    pub fn new() -> StackVec<A> {\n        unsafe {\n            StackVec {\n                length: 0,\n                data: mem::uninitialized(),\n            }\n        }\n    }\n\n    /// Construct a new `StackVec` from a `Vec<A::Item>`.\n    ///\n    /// Elements will be copied to the inline buffer if vec.len() <= A::size().\n    ///\n    /// ```rust\n    /// use stackvector::StackVec;\n    ///\n    /// let vec = vec![1, 2, 3, 4, 5];\n    /// let stack_vec: StackVec<[_; 5]> = StackVec::from_vec(vec);\n    ///\n    /// assert_eq!(&*stack_vec, &[1, 2, 3, 4, 5]);\n    /// ```\n    #[inline]\n    pub fn from_vec(vec: Vec<A::Item>) -> StackVec<A> {\n        assert!(vec.len() <= A::size());\n        unsafe { Self::from_vec_unchecked(vec) }\n    }\n\n    /// Construct a new `StackVec` from a `Vec<A::Item>` without bounds checking.\n    pub unsafe fn from_vec_unchecked(mut vec: Vec<A::Item>) -> StackVec<A> {\n        let mut data: A = mem::uninitialized();\n        let len = vec.len();\n        vec.set_len(0);\n        ptr::copy_nonoverlapping(vec.as_ptr(), data.ptr_mut(), len);\n\n        StackVec {\n            length: len,\n            data: mem::ManuallyDrop::new(data),\n        }\n    }\n\n    /// Constructs a new `StackVec` on the stack from an `A` without\n    /// copying elements.\n    ///\n    /// ```rust\n    /// use stackvector::StackVec;\n    ///\n    /// let buf = [1, 2, 3, 4, 5];\n    /// let stack_vec: StackVec<_> = StackVec::from_buf(buf);\n    ///\n    /// assert_eq!(&*stack_vec, &[1, 2, 3, 4, 5]);\n    /// ```\n    #[inline]\n    pub fn from_buf(buf: A) -> StackVec<A> {\n        StackVec {\n            length: A::size(),\n            data: mem::ManuallyDrop::new(buf),\n        }\n    }\n\n    /// Constructs a new `StackVec` on the stack from an `A` without\n    /// copying elements. Also sets the length, which must be less or\n    /// equal to the size of `buf`.\n    ///\n    /// ```rust\n    /// use stackvector::StackVec;\n    ///\n    /// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n    /// let stack_vec: StackVec<_> = StackVec::from_buf_and_len(buf, 5);\n    ///\n    /// assert_eq!(&*stack_vec, &[1, 2, 3, 4, 5]);\n    /// ```\n    #[inline]\n    pub fn from_buf_and_len(buf: A, len: usize) -> StackVec<A> {\n        assert!(len <= A::size());\n        unsafe { StackVec::from_buf_and_len_unchecked(buf, len) }\n    }\n\n    /// Constructs a new `StackVec` on the stack from an `A` without\n    /// copying elements. Also sets the length. The user is responsible\n    /// for ensuring that `len <= A::size()`.\n    ///\n    /// ```rust\n    /// use stackvector::StackVec;\n    ///\n    /// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n    /// let stack_vec: StackVec<_> = unsafe {\n    ///     StackVec::from_buf_and_len_unchecked(buf, 5)\n    /// };\n    ///\n    /// assert_eq!(&*stack_vec, &[1, 2, 3, 4, 5]);\n    /// ```\n    #[inline]\n    pub unsafe fn from_buf_and_len_unchecked(buf: A, len: usize) -> StackVec<A> {\n        StackVec {\n            length: len,\n            data: mem::ManuallyDrop::new(buf),\n        }\n    }\n\n    /// Sets the length of a vector.\n    ///\n    /// This will explicitly set the size of the vector, without actually\n    /// modifying its buffers, so it is up to the caller to ensure that the\n    /// vector is actually the specified size.\n    #[inline]\n    pub unsafe fn set_len(&mut self, new_len: usize) {\n        self.length = new_len;\n    }\n\n    /// The number of elements stored in the vector.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.length\n    }\n\n    /// If the vector is empty.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// The number of items the vector can hold.\n    #[inline]\n    pub fn capacity(&self) -> usize {\n        A::size()\n    }\n\n    /// Empty the vector and return an iterator over its former contents.\n    pub fn drain(&mut self) -> Drain<A::Item> {\n        unsafe {\n            let slice = slice::from_raw_parts_mut(self.as_mut_ptr(), self.len());\n            self.set_len(0);\n\n            Drain {\n                iter: slice.iter_mut(),\n            }\n        }\n    }\n\n    /// Append an item to the vector.\n    #[inline]\n    pub fn push(&mut self, value: A::Item) {\n        assert!(self.len() < self.capacity());\n        unsafe {\n            ptr::write(self.as_mut_ptr().padd(self.length), value);\n            self.length += 1;\n        }\n    }\n\n    /// Remove an item from the end of the vector and return it, or None if empty.\n    #[inline]\n    pub fn pop(&mut self) -> Option<A::Item> {\n        unsafe {\n            if self.len() == 0 {\n                None\n            } else {\n                self.length -=1;\n                Some(ptr::read(self.as_mut_ptr().padd(self.length)))\n            }\n        }\n    }\n\n    /// Shorten the vector, keeping the first `len` elements and dropping the rest.\n    ///\n    /// If `len` is greater than or equal to the vector's current length, this has no\n    /// effect.\n    /// `shrink_to_fit` after truncating.\n    pub fn truncate(&mut self, len: usize) {\n        unsafe {\n            while len < self.length {\n                self.length -= 1;\n                ptr::drop_in_place(self.as_mut_ptr().padd(self.length));\n            }\n        }\n    }\n\n    /// Extracts a slice containing the entire vector.\n    ///\n    /// Equivalent to `&s[..]`.\n    #[inline]\n    pub fn as_slice(&self) -> &[A::Item] {\n        self\n    }\n\n    /// Extracts a mutable slice of the entire vector.\n    ///\n    /// Equivalent to `&mut s[..]`.\n    #[inline]\n    pub fn as_mut_slice(&mut self) -> &mut [A::Item] {\n        self\n    }\n\n    /// Remove the element at position `index`, replacing it with the last element.\n    ///\n    /// This does not preserve ordering, but is O(1).\n    ///\n    /// Panics if `index` is out of bounds.\n    #[inline]\n    pub fn swap_remove(&mut self, index: usize) -> A::Item {\n        let len = self.len();\n        self.swap(len - 1, index);\n        unsafe { self.pop().unchecked_unwrap() }\n    }\n\n    /// Remove all elements from the vector.\n    #[inline]\n    pub fn clear(&mut self) {\n        self.truncate(0);\n    }\n\n    /// Remove and return the element at position `index`, shifting all elements after it to the\n    /// left.\n    ///\n    /// Panics if `index` is out of bounds.\n    pub fn remove(&mut self, index: usize) -> A::Item {\n        assert!(index < self.len());\n        unsafe {\n            self.length -= 1;\n            let ptr = self.as_mut_ptr().padd(index);\n            let item = ptr::read(ptr);\n            ptr::copy(ptr.offset(1), ptr, self.length - index);\n            item\n        }\n    }\n\n    /// Insert an element at position `index`, shifting all elements after it to the right.\n    ///\n    /// Panics if `index` is out of bounds.\n    pub fn insert(&mut self, index: usize, element: A::Item) {\n        assert!(index < self.len() && self.len() < self.capacity());\n        unsafe {\n            let ptr = self.as_mut_ptr().padd(index);\n            ptr::copy(ptr, ptr.offset(1), self.length - index);\n            ptr::write(ptr, element);\n            self.length += 1;\n        }\n    }\n\n    /// Insert multiple elements at position `index`, shifting all following elements toward the\n    /// back.\n    pub fn insert_many<I: iter::IntoIterator<Item=A::Item>>(&mut self, index: usize, iterable: I) {\n        let iter = iterable.into_iter();\n        if index == self.len() {\n            return self.extend(iter);\n        }\n\n        let (lower_size_bound, _) = iter.size_hint();\n        assert!(lower_size_bound <= std::isize::MAX as usize);  // Ensure offset is indexable\n        assert!(index + lower_size_bound >= index);             // Protect against overflow\n        assert!(self.len() + lower_size_bound <= self.capacity());\n\n        unsafe {\n            let old_len = self.len();\n            assert!(index <= old_len);\n            let mut ptr = self.as_mut_ptr().padd(index);\n\n            // Move the trailing elements.\n            ptr::copy(ptr, ptr.padd(lower_size_bound), old_len - index);\n\n            // In case the iterator panics, don't double-drop the items we just copied above.\n            self.set_len(index);\n\n            let mut num_added = 0;\n            for element in iter {\n                let mut cur = ptr.padd(num_added);\n                if num_added >= lower_size_bound {\n                    // Iterator provided more elements than the hint.  Move trailing items again.\n                    assert!(self.len() + 1 <= self.capacity());\n                    ptr = self.as_mut_ptr().padd(index);\n                    cur = ptr.padd(num_added);\n                    ptr::copy(cur, cur.padd(1), old_len - index);\n                }\n                ptr::write(cur, element);\n                num_added += 1;\n            }\n            if num_added < lower_size_bound {\n                // Iterator provided fewer elements than the hint\n                ptr::copy(ptr.padd(lower_size_bound), ptr.padd(num_added), old_len - index);\n            }\n\n            self.set_len(old_len + num_added);\n        }\n    }\n\n    /// Convert a StackVec to a Vec.\n    pub fn into_vec(self) -> Vec<A::Item> {\n        self.into_iter().collect()\n    }\n\n    /// Convert the StackVec into an `A`.\n    pub fn into_inner(self) -> Result<A, Self> {\n        if self.len() != A::size() {\n            Err(self)\n        } else {\n            unsafe {\n                let data = ptr::read(&self.data);\n                mem::forget(self);\n                Ok(mem::ManuallyDrop::into_inner(data))\n            }\n        }\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n    /// This method operates in place and preserves the order of the retained\n    /// elements.\n    pub fn retain<F: FnMut(&mut A::Item) -> bool>(&mut self, mut f: F) {\n        let mut del = 0;\n        let len = self.len();\n        for i in 0..len {\n            if !f(&mut self[i]) {\n                del += 1;\n            } else if del > 0 {\n                self.swap(i - del, i);\n            }\n        }\n        self.truncate(len - del);\n    }\n\n    /// Removes consecutive duplicate elements.\n    pub fn dedup(&mut self) where A::Item: PartialEq<A::Item> {\n        self.dedup_by(|a, b| a == b);\n    }\n\n    /// Removes consecutive duplicate elements using the given equality relation.\n    pub fn dedup_by<F>(&mut self, mut same_bucket: F)\n        where F: FnMut(&mut A::Item, &mut A::Item) -> bool\n    {\n        // See the implementation of Vec::dedup_by in the\n        // standard library for an explanation of this algorithm.\n        let len = self.len();\n        if len <= 1 {\n            return;\n        }\n\n        let ptr = self.as_mut_ptr();\n        let mut w: usize = 1;\n\n        unsafe {\n            for r in 1..len {\n                let p_r = ptr.offset(r as isize);\n                let p_wm1 = ptr.offset((w - 1) as isize);\n                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n                    if r != w {\n                        let p_w = p_wm1.offset(1);\n                        mem::swap(&mut *p_r, &mut *p_w);\n                    }\n                    w += 1;\n                }\n            }\n        }\n\n        self.truncate(w);\n    }\n\n    /// Removes consecutive elements that map to the same key.\n    pub fn dedup_by_key<F, K>(&mut self, mut key: F)\n        where F: FnMut(&mut A::Item) -> K,\n              K: PartialEq<K>\n    {\n        self.dedup_by(|a, b| key(a) == key(b));\n    }\n}","impl<A: Array> VecLike<A::Item> for StackVec<A> {\n    #[inline]\n    fn push(&mut self, value: A::Item) {\n        StackVec::push(self, value);\n    }\n\n    #[inline]\n    fn pop(&mut self) -> Option<A::Item> {\n        StackVec::pop(self)\n    }\n}","impl<A: Array> fmt::Debug for StackVec<A> where A::Item: fmt::Debug {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}","impl<A: Array> hash::Hash for StackVec<A> where A::Item: hash::Hash {\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        (**self).hash(state)\n    }\n}","impl<A: Array> iter::FromIterator<A::Item> for StackVec<A> {\n    fn from_iter<I: iter::IntoIterator<Item=A::Item>>(iterable: I) -> StackVec<A> {\n        let mut v = StackVec::new();\n        v.extend(iterable);\n        v\n    }\n}","impl<A: Array> ops::Deref for StackVec<A> {\n    type Target = [A::Item];\n    #[inline]\n    fn deref(&self) -> &[A::Item] {\n        unsafe {\n            slice::from_raw_parts(self.data.ptr(), self.len())\n        }\n    }\n}","impl<A: Array> ops::DerefMut for StackVec<A> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut [A::Item] {\n        unsafe {\n            slice::from_raw_parts_mut(self.data.ptr_mut(), self.len())\n        }\n    }\n}","impl<A: Array> ops::Index<$index_type> for StackVec<A> {\n            type Output = $output_type;\n            #[inline]\n            fn index(&self, index: $index_type) -> &$output_type {\n                &(&**self)[index]\n            }\n        }","impl<A: Array> ops::IndexMut<$index_type> for StackVec<A> {\n            #[inline]\n            fn index_mut(&mut self, index: $index_type) -> &mut $output_type {\n                &mut (&mut **self)[index]\n            }\n        }","unsafe impl<A: Array> Send for StackVec<A> where A::Item: Send {\n}"],"std::vec::Vec":["impl<T: Clone> ExtendFromSlice<T> for Vec<T> {\n    fn extend_from_slice(&mut self, other: &[T]) {\n        Vec::extend_from_slice(self, other)\n    }\n}","impl<T> VecLike<T> for Vec<T> {\n    #[inline]\n    fn push(&mut self, value: T) {\n        Vec::push(self, value);\n    }\n\n    #[inline]\n    fn pop(&mut self) -> Option<T> {\n        Vec::pop(self)\n    }\n}"]},"single_path_import":{},"srcs":{"<&'a StackVec<A> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a mut StackVec<A> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter_mut()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<*const T as PointerMethods>::padd":["#[inline(always)]\nunsafe fn padd(self, count: usize) -> Self{\n        #[cfg(has_pointer_methods)]\n        return self.add(count);\n\n        #[cfg(not(has_pointer_methods))]\n        return self.offset(count as isize);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<*mut T as PointerMethods>::padd":["#[inline(always)]\nunsafe fn padd(self, count: usize) -> Self{\n        #[cfg(has_pointer_methods)]\n        return self.add(count);\n\n        #[cfg(not(has_pointer_methods))]\n        return self.offset(count as isize);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<T>{\n        self.iter.next_back().map(|reference| unsafe { ptr::read(reference) })\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<T>{\n        self.iter.next().map(|reference| unsafe { ptr::read(reference) })\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        // Destroy the remaining elements.\n        for _ in self.by_ref() {}\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<A> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<A::Item>{\n        if self.current == self.end {\n            None\n        }\n        else {\n            unsafe {\n                self.end -= 1;\n                Some(ptr::read(self.data.as_ptr().padd(self.end)))\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<A> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<A::Item>{\n        if self.current == self.end {\n            None\n        }\n        else {\n            unsafe {\n                let current = self.current;\n                self.current += 1;\n                Some(ptr::read(self.data.as_ptr().padd(current)))\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<A> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        let size = self.end - self.current;\n        (size, Some(size))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<A> as std::ops::Drop>::drop":["fn drop(&mut self){\n        for _ in self {\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SetLenOnDrop<'a> as std::ops::Drop>::drop":["#[inline]\nfn drop(&mut self){\n        *self.len = self.local_len;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as ExtendFromSlice<<A as Array>::Item>>::extend_from_slice":["fn extend_from_slice(&mut self, other: &[A::Item]){\n        StackVec::extend_from_slice(self, other)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as VecLike<<A as Array>::Item>>::pop":["#[inline]\nfn pop(&mut self) -> Option<A::Item>{\n        StackVec::pop(self)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as VecLike<<A as Array>::Item>>::push":["#[inline]\nfn push(&mut self, value: A::Item){\n        StackVec::push(self, value);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::borrow::Borrow<[<A as Array>::Item]>>::borrow":["#[inline]\nfn borrow(&self) -> &[A::Item]{\n        self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::borrow::BorrowMut<[<A as Array>::Item]>>::borrow_mut":["#[inline]\nfn borrow_mut(&mut self) -> &mut [A::Item]{\n        self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::clone::Clone>::clone":["fn clone(&self) -> StackVec<A>{\n        let mut new_vector = StackVec::new();\n        for element in self.iter() {\n            new_vector.push(element.clone())\n        }\n        new_vector\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::cmp::Ord>::cmp":["#[inline]\nfn cmp(&self, other: &StackVec<A>) -> cmp::Ordering{\n        Ord::cmp(&**self, &**other)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::cmp::PartialEq<StackVec<B>>>::eq":["#[inline]\nfn eq(&self, other: &StackVec<B>) -> bool{\n        self[..] == other[..]\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::cmp::PartialEq<StackVec<B>>>::ne":["#[inline]\nfn ne(&self, other: &StackVec<B>) -> bool{\n        self[..] != other[..]\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::cmp::PartialOrd>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &StackVec<A>) -> Option<cmp::Ordering>{\n        PartialOrd::partial_cmp(&**self, &**other)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::convert::AsMut<[<A as Array>::Item]>>::as_mut":["#[inline]\nfn as_mut(&mut self) -> &mut [A::Item]{\n        self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::convert::AsRef<[<A as Array>::Item]>>::as_ref":["#[inline]\nfn as_ref(&self) -> &[A::Item]{\n        self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::convert::From<&'a [<A as Array>::Item]>>::from":["#[inline]\nfn from(slice: &'a [A::Item]) -> StackVec<A>{\n        slice.into_iter().cloned().collect()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::convert::From<A>>::from":["#[inline]\nfn from(array: A) -> StackVec<A>{\n        StackVec::from_buf(array)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::convert::From<std::vec::Vec<<A as Array>::Item>>>::from":["#[inline]\nfn from(vec: Vec<A::Item>) -> StackVec<A>{\n        StackVec::from_vec(vec)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::default::Default>::default":["#[inline]\nfn default() -> StackVec<A>{\n        StackVec::new()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_list().entries(self.iter()).finish()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::hash::Hash>::hash":["fn hash<H: hash::Hasher>(&self, state: &mut H){\n        (**self).hash(state)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::io::Write>::flush":["#[inline]\nfn flush(&mut self) -> io::Result<()>{\n        Ok(())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::io::Write>::write":["#[inline]\nfn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.extend_from_slice(buf);\n        Ok(buf.len())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::io::Write>::write_all":["#[inline]\nfn write_all(&mut self, buf: &[u8]) -> io::Result<()>{\n        self.extend_from_slice(buf);\n        Ok(())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::iter::Extend<<A as Array>::Item>>::extend":["fn extend<I: iter::IntoIterator<Item=A::Item>>(&mut self, iterable: I){\n        let mut iter = iterable.into_iter();\n        let (lower_bound, upper_bound) = iter.size_hint();\n        let upper_bound = upper_bound.expect(\"iterable must provide upper bound.\");\n        assert!(self.len() + upper_bound <= self.capacity());\n\n        unsafe {\n            let len = self.len();\n            let ptr = self.as_mut_ptr().padd(len);\n            let mut count = 0;\n            while count < lower_bound {\n                if let Some(out) = iter.next() {\n                    ptr::write(ptr.padd(count), out);\n                    count += 1;\n                } else {\n                    break;\n                }\n            }\n            self.set_len(len + count);\n        }\n\n        for elem in iter {\n            self.push(elem);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::iter::FromIterator<<A as Array>::Item>>::from_iter":["fn from_iter<I: iter::IntoIterator<Item=A::Item>>(iterable: I) -> StackVec<A>{\n        let mut v = StackVec::new();\n        v.extend(iterable);\n        v\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::iter::IntoIterator>::into_iter":["fn into_iter(mut self) -> Self::IntoIter{\n        unsafe {\n            // Set StackVec len to zero as `IntoIter` drop handles dropping of the elements\n            let len = self.len();\n            self.set_len(0);\n            IntoIter {\n                data: self,\n                current: 0,\n                end: len,\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::Deref>::deref":["#[inline]\nfn deref(&self) -> &[A::Item]{\n        unsafe {\n            slice::from_raw_parts(self.data.ptr(), self.len())\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::DerefMut>::deref_mut":["#[inline]\nfn deref_mut(&mut self) -> &mut [A::Item]{\n        unsafe {\n            slice::from_raw_parts_mut(self.data.ptr_mut(), self.len())\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::Drop>::drop":["fn drop(&mut self){\n        unsafe {\n            ptr::drop_in_place(&mut self[..]);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::Index<std::ops::Range<usize>>>::index":["#[inline]\nfn index(&self, index: $index_type) -> &$output_type{\n                &(&**self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::Index<std::ops::RangeFrom<usize>>>::index":["#[inline]\nfn index(&self, index: $index_type) -> &$output_type{\n                &(&**self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::Index<std::ops::RangeFull>>::index":["#[inline]\nfn index(&self, index: $index_type) -> &$output_type{\n                &(&**self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::Index<std::ops::RangeInclusive<usize>>>::index":["#[inline]\nfn index(&self, index: $index_type) -> &$output_type{\n                &(&**self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::Index<std::ops::RangeTo<usize>>>::index":["#[inline]\nfn index(&self, index: $index_type) -> &$output_type{\n                &(&**self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::Index<std::ops::RangeToInclusive<usize>>>::index":["#[inline]\nfn index(&self, index: $index_type) -> &$output_type{\n                &(&**self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::Index<usize>>::index":["#[inline]\nfn index(&self, index: $index_type) -> &$output_type{\n                &(&**self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::IndexMut<std::ops::Range<usize>>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: $index_type) -> &mut $output_type{\n                &mut (&mut **self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeFrom<usize>>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: $index_type) -> &mut $output_type{\n                &mut (&mut **self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeFull>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: $index_type) -> &mut $output_type{\n                &mut (&mut **self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeInclusive<usize>>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: $index_type) -> &mut $output_type{\n                &mut (&mut **self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeTo<usize>>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: $index_type) -> &mut $output_type{\n                &mut (&mut **self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeToInclusive<usize>>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: $index_type) -> &mut $output_type{\n                &mut (&mut **self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<StackVec<A> as std::ops::IndexMut<usize>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: $index_type) -> &mut $output_type{\n                &mut (&mut **self)[index]\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 0] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 0] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 0] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 1024] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 1024] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 1024] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 1048576] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 1048576] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 1048576] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 10] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 10] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 10] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 11] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 11] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 11] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 128] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 128] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 128] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 12] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 12] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 12] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 131072] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 131072] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 131072] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 13] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 13] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 13] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 14] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 14] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 14] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 15] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 15] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 15] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 16384] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 16384] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 16384] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 16] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 16] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 16] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 1] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 1] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 1] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 2048] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 2048] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 2048] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 20] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 20] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 20] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 24] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 24] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 24] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 256] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 256] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 256] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 262144] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 262144] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 262144] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 2] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 2] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 2] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 32768] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 32768] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 32768] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 32] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 32] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 32] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 36] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 36] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 36] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 3] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 3] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 3] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 4096] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 4096] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 4096] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 4] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 4] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 4] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 512] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 512] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 512] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 524288] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 524288] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 524288] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 5] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 5] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 5] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 64] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 64] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 64] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 65536] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 65536] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 65536] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 6] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 6] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 6] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 7] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 7] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 7] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 8192] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 8192] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 8192] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 8] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 8] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 8] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 9] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 9] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 9] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<std::vec::Vec<T> as ExtendFromSlice<T>>::extend_from_slice":["fn extend_from_slice(&mut self, other: &[T]){\n        Vec::extend_from_slice(self, other)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<std::vec::Vec<T> as VecLike<T>>::pop":["#[inline]\nfn pop(&mut self) -> Option<T>{\n        Vec::pop(self)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<std::vec::Vec<T> as VecLike<T>>::push":["#[inline]\nfn push(&mut self, value: T){\n        Vec::push(self, value);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Array":["/// Types that can be used as the backing store for a StackVec\npub unsafe trait Array {\n    /// The type of the array's elements.\n    type Item;\n    /// Returns the number of items the array can hold.\n    fn size() -> usize;\n    /// Returns a pointer to the first element of the array.\n    fn ptr(&self) -> *const Self::Item;\n    /// Returns a mutable pointer to the first element of the array.\n    fn ptr_mut(&mut self) -> *mut Self::Item;\n}","Real(LocalPath(\"src/lib.rs\"))"],"Drain":["/// An iterator that removes the items from a `StackVec` and yields them by value.\n///\n/// Returned from [`StackVec::drain`][1].\n///\n/// [1]: struct.StackVec.html#method.drain\npub struct Drain<'a, T: 'a> {\n    iter: slice::IterMut<'a, T>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"ExtendFromSlice":["/// Trait to be implemented by a collection that can be extended from a slice\n///\n/// ## Example\n///\n/// ```rust\n/// use stackvector::{ExtendFromSlice, StackVec};\n///\n/// fn initialize<V: ExtendFromSlice<u8>>(v: &mut V) {\n///     v.extend_from_slice(b\"Test!\");\n/// }\n///\n/// let mut vec = Vec::new();\n/// initialize(&mut vec);\n/// assert_eq!(&vec, b\"Test!\");\n///\n/// let mut stack_vec = StackVec::<[u8; 8]>::new();\n/// initialize(&mut stack_vec);\n/// assert_eq!(&stack_vec as &[_], b\"Test!\");\n/// ```\npub trait ExtendFromSlice<T> {\n    /// Extends a collection from a slice of its element type\n    fn extend_from_slice(&mut self, other: &[T]);\n}","Real(LocalPath(\"src/lib.rs\"))"],"IntoIter":["/// An iterator that consumes a `StackVec` and yields its items by value.\n///\n/// Returned from [`StackVec::into_iter`][1].\n///\n/// [1]: struct.StackVec.html#method.into_iter\npub struct IntoIter<A: Array> {\n    data: StackVec<A>,\n    current: usize,\n    end: usize,\n}","Real(LocalPath(\"src/lib.rs\"))"],"PointerMethods":["trait PointerMethods {\n    // Add to the pointer (use padd to avoid conflict with ptr::add).\n    unsafe fn padd(self, count: usize) -> Self;\n}","Real(LocalPath(\"src/lib.rs\"))"],"SetLenOnDrop":["/// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n///\n/// Copied from https://github.com/rust-lang/rust/pull/36355\nstruct SetLenOnDrop<'a> {\n    len: &'a mut usize,\n    local_len: usize,\n}","Real(LocalPath(\"src/lib.rs\"))"],"SetLenOnDrop::<'a>::increment_len":["#[inline]\nfn increment_len(&mut self, increment: usize){\n        self.local_len += increment;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SetLenOnDrop::<'a>::new":["#[inline]\nfn new(len: &'a mut usize) -> Self{\n        SetLenOnDrop { local_len: *len, len: len }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec":["/// A `Vec`-like container that stores elements on the stack.\n///\n/// The amount of data that a `StackVec` can store inline depends on its backing store. The backing\n/// store can be any type that implements the `Array` trait; usually it is a small fixed-sized\n/// array.  For example a `StackVec<[u64; 8]>` can hold up to eight 64-bit integers inline.\n///\n/// ## Example\n///\n/// ```rust,should_panic\n/// use stackvector::StackVec;\n/// let mut v = StackVec::<[u8; 4]>::new(); // initialize an empty vector\n///\n/// // The vector can hold up to 4 items without spilling onto the heap.\n/// v.extend(0..4);\n/// assert_eq!(v.len(), 4);\n///\n/// // Pushing another element will force the buffer to spill and panic:\n/// v.push(4);\n/// ```\npub struct StackVec<A: Array> {\n    // The capacity field is used for iteration and other optimizations.\n    // Publicly expose the fields, so they may be used in constant\n    // initialization.\n    pub length: usize,\n    pub data: mem::ManuallyDrop<A>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::as_mut_slice":["/// Extracts a mutable slice of the entire vector.\n///\n/// Equivalent to `&mut s[..]`.\n#[inline]\npub fn as_mut_slice(&mut self) -> &mut [A::Item]{\n        self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::as_slice":["/// Extracts a slice containing the entire vector.\n///\n/// Equivalent to `&s[..]`.\n#[inline]\npub fn as_slice(&self) -> &[A::Item]{\n        self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::capacity":["/// The number of items the vector can hold.\n#[inline]\npub fn capacity(&self) -> usize{\n        A::size()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::clear":["/// Remove all elements from the vector.\n#[inline]\npub fn clear(&mut self){\n        self.truncate(0);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::dedup":["/// Removes consecutive duplicate elements.\npub fn dedup(&mut self) where A::Item: PartialEq<A::Item>{\n        self.dedup_by(|a, b| a == b);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::dedup_by":["/// Removes consecutive duplicate elements using the given equality relation.\npub fn dedup_by<F>(&mut self, mut same_bucket: F)\n        where F: FnMut(&mut A::Item, &mut A::Item) -> bool{\n        // See the implementation of Vec::dedup_by in the\n        // standard library for an explanation of this algorithm.\n        let len = self.len();\n        if len <= 1 {\n            return;\n        }\n\n        let ptr = self.as_mut_ptr();\n        let mut w: usize = 1;\n\n        unsafe {\n            for r in 1..len {\n                let p_r = ptr.offset(r as isize);\n                let p_wm1 = ptr.offset((w - 1) as isize);\n                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n                    if r != w {\n                        let p_w = p_wm1.offset(1);\n                        mem::swap(&mut *p_r, &mut *p_w);\n                    }\n                    w += 1;\n                }\n            }\n        }\n\n        self.truncate(w);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::dedup_by_key":["/// Removes consecutive elements that map to the same key.\npub fn dedup_by_key<F, K>(&mut self, mut key: F)\n        where F: FnMut(&mut A::Item) -> K,\n              K: PartialEq<K>{\n        self.dedup_by(|a, b| key(a) == key(b));\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::drain":["/// Empty the vector and return an iterator over its former contents.\npub fn drain(&mut self) -> Drain<A::Item>{\n        unsafe {\n            let slice = slice::from_raw_parts_mut(self.as_mut_ptr(), self.len());\n            self.set_len(0);\n\n            Drain {\n                iter: slice.iter_mut(),\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::extend_from_slice":["/// Copy elements from a slice and append them to the vector.\n///\n/// For slices of `Copy` types, this is more efficient than `extend`.\n#[inline]\npub fn extend_from_slice(&mut self, slice: &[A::Item]){\n        let len = self.len();\n        self.insert_from_slice(len, slice);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::from_buf":["/// Constructs a new `StackVec` on the stack from an `A` without\n/// copying elements.\n///\n/// ```rust\n/// use stackvector::StackVec;\n///\n/// let buf = [1, 2, 3, 4, 5];\n/// let stack_vec: StackVec<_> = StackVec::from_buf(buf);\n///\n/// assert_eq!(&*stack_vec, &[1, 2, 3, 4, 5]);\n/// ```\n#[inline]\npub fn from_buf(buf: A) -> StackVec<A>{\n        StackVec {\n            length: A::size(),\n            data: mem::ManuallyDrop::new(buf),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::from_buf_and_len":["/// Constructs a new `StackVec` on the stack from an `A` without\n/// copying elements. Also sets the length, which must be less or\n/// equal to the size of `buf`.\n///\n/// ```rust\n/// use stackvector::StackVec;\n///\n/// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n/// let stack_vec: StackVec<_> = StackVec::from_buf_and_len(buf, 5);\n///\n/// assert_eq!(&*stack_vec, &[1, 2, 3, 4, 5]);\n/// ```\n#[inline]\npub fn from_buf_and_len(buf: A, len: usize) -> StackVec<A>{\n        assert!(len <= A::size());\n        unsafe { StackVec::from_buf_and_len_unchecked(buf, len) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::from_buf_and_len_unchecked":["/// Constructs a new `StackVec` on the stack from an `A` without\n/// copying elements. Also sets the length. The user is responsible\n/// for ensuring that `len <= A::size()`.\n///\n/// ```rust\n/// use stackvector::StackVec;\n///\n/// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n/// let stack_vec: StackVec<_> = unsafe {\n///     StackVec::from_buf_and_len_unchecked(buf, 5)\n/// };\n///\n/// assert_eq!(&*stack_vec, &[1, 2, 3, 4, 5]);\n/// ```\n#[inline]\npub unsafe fn from_buf_and_len_unchecked(buf: A, len: usize) -> StackVec<A>{\n        StackVec {\n            length: len,\n            data: mem::ManuallyDrop::new(buf),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::from_elem":["/// Creates a `StackVec` with `n` copies of `elem`.\n/// ```\n/// use stackvector::StackVec;\n///\n/// let v = StackVec::<[char; 128]>::from_elem('d', 2);\n/// assert_eq!(v, StackVec::from_buf(['d', 'd']));\n/// ```\npub fn from_elem(elem: A::Item, n: usize) -> Self{\n        assert!(n <= A::size());\n        let mut v = StackVec::<A>::new();\n        unsafe {\n            let ptr = v.as_mut_ptr();\n            let mut local_len = SetLenOnDrop::new(&mut v.length);\n            for i in 0..n as isize {\n                ptr::write(ptr.offset(i), elem.clone());\n                local_len.increment_len(1);\n            }\n        }\n        v\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::from_slice":["/// Copy the elements from a slice into a new `StackVec`.\n///\n/// For slices of `Copy` types, this is more efficient than `StackVec::from(slice)`.\npub fn from_slice(slice: &[A::Item]) -> Self{\n        assert!(slice.len() <= A::size());\n        StackVec {\n            length: slice.len(),\n            data: unsafe {\n                let mut data: A = mem::uninitialized();\n                ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), slice.len());\n                mem::ManuallyDrop::new(data)\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::from_vec":["/// Construct a new `StackVec` from a `Vec<A::Item>`.\n///\n/// Elements will be copied to the inline buffer if vec.len() <= A::size().\n///\n/// ```rust\n/// use stackvector::StackVec;\n///\n/// let vec = vec![1, 2, 3, 4, 5];\n/// let stack_vec: StackVec<[_; 5]> = StackVec::from_vec(vec);\n///\n/// assert_eq!(&*stack_vec, &[1, 2, 3, 4, 5]);\n/// ```\n#[inline]\npub fn from_vec(vec: Vec<A::Item>) -> StackVec<A>{\n        assert!(vec.len() <= A::size());\n        unsafe { Self::from_vec_unchecked(vec) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::from_vec_unchecked":["/// Construct a new `StackVec` from a `Vec<A::Item>` without bounds checking.\npub unsafe fn from_vec_unchecked(mut vec: Vec<A::Item>) -> StackVec<A>{\n        let mut data: A = mem::uninitialized();\n        let len = vec.len();\n        vec.set_len(0);\n        ptr::copy_nonoverlapping(vec.as_ptr(), data.ptr_mut(), len);\n\n        StackVec {\n            length: len,\n            data: mem::ManuallyDrop::new(data),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::insert":["/// Insert an element at position `index`, shifting all elements after it to the right.\n///\n/// Panics if `index` is out of bounds.\npub fn insert(&mut self, index: usize, element: A::Item){\n        assert!(index < self.len() && self.len() < self.capacity());\n        unsafe {\n            let ptr = self.as_mut_ptr().padd(index);\n            ptr::copy(ptr, ptr.offset(1), self.length - index);\n            ptr::write(ptr, element);\n            self.length += 1;\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::insert_from_slice":["/// Copy elements from a slice into the vector at position `index`, shifting any following\n/// elements toward the back.\n///\n/// For slices of `Copy` types, this is more efficient than `insert`.\npub fn insert_from_slice(&mut self, index: usize, slice: &[A::Item]){\n        assert!(index <= self.len() && self.len() + slice.len() <= self.capacity());\n        unsafe {\n            let len = self.len();\n            let slice_ptr = slice.as_ptr();\n            let ptr = self.as_mut_ptr().padd(index);\n            ptr::copy(ptr, ptr.padd(slice.len()), len - index);\n            ptr::copy_nonoverlapping(slice_ptr, ptr, slice.len());\n            self.set_len(len + slice.len());\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::insert_many":["/// Insert multiple elements at position `index`, shifting all following elements toward the\n/// back.\npub fn insert_many<I: iter::IntoIterator<Item=A::Item>>(&mut self, index: usize, iterable: I){\n        let iter = iterable.into_iter();\n        if index == self.len() {\n            return self.extend(iter);\n        }\n\n        let (lower_size_bound, _) = iter.size_hint();\n        assert!(lower_size_bound <= std::isize::MAX as usize);  // Ensure offset is indexable\n        assert!(index + lower_size_bound >= index);             // Protect against overflow\n        assert!(self.len() + lower_size_bound <= self.capacity());\n\n        unsafe {\n            let old_len = self.len();\n            assert!(index <= old_len);\n            let mut ptr = self.as_mut_ptr().padd(index);\n\n            // Move the trailing elements.\n            ptr::copy(ptr, ptr.padd(lower_size_bound), old_len - index);\n\n            // In case the iterator panics, don't double-drop the items we just copied above.\n            self.set_len(index);\n\n            let mut num_added = 0;\n            for element in iter {\n                let mut cur = ptr.padd(num_added);\n                if num_added >= lower_size_bound {\n                    // Iterator provided more elements than the hint.  Move trailing items again.\n                    assert!(self.len() + 1 <= self.capacity());\n                    ptr = self.as_mut_ptr().padd(index);\n                    cur = ptr.padd(num_added);\n                    ptr::copy(cur, cur.padd(1), old_len - index);\n                }\n                ptr::write(cur, element);\n                num_added += 1;\n            }\n            if num_added < lower_size_bound {\n                // Iterator provided fewer elements than the hint\n                ptr::copy(ptr.padd(lower_size_bound), ptr.padd(num_added), old_len - index);\n            }\n\n            self.set_len(old_len + num_added);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::into_inner":["/// Convert the StackVec into an `A`.\npub fn into_inner(self) -> Result<A, Self>{\n        if self.len() != A::size() {\n            Err(self)\n        } else {\n            unsafe {\n                let data = ptr::read(&self.data);\n                mem::forget(self);\n                Ok(mem::ManuallyDrop::into_inner(data))\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::into_vec":["/// Convert a StackVec to a Vec.\npub fn into_vec(self) -> Vec<A::Item>{\n        self.into_iter().collect()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::is_empty":["/// If the vector is empty.\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::len":["/// The number of elements stored in the vector.\n#[inline]\npub fn len(&self) -> usize{\n        self.length\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::new":["/// Construct an empty vector\n#[inline]\npub fn new() -> StackVec<A>{\n        unsafe {\n            StackVec {\n                length: 0,\n                data: mem::uninitialized(),\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::pop":["/// Remove an item from the end of the vector and return it, or None if empty.\n#[inline]\npub fn pop(&mut self) -> Option<A::Item>{\n        unsafe {\n            if self.len() == 0 {\n                None\n            } else {\n                self.length -=1;\n                Some(ptr::read(self.as_mut_ptr().padd(self.length)))\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::push":["/// Append an item to the vector.\n#[inline]\npub fn push(&mut self, value: A::Item){\n        assert!(self.len() < self.capacity());\n        unsafe {\n            ptr::write(self.as_mut_ptr().padd(self.length), value);\n            self.length += 1;\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::remove":["/// Remove and return the element at position `index`, shifting all elements after it to the\n/// left.\n///\n/// Panics if `index` is out of bounds.\npub fn remove(&mut self, index: usize) -> A::Item{\n        assert!(index < self.len());\n        unsafe {\n            self.length -= 1;\n            let ptr = self.as_mut_ptr().padd(index);\n            let item = ptr::read(ptr);\n            ptr::copy(ptr.offset(1), ptr, self.length - index);\n            item\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::resize":["/// Resizes the vector so that its length is equal to `len`.\n///\n/// If `len` is less than the current length, the vector simply truncated.\n///\n/// If `len` is greater than the current length, `value` is appended to the\n/// vector until its length equals `len`.\npub fn resize(&mut self, len: usize, value: A::Item){\n        assert!(len <= self.capacity());\n        let old_len = self.len();\n        if len > old_len {\n            self.extend(iter::repeat(value).take(len - old_len));\n        } else {\n            self.truncate(len);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::retain":["/// Retains only the elements specified by the predicate.\n///\n/// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n/// This method operates in place and preserves the order of the retained\n/// elements.\npub fn retain<F: FnMut(&mut A::Item) -> bool>(&mut self, mut f: F){\n        let mut del = 0;\n        let len = self.len();\n        for i in 0..len {\n            if !f(&mut self[i]) {\n                del += 1;\n            } else if del > 0 {\n                self.swap(i - del, i);\n            }\n        }\n        self.truncate(len - del);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::set_len":["/// Sets the length of a vector.\n///\n/// This will explicitly set the size of the vector, without actually\n/// modifying its buffers, so it is up to the caller to ensure that the\n/// vector is actually the specified size.\n#[inline]\npub unsafe fn set_len(&mut self, new_len: usize){\n        self.length = new_len;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::swap_remove":["/// Remove the element at position `index`, replacing it with the last element.\n///\n/// This does not preserve ordering, but is O(1).\n///\n/// Panics if `index` is out of bounds.\n#[inline]\npub fn swap_remove(&mut self, index: usize) -> A::Item{\n        let len = self.len();\n        self.swap(len - 1, index);\n        unsafe { self.pop().unchecked_unwrap() }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"StackVec::<A>::truncate":["/// Shorten the vector, keeping the first `len` elements and dropping the rest.\n///\n/// If `len` is greater than or equal to the vector's current length, this has no\n/// effect.\n/// `shrink_to_fit` after truncating.\npub fn truncate(&mut self, len: usize){\n        unsafe {\n            while len < self.length {\n                self.length -= 1;\n                ptr::drop_in_place(self.as_mut_ptr().padd(self.length));\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"VecLike":["/// Common operations implemented by both `Vec` and `StackVec`.\n///\n/// This can be used to write generic code that works with both `Vec` and `StackVec`.\n///\n/// ## Example\n///\n/// ```rust\n/// use stackvector::{VecLike, StackVec};\n///\n/// fn initialize<V: VecLike<u8>>(v: &mut V) {\n///     for i in 0..5 {\n///         v.push(i);\n///     }\n/// }\n///\n/// let mut vec = Vec::new();\n/// initialize(&mut vec);\n///\n/// let mut stack_vec = StackVec::<[u8; 8]>::new();\n/// initialize(&mut stack_vec);\n/// ```\n#[deprecated(note = \"Use `Extend` and `Deref<[T]>` instead\")]\npub trait VecLike<T>:\n        ops::Index<usize, Output=T> +\n        ops::IndexMut<usize> +\n        ops::Index<ops::Range<usize>, Output=[T]> +\n        ops::IndexMut<ops::Range<usize>> +\n        ops::Index<ops::RangeFrom<usize>, Output=[T]> +\n        ops::IndexMut<ops::RangeFrom<usize>> +\n        ops::Index<ops::RangeTo<usize>, Output=[T]> +\n        ops::IndexMut<ops::RangeTo<usize>> +\n        ops::Index<ops::RangeFull, Output=[T]> +\n        ops::IndexMut<ops::RangeFull> +\n        ops::DerefMut<Target = [T]> +\n        Extend<T> {\n\n    /// Append an element to the vector.\n    fn push(&mut self, value: T);\n\n    /// Pop an element from the end of the vector.\n    fn pop(&mut self) -> Option<T>;\n}","Real(LocalPath(\"src/lib.rs\"))"]},"struct_constructor":{"&<A as Array>::Item":["index"],"&[<A as Array>::Item]":["as_ref","as_slice","borrow","deref","index"],"&mut <A as Array>::Item":["index_mut"],"&mut [<A as Array>::Item]":["as_mut","as_mut_slice","borrow_mut","deref_mut","index_mut"],"(usize, std::option::Option<usize>)":["size_hint"],"*const <Self as Array>::Item":["ptr"],"*mut <Self as Array>::Item":["ptr_mut"],"<&'a StackVec<A> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a mut StackVec<A> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<A as Array>::Item":["next","next_back","pop","remove","swap_remove"],"<StackVec<A> as std::iter::IntoIterator>::IntoIter":["into_iter"],"Drain":["drain"],"SetLenOnDrop":["new"],"StackVec":["clone","default","from","from_buf","from_buf_and_len","from_buf_and_len_unchecked","from_elem","from_iter","from_slice","from_vec","from_vec_unchecked","new"],"bool":["eq","is_empty","ne"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::vec::Vec":["into_vec"],"usize":["capacity","len","size","write"]},"struct_to_trait":{"Drain":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::ops::Drop"],"IntoIter":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::ops::Drop"],"SetLenOnDrop":["std::ops::Drop"],"StackVec":["ExtendFromSlice","VecLike","std::borrow::Borrow","std::borrow::BorrowMut","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsMut","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::hash::Hash","std::io::Write","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::marker::Send","std::ops::Deref","std::ops::DerefMut","std::ops::Drop","std::ops::Index","std::ops::IndexMut"],"std::vec::Vec":["ExtendFromSlice","VecLike"]},"targets":{"<&'a StackVec<A> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<&'a mut StackVec<A> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<*const T as PointerMethods>::padd":["padd","Real(LocalPath(\"src/lib.rs\"))","PointerMethods"],"<*mut T as PointerMethods>::padd":["padd","Real(LocalPath(\"src/lib.rs\"))","PointerMethods"],"<Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/lib.rs\"))","std::iter::DoubleEndedIterator"],"<Drain<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<Drain<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<Drain<'a, T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","std::ops::Drop"],"<IntoIter<A> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/lib.rs\"))","std::iter::DoubleEndedIterator"],"<IntoIter<A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<IntoIter<A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<IntoIter<A> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","std::ops::Drop"],"<SetLenOnDrop<'a> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","std::ops::Drop"],"<StackVec<A> as ExtendFromSlice<<A as Array>::Item>>::extend_from_slice":["extend_from_slice","Real(LocalPath(\"src/lib.rs\"))","ExtendFromSlice"],"<StackVec<A> as VecLike<<A as Array>::Item>>::pop":["pop","Real(LocalPath(\"src/lib.rs\"))","VecLike"],"<StackVec<A> as VecLike<<A as Array>::Item>>::push":["push","Real(LocalPath(\"src/lib.rs\"))","VecLike"],"<StackVec<A> as std::borrow::Borrow<[<A as Array>::Item]>>::borrow":["borrow","Real(LocalPath(\"src/lib.rs\"))","std::borrow::Borrow"],"<StackVec<A> as std::borrow::BorrowMut<[<A as Array>::Item]>>::borrow_mut":["borrow_mut","Real(LocalPath(\"src/lib.rs\"))","std::borrow::BorrowMut"],"<StackVec<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","std::clone::Clone"],"<StackVec<A> as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/lib.rs\"))","std::cmp::Ord"],"<StackVec<A> as std::cmp::PartialEq<StackVec<B>>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<StackVec<A> as std::cmp::PartialEq<StackVec<B>>>::ne":["ne","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<StackVec<A> as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialOrd"],"<StackVec<A> as std::convert::AsMut<[<A as Array>::Item]>>::as_mut":["as_mut","Real(LocalPath(\"src/lib.rs\"))","std::convert::AsMut"],"<StackVec<A> as std::convert::AsRef<[<A as Array>::Item]>>::as_ref":["as_ref","Real(LocalPath(\"src/lib.rs\"))","std::convert::AsRef"],"<StackVec<A> as std::convert::From<&'a [<A as Array>::Item]>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<StackVec<A> as std::convert::From<A>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<StackVec<A> as std::convert::From<std::vec::Vec<<A as Array>::Item>>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<StackVec<A> as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<StackVec<A> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<StackVec<A> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/lib.rs\"))","std::hash::Hash"],"<StackVec<A> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/lib.rs\"))","std::io::Write"],"<StackVec<A> as std::io::Write>::write":["write","Real(LocalPath(\"src/lib.rs\"))","std::io::Write"],"<StackVec<A> as std::io::Write>::write_all":["write_all","Real(LocalPath(\"src/lib.rs\"))","std::io::Write"],"<StackVec<A> as std::iter::Extend<<A as Array>::Item>>::extend":["extend","Real(LocalPath(\"src/lib.rs\"))","std::iter::Extend"],"<StackVec<A> as std::iter::FromIterator<<A as Array>::Item>>::from_iter":["from_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::FromIterator"],"<StackVec<A> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<StackVec<A> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/lib.rs\"))","std::ops::Deref"],"<StackVec<A> as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/lib.rs\"))","std::ops::DerefMut"],"<StackVec<A> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","std::ops::Drop"],"<StackVec<A> as std::ops::Index<std::ops::Range<usize>>>::index":["index","Real(LocalPath(\"src/lib.rs\"))","std::ops::Index"],"<StackVec<A> as std::ops::Index<std::ops::RangeFrom<usize>>>::index":["index","Real(LocalPath(\"src/lib.rs\"))","std::ops::Index"],"<StackVec<A> as std::ops::Index<std::ops::RangeFull>>::index":["index","Real(LocalPath(\"src/lib.rs\"))","std::ops::Index"],"<StackVec<A> as std::ops::Index<std::ops::RangeInclusive<usize>>>::index":["index","Real(LocalPath(\"src/lib.rs\"))","std::ops::Index"],"<StackVec<A> as std::ops::Index<std::ops::RangeTo<usize>>>::index":["index","Real(LocalPath(\"src/lib.rs\"))","std::ops::Index"],"<StackVec<A> as std::ops::Index<std::ops::RangeToInclusive<usize>>>::index":["index","Real(LocalPath(\"src/lib.rs\"))","std::ops::Index"],"<StackVec<A> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/lib.rs\"))","std::ops::Index"],"<StackVec<A> as std::ops::IndexMut<std::ops::Range<usize>>>::index_mut":["index_mut","Real(LocalPath(\"src/lib.rs\"))","std::ops::IndexMut"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeFrom<usize>>>::index_mut":["index_mut","Real(LocalPath(\"src/lib.rs\"))","std::ops::IndexMut"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeFull>>::index_mut":["index_mut","Real(LocalPath(\"src/lib.rs\"))","std::ops::IndexMut"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeInclusive<usize>>>::index_mut":["index_mut","Real(LocalPath(\"src/lib.rs\"))","std::ops::IndexMut"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeTo<usize>>>::index_mut":["index_mut","Real(LocalPath(\"src/lib.rs\"))","std::ops::IndexMut"],"<StackVec<A> as std::ops::IndexMut<std::ops::RangeToInclusive<usize>>>::index_mut":["index_mut","Real(LocalPath(\"src/lib.rs\"))","std::ops::IndexMut"],"<StackVec<A> as std::ops::IndexMut<usize>>::index_mut":["index_mut","Real(LocalPath(\"src/lib.rs\"))","std::ops::IndexMut"],"<[T; 0] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 0] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 0] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 1024] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 1024] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 1024] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 1048576] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 1048576] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 1048576] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 10] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 10] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 10] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 11] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 11] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 11] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 128] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 128] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 128] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 12] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 12] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 12] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 131072] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 131072] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 131072] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 13] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 13] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 13] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 14] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 14] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 14] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 15] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 15] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 15] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 16384] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 16384] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 16384] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 16] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 16] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 16] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 1] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 1] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 1] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 2048] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 2048] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 2048] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 20] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 20] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 20] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 24] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 24] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 24] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 256] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 256] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 256] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 262144] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 262144] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 262144] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 2] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 2] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 2] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 32768] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 32768] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 32768] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 32] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 32] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 32] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 36] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 36] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 36] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 3] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 3] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 3] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 4096] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 4096] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 4096] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 4] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 4] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 4] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 512] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 512] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 512] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 524288] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 524288] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 524288] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 5] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 5] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 5] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 64] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 64] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 64] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 65536] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 65536] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 65536] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 6] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 6] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 6] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 7] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 7] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 7] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 8192] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 8192] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 8192] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 8] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 8] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 8] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 9] as Array>::ptr":["ptr","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 9] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 9] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<std::vec::Vec<T> as ExtendFromSlice<T>>::extend_from_slice":["extend_from_slice","Real(LocalPath(\"src/lib.rs\"))","ExtendFromSlice"],"<std::vec::Vec<T> as VecLike<T>>::pop":["pop","Real(LocalPath(\"src/lib.rs\"))","VecLike"],"<std::vec::Vec<T> as VecLike<T>>::push":["push","Real(LocalPath(\"src/lib.rs\"))","VecLike"],"SetLenOnDrop::<'a>::increment_len":["increment_len","Real(LocalPath(\"src/lib.rs\"))",""],"SetLenOnDrop::<'a>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::as_mut_slice":["as_mut_slice","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::as_slice":["as_slice","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::capacity":["capacity","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::clear":["clear","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::dedup":["dedup","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::dedup_by":["dedup_by","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::dedup_by_key":["dedup_by_key","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::drain":["drain","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::extend_from_slice":["extend_from_slice","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::from_buf":["from_buf","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::from_buf_and_len":["from_buf_and_len","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::from_buf_and_len_unchecked":["from_buf_and_len_unchecked","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::from_elem":["from_elem","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::from_slice":["from_slice","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::from_vec":["from_vec","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::from_vec_unchecked":["from_vec_unchecked","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::insert":["insert","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::insert_from_slice":["insert_from_slice","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::insert_many":["insert_many","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::into_inner":["into_inner","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::into_vec":["into_vec","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::is_empty":["is_empty","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::len":["len","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::pop":["pop","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::push":["push","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::remove":["remove","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::resize":["resize","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::retain":["retain","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::set_len":["set_len","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::swap_remove":["swap_remove","Real(LocalPath(\"src/lib.rs\"))",""],"StackVec::<A>::truncate":["truncate","Real(LocalPath(\"src/lib.rs\"))",""]},"trait_to_struct":{"ExtendFromSlice":["StackVec","std::vec::Vec"],"VecLike":["StackVec","std::vec::Vec"],"std::borrow::Borrow":["StackVec"],"std::borrow::BorrowMut":["StackVec"],"std::clone::Clone":["StackVec"],"std::cmp::Eq":["StackVec"],"std::cmp::Ord":["StackVec"],"std::cmp::PartialEq":["StackVec"],"std::cmp::PartialOrd":["StackVec"],"std::convert::AsMut":["StackVec"],"std::convert::AsRef":["StackVec"],"std::convert::From":["StackVec"],"std::default::Default":["StackVec"],"std::fmt::Debug":["StackVec"],"std::hash::Hash":["StackVec"],"std::io::Write":["StackVec"],"std::iter::DoubleEndedIterator":["Drain","IntoIter"],"std::iter::ExactSizeIterator":["Drain","IntoIter"],"std::iter::Extend":["StackVec"],"std::iter::FromIterator":["StackVec"],"std::iter::IntoIterator":["StackVec"],"std::iter::Iterator":["Drain","IntoIter"],"std::marker::Send":["StackVec"],"std::ops::Deref":["StackVec"],"std::ops::DerefMut":["StackVec"],"std::ops::Drop":["Drain","IntoIter","SetLenOnDrop","StackVec"],"std::ops::Index":["StackVec"],"std::ops::IndexMut":["StackVec"]},"type_to_def_path":{"Drain<'a, T>":"Drain","IntoIter<A>":"IntoIter","SetLenOnDrop<'a>":"SetLenOnDrop","StackVec<A>":"StackVec"}}