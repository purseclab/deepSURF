{"dependencies":{"<&'a SmallVec<A> as std::iter::IntoIterator>::into_iter":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<&'a mut SmallVec<A> as std::iter::IntoIterator>::into_iter":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back":["Drain","std::marker::Sized","std::option::Option","std::slice::IterMut"],"<Drain<'a, T> as std::iter::Iterator>::next":["Drain","std::marker::Sized","std::option::Option","std::slice::IterMut"],"<Drain<'a, T> as std::iter::Iterator>::size_hint":["Drain","std::marker::Sized","std::option::Option","std::slice::IterMut"],"<Drain<'a, T> as std::ops::Drop>::drop":["Drain","std::marker::Sized","std::slice::IterMut"],"<IntoIter<A> as std::iter::DoubleEndedIterator>::next_back":["Array","IntoIter","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"<IntoIter<A> as std::iter::Iterator>::next":["Array","IntoIter","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"<IntoIter<A> as std::iter::Iterator>::size_hint":["Array","IntoIter","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"<IntoIter<A> as std::ops::Drop>::drop":["Array","IntoIter","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SetLenOnDrop<'a> as std::ops::Drop>::drop":["SetLenOnDrop"],"<SmallVec<A> as ExtendFromSlice<<A as Array>::Item>>::extend_from_slice":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as VecLike<<A as Array>::Item>>::push":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::borrow::Borrow<[<A as Array>::Item]>>::borrow":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::borrow::BorrowMut<[<A as Array>::Item]>>::borrow_mut":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::clone::Clone>::clone":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::cmp::Ord>::cmp":["Array","SmallVec","SmallVecData","std::cmp::Ordering","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::cmp::PartialEq<SmallVec<B>>>::eq":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::cmp::PartialEq<SmallVec<B>>>::ne":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::cmp::PartialOrd>::partial_cmp":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"<SmallVec<A> as std::convert::AsMut<[<A as Array>::Item]>>::as_mut":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::convert::AsRef<[<A as Array>::Item]>>::as_ref":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::convert::From<&'a [<A as Array>::Item]>>::from":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::convert::From<A>>::from":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::convert::From<std::vec::Vec<<A as Array>::Item>>>::from":["Array","SmallVec","SmallVecData","std::alloc::Allocator","std::marker::Sized","std::mem::ManuallyDrop","std::vec::Vec"],"<SmallVec<A> as std::default::Default>::default":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::fmt::Debug>::fmt":["Array","SmallVec","SmallVecData","std::fmt::Formatter","std::marker::Sized","std::mem::ManuallyDrop","std::result::Result"],"<SmallVec<A> as std::hash::Hash>::hash":["Array","SmallVec","SmallVecData","std::hash::Hasher","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::io::Write>::flush":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::result::Result"],"<SmallVec<A> as std::io::Write>::write":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::result::Result"],"<SmallVec<A> as std::io::Write>::write_all":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::result::Result"],"<SmallVec<A> as std::iter::Extend<<A as Array>::Item>>::extend":["Array","SmallVec","SmallVecData","std::iter::IntoIterator","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::iter::FromIterator<<A as Array>::Item>>::from_iter":["Array","SmallVec","SmallVecData","std::iter::IntoIterator","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::iter::IntoIterator>::into_iter":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::ops::Deref>::deref":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::ops::DerefMut>::deref_mut":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::ops::Drop>::drop":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::ops::Index<std::ops::Range<usize>>>::index":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range"],"<SmallVec<A> as std::ops::Index<std::ops::RangeFrom<usize>>>::index":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeFrom"],"<SmallVec<A> as std::ops::Index<std::ops::RangeFull>>::index":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeFull"],"<SmallVec<A> as std::ops::Index<std::ops::RangeTo<usize>>>::index":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeTo"],"<SmallVec<A> as std::ops::Index<usize>>::index":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<SmallVec<A> as std::ops::IndexMut<std::ops::Range<usize>>>::index_mut":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::Range"],"<SmallVec<A> as std::ops::IndexMut<std::ops::RangeFrom<usize>>>::index_mut":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeFrom"],"<SmallVec<A> as std::ops::IndexMut<std::ops::RangeFull>>::index_mut":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeFull"],"<SmallVec<A> as std::ops::IndexMut<std::ops::RangeTo<usize>>>::index_mut":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::RangeTo"],"<SmallVec<A> as std::ops::IndexMut<usize>>::index_mut":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"<[T; 0] as Array>::ptr":[],"<[T; 0] as Array>::ptr_mut":[],"<[T; 0] as Array>::size":[],"<[T; 1024] as Array>::ptr":[],"<[T; 1024] as Array>::ptr_mut":[],"<[T; 1024] as Array>::size":[],"<[T; 1048576] as Array>::ptr":[],"<[T; 1048576] as Array>::ptr_mut":[],"<[T; 1048576] as Array>::size":[],"<[T; 10] as Array>::ptr":[],"<[T; 10] as Array>::ptr_mut":[],"<[T; 10] as Array>::size":[],"<[T; 11] as Array>::ptr":[],"<[T; 11] as Array>::ptr_mut":[],"<[T; 11] as Array>::size":[],"<[T; 128] as Array>::ptr":[],"<[T; 128] as Array>::ptr_mut":[],"<[T; 128] as Array>::size":[],"<[T; 12] as Array>::ptr":[],"<[T; 12] as Array>::ptr_mut":[],"<[T; 12] as Array>::size":[],"<[T; 131072] as Array>::ptr":[],"<[T; 131072] as Array>::ptr_mut":[],"<[T; 131072] as Array>::size":[],"<[T; 13] as Array>::ptr":[],"<[T; 13] as Array>::ptr_mut":[],"<[T; 13] as Array>::size":[],"<[T; 14] as Array>::ptr":[],"<[T; 14] as Array>::ptr_mut":[],"<[T; 14] as Array>::size":[],"<[T; 15] as Array>::ptr":[],"<[T; 15] as Array>::ptr_mut":[],"<[T; 15] as Array>::size":[],"<[T; 16384] as Array>::ptr":[],"<[T; 16384] as Array>::ptr_mut":[],"<[T; 16384] as Array>::size":[],"<[T; 16] as Array>::ptr":[],"<[T; 16] as Array>::ptr_mut":[],"<[T; 16] as Array>::size":[],"<[T; 1] as Array>::ptr":[],"<[T; 1] as Array>::ptr_mut":[],"<[T; 1] as Array>::size":[],"<[T; 2048] as Array>::ptr":[],"<[T; 2048] as Array>::ptr_mut":[],"<[T; 2048] as Array>::size":[],"<[T; 20] as Array>::ptr":[],"<[T; 20] as Array>::ptr_mut":[],"<[T; 20] as Array>::size":[],"<[T; 24] as Array>::ptr":[],"<[T; 24] as Array>::ptr_mut":[],"<[T; 24] as Array>::size":[],"<[T; 256] as Array>::ptr":[],"<[T; 256] as Array>::ptr_mut":[],"<[T; 256] as Array>::size":[],"<[T; 262144] as Array>::ptr":[],"<[T; 262144] as Array>::ptr_mut":[],"<[T; 262144] as Array>::size":[],"<[T; 2] as Array>::ptr":[],"<[T; 2] as Array>::ptr_mut":[],"<[T; 2] as Array>::size":[],"<[T; 32768] as Array>::ptr":[],"<[T; 32768] as Array>::ptr_mut":[],"<[T; 32768] as Array>::size":[],"<[T; 32] as Array>::ptr":[],"<[T; 32] as Array>::ptr_mut":[],"<[T; 32] as Array>::size":[],"<[T; 36] as Array>::ptr":[],"<[T; 36] as Array>::ptr_mut":[],"<[T; 36] as Array>::size":[],"<[T; 3] as Array>::ptr":[],"<[T; 3] as Array>::ptr_mut":[],"<[T; 3] as Array>::size":[],"<[T; 4096] as Array>::ptr":[],"<[T; 4096] as Array>::ptr_mut":[],"<[T; 4096] as Array>::size":[],"<[T; 4] as Array>::ptr":[],"<[T; 4] as Array>::ptr_mut":[],"<[T; 4] as Array>::size":[],"<[T; 512] as Array>::ptr":[],"<[T; 512] as Array>::ptr_mut":[],"<[T; 512] as Array>::size":[],"<[T; 524288] as Array>::ptr":[],"<[T; 524288] as Array>::ptr_mut":[],"<[T; 524288] as Array>::size":[],"<[T; 5] as Array>::ptr":[],"<[T; 5] as Array>::ptr_mut":[],"<[T; 5] as Array>::size":[],"<[T; 64] as Array>::ptr":[],"<[T; 64] as Array>::ptr_mut":[],"<[T; 64] as Array>::size":[],"<[T; 65536] as Array>::ptr":[],"<[T; 65536] as Array>::ptr_mut":[],"<[T; 65536] as Array>::size":[],"<[T; 6] as Array>::ptr":[],"<[T; 6] as Array>::ptr_mut":[],"<[T; 6] as Array>::size":[],"<[T; 7] as Array>::ptr":[],"<[T; 7] as Array>::ptr_mut":[],"<[T; 7] as Array>::size":[],"<[T; 8192] as Array>::ptr":[],"<[T; 8192] as Array>::ptr_mut":[],"<[T; 8192] as Array>::size":[],"<[T; 8] as Array>::ptr":[],"<[T; 8] as Array>::ptr_mut":[],"<[T; 8] as Array>::size":[],"<[T; 9] as Array>::ptr":[],"<[T; 9] as Array>::ptr_mut":[],"<[T; 9] as Array>::size":[],"<std::vec::Vec<T> as ExtendFromSlice<T>>::extend_from_slice":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<std::vec::Vec<T> as VecLike<T>>::push":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Array::ptr":[],"Array::ptr_mut":[],"Array::size":[],"Drain":["Drain","std::marker::Sized","std::slice::IterMut"],"ExtendFromSlice::extend_from_slice":[],"IntoIter":["Array","IntoIter","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SetLenOnDrop":["SetLenOnDrop"],"SetLenOnDrop::<'a>::increment_len":["SetLenOnDrop"],"SetLenOnDrop::<'a>::new":["SetLenOnDrop"],"SmallVec":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::as_mut_slice":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::as_slice":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::capacity":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::clear":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::dedup":["Array","SmallVec","SmallVecData","std::cmp::PartialEq","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::dedup_by":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::FnMut"],"SmallVec::<A>::dedup_by_key":["Array","SmallVec","SmallVecData","std::cmp::PartialEq","std::marker::Sized","std::mem::ManuallyDrop","std::ops::FnMut"],"SmallVec::<A>::drain":["Array","Drain","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::slice::IterMut"],"SmallVec::<A>::extend_from_slice":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::from_buf":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::from_buf_and_len":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::from_buf_and_len_unchecked":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::from_elem":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::from_raw_parts":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::from_slice":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::from_vec":["Array","SmallVec","SmallVecData","std::alloc::Allocator","std::marker::Sized","std::mem::ManuallyDrop","std::vec::Vec"],"SmallVec::<A>::grow":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::inline_size":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::insert":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::insert_from_slice":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::insert_many":["Array","SmallVec","SmallVecData","std::iter::IntoIterator","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::into_inner":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::result::Result"],"SmallVec::<A>::into_vec":["Array","SmallVec","SmallVecData","std::alloc::Allocator","std::marker::Sized","std::mem::ManuallyDrop","std::vec::Vec"],"SmallVec::<A>::is_empty":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::len":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::new":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::pop":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"SmallVec::<A>::push":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::remove":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::reserve":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::reserve_exact":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::resize":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::retain":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop","std::ops::FnMut"],"SmallVec::<A>::set_len":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::shrink_to_fit":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::spilled":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::swap_remove":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::triple":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::triple_mut":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::truncate":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVec::<A>::with_capacity":["Array","SmallVec","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVecData":["Array","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVecData::<A>::from_heap":["Array","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVecData::<A>::from_inline":["Array","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVecData::<A>::heap":["Array","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVecData::<A>::heap_mut":["Array","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVecData::<A>::inline":["Array","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVecData::<A>::inline_mut":["Array","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"SmallVecData::<A>::into_inline":["Array","SmallVecData","std::marker::Sized","std::mem::ManuallyDrop"],"VecLike::push":[],"deallocate":["std::marker::Sized"]},"glob_path_import":{},"self_to_fn":{"Drain":["impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back().map(|reference| unsafe { ptr::read(reference) })\n    }\n}","impl<'a, T: 'a> Drop for Drain<'a,T> {\n    fn drop(&mut self) {\n        // Destroy the remaining elements.\n        for _ in self.by_ref() {}\n    }\n}","impl<'a, T: 'a> Iterator for Drain<'a,T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        self.iter.next().map(|reference| unsafe { ptr::read(reference) })\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}","impl<'a, T> ExactSizeIterator for Drain<'a, T> { }"],"IntoIter":["impl<A: Array> DoubleEndedIterator for IntoIter<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A::Item> {\n        if self.current == self.end {\n            None\n        }\n        else {\n            unsafe {\n                self.end -= 1;\n                Some(ptr::read(self.data.as_ptr().offset(self.end as isize)))\n            }\n        }\n    }\n}","impl<A: Array> Drop for IntoIter<A> {\n    fn drop(&mut self) {\n        for _ in self { }\n    }\n}","impl<A: Array> ExactSizeIterator for IntoIter<A> { }","impl<A: Array> Iterator for IntoIter<A> {\n    type Item = A::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<A::Item> {\n        if self.current == self.end {\n            None\n        }\n        else {\n            unsafe {\n                let current = self.current as isize;\n                self.current += 1;\n                Some(ptr::read(self.data.as_ptr().offset(current)))\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let size = self.end - self.current;\n        (size, Some(size))\n    }\n}"],"SetLenOnDrop":["impl<'a> Drop for SetLenOnDrop<'a> {\n    #[inline]\n    fn drop(&mut self) {\n        *self.len = self.local_len;\n    }\n}","impl<'a> SetLenOnDrop<'a> {\n    #[inline]\n    fn new(len: &'a mut usize) -> Self {\n        SetLenOnDrop { local_len: *len, len: len }\n    }\n\n    #[inline]\n    fn increment_len(&mut self, increment: usize) {\n        self.local_len += increment;\n    }\n}"],"SmallVec":["impl<'a, A: Array> From<&'a [A::Item]> for SmallVec<A> where A::Item: Clone {\n    #[cfg(not(feature = \"specialization\"))]\n    #[inline]\n    fn from(slice: &'a [A::Item]) -> SmallVec<A> {\n        slice.into_iter().cloned().collect()\n    }\n\n    #[cfg(feature = \"specialization\")]\n    #[inline]\n    fn from(slice: &'a [A::Item]) -> SmallVec<A> {\n        SmallVec::spec_from(slice)\n    }\n}","impl<A: Array, B: Array> PartialEq<SmallVec<B>> for SmallVec<A>\n    where A::Item: PartialEq<B::Item> {\n    #[inline]\n    fn eq(&self, other: &SmallVec<B>) -> bool { self[..] == other[..] }\n    #[inline]\n    fn ne(&self, other: &SmallVec<B>) -> bool { self[..] != other[..] }\n}","impl<A: Array<Item = u8>> io::Write for SmallVec<A> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.extend_from_slice(buf);\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.extend_from_slice(buf);\n        Ok(())\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}","impl<A: Array> AsMut<[A::Item]> for SmallVec<A> {\n    #[inline]\n    fn as_mut(&mut self) -> &mut [A::Item] {\n        self\n    }\n}","impl<A: Array> AsRef<[A::Item]> for SmallVec<A> {\n    #[inline]\n    fn as_ref(&self) -> &[A::Item] {\n        self\n    }\n}","impl<A: Array> Borrow<[A::Item]> for SmallVec<A> {\n    #[inline]\n    fn borrow(&self) -> &[A::Item] {\n        self\n    }\n}","impl<A: Array> BorrowMut<[A::Item]> for SmallVec<A> {\n    #[inline]\n    fn borrow_mut(&mut self) -> &mut [A::Item] {\n        self\n    }\n}","impl<A: Array> Clone for SmallVec<A> where A::Item: Clone {\n    fn clone(&self) -> SmallVec<A> {\n        let mut new_vector = SmallVec::with_capacity(self.len());\n        for element in self.iter() {\n            new_vector.push((*element).clone())\n        }\n        new_vector\n    }\n}","impl<A: Array> Default for SmallVec<A> {\n    #[inline]\n    fn default() -> SmallVec<A> {\n        SmallVec::new()\n    }\n}","impl<A: Array> Drop for SmallVec<A> {\n    fn drop(&mut self) {\n        unsafe {\n            if self.spilled() {\n                let (ptr, len) = self.data.heap();\n                Vec::from_raw_parts(ptr, len, self.capacity);\n            } else {\n                ptr::drop_in_place(&mut self[..]);\n            }\n        }\n    }\n}","impl<A: Array> Eq for SmallVec<A> where A::Item: Eq {}","impl<A: Array> Extend<A::Item> for SmallVec<A> {\n    fn extend<I: IntoIterator<Item=A::Item>>(&mut self, iterable: I) {\n        let mut iter = iterable.into_iter();\n        let (lower_size_bound, _) = iter.size_hint();\n        self.reserve(lower_size_bound);\n\n        unsafe {\n            let len = self.len();\n            let ptr = self.as_mut_ptr().offset(len as isize);\n            let mut count = 0;\n            while count < lower_size_bound {\n                if let Some(out) = iter.next() {\n                    ptr::write(ptr.offset(count as isize), out);\n                    count += 1;\n                } else {\n                    break;\n                }\n            }\n            self.set_len(len + count);\n        }\n\n        for elem in iter {\n            self.push(elem);\n        }\n    }\n}","impl<A: Array> ExtendFromSlice<A::Item> for SmallVec<A> where A::Item: Copy {\n    fn extend_from_slice(&mut self, other: &[A::Item]) {\n        SmallVec::extend_from_slice(self, other)\n    }\n}","impl<A: Array> From<A> for SmallVec<A> {\n    #[inline]\n    fn from(array: A) -> SmallVec<A> {\n        SmallVec::from_buf(array)\n    }\n}","impl<A: Array> From<Vec<A::Item>> for SmallVec<A> {\n    #[inline]\n    fn from(vec: Vec<A::Item>) -> SmallVec<A> {\n        SmallVec::from_vec(vec)\n    }\n}","impl<A: Array> FromIterator<A::Item> for SmallVec<A> {\n    fn from_iter<I: IntoIterator<Item=A::Item>>(iterable: I) -> SmallVec<A> {\n        let mut v = SmallVec::new();\n        v.extend(iterable);\n        v\n    }\n}","impl<A: Array> Hash for SmallVec<A> where A::Item: Hash {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        (**self).hash(state)\n    }\n}","impl<A: Array> IntoIterator for SmallVec<A> {\n    type IntoIter = IntoIter<A>;\n    type Item = A::Item;\n    fn into_iter(mut self) -> Self::IntoIter {\n        unsafe {\n            // Set SmallVec len to zero as `IntoIter` drop handles dropping of the elements\n            let len = self.len();\n            self.set_len(0);\n            IntoIter {\n                data: self,\n                current: 0,\n                end: len,\n            }\n        }\n    }\n}","impl<A: Array> Ord for SmallVec<A> where A::Item: Ord {\n    #[inline]\n    fn cmp(&self, other: &SmallVec<A>) -> cmp::Ordering {\n        Ord::cmp(&**self, &**other)\n    }\n}","impl<A: Array> PartialOrd for SmallVec<A> where A::Item: PartialOrd {\n    #[inline]\n    fn partial_cmp(&self, other: &SmallVec<A>) -> Option<cmp::Ordering> {\n        PartialOrd::partial_cmp(&**self, &**other)\n    }\n}","impl<A: Array> SmallVec<A> where A::Item: Clone {\n    /// Resizes the vector so that its length is equal to `len`.\n    ///\n    /// If `len` is less than the current length, the vector simply truncated.\n    ///\n    /// If `len` is greater than the current length, `value` is appended to the\n    /// vector until its length equals `len`.\n    pub fn resize(&mut self, len: usize, value: A::Item) {\n        let old_len = self.len();\n\n        if len > old_len {\n            self.extend(repeat(value).take(len - old_len));\n        } else {\n            self.truncate(len);\n        }\n    }\n\n    /// Creates a `SmallVec` with `n` copies of `elem`.\n    /// ```\n    /// use smallvec::SmallVec;\n    ///\n    /// let v = SmallVec::<[char; 128]>::from_elem('d', 2);\n    /// assert_eq!(v, SmallVec::from_buf(['d', 'd']));\n    /// ```\n    pub fn from_elem(elem: A::Item, n: usize) -> Self {\n        if n > A::size() {\n            vec![elem; n].into()\n        } else {\n            let mut v = SmallVec::<A>::new();\n            unsafe {\n                let (ptr, len_ptr, _) = v.triple_mut();\n                let mut local_len = SetLenOnDrop::new(len_ptr);\n\n                for i in 0..n as isize {\n                    ::std::ptr::write(ptr.offset(i), elem.clone());\n                    local_len.increment_len(1);\n                }\n            }\n            v\n        }\n    }\n}","impl<A: Array> SmallVec<A> where A::Item: Copy {\n    /// Copy the elements from a slice into a new `SmallVec`.\n    ///\n    /// For slices of `Copy` types, this is more efficient than `SmallVec::from(slice)`.\n    pub fn from_slice(slice: &[A::Item]) -> Self {\n        let len = slice.len();\n        if len <= A::size() {\n            SmallVec {\n                capacity: len,\n                data: SmallVecData::from_inline(unsafe {\n                    let mut data: A = mem::uninitialized();\n                    ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);\n                    data\n                })\n            }\n        } else {\n            let mut b = slice.to_vec();\n            let (ptr, cap) = (b.as_mut_ptr(), b.capacity());\n            mem::forget(b);\n            SmallVec {\n                capacity: cap,\n                data: SmallVecData::from_heap(ptr, len),\n            }\n        }\n    }\n\n    /// Copy elements from a slice into the vector at position `index`, shifting any following\n    /// elements toward the back.\n    ///\n    /// For slices of `Copy` types, this is more efficient than `insert`.\n    pub fn insert_from_slice(&mut self, index: usize, slice: &[A::Item]) {\n        self.reserve(slice.len());\n\n        let len = self.len();\n        assert!(index <= len);\n\n        unsafe {\n            let slice_ptr = slice.as_ptr();\n            let ptr = self.as_mut_ptr().offset(index as isize);\n            ptr::copy(ptr, ptr.offset(slice.len() as isize), len - index);\n            ptr::copy_nonoverlapping(slice_ptr, ptr, slice.len());\n            self.set_len(len + slice.len());\n        }\n    }\n\n    /// Copy elements from a slice and append them to the vector.\n    ///\n    /// For slices of `Copy` types, this is more efficient than `extend`.\n    #[inline]\n    pub fn extend_from_slice(&mut self, slice: &[A::Item]) {\n        let len = self.len();\n        self.insert_from_slice(len, slice);\n    }\n}","impl<A: Array> SmallVec<A> {\n    /// Construct an empty vector\n    #[inline]\n    pub fn new() -> SmallVec<A> {\n        unsafe {\n            SmallVec {\n                capacity: 0,\n                data: SmallVecData::from_inline(mem::uninitialized()),\n            }\n        }\n    }\n\n    /// Construct an empty vector with enough capacity pre-allocated to store at least `n`\n    /// elements.\n    ///\n    /// Will create a heap allocation only if `n` is larger than the inline capacity.\n    ///\n    /// ```\n    /// # use smallvec::SmallVec;\n    ///\n    /// let v: SmallVec<[u8; 3]> = SmallVec::with_capacity(100);\n    ///\n    /// assert!(v.is_empty());\n    /// assert!(v.capacity() >= 100);\n    /// ```\n    #[inline]\n    pub fn with_capacity(n: usize) -> Self {\n        let mut v = SmallVec::new();\n        v.reserve_exact(n);\n        v\n    }\n\n    /// Construct a new `SmallVec` from a `Vec<A::Item>`.\n    ///\n    /// Elements will be copied to the inline buffer if vec.capacity() <= A::size().\n    ///\n    /// ```rust\n    /// use smallvec::SmallVec;\n    ///\n    /// let vec = vec![1, 2, 3, 4, 5];\n    /// let small_vec: SmallVec<[_; 3]> = SmallVec::from_vec(vec);\n    ///\n    /// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n    /// ```\n    #[inline]\n    pub fn from_vec(mut vec: Vec<A::Item>) -> SmallVec<A> {\n        if vec.capacity() <= A::size() {\n            unsafe {\n                let mut data = SmallVecData::<A>::from_inline(mem::uninitialized());\n                let len = vec.len();\n                vec.set_len(0);\n                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut().ptr_mut(), len);\n\n                SmallVec {\n                    capacity: len,\n                    data,\n                }\n            }\n        } else {\n            let (ptr, cap, len) = (vec.as_mut_ptr(), vec.capacity(), vec.len());\n            mem::forget(vec);\n\n            SmallVec {\n                capacity: cap,\n                data: SmallVecData::from_heap(ptr, len),\n            }\n        }\n    }\n\n    /// Constructs a new `SmallVec` on the stack from an `A` without\n    /// copying elements.\n    ///\n    /// ```rust\n    /// use smallvec::SmallVec;\n    ///\n    /// let buf = [1, 2, 3, 4, 5];\n    /// let small_vec: SmallVec<_> = SmallVec::from_buf(buf);\n    ///\n    /// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n    /// ```\n    #[inline]\n    pub fn from_buf(buf: A) -> SmallVec<A> {\n        SmallVec {\n            capacity: A::size(),\n            data: SmallVecData::from_inline(buf),\n        }\n    }\n\n    /// Constructs a new `SmallVec` on the stack from an `A` without\n    /// copying elements. Also sets the length, which must be less or\n    /// equal to the size of `buf`.\n    ///\n    /// ```rust\n    /// use smallvec::SmallVec;\n    ///\n    /// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n    /// let small_vec: SmallVec<_> = SmallVec::from_buf_and_len(buf, 5);\n    ///\n    /// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n    /// ```\n    #[inline]\n    pub fn from_buf_and_len(buf: A, len: usize) -> SmallVec<A> {\n        assert!(len <= A::size());\n        unsafe { SmallVec::from_buf_and_len_unchecked(buf, len) }\n    }\n\n    /// Constructs a new `SmallVec` on the stack from an `A` without\n    /// copying elements. Also sets the length. The user is responsible\n    /// for ensuring that `len <= A::size()`.\n    ///\n    /// ```rust\n    /// use smallvec::SmallVec;\n    ///\n    /// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n    /// let small_vec: SmallVec<_> = unsafe {\n    ///     SmallVec::from_buf_and_len_unchecked(buf, 5)\n    /// };\n    ///\n    /// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n    /// ```\n    #[inline]\n    pub unsafe fn from_buf_and_len_unchecked(buf: A, len: usize) -> SmallVec<A> {\n        SmallVec {\n            capacity: len,\n            data: SmallVecData::from_inline(buf),\n        }\n    }\n\n\n    /// Sets the length of a vector.\n    ///\n    /// This will explicitly set the size of the vector, without actually\n    /// modifying its buffers, so it is up to the caller to ensure that the\n    /// vector is actually the specified size.\n    pub unsafe fn set_len(&mut self, new_len: usize) {\n        let (_, len_ptr, _) = self.triple_mut();\n        *len_ptr = new_len;\n    }\n\n    /// The maximum number of elements this vector can hold inline\n    #[inline]\n    pub fn inline_size(&self) -> usize {\n        A::size()\n    }\n\n    /// The number of elements stored in the vector\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.triple().1\n    }\n\n    /// Returns `true` if the vector is empty\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// The number of items the vector can hold without reallocating\n    #[inline]\n    pub fn capacity(&self) -> usize {\n        self.triple().2\n    }\n\n    /// Returns a tuple with (data ptr, len, capacity)\n    /// Useful to get all SmallVec properties with a single check of the current storage variant.\n    #[inline]\n    fn triple(&self) -> (*const A::Item, usize, usize) {\n        unsafe {\n            if self.spilled() {\n                let (ptr, len) = self.data.heap();\n                (ptr, len, self.capacity)\n            } else {\n                (self.data.inline().ptr(), self.capacity, A::size())\n            }\n        }\n    }\n\n    /// Returns a tuple with (data ptr, len ptr, capacity)\n    #[inline]\n    fn triple_mut(&mut self) -> (*mut A::Item, &mut usize, usize) {\n        unsafe {\n            if self.spilled() {\n                let &mut (ptr, ref mut len_ptr) = self.data.heap_mut();\n                (ptr, len_ptr, self.capacity)\n            } else {\n                (self.data.inline_mut().ptr_mut(), &mut self.capacity, A::size())\n            }\n        }\n    }\n\n    /// Returns `true` if the data has spilled into a separate heap-allocated buffer.\n    #[inline]\n    pub fn spilled(&self) -> bool {\n        self.capacity > A::size()\n    }\n\n    /// Empty the vector and return an iterator over its former contents.\n    pub fn drain(&mut self) -> Drain<A::Item> {\n        unsafe {\n            let ptr = self.as_mut_ptr();\n\n            let current_len = self.len();\n            self.set_len(0);\n\n            let slice = slice::from_raw_parts_mut(ptr, current_len);\n\n            Drain {\n                iter: slice.iter_mut(),\n            }\n        }\n    }\n\n    /// Append an item to the vector.\n    #[inline]\n    pub fn push(&mut self, value: A::Item) {\n        unsafe {\n            let (_, &mut len, cap) = self.triple_mut();\n            if len == cap {\n                self.reserve(1);\n            }\n            let (ptr, len_ptr, _) = self.triple_mut();\n            *len_ptr = len + 1;\n            ptr::write(ptr.offset(len as isize), value);\n        }\n    }\n\n    /// Remove an item from the end of the vector and return it, or None if empty.\n    #[inline]\n    pub fn pop(&mut self) -> Option<A::Item> {\n        unsafe {\n            let (ptr, len_ptr, _) = self.triple_mut();\n            if *len_ptr == 0 {\n                return None;\n            }\n            let last_index = *len_ptr - 1;\n            *len_ptr = last_index;\n            Some(ptr::read(ptr.offset(last_index as isize)))\n        }\n    }\n\n    /// Re-allocate to set the capacity to `max(new_cap, inline_size())`.\n    ///\n    /// Panics if `new_cap` is less than the vector's length.\n    pub fn grow(&mut self, new_cap: usize) {\n        unsafe {\n            let (ptr, &mut len, cap) = self.triple_mut();\n            let unspilled = !self.spilled();\n            assert!(new_cap >= len);\n            if new_cap <= self.inline_size() {\n                if unspilled {\n                    return;\n                }\n                self.data = SmallVecData::from_inline(mem::uninitialized());\n                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n            } else if new_cap != cap {\n                let mut vec = Vec::with_capacity(new_cap);\n                let new_alloc = vec.as_mut_ptr();\n                mem::forget(vec);\n                ptr::copy_nonoverlapping(ptr, new_alloc, len);\n                self.data = SmallVecData::from_heap(new_alloc, len);\n                self.capacity = new_cap;\n                if unspilled {\n                    return;\n                }\n            }\n            deallocate(ptr, cap);\n        }\n    }\n\n    /// Reserve capacity for `additional` more elements to be inserted.\n    ///\n    /// May reserve more space to avoid frequent reallocations.\n    ///\n    /// If the new capacity would overflow `usize` then it will be set to `usize::max_value()`\n    /// instead. (This means that inserting `additional` new elements is not guaranteed to be\n    /// possible after calling this function.)\n    #[inline]\n    pub fn reserve(&mut self, additional: usize) {\n        // prefer triple_mut() even if triple() would work\n        // so that the optimizer removes duplicated calls to it\n        // from callers like insert()\n        let (_, &mut len, cap) = self.triple_mut();\n        if cap - len < additional {\n            let new_cap = len.checked_add(additional).\n                and_then(usize::checked_next_power_of_two).\n                unwrap_or(usize::max_value());\n            self.grow(new_cap);\n        }\n    }\n\n    /// Reserve the minimum capacity for `additional` more elements to be inserted.\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    pub fn reserve_exact(&mut self, additional: usize) {\n        let (_, &mut len, cap) = self.triple_mut();\n        if cap - len < additional {\n            match len.checked_add(additional) {\n                Some(cap) => self.grow(cap),\n                None => panic!(\"reserve_exact overflow\"),\n            }\n        }\n    }\n\n    /// Shrink the capacity of the vector as much as possible.\n    ///\n    /// When possible, this will move data from an external heap buffer to the vector's inline\n    /// storage.\n    pub fn shrink_to_fit(&mut self) {\n        if !self.spilled() {\n            return;\n        }\n        let len = self.len();\n        if self.inline_size() >= len {\n            unsafe {\n                let (ptr, len) = self.data.heap();\n                self.data = SmallVecData::from_inline(mem::uninitialized());\n                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n                deallocate(ptr, self.capacity);\n                self.capacity = len;\n            }\n        } else if self.capacity() > len {\n            self.grow(len);\n        }\n    }\n\n    /// Shorten the vector, keeping the first `len` elements and dropping the rest.\n    ///\n    /// If `len` is greater than or equal to the vector's current length, this has no\n    /// effect.\n    ///\n    /// This does not re-allocate.  If you want the vector's capacity to shrink, call\n    /// `shrink_to_fit` after truncating.\n    pub fn truncate(&mut self, len: usize) {\n        unsafe {\n            let (ptr, len_ptr, _) = self.triple_mut();\n            while len < *len_ptr {\n                let last_index = *len_ptr - 1;\n                *len_ptr = last_index;\n                ptr::drop_in_place(ptr.offset(last_index as isize));\n            }\n        }\n    }\n\n    /// Extracts a slice containing the entire vector.\n    ///\n    /// Equivalent to `&s[..]`.\n    pub fn as_slice(&self) -> &[A::Item] {\n        self\n    }\n\n    /// Extracts a mutable slice of the entire vector.\n    ///\n    /// Equivalent to `&mut s[..]`.\n    pub fn as_mut_slice(&mut self) -> &mut [A::Item] {\n        self\n    }\n\n    /// Remove the element at position `index`, replacing it with the last element.\n    ///\n    /// This does not preserve ordering, but is O(1).\n    ///\n    /// Panics if `index` is out of bounds.\n    #[inline]\n    pub fn swap_remove(&mut self, index: usize) -> A::Item {\n        let len = self.len();\n        self.swap(len - 1, index);\n        unsafe { self.pop().unchecked_unwrap() }\n    }\n\n    /// Remove all elements from the vector.\n    #[inline]\n    pub fn clear(&mut self) {\n        self.truncate(0);\n    }\n\n    /// Remove and return the element at position `index`, shifting all elements after it to the\n    /// left.\n    ///\n    /// Panics if `index` is out of bounds.\n    pub fn remove(&mut self, index: usize) -> A::Item {\n        unsafe {\n            let (mut ptr, len_ptr, _) = self.triple_mut();\n            let len = *len_ptr;\n            assert!(index < len);\n            *len_ptr = len - 1;\n            ptr = ptr.offset(index as isize);\n            let item = ptr::read(ptr);\n            ptr::copy(ptr.offset(1), ptr, len - index - 1);\n            item\n        }\n    }\n\n    /// Insert an element at position `index`, shifting all elements after it to the right.\n    ///\n    /// Panics if `index` is out of bounds.\n    pub fn insert(&mut self, index: usize, element: A::Item) {\n        self.reserve(1);\n\n        unsafe {\n            let (mut ptr, len_ptr, _) = self.triple_mut();\n            let len = *len_ptr;\n            assert!(index <= len);\n            *len_ptr = len + 1;\n            ptr = ptr.offset(index as isize);\n            ptr::copy(ptr, ptr.offset(1), len - index);\n            ptr::write(ptr, element);\n        }\n    }\n\n    /// Insert multiple elements at position `index`, shifting all following elements toward the\n    /// back.\n    pub fn insert_many<I: IntoIterator<Item=A::Item>>(&mut self, index: usize, iterable: I) {\n        let iter = iterable.into_iter();\n        if index == self.len() {\n            return self.extend(iter);\n        }\n\n        let (lower_size_bound, _) = iter.size_hint();\n        assert!(lower_size_bound <= std::isize::MAX as usize);  // Ensure offset is indexable\n        assert!(index + lower_size_bound >= index);  // Protect against overflow\n        self.reserve(lower_size_bound);\n\n        unsafe {\n            let old_len = self.len();\n            assert!(index <= old_len);\n            let mut ptr = self.as_mut_ptr().offset(index as isize);\n\n            // Move the trailing elements.\n            ptr::copy(ptr, ptr.offset(lower_size_bound as isize), old_len - index);\n\n            // In case the iterator panics, don't double-drop the items we just copied above.\n            self.set_len(index);\n\n            let mut num_added = 0;\n            for element in iter {\n                let mut cur = ptr.offset(num_added as isize);\n                if num_added >= lower_size_bound {\n                    // Iterator provided more elements than the hint.  Move trailing items again.\n                    self.reserve(1);\n                    ptr = self.as_mut_ptr().offset(index as isize);\n                    cur = ptr.offset(num_added as isize);\n                    ptr::copy(cur, cur.offset(1), old_len - index);\n                }\n                ptr::write(cur, element);\n                num_added += 1;\n            }\n            if num_added < lower_size_bound {\n                // Iterator provided fewer elements than the hint\n                ptr::copy(ptr.offset(lower_size_bound as isize), ptr.offset(num_added as isize), old_len - index);\n            }\n\n            self.set_len(old_len + num_added);\n        }\n    }\n\n    /// Convert a SmallVec to a Vec, without reallocating if the SmallVec has already spilled onto\n    /// the heap.\n    pub fn into_vec(self) -> Vec<A::Item> {\n        if self.spilled() {\n            unsafe {\n                let (ptr, len) = self.data.heap();\n                let v = Vec::from_raw_parts(ptr, len, self.capacity);\n                mem::forget(self);\n                v\n            }\n        } else {\n            self.into_iter().collect()\n        }\n    }\n\n    /// Convert the SmallVec into an `A` if possible. Otherwise return `Err(Self)`.\n    ///\n    /// This method returns `Err(Self)` if the SmallVec is too short (and the `A` contains uninitialized elements),\n    /// or if the SmallVec is too long (and all the elements were spilled to the heap).\n    pub fn into_inner(self) -> Result<A, Self> {\n        if self.spilled() || self.len() != A::size() {\n            Err(self)\n        } else {\n            unsafe {\n                let data = ptr::read(&self.data);\n                mem::forget(self);\n                Ok(data.into_inline())\n            }\n        }\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n    /// This method operates in place and preserves the order of the retained\n    /// elements.\n    pub fn retain<F: FnMut(&mut A::Item) -> bool>(&mut self, mut f: F) {\n        let mut del = 0;\n        let len = self.len();\n        for i in 0..len {\n            if !f(&mut self[i]) {\n                del += 1;\n            } else if del > 0 {\n                self.swap(i - del, i);\n            }\n        }\n        self.truncate(len - del);\n    }\n\n    /// Removes consecutive duplicate elements.\n    pub fn dedup(&mut self) where A::Item: PartialEq<A::Item> {\n        self.dedup_by(|a, b| a == b);\n    }\n\n    /// Removes consecutive duplicate elements using the given equality relation.\n    pub fn dedup_by<F>(&mut self, mut same_bucket: F)\n        where F: FnMut(&mut A::Item, &mut A::Item) -> bool\n    {\n        // See the implementation of Vec::dedup_by in the\n        // standard library for an explanation of this algorithm.\n        let len = self.len();\n        if len <= 1 {\n            return;\n        }\n\n        let ptr = self.as_mut_ptr();\n        let mut w: usize = 1;\n\n        unsafe {\n            for r in 1..len {\n                let p_r = ptr.offset(r as isize);\n                let p_wm1 = ptr.offset((w - 1) as isize);\n                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n                    if r != w {\n                        let p_w = p_wm1.offset(1);\n                        mem::swap(&mut *p_r, &mut *p_w);\n                    }\n                    w += 1;\n                }\n            }\n        }\n\n        self.truncate(w);\n    }\n\n    /// Removes consecutive elements that map to the same key.\n    pub fn dedup_by_key<F, K>(&mut self, mut key: F)\n        where F: FnMut(&mut A::Item) -> K,\n              K: PartialEq<K>\n    {\n        self.dedup_by(|a, b| key(a) == key(b));\n    }\n\n    /// Creates a `SmallVec` directly from the raw components of another\n    /// `SmallVec`.\n    ///\n    /// # Safety\n    ///\n    /// This is highly unsafe, due to the number of invariants that aren't\n    /// checked:\n    ///\n    /// * `ptr` needs to have been previously allocated via `SmallVec` for its\n    ///   spilled storage (at least, it's highly likely to be incorrect if it\n    ///   wasn't).\n    /// * `ptr`'s `A::Item` type needs to be the same size and alignment that\n    ///   it was allocated with\n    /// * `length` needs to be less than or equal to `capacity`.\n    /// * `capacity` needs to be the capacity that the pointer was allocated\n    ///   with.\n    ///\n    /// Violating these may cause problems like corrupting the allocator's\n    /// internal data structures.\n    ///\n    /// Additionally, `capacity` must be greater than the amount of inline\n    /// storage `A` has; that is, the new `SmallVec` must need to spill over\n    /// into heap allocated storage. This condition is asserted against.\n    ///\n    /// The ownership of `ptr` is effectively transferred to the\n    /// `SmallVec` which may then deallocate, reallocate or change the\n    /// contents of memory pointed to by the pointer at will. Ensure\n    /// that nothing else uses the pointer after calling this\n    /// function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate smallvec;\n    /// # use smallvec::SmallVec;\n    /// use std::mem;\n    /// use std::ptr;\n    ///\n    /// fn main() {\n    ///     let mut v: SmallVec<[_; 1]> = smallvec![1, 2, 3];\n    ///\n    ///     // Pull out the important parts of `v`.\n    ///     let p = v.as_mut_ptr();\n    ///     let len = v.len();\n    ///     let cap = v.capacity();\n    ///     let spilled = v.spilled();\n    ///\n    ///     unsafe {\n    ///         // Forget all about `v`. The heap allocation that stored the\n    ///         // three values won't be deallocated.\n    ///         mem::forget(v);\n    ///\n    ///         // Overwrite memory with [4, 5, 6].\n    ///         //\n    ///         // This is only safe if `spilled` is true! Otherwise, we are\n    ///         // writing into the old `SmallVec`'s inline storage on the\n    ///         // stack.\n    ///         assert!(spilled);\n    ///         for i in 0..len as isize {\n    ///             ptr::write(p.offset(i), 4 + i);\n    ///         }\n    ///\n    ///         // Put everything back together into a SmallVec with a different\n    ///         // amount of inline storage, but which is still less than `cap`.\n    ///         let rebuilt = SmallVec::<[_; 2]>::from_raw_parts(p, len, cap);\n    ///         assert_eq!(&*rebuilt, &[4, 5, 6]);\n    ///     }\n    /// }\n    pub unsafe fn from_raw_parts(\n        ptr: *mut A::Item,\n        length: usize,\n        capacity: usize,\n    ) -> SmallVec<A> {\n        assert!(capacity > A::size());\n        SmallVec {\n            capacity,\n            data: SmallVecData::from_heap(ptr, length),\n        }\n    }\n}","impl<A: Array> VecLike<A::Item> for SmallVec<A> {\n    #[inline]\n    fn push(&mut self, value: A::Item) {\n        SmallVec::push(self, value);\n    }\n}","impl<A: Array> fmt::Debug for SmallVec<A> where A::Item: fmt::Debug {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}","impl<A: Array> ops::Deref for SmallVec<A> {\n    type Target = [A::Item];\n    #[inline]\n    fn deref(&self) -> &[A::Item] {\n        unsafe {\n            let (ptr, len, _) = self.triple();\n            slice::from_raw_parts(ptr, len)\n        }\n    }\n}","impl<A: Array> ops::DerefMut for SmallVec<A> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut [A::Item] {\n        unsafe {\n            let (ptr, &mut len, _) = self.triple_mut();\n            slice::from_raw_parts_mut(ptr, len)\n        }\n    }\n}","impl<A: Array> ops::Index<$index_type> for SmallVec<A> {\n            type Output = $output_type;\n            #[inline]\n            fn index(&self, index: $index_type) -> &$output_type {\n                &(&**self)[index]\n            }\n        }","impl<A: Array> ops::IndexMut<$index_type> for SmallVec<A> {\n            #[inline]\n            fn index_mut(&mut self, index: $index_type) -> &mut $output_type {\n                &mut (&mut **self)[index]\n            }\n        }","unsafe impl<A: Array> Send for SmallVec<A> where A::Item: Send {}"],"SmallVecData":["impl<A: Array> SmallVecData<A> {\n    #[inline]\n    unsafe fn inline(&self) -> &A {\n        match *self {\n            SmallVecData::Inline(ref a) => a,\n            _ => debug_unreachable!(),\n        }\n    }\n    #[inline]\n    unsafe fn inline_mut(&mut self) -> &mut A {\n        match *self {\n            SmallVecData::Inline(ref mut a) => a,\n            _ => debug_unreachable!(),\n        }\n    }\n    #[inline]\n    fn from_inline(inline: A) -> SmallVecData<A> {\n        SmallVecData::Inline(ManuallyDrop::new(inline))\n    }\n    #[inline]\n    unsafe fn into_inline(self) -> A {\n        match self {\n            SmallVecData::Inline(a) => ManuallyDrop::into_inner(a),\n            _ => debug_unreachable!(),\n        }\n    }\n    #[inline]\n    unsafe fn heap(&self) -> (*mut A::Item, usize) {\n        match *self {\n            SmallVecData::Heap(data) => data,\n            _ => debug_unreachable!(),\n        }\n    }\n    #[inline]\n    unsafe fn heap_mut(&mut self) -> &mut (*mut A::Item, usize) {\n        match *self {\n            SmallVecData::Heap(ref mut data) => data,\n            _ => debug_unreachable!(),\n        }\n    }\n    #[inline]\n    fn from_heap(ptr: *mut A::Item, len: usize) -> SmallVecData<A> {\n        SmallVecData::Heap((ptr, len))\n    }\n}","unsafe impl<A: Array + Send> Send for SmallVecData<A> {}","unsafe impl<A: Array + Sync> Sync for SmallVecData<A> {}"],"std::vec::Vec":["impl<T: Clone> ExtendFromSlice<T> for Vec<T> {\n    fn extend_from_slice(&mut self, other: &[T]) {\n        Vec::extend_from_slice(self, other)\n    }\n}","impl<T> VecLike<T> for Vec<T> {\n    #[inline]\n    fn push(&mut self, value: T) {\n        Vec::push(self, value);\n    }\n}"]},"single_path_import":{},"srcs":{"<&'a SmallVec<A> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"lib.rs\"))"],"<&'a mut SmallVec<A> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter_mut()\n    }","Real(LocalPath(\"lib.rs\"))"],"<Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<T>{\n        self.iter.next_back().map(|reference| unsafe { ptr::read(reference) })\n    }","Real(LocalPath(\"lib.rs\"))"],"<Drain<'a, T> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<T>{\n        self.iter.next().map(|reference| unsafe { ptr::read(reference) })\n    }","Real(LocalPath(\"lib.rs\"))"],"<Drain<'a, T> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"lib.rs\"))"],"<Drain<'a, T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        // Destroy the remaining elements.\n        for _ in self.by_ref() {}\n    }","Real(LocalPath(\"lib.rs\"))"],"<IntoIter<A> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<A::Item>{\n        if self.current == self.end {\n            None\n        }\n        else {\n            unsafe {\n                self.end -= 1;\n                Some(ptr::read(self.data.as_ptr().offset(self.end as isize)))\n            }\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"<IntoIter<A> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<A::Item>{\n        if self.current == self.end {\n            None\n        }\n        else {\n            unsafe {\n                let current = self.current as isize;\n                self.current += 1;\n                Some(ptr::read(self.data.as_ptr().offset(current)))\n            }\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"<IntoIter<A> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        let size = self.end - self.current;\n        (size, Some(size))\n    }","Real(LocalPath(\"lib.rs\"))"],"<IntoIter<A> as std::ops::Drop>::drop":["fn drop(&mut self){\n        for _ in self { }\n    }","Real(LocalPath(\"lib.rs\"))"],"<SetLenOnDrop<'a> as std::ops::Drop>::drop":["#[inline]\nfn drop(&mut self){\n        *self.len = self.local_len;\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as ExtendFromSlice<<A as Array>::Item>>::extend_from_slice":["fn extend_from_slice(&mut self, other: &[A::Item]){\n        SmallVec::extend_from_slice(self, other)\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as VecLike<<A as Array>::Item>>::push":["#[inline]\nfn push(&mut self, value: A::Item){\n        SmallVec::push(self, value);\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::borrow::Borrow<[<A as Array>::Item]>>::borrow":["#[inline]\nfn borrow(&self) -> &[A::Item]{\n        self\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::borrow::BorrowMut<[<A as Array>::Item]>>::borrow_mut":["#[inline]\nfn borrow_mut(&mut self) -> &mut [A::Item]{\n        self\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::clone::Clone>::clone":["fn clone(&self) -> SmallVec<A>{\n        let mut new_vector = SmallVec::with_capacity(self.len());\n        for element in self.iter() {\n            new_vector.push((*element).clone())\n        }\n        new_vector\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::cmp::Ord>::cmp":["#[inline]\nfn cmp(&self, other: &SmallVec<A>) -> cmp::Ordering{\n        Ord::cmp(&**self, &**other)\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::cmp::PartialEq<SmallVec<B>>>::eq":["#[inline]\nfn eq(&self, other: &SmallVec<B>) -> bool{ self[..] == other[..] }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::cmp::PartialEq<SmallVec<B>>>::ne":["#[inline]\nfn ne(&self, other: &SmallVec<B>) -> bool{ self[..] != other[..] }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::cmp::PartialOrd>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &SmallVec<A>) -> Option<cmp::Ordering>{\n        PartialOrd::partial_cmp(&**self, &**other)\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::convert::AsMut<[<A as Array>::Item]>>::as_mut":["#[inline]\nfn as_mut(&mut self) -> &mut [A::Item]{\n        self\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::convert::AsRef<[<A as Array>::Item]>>::as_ref":["#[inline]\nfn as_ref(&self) -> &[A::Item]{\n        self\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::convert::From<&'a [<A as Array>::Item]>>::from":["#[cfg(not(feature = \"specialization\"))]\n#[inline]\nfn from(slice: &'a [A::Item]) -> SmallVec<A>{\n        slice.into_iter().cloned().collect()\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::convert::From<A>>::from":["#[inline]\nfn from(array: A) -> SmallVec<A>{\n        SmallVec::from_buf(array)\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::convert::From<std::vec::Vec<<A as Array>::Item>>>::from":["#[inline]\nfn from(vec: Vec<A::Item>) -> SmallVec<A>{\n        SmallVec::from_vec(vec)\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::default::Default>::default":["#[inline]\nfn default() -> SmallVec<A>{\n        SmallVec::new()\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_list().entries(self.iter()).finish()\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::hash::Hash>::hash":["fn hash<H: Hasher>(&self, state: &mut H){\n        (**self).hash(state)\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::io::Write>::flush":["#[inline]\nfn flush(&mut self) -> io::Result<()>{\n        Ok(())\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::io::Write>::write":["#[inline]\nfn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.extend_from_slice(buf);\n        Ok(buf.len())\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::io::Write>::write_all":["#[inline]\nfn write_all(&mut self, buf: &[u8]) -> io::Result<()>{\n        self.extend_from_slice(buf);\n        Ok(())\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::iter::Extend<<A as Array>::Item>>::extend":["fn extend<I: IntoIterator<Item=A::Item>>(&mut self, iterable: I){\n        let mut iter = iterable.into_iter();\n        let (lower_size_bound, _) = iter.size_hint();\n        self.reserve(lower_size_bound);\n\n        unsafe {\n            let len = self.len();\n            let ptr = self.as_mut_ptr().offset(len as isize);\n            let mut count = 0;\n            while count < lower_size_bound {\n                if let Some(out) = iter.next() {\n                    ptr::write(ptr.offset(count as isize), out);\n                    count += 1;\n                } else {\n                    break;\n                }\n            }\n            self.set_len(len + count);\n        }\n\n        for elem in iter {\n            self.push(elem);\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::iter::FromIterator<<A as Array>::Item>>::from_iter":["fn from_iter<I: IntoIterator<Item=A::Item>>(iterable: I) -> SmallVec<A>{\n        let mut v = SmallVec::new();\n        v.extend(iterable);\n        v\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::iter::IntoIterator>::into_iter":["fn into_iter(mut self) -> Self::IntoIter{\n        unsafe {\n            // Set SmallVec len to zero as `IntoIter` drop handles dropping of the elements\n            let len = self.len();\n            self.set_len(0);\n            IntoIter {\n                data: self,\n                current: 0,\n                end: len,\n            }\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::ops::Deref>::deref":["#[inline]\nfn deref(&self) -> &[A::Item]{\n        unsafe {\n            let (ptr, len, _) = self.triple();\n            slice::from_raw_parts(ptr, len)\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::ops::DerefMut>::deref_mut":["#[inline]\nfn deref_mut(&mut self) -> &mut [A::Item]{\n        unsafe {\n            let (ptr, &mut len, _) = self.triple_mut();\n            slice::from_raw_parts_mut(ptr, len)\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::ops::Drop>::drop":["fn drop(&mut self){\n        unsafe {\n            if self.spilled() {\n                let (ptr, len) = self.data.heap();\n                Vec::from_raw_parts(ptr, len, self.capacity);\n            } else {\n                ptr::drop_in_place(&mut self[..]);\n            }\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::ops::Index<std::ops::Range<usize>>>::index":["#[inline]\nfn index(&self, index: $index_type) -> &$output_type{\n                &(&**self)[index]\n            }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::ops::Index<std::ops::RangeFrom<usize>>>::index":["#[inline]\nfn index(&self, index: $index_type) -> &$output_type{\n                &(&**self)[index]\n            }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::ops::Index<std::ops::RangeFull>>::index":["#[inline]\nfn index(&self, index: $index_type) -> &$output_type{\n                &(&**self)[index]\n            }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::ops::Index<std::ops::RangeTo<usize>>>::index":["#[inline]\nfn index(&self, index: $index_type) -> &$output_type{\n                &(&**self)[index]\n            }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::ops::Index<usize>>::index":["#[inline]\nfn index(&self, index: $index_type) -> &$output_type{\n                &(&**self)[index]\n            }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::ops::IndexMut<std::ops::Range<usize>>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: $index_type) -> &mut $output_type{\n                &mut (&mut **self)[index]\n            }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::ops::IndexMut<std::ops::RangeFrom<usize>>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: $index_type) -> &mut $output_type{\n                &mut (&mut **self)[index]\n            }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::ops::IndexMut<std::ops::RangeFull>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: $index_type) -> &mut $output_type{\n                &mut (&mut **self)[index]\n            }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::ops::IndexMut<std::ops::RangeTo<usize>>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: $index_type) -> &mut $output_type{\n                &mut (&mut **self)[index]\n            }","Real(LocalPath(\"lib.rs\"))"],"<SmallVec<A> as std::ops::IndexMut<usize>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: $index_type) -> &mut $output_type{\n                &mut (&mut **self)[index]\n            }","Real(LocalPath(\"lib.rs\"))"],"<[T; 0] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 0] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 0] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 1024] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 1024] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 1024] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 1048576] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 1048576] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 1048576] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 10] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 10] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 10] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 11] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 11] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 11] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 128] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 128] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 128] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 12] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 12] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 12] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 131072] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 131072] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 131072] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 13] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 13] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 13] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 14] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 14] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 14] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 15] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 15] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 15] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 16384] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 16384] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 16384] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 16] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 16] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 16] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 1] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 1] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 1] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 2048] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 2048] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 2048] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 20] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 20] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 20] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 24] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 24] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 24] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 256] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 256] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 256] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 262144] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 262144] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 262144] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 2] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 2] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 2] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 32768] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 32768] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 32768] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 32] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 32] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 32] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 36] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 36] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 36] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 3] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 3] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 3] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 4096] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 4096] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 4096] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 4] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 4] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 4] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 512] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 512] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 512] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 524288] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 524288] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 524288] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 5] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 5] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 5] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 64] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 64] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 64] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 65536] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 65536] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 65536] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 6] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 6] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 6] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 7] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 7] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 7] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 8192] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 8192] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 8192] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 8] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 8] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 8] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<[T; 9] as Array>::ptr":["fn ptr(&self) -> *const T{ self.as_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 9] as Array>::ptr_mut":["fn ptr_mut(&mut self) -> *mut T{ self.as_mut_ptr() }","Real(LocalPath(\"lib.rs\"))"],"<[T; 9] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"lib.rs\"))"],"<std::vec::Vec<T> as ExtendFromSlice<T>>::extend_from_slice":["fn extend_from_slice(&mut self, other: &[T]){\n        Vec::extend_from_slice(self, other)\n    }","Real(LocalPath(\"lib.rs\"))"],"<std::vec::Vec<T> as VecLike<T>>::push":["#[inline]\nfn push(&mut self, value: T){\n        Vec::push(self, value);\n    }","Real(LocalPath(\"lib.rs\"))"],"Array":["/// Types that can be used as the backing store for a SmallVec\npub unsafe trait Array {\n    /// The type of the array's elements.\n    type Item;\n    /// Returns the number of items the array can hold.\n    fn size() -> usize;\n    /// Returns a pointer to the first element of the array.\n    fn ptr(&self) -> *const Self::Item;\n    /// Returns a mutable pointer to the first element of the array.\n    fn ptr_mut(&mut self) -> *mut Self::Item;\n}","Real(LocalPath(\"lib.rs\"))"],"Drain":["/// An iterator that removes the items from a `SmallVec` and yields them by value.\n///\n/// Returned from [`SmallVec::drain`][1].\n///\n/// [1]: struct.SmallVec.html#method.drain\npub struct Drain<'a, T: 'a> {\n    iter: slice::IterMut<'a,T>,\n}","Real(LocalPath(\"lib.rs\"))"],"ExtendFromSlice":["/// Trait to be implemented by a collection that can be extended from a slice\n///\n/// ## Example\n///\n/// ```rust\n/// use smallvec::{ExtendFromSlice, SmallVec};\n///\n/// fn initialize<V: ExtendFromSlice<u8>>(v: &mut V) {\n///     v.extend_from_slice(b\"Test!\");\n/// }\n///\n/// let mut vec = Vec::new();\n/// initialize(&mut vec);\n/// assert_eq!(&vec, b\"Test!\");\n///\n/// let mut small_vec = SmallVec::<[u8; 8]>::new();\n/// initialize(&mut small_vec);\n/// assert_eq!(&small_vec as &[_], b\"Test!\");\n/// ```\npub trait ExtendFromSlice<T> {\n    /// Extends a collection from a slice of its element type\n    fn extend_from_slice(&mut self, other: &[T]);\n}","Real(LocalPath(\"lib.rs\"))"],"IntoIter":["/// An iterator that consumes a `SmallVec` and yields its items by value.\n///\n/// Returned from [`SmallVec::into_iter`][1].\n///\n/// [1]: struct.SmallVec.html#method.into_iter\npub struct IntoIter<A: Array> {\n    data: SmallVec<A>,\n    current: usize,\n    end: usize,\n}","Real(LocalPath(\"lib.rs\"))"],"SetLenOnDrop":["/// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n///\n/// Copied from https://github.com/rust-lang/rust/pull/36355\nstruct SetLenOnDrop<'a> {\n    len: &'a mut usize,\n    local_len: usize,\n}","Real(LocalPath(\"lib.rs\"))"],"SetLenOnDrop::<'a>::increment_len":["#[inline]\nfn increment_len(&mut self, increment: usize){\n        self.local_len += increment;\n    }","Real(LocalPath(\"lib.rs\"))"],"SetLenOnDrop::<'a>::new":["#[inline]\nfn new(len: &'a mut usize) -> Self{\n        SetLenOnDrop { local_len: *len, len: len }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec":["/// A `Vec`-like container that can store a small number of elements inline.\n///\n/// `SmallVec` acts like a vector, but can store a limited amount of data inline within the\n/// `Smallvec` struct rather than in a separate allocation.  If the data exceeds this limit, the\n/// `SmallVec` will \"spill\" its data onto the heap, allocating a new buffer to hold it.\n///\n/// The amount of data that a `SmallVec` can store inline depends on its backing store. The backing\n/// store can be any type that implements the `Array` trait; usually it is a small fixed-sized\n/// array.  For example a `SmallVec<[u64; 8]>` can hold up to eight 64-bit integers inline.\n///\n/// ## Example\n///\n/// ```rust\n/// use smallvec::SmallVec;\n/// let mut v = SmallVec::<[u8; 4]>::new(); // initialize an empty vector\n///\n/// // The vector can hold up to 4 items without spilling onto the heap.\n/// v.extend(0..4);\n/// assert_eq!(v.len(), 4);\n/// assert!(!v.spilled());\n///\n/// // Pushing another element will force the buffer to spill:\n/// v.push(4);\n/// assert_eq!(v.len(), 5);\n/// assert!(v.spilled());\n/// ```\npub struct SmallVec<A: Array> {\n    // The capacity field is used to determine which of the storage variants is active:\n    // If capacity <= A::size() then the inline variant is used and capacity holds the current length of the vector (number of elements actually in use).\n    // If capacity > A::size() then the heap variant is used and capacity holds the size of the memory allocation.\n    capacity: usize,\n    data: SmallVecData<A>,\n}","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::as_mut_slice":["/// Extracts a mutable slice of the entire vector.\n///\n/// Equivalent to `&mut s[..]`.\npub fn as_mut_slice(&mut self) -> &mut [A::Item]{\n        self\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::as_slice":["/// Extracts a slice containing the entire vector.\n///\n/// Equivalent to `&s[..]`.\npub fn as_slice(&self) -> &[A::Item]{\n        self\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::capacity":["/// The number of items the vector can hold without reallocating\n#[inline]\npub fn capacity(&self) -> usize{\n        self.triple().2\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::clear":["/// Remove all elements from the vector.\n#[inline]\npub fn clear(&mut self){\n        self.truncate(0);\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::dedup":["/// Removes consecutive duplicate elements.\npub fn dedup(&mut self) where A::Item: PartialEq<A::Item>{\n        self.dedup_by(|a, b| a == b);\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::dedup_by":["/// Removes consecutive duplicate elements using the given equality relation.\npub fn dedup_by<F>(&mut self, mut same_bucket: F)\n        where F: FnMut(&mut A::Item, &mut A::Item) -> bool{\n        // See the implementation of Vec::dedup_by in the\n        // standard library for an explanation of this algorithm.\n        let len = self.len();\n        if len <= 1 {\n            return;\n        }\n\n        let ptr = self.as_mut_ptr();\n        let mut w: usize = 1;\n\n        unsafe {\n            for r in 1..len {\n                let p_r = ptr.offset(r as isize);\n                let p_wm1 = ptr.offset((w - 1) as isize);\n                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n                    if r != w {\n                        let p_w = p_wm1.offset(1);\n                        mem::swap(&mut *p_r, &mut *p_w);\n                    }\n                    w += 1;\n                }\n            }\n        }\n\n        self.truncate(w);\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::dedup_by_key":["/// Removes consecutive elements that map to the same key.\npub fn dedup_by_key<F, K>(&mut self, mut key: F)\n        where F: FnMut(&mut A::Item) -> K,\n              K: PartialEq<K>{\n        self.dedup_by(|a, b| key(a) == key(b));\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::drain":["/// Empty the vector and return an iterator over its former contents.\npub fn drain(&mut self) -> Drain<A::Item>{\n        unsafe {\n            let ptr = self.as_mut_ptr();\n\n            let current_len = self.len();\n            self.set_len(0);\n\n            let slice = slice::from_raw_parts_mut(ptr, current_len);\n\n            Drain {\n                iter: slice.iter_mut(),\n            }\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::extend_from_slice":["/// Copy elements from a slice and append them to the vector.\n///\n/// For slices of `Copy` types, this is more efficient than `extend`.\n#[inline]\npub fn extend_from_slice(&mut self, slice: &[A::Item]){\n        let len = self.len();\n        self.insert_from_slice(len, slice);\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::from_buf":["/// Constructs a new `SmallVec` on the stack from an `A` without\n/// copying elements.\n///\n/// ```rust\n/// use smallvec::SmallVec;\n///\n/// let buf = [1, 2, 3, 4, 5];\n/// let small_vec: SmallVec<_> = SmallVec::from_buf(buf);\n///\n/// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n/// ```\n#[inline]\npub fn from_buf(buf: A) -> SmallVec<A>{\n        SmallVec {\n            capacity: A::size(),\n            data: SmallVecData::from_inline(buf),\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::from_buf_and_len":["/// Constructs a new `SmallVec` on the stack from an `A` without\n/// copying elements. Also sets the length, which must be less or\n/// equal to the size of `buf`.\n///\n/// ```rust\n/// use smallvec::SmallVec;\n///\n/// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n/// let small_vec: SmallVec<_> = SmallVec::from_buf_and_len(buf, 5);\n///\n/// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n/// ```\n#[inline]\npub fn from_buf_and_len(buf: A, len: usize) -> SmallVec<A>{\n        assert!(len <= A::size());\n        unsafe { SmallVec::from_buf_and_len_unchecked(buf, len) }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::from_buf_and_len_unchecked":["/// Constructs a new `SmallVec` on the stack from an `A` without\n/// copying elements. Also sets the length. The user is responsible\n/// for ensuring that `len <= A::size()`.\n///\n/// ```rust\n/// use smallvec::SmallVec;\n///\n/// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n/// let small_vec: SmallVec<_> = unsafe {\n///     SmallVec::from_buf_and_len_unchecked(buf, 5)\n/// };\n///\n/// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n/// ```\n#[inline]\npub unsafe fn from_buf_and_len_unchecked(buf: A, len: usize) -> SmallVec<A>{\n        SmallVec {\n            capacity: len,\n            data: SmallVecData::from_inline(buf),\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::from_elem":["/// Creates a `SmallVec` with `n` copies of `elem`.\n/// ```\n/// use smallvec::SmallVec;\n///\n/// let v = SmallVec::<[char; 128]>::from_elem('d', 2);\n/// assert_eq!(v, SmallVec::from_buf(['d', 'd']));\n/// ```\npub fn from_elem(elem: A::Item, n: usize) -> Self{\n        if n > A::size() {\n            vec![elem; n].into()\n        } else {\n            let mut v = SmallVec::<A>::new();\n            unsafe {\n                let (ptr, len_ptr, _) = v.triple_mut();\n                let mut local_len = SetLenOnDrop::new(len_ptr);\n\n                for i in 0..n as isize {\n                    ::std::ptr::write(ptr.offset(i), elem.clone());\n                    local_len.increment_len(1);\n                }\n            }\n            v\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::from_raw_parts":["/// Creates a `SmallVec` directly from the raw components of another\n/// `SmallVec`.\n///\n/// # Safety\n///\n/// This is highly unsafe, due to the number of invariants that aren't\n/// checked:\n///\n/// * `ptr` needs to have been previously allocated via `SmallVec` for its\n///   spilled storage (at least, it's highly likely to be incorrect if it\n///   wasn't).\n/// * `ptr`'s `A::Item` type needs to be the same size and alignment that\n///   it was allocated with\n/// * `length` needs to be less than or equal to `capacity`.\n/// * `capacity` needs to be the capacity that the pointer was allocated\n///   with.\n///\n/// Violating these may cause problems like corrupting the allocator's\n/// internal data structures.\n///\n/// Additionally, `capacity` must be greater than the amount of inline\n/// storage `A` has; that is, the new `SmallVec` must need to spill over\n/// into heap allocated storage. This condition is asserted against.\n///\n/// The ownership of `ptr` is effectively transferred to the\n/// `SmallVec` which may then deallocate, reallocate or change the\n/// contents of memory pointed to by the pointer at will. Ensure\n/// that nothing else uses the pointer after calling this\n/// function.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate smallvec;\n/// # use smallvec::SmallVec;\n/// use std::mem;\n/// use std::ptr;\n///\n/// fn main() {\n///     let mut v: SmallVec<[_; 1]> = smallvec![1, 2, 3];\n///\n///     // Pull out the important parts of `v`.\n///     let p = v.as_mut_ptr();\n///     let len = v.len();\n///     let cap = v.capacity();\n///     let spilled = v.spilled();\n///\n///     unsafe {\n///         // Forget all about `v`. The heap allocation that stored the\n///         // three values won't be deallocated.\n///         mem::forget(v);\n///\n///         // Overwrite memory with [4, 5, 6].\n///         //\n///         // This is only safe if `spilled` is true! Otherwise, we are\n///         // writing into the old `SmallVec`'s inline storage on the\n///         // stack.\n///         assert!(spilled);\n///         for i in 0..len as isize {\n///             ptr::write(p.offset(i), 4 + i);\n///         }\n///\n///         // Put everything back together into a SmallVec with a different\n///         // amount of inline storage, but which is still less than `cap`.\n///         let rebuilt = SmallVec::<[_; 2]>::from_raw_parts(p, len, cap);\n///         assert_eq!(&*rebuilt, &[4, 5, 6]);\n///     }\n/// }\npub unsafe fn from_raw_parts(\n        ptr: *mut A::Item,\n        length: usize,\n        capacity: usize,\n    ) -> SmallVec<A>{\n        assert!(capacity > A::size());\n        SmallVec {\n            capacity,\n            data: SmallVecData::from_heap(ptr, length),\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::from_slice":["/// Copy the elements from a slice into a new `SmallVec`.\n///\n/// For slices of `Copy` types, this is more efficient than `SmallVec::from(slice)`.\npub fn from_slice(slice: &[A::Item]) -> Self{\n        let len = slice.len();\n        if len <= A::size() {\n            SmallVec {\n                capacity: len,\n                data: SmallVecData::from_inline(unsafe {\n                    let mut data: A = mem::uninitialized();\n                    ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);\n                    data\n                })\n            }\n        } else {\n            let mut b = slice.to_vec();\n            let (ptr, cap) = (b.as_mut_ptr(), b.capacity());\n            mem::forget(b);\n            SmallVec {\n                capacity: cap,\n                data: SmallVecData::from_heap(ptr, len),\n            }\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::from_vec":["/// Construct a new `SmallVec` from a `Vec<A::Item>`.\n///\n/// Elements will be copied to the inline buffer if vec.capacity() <= A::size().\n///\n/// ```rust\n/// use smallvec::SmallVec;\n///\n/// let vec = vec![1, 2, 3, 4, 5];\n/// let small_vec: SmallVec<[_; 3]> = SmallVec::from_vec(vec);\n///\n/// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n/// ```\n#[inline]\npub fn from_vec(mut vec: Vec<A::Item>) -> SmallVec<A>{\n        if vec.capacity() <= A::size() {\n            unsafe {\n                let mut data = SmallVecData::<A>::from_inline(mem::uninitialized());\n                let len = vec.len();\n                vec.set_len(0);\n                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut().ptr_mut(), len);\n\n                SmallVec {\n                    capacity: len,\n                    data,\n                }\n            }\n        } else {\n            let (ptr, cap, len) = (vec.as_mut_ptr(), vec.capacity(), vec.len());\n            mem::forget(vec);\n\n            SmallVec {\n                capacity: cap,\n                data: SmallVecData::from_heap(ptr, len),\n            }\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::grow":["/// Re-allocate to set the capacity to `max(new_cap, inline_size())`.\n///\n/// Panics if `new_cap` is less than the vector's length.\npub fn grow(&mut self, new_cap: usize){\n        unsafe {\n            let (ptr, &mut len, cap) = self.triple_mut();\n            let unspilled = !self.spilled();\n            assert!(new_cap >= len);\n            if new_cap <= self.inline_size() {\n                if unspilled {\n                    return;\n                }\n                self.data = SmallVecData::from_inline(mem::uninitialized());\n                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n            } else if new_cap != cap {\n                let mut vec = Vec::with_capacity(new_cap);\n                let new_alloc = vec.as_mut_ptr();\n                mem::forget(vec);\n                ptr::copy_nonoverlapping(ptr, new_alloc, len);\n                self.data = SmallVecData::from_heap(new_alloc, len);\n                self.capacity = new_cap;\n                if unspilled {\n                    return;\n                }\n            }\n            deallocate(ptr, cap);\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::inline_size":["/// The maximum number of elements this vector can hold inline\n#[inline]\npub fn inline_size(&self) -> usize{\n        A::size()\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::insert":["/// Insert an element at position `index`, shifting all elements after it to the right.\n///\n/// Panics if `index` is out of bounds.\npub fn insert(&mut self, index: usize, element: A::Item){\n        self.reserve(1);\n\n        unsafe {\n            let (mut ptr, len_ptr, _) = self.triple_mut();\n            let len = *len_ptr;\n            assert!(index <= len);\n            *len_ptr = len + 1;\n            ptr = ptr.offset(index as isize);\n            ptr::copy(ptr, ptr.offset(1), len - index);\n            ptr::write(ptr, element);\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::insert_from_slice":["/// Copy elements from a slice into the vector at position `index`, shifting any following\n/// elements toward the back.\n///\n/// For slices of `Copy` types, this is more efficient than `insert`.\npub fn insert_from_slice(&mut self, index: usize, slice: &[A::Item]){\n        self.reserve(slice.len());\n\n        let len = self.len();\n        assert!(index <= len);\n\n        unsafe {\n            let slice_ptr = slice.as_ptr();\n            let ptr = self.as_mut_ptr().offset(index as isize);\n            ptr::copy(ptr, ptr.offset(slice.len() as isize), len - index);\n            ptr::copy_nonoverlapping(slice_ptr, ptr, slice.len());\n            self.set_len(len + slice.len());\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::insert_many":["/// Insert multiple elements at position `index`, shifting all following elements toward the\n/// back.\npub fn insert_many<I: IntoIterator<Item=A::Item>>(&mut self, index: usize, iterable: I){\n        let iter = iterable.into_iter();\n        if index == self.len() {\n            return self.extend(iter);\n        }\n\n        let (lower_size_bound, _) = iter.size_hint();\n        assert!(lower_size_bound <= std::isize::MAX as usize);  // Ensure offset is indexable\n        assert!(index + lower_size_bound >= index);  // Protect against overflow\n        self.reserve(lower_size_bound);\n\n        unsafe {\n            let old_len = self.len();\n            assert!(index <= old_len);\n            let mut ptr = self.as_mut_ptr().offset(index as isize);\n\n            // Move the trailing elements.\n            ptr::copy(ptr, ptr.offset(lower_size_bound as isize), old_len - index);\n\n            // In case the iterator panics, don't double-drop the items we just copied above.\n            self.set_len(index);\n\n            let mut num_added = 0;\n            for element in iter {\n                let mut cur = ptr.offset(num_added as isize);\n                if num_added >= lower_size_bound {\n                    // Iterator provided more elements than the hint.  Move trailing items again.\n                    self.reserve(1);\n                    ptr = self.as_mut_ptr().offset(index as isize);\n                    cur = ptr.offset(num_added as isize);\n                    ptr::copy(cur, cur.offset(1), old_len - index);\n                }\n                ptr::write(cur, element);\n                num_added += 1;\n            }\n            if num_added < lower_size_bound {\n                // Iterator provided fewer elements than the hint\n                ptr::copy(ptr.offset(lower_size_bound as isize), ptr.offset(num_added as isize), old_len - index);\n            }\n\n            self.set_len(old_len + num_added);\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::into_inner":["/// Convert the SmallVec into an `A` if possible. Otherwise return `Err(Self)`.\n///\n/// This method returns `Err(Self)` if the SmallVec is too short (and the `A` contains uninitialized elements),\n/// or if the SmallVec is too long (and all the elements were spilled to the heap).\npub fn into_inner(self) -> Result<A, Self>{\n        if self.spilled() || self.len() != A::size() {\n            Err(self)\n        } else {\n            unsafe {\n                let data = ptr::read(&self.data);\n                mem::forget(self);\n                Ok(data.into_inline())\n            }\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::into_vec":["/// Convert a SmallVec to a Vec, without reallocating if the SmallVec has already spilled onto\n/// the heap.\npub fn into_vec(self) -> Vec<A::Item>{\n        if self.spilled() {\n            unsafe {\n                let (ptr, len) = self.data.heap();\n                let v = Vec::from_raw_parts(ptr, len, self.capacity);\n                mem::forget(self);\n                v\n            }\n        } else {\n            self.into_iter().collect()\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::is_empty":["/// Returns `true` if the vector is empty\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::len":["/// The number of elements stored in the vector\n#[inline]\npub fn len(&self) -> usize{\n        self.triple().1\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::new":["/// Construct an empty vector\n#[inline]\npub fn new() -> SmallVec<A>{\n        unsafe {\n            SmallVec {\n                capacity: 0,\n                data: SmallVecData::from_inline(mem::uninitialized()),\n            }\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::pop":["/// Remove an item from the end of the vector and return it, or None if empty.\n#[inline]\npub fn pop(&mut self) -> Option<A::Item>{\n        unsafe {\n            let (ptr, len_ptr, _) = self.triple_mut();\n            if *len_ptr == 0 {\n                return None;\n            }\n            let last_index = *len_ptr - 1;\n            *len_ptr = last_index;\n            Some(ptr::read(ptr.offset(last_index as isize)))\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::push":["/// Append an item to the vector.\n#[inline]\npub fn push(&mut self, value: A::Item){\n        unsafe {\n            let (_, &mut len, cap) = self.triple_mut();\n            if len == cap {\n                self.reserve(1);\n            }\n            let (ptr, len_ptr, _) = self.triple_mut();\n            *len_ptr = len + 1;\n            ptr::write(ptr.offset(len as isize), value);\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::remove":["/// Remove and return the element at position `index`, shifting all elements after it to the\n/// left.\n///\n/// Panics if `index` is out of bounds.\npub fn remove(&mut self, index: usize) -> A::Item{\n        unsafe {\n            let (mut ptr, len_ptr, _) = self.triple_mut();\n            let len = *len_ptr;\n            assert!(index < len);\n            *len_ptr = len - 1;\n            ptr = ptr.offset(index as isize);\n            let item = ptr::read(ptr);\n            ptr::copy(ptr.offset(1), ptr, len - index - 1);\n            item\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::reserve":["/// Reserve capacity for `additional` more elements to be inserted.\n///\n/// May reserve more space to avoid frequent reallocations.\n///\n/// If the new capacity would overflow `usize` then it will be set to `usize::max_value()`\n/// instead. (This means that inserting `additional` new elements is not guaranteed to be\n/// possible after calling this function.)\n#[inline]\npub fn reserve(&mut self, additional: usize){\n        // prefer triple_mut() even if triple() would work\n        // so that the optimizer removes duplicated calls to it\n        // from callers like insert()\n        let (_, &mut len, cap) = self.triple_mut();\n        if cap - len < additional {\n            let new_cap = len.checked_add(additional).\n                and_then(usize::checked_next_power_of_two).\n                unwrap_or(usize::max_value());\n            self.grow(new_cap);\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::reserve_exact":["/// Reserve the minimum capacity for `additional` more elements to be inserted.\n///\n/// Panics if the new capacity overflows `usize`.\npub fn reserve_exact(&mut self, additional: usize){\n        let (_, &mut len, cap) = self.triple_mut();\n        if cap - len < additional {\n            match len.checked_add(additional) {\n                Some(cap) => self.grow(cap),\n                None => panic!(\"reserve_exact overflow\"),\n            }\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::resize":["/// Resizes the vector so that its length is equal to `len`.\n///\n/// If `len` is less than the current length, the vector simply truncated.\n///\n/// If `len` is greater than the current length, `value` is appended to the\n/// vector until its length equals `len`.\npub fn resize(&mut self, len: usize, value: A::Item){\n        let old_len = self.len();\n\n        if len > old_len {\n            self.extend(repeat(value).take(len - old_len));\n        } else {\n            self.truncate(len);\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::retain":["/// Retains only the elements specified by the predicate.\n///\n/// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n/// This method operates in place and preserves the order of the retained\n/// elements.\npub fn retain<F: FnMut(&mut A::Item) -> bool>(&mut self, mut f: F){\n        let mut del = 0;\n        let len = self.len();\n        for i in 0..len {\n            if !f(&mut self[i]) {\n                del += 1;\n            } else if del > 0 {\n                self.swap(i - del, i);\n            }\n        }\n        self.truncate(len - del);\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::set_len":["/// Sets the length of a vector.\n///\n/// This will explicitly set the size of the vector, without actually\n/// modifying its buffers, so it is up to the caller to ensure that the\n/// vector is actually the specified size.\npub unsafe fn set_len(&mut self, new_len: usize){\n        let (_, len_ptr, _) = self.triple_mut();\n        *len_ptr = new_len;\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::shrink_to_fit":["/// Shrink the capacity of the vector as much as possible.\n///\n/// When possible, this will move data from an external heap buffer to the vector's inline\n/// storage.\npub fn shrink_to_fit(&mut self){\n        if !self.spilled() {\n            return;\n        }\n        let len = self.len();\n        if self.inline_size() >= len {\n            unsafe {\n                let (ptr, len) = self.data.heap();\n                self.data = SmallVecData::from_inline(mem::uninitialized());\n                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n                deallocate(ptr, self.capacity);\n                self.capacity = len;\n            }\n        } else if self.capacity() > len {\n            self.grow(len);\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::spilled":["/// Returns `true` if the data has spilled into a separate heap-allocated buffer.\n#[inline]\npub fn spilled(&self) -> bool{\n        self.capacity > A::size()\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::swap_remove":["/// Remove the element at position `index`, replacing it with the last element.\n///\n/// This does not preserve ordering, but is O(1).\n///\n/// Panics if `index` is out of bounds.\n#[inline]\npub fn swap_remove(&mut self, index: usize) -> A::Item{\n        let len = self.len();\n        self.swap(len - 1, index);\n        unsafe { self.pop().unchecked_unwrap() }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::triple":["/// Returns a tuple with (data ptr, len, capacity)\n/// Useful to get all SmallVec properties with a single check of the current storage variant.\n#[inline]\nfn triple(&self) -> (*const A::Item, usize, usize){\n        unsafe {\n            if self.spilled() {\n                let (ptr, len) = self.data.heap();\n                (ptr, len, self.capacity)\n            } else {\n                (self.data.inline().ptr(), self.capacity, A::size())\n            }\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::triple_mut":["/// Returns a tuple with (data ptr, len ptr, capacity)\n#[inline]\nfn triple_mut(&mut self) -> (*mut A::Item, &mut usize, usize){\n        unsafe {\n            if self.spilled() {\n                let &mut (ptr, ref mut len_ptr) = self.data.heap_mut();\n                (ptr, len_ptr, self.capacity)\n            } else {\n                (self.data.inline_mut().ptr_mut(), &mut self.capacity, A::size())\n            }\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::truncate":["/// Shorten the vector, keeping the first `len` elements and dropping the rest.\n///\n/// If `len` is greater than or equal to the vector's current length, this has no\n/// effect.\n///\n/// This does not re-allocate.  If you want the vector's capacity to shrink, call\n/// `shrink_to_fit` after truncating.\npub fn truncate(&mut self, len: usize){\n        unsafe {\n            let (ptr, len_ptr, _) = self.triple_mut();\n            while len < *len_ptr {\n                let last_index = *len_ptr - 1;\n                *len_ptr = last_index;\n                ptr::drop_in_place(ptr.offset(last_index as isize));\n            }\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVec::<A>::with_capacity":["/// Construct an empty vector with enough capacity pre-allocated to store at least `n`\n/// elements.\n///\n/// Will create a heap allocation only if `n` is larger than the inline capacity.\n///\n/// ```\n/// # use smallvec::SmallVec;\n///\n/// let v: SmallVec<[u8; 3]> = SmallVec::with_capacity(100);\n///\n/// assert!(v.is_empty());\n/// assert!(v.capacity() >= 100);\n/// ```\n#[inline]\npub fn with_capacity(n: usize) -> Self{\n        let mut v = SmallVec::new();\n        v.reserve_exact(n);\n        v\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVecData":["#[cfg(not(feature = \"union\"))]\nenum SmallVecData<A: Array> {\n    Inline(ManuallyDrop<A>),\n    Heap((*mut A::Item, usize)),\n}","Real(LocalPath(\"lib.rs\"))"],"SmallVecData::<A>::from_heap":["#[inline]\nfn from_heap(ptr: *mut A::Item, len: usize) -> SmallVecData<A>{\n        SmallVecData::Heap((ptr, len))\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVecData::<A>::from_inline":["#[inline]\nfn from_inline(inline: A) -> SmallVecData<A>{\n        SmallVecData::Inline(ManuallyDrop::new(inline))\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVecData::<A>::heap":["#[inline]\nunsafe fn heap(&self) -> (*mut A::Item, usize){\n        match *self {\n            SmallVecData::Heap(data) => data,\n            _ => debug_unreachable!(),\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVecData::<A>::heap_mut":["#[inline]\nunsafe fn heap_mut(&mut self) -> &mut (*mut A::Item, usize){\n        match *self {\n            SmallVecData::Heap(ref mut data) => data,\n            _ => debug_unreachable!(),\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVecData::<A>::inline":["#[inline]\nunsafe fn inline(&self) -> &A{\n        match *self {\n            SmallVecData::Inline(ref a) => a,\n            _ => debug_unreachable!(),\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVecData::<A>::inline_mut":["#[inline]\nunsafe fn inline_mut(&mut self) -> &mut A{\n        match *self {\n            SmallVecData::Inline(ref mut a) => a,\n            _ => debug_unreachable!(),\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"SmallVecData::<A>::into_inline":["#[inline]\nunsafe fn into_inline(self) -> A{\n        match self {\n            SmallVecData::Inline(a) => ManuallyDrop::into_inner(a),\n            _ => debug_unreachable!(),\n        }\n    }","Real(LocalPath(\"lib.rs\"))"],"VecLike":["/// Common operations implemented by both `Vec` and `SmallVec`.\n///\n/// This can be used to write generic code that works with both `Vec` and `SmallVec`.\n///\n/// ## Example\n///\n/// ```rust\n/// use smallvec::{VecLike, SmallVec};\n///\n/// fn initialize<V: VecLike<u8>>(v: &mut V) {\n///     for i in 0..5 {\n///         v.push(i);\n///     }\n/// }\n///\n/// let mut vec = Vec::new();\n/// initialize(&mut vec);\n///\n/// let mut small_vec = SmallVec::<[u8; 8]>::new();\n/// initialize(&mut small_vec);\n/// ```\n#[deprecated(note = \"Use `Extend` and `Deref<[T]>` instead\")]\npub trait VecLike<T>:\n        ops::Index<usize, Output=T> +\n        ops::IndexMut<usize> +\n        ops::Index<ops::Range<usize>, Output=[T]> +\n        ops::IndexMut<ops::Range<usize>> +\n        ops::Index<ops::RangeFrom<usize>, Output=[T]> +\n        ops::IndexMut<ops::RangeFrom<usize>> +\n        ops::Index<ops::RangeTo<usize>, Output=[T]> +\n        ops::IndexMut<ops::RangeTo<usize>> +\n        ops::Index<ops::RangeFull, Output=[T]> +\n        ops::IndexMut<ops::RangeFull> +\n        ops::DerefMut<Target = [T]> +\n        Extend<T> {\n\n    /// Append an element to the vector.\n    fn push(&mut self, value: T);\n}","Real(LocalPath(\"lib.rs\"))"],"deallocate":["unsafe fn deallocate<T>(ptr: *mut T, capacity: usize){\n    let _vec: Vec<T> = Vec::from_raw_parts(ptr, 0, capacity);\n    // Let it drop.\n}","Real(LocalPath(\"lib.rs\"))"]},"struct_constructor":{"&<A as Array>::Item":["index"],"&[<A as Array>::Item]":["as_ref","as_slice","borrow","deref","index"],"&mut (*mut <A as Array>::Item, usize)":["heap_mut"],"&mut <A as Array>::Item":["index_mut"],"&mut [<A as Array>::Item]":["as_mut","as_mut_slice","borrow_mut","deref_mut","index_mut"],"(*const <A as Array>::Item, usize, usize)":["triple"],"(*mut <A as Array>::Item, &mut usize, usize)":["triple_mut"],"(*mut <A as Array>::Item, usize)":["heap"],"(usize, std::option::Option<usize>)":["size_hint"],"*const <Self as Array>::Item":["ptr"],"*mut <Self as Array>::Item":["ptr_mut"],"<&'a SmallVec<A> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a mut SmallVec<A> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<A as Array>::Item":["next","next_back","pop","remove","swap_remove"],"<SmallVec<A> as std::iter::IntoIterator>::IntoIter":["into_iter"],"Drain":["drain"],"SetLenOnDrop":["new"],"SmallVec":["clone","default","from","from_buf","from_buf_and_len","from_buf_and_len_unchecked","from_elem","from_iter","from_raw_parts","from_slice","from_vec","new","with_capacity"],"SmallVecData":["from_heap","from_inline"],"bool":["eq","is_empty","ne","spilled"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::vec::Vec":["into_vec"],"usize":["capacity","inline_size","len","size","write"]},"struct_to_trait":{"Drain":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::ops::Drop"],"IntoIter":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::ops::Drop"],"SetLenOnDrop":["std::ops::Drop"],"SmallVec":["ExtendFromSlice","VecLike","std::borrow::Borrow","std::borrow::BorrowMut","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsMut","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::hash::Hash","std::io::Write","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::marker::Send","std::ops::Deref","std::ops::DerefMut","std::ops::Drop","std::ops::Index","std::ops::IndexMut"],"SmallVecData":["std::marker::Send","std::marker::Sync"],"std::vec::Vec":["ExtendFromSlice","VecLike"]},"targets":{"<&'a SmallVec<A> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"lib.rs\"))","std::iter::IntoIterator"],"<&'a mut SmallVec<A> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"lib.rs\"))","std::iter::IntoIterator"],"<Drain<'a, T> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"lib.rs\"))","std::iter::DoubleEndedIterator"],"<Drain<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"lib.rs\"))","std::iter::Iterator"],"<Drain<'a, T> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"lib.rs\"))","std::iter::Iterator"],"<Drain<'a, T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"lib.rs\"))","std::ops::Drop"],"<IntoIter<A> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"lib.rs\"))","std::iter::DoubleEndedIterator"],"<IntoIter<A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"lib.rs\"))","std::iter::Iterator"],"<IntoIter<A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"lib.rs\"))","std::iter::Iterator"],"<IntoIter<A> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"lib.rs\"))","std::ops::Drop"],"<SetLenOnDrop<'a> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"lib.rs\"))","std::ops::Drop"],"<SmallVec<A> as ExtendFromSlice<<A as Array>::Item>>::extend_from_slice":["extend_from_slice","Real(LocalPath(\"lib.rs\"))","ExtendFromSlice"],"<SmallVec<A> as VecLike<<A as Array>::Item>>::push":["push","Real(LocalPath(\"lib.rs\"))","VecLike"],"<SmallVec<A> as std::borrow::Borrow<[<A as Array>::Item]>>::borrow":["borrow","Real(LocalPath(\"lib.rs\"))","std::borrow::Borrow"],"<SmallVec<A> as std::borrow::BorrowMut<[<A as Array>::Item]>>::borrow_mut":["borrow_mut","Real(LocalPath(\"lib.rs\"))","std::borrow::BorrowMut"],"<SmallVec<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"lib.rs\"))","std::clone::Clone"],"<SmallVec<A> as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"lib.rs\"))","std::cmp::Ord"],"<SmallVec<A> as std::cmp::PartialEq<SmallVec<B>>>::eq":["eq","Real(LocalPath(\"lib.rs\"))","std::cmp::PartialEq"],"<SmallVec<A> as std::cmp::PartialEq<SmallVec<B>>>::ne":["ne","Real(LocalPath(\"lib.rs\"))","std::cmp::PartialEq"],"<SmallVec<A> as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"lib.rs\"))","std::cmp::PartialOrd"],"<SmallVec<A> as std::convert::AsMut<[<A as Array>::Item]>>::as_mut":["as_mut","Real(LocalPath(\"lib.rs\"))","std::convert::AsMut"],"<SmallVec<A> as std::convert::AsRef<[<A as Array>::Item]>>::as_ref":["as_ref","Real(LocalPath(\"lib.rs\"))","std::convert::AsRef"],"<SmallVec<A> as std::convert::From<&'a [<A as Array>::Item]>>::from":["from","Real(LocalPath(\"lib.rs\"))","std::convert::From"],"<SmallVec<A> as std::convert::From<A>>::from":["from","Real(LocalPath(\"lib.rs\"))","std::convert::From"],"<SmallVec<A> as std::convert::From<std::vec::Vec<<A as Array>::Item>>>::from":["from","Real(LocalPath(\"lib.rs\"))","std::convert::From"],"<SmallVec<A> as std::default::Default>::default":["default","Real(LocalPath(\"lib.rs\"))","std::default::Default"],"<SmallVec<A> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"lib.rs\"))","std::fmt::Debug"],"<SmallVec<A> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"lib.rs\"))","std::hash::Hash"],"<SmallVec<A> as std::io::Write>::flush":["flush","Real(LocalPath(\"lib.rs\"))","std::io::Write"],"<SmallVec<A> as std::io::Write>::write":["write","Real(LocalPath(\"lib.rs\"))","std::io::Write"],"<SmallVec<A> as std::io::Write>::write_all":["write_all","Real(LocalPath(\"lib.rs\"))","std::io::Write"],"<SmallVec<A> as std::iter::Extend<<A as Array>::Item>>::extend":["extend","Real(LocalPath(\"lib.rs\"))","std::iter::Extend"],"<SmallVec<A> as std::iter::FromIterator<<A as Array>::Item>>::from_iter":["from_iter","Real(LocalPath(\"lib.rs\"))","std::iter::FromIterator"],"<SmallVec<A> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"lib.rs\"))","std::iter::IntoIterator"],"<SmallVec<A> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"lib.rs\"))","std::ops::Deref"],"<SmallVec<A> as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"lib.rs\"))","std::ops::DerefMut"],"<SmallVec<A> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"lib.rs\"))","std::ops::Drop"],"<SmallVec<A> as std::ops::Index<std::ops::Range<usize>>>::index":["index","Real(LocalPath(\"lib.rs\"))","std::ops::Index"],"<SmallVec<A> as std::ops::Index<std::ops::RangeFrom<usize>>>::index":["index","Real(LocalPath(\"lib.rs\"))","std::ops::Index"],"<SmallVec<A> as std::ops::Index<std::ops::RangeFull>>::index":["index","Real(LocalPath(\"lib.rs\"))","std::ops::Index"],"<SmallVec<A> as std::ops::Index<std::ops::RangeTo<usize>>>::index":["index","Real(LocalPath(\"lib.rs\"))","std::ops::Index"],"<SmallVec<A> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"lib.rs\"))","std::ops::Index"],"<SmallVec<A> as std::ops::IndexMut<std::ops::Range<usize>>>::index_mut":["index_mut","Real(LocalPath(\"lib.rs\"))","std::ops::IndexMut"],"<SmallVec<A> as std::ops::IndexMut<std::ops::RangeFrom<usize>>>::index_mut":["index_mut","Real(LocalPath(\"lib.rs\"))","std::ops::IndexMut"],"<SmallVec<A> as std::ops::IndexMut<std::ops::RangeFull>>::index_mut":["index_mut","Real(LocalPath(\"lib.rs\"))","std::ops::IndexMut"],"<SmallVec<A> as std::ops::IndexMut<std::ops::RangeTo<usize>>>::index_mut":["index_mut","Real(LocalPath(\"lib.rs\"))","std::ops::IndexMut"],"<SmallVec<A> as std::ops::IndexMut<usize>>::index_mut":["index_mut","Real(LocalPath(\"lib.rs\"))","std::ops::IndexMut"],"<[T; 0] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 0] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 0] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 1024] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 1024] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 1024] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 1048576] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 1048576] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 1048576] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 10] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 10] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 10] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 11] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 11] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 11] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 128] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 128] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 128] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 12] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 12] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 12] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 131072] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 131072] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 131072] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 13] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 13] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 13] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 14] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 14] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 14] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 15] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 15] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 15] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 16384] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 16384] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 16384] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 16] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 16] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 16] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 1] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 1] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 1] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 2048] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 2048] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 2048] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 20] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 20] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 20] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 24] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 24] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 24] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 256] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 256] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 256] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 262144] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 262144] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 262144] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 2] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 2] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 2] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 32768] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 32768] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 32768] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 32] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 32] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 32] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 36] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 36] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 36] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 3] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 3] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 3] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 4096] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 4096] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 4096] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 4] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 4] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 4] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 512] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 512] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 512] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 524288] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 524288] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 524288] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 5] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 5] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 5] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 64] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 64] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 64] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 65536] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 65536] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 65536] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 6] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 6] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 6] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 7] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 7] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 7] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 8192] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 8192] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 8192] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 8] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 8] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 8] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 9] as Array>::ptr":["ptr","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 9] as Array>::ptr_mut":["ptr_mut","Real(LocalPath(\"lib.rs\"))","Array"],"<[T; 9] as Array>::size":["size","Real(LocalPath(\"lib.rs\"))","Array"],"<std::vec::Vec<T> as ExtendFromSlice<T>>::extend_from_slice":["extend_from_slice","Real(LocalPath(\"lib.rs\"))","ExtendFromSlice"],"<std::vec::Vec<T> as VecLike<T>>::push":["push","Real(LocalPath(\"lib.rs\"))","VecLike"],"SetLenOnDrop::<'a>::increment_len":["increment_len","Real(LocalPath(\"lib.rs\"))",""],"SetLenOnDrop::<'a>::new":["new","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::as_mut_slice":["as_mut_slice","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::as_slice":["as_slice","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::capacity":["capacity","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::clear":["clear","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::dedup":["dedup","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::dedup_by":["dedup_by","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::dedup_by_key":["dedup_by_key","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::drain":["drain","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::extend_from_slice":["extend_from_slice","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::from_buf":["from_buf","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::from_buf_and_len":["from_buf_and_len","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::from_buf_and_len_unchecked":["from_buf_and_len_unchecked","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::from_elem":["from_elem","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::from_raw_parts":["from_raw_parts","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::from_slice":["from_slice","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::from_vec":["from_vec","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::grow":["grow","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::inline_size":["inline_size","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::insert":["insert","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::insert_from_slice":["insert_from_slice","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::insert_many":["insert_many","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::into_inner":["into_inner","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::into_vec":["into_vec","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::is_empty":["is_empty","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::len":["len","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::new":["new","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::pop":["pop","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::push":["push","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::remove":["remove","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::reserve":["reserve","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::reserve_exact":["reserve_exact","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::resize":["resize","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::retain":["retain","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::set_len":["set_len","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::shrink_to_fit":["shrink_to_fit","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::spilled":["spilled","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::swap_remove":["swap_remove","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::triple":["triple","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::triple_mut":["triple_mut","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::truncate":["truncate","Real(LocalPath(\"lib.rs\"))",""],"SmallVec::<A>::with_capacity":["with_capacity","Real(LocalPath(\"lib.rs\"))",""],"SmallVecData::<A>::from_heap":["from_heap","Real(LocalPath(\"lib.rs\"))",""],"SmallVecData::<A>::from_inline":["from_inline","Real(LocalPath(\"lib.rs\"))",""],"SmallVecData::<A>::heap":["heap","Real(LocalPath(\"lib.rs\"))",""],"SmallVecData::<A>::heap_mut":["heap_mut","Real(LocalPath(\"lib.rs\"))",""],"SmallVecData::<A>::inline":["inline","Real(LocalPath(\"lib.rs\"))",""],"SmallVecData::<A>::inline_mut":["inline_mut","Real(LocalPath(\"lib.rs\"))",""],"SmallVecData::<A>::into_inline":["into_inline","Real(LocalPath(\"lib.rs\"))",""],"deallocate":["deallocate","Real(LocalPath(\"lib.rs\"))",""]},"trait_to_struct":{"ExtendFromSlice":["SmallVec","std::vec::Vec"],"VecLike":["SmallVec","std::vec::Vec"],"std::borrow::Borrow":["SmallVec"],"std::borrow::BorrowMut":["SmallVec"],"std::clone::Clone":["SmallVec"],"std::cmp::Eq":["SmallVec"],"std::cmp::Ord":["SmallVec"],"std::cmp::PartialEq":["SmallVec"],"std::cmp::PartialOrd":["SmallVec"],"std::convert::AsMut":["SmallVec"],"std::convert::AsRef":["SmallVec"],"std::convert::From":["SmallVec"],"std::default::Default":["SmallVec"],"std::fmt::Debug":["SmallVec"],"std::hash::Hash":["SmallVec"],"std::io::Write":["SmallVec"],"std::iter::DoubleEndedIterator":["Drain","IntoIter"],"std::iter::ExactSizeIterator":["Drain","IntoIter"],"std::iter::Extend":["SmallVec"],"std::iter::FromIterator":["SmallVec"],"std::iter::IntoIterator":["SmallVec"],"std::iter::Iterator":["Drain","IntoIter"],"std::marker::Send":["SmallVec","SmallVecData"],"std::marker::Sync":["SmallVecData"],"std::ops::Deref":["SmallVec"],"std::ops::DerefMut":["SmallVec"],"std::ops::Drop":["Drain","IntoIter","SetLenOnDrop","SmallVec"],"std::ops::Index":["SmallVec"],"std::ops::IndexMut":["SmallVec"]},"type_to_def_path":{"Drain<'a, T>":"Drain","IntoIter<A>":"IntoIter","SetLenOnDrop<'a>":"SetLenOnDrop","SmallVec<A>":"SmallVec","SmallVecData<A>":"SmallVecData"}}