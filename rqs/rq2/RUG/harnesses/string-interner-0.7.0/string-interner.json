{"dependencies":{"<InternalStrRef as std::clone::Clone>::clone":["InternalStrRef"],"<InternalStrRef as std::cmp::Eq>::assert_receiver_is_total_eq":["InternalStrRef"],"<InternalStrRef as std::cmp::PartialEq>::eq":["InternalStrRef"],"<InternalStrRef as std::convert::From<T>>::from":["InternalStrRef"],"<InternalStrRef as std::fmt::Debug>::fmt":["InternalStrRef","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<InternalStrRef as std::hash::Hash>::hash":["InternalStrRef","std::hash::Hasher","std::marker::Sized"],"<IntoIter<S> as std::iter::Iterator>::next":["InternalStrRef","IntoIter","Sym","Symbol","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::iter::Enumerate","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option"],"<IntoIter<S> as std::iter::Iterator>::size_hint":["InternalStrRef","IntoIter","Sym","Symbol","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::iter::Enumerate","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option"],"<Iter<'a, S> as std::iter::Iterator>::next":["Iter","std::iter::Enumerate","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<Iter<'a, S> as std::iter::Iterator>::size_hint":["Iter","std::iter::Enumerate","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<StringInterner<S, H> as std::clone::Clone>::clone":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"<StringInterner<S, H> as std::cmp::Eq>::assert_receiver_is_total_eq":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"<StringInterner<S, H> as std::cmp::PartialEq>::eq":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"<StringInterner<S, H> as std::fmt::Debug>::fmt":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::fmt::Formatter","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::result::Result","std::vec::Vec"],"<StringInterner<S, H> as std::iter::IntoIterator>::into_iter":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"<StringInterner<S> as std::iter::FromIterator<T>>::from_iter":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::iter::IntoIterator","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"<StringInterner<Sym> as std::default::Default>::default":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"<Sym as Symbol>::from_usize":["Sym","std::num::NonZeroU32"],"<Sym as Symbol>::to_usize":["Sym","std::num::NonZeroU32"],"<Sym as std::clone::Clone>::clone":["Sym","std::num::NonZeroU32"],"<Sym as std::cmp::Eq>::assert_receiver_is_total_eq":["Sym","std::num::NonZeroU32"],"<Sym as std::cmp::Ord>::cmp":["Sym","std::cmp::Ordering","std::num::NonZeroU32"],"<Sym as std::cmp::PartialEq>::eq":["Sym","std::num::NonZeroU32"],"<Sym as std::cmp::PartialOrd>::partial_cmp":["Sym","std::marker::Sized","std::num::NonZeroU32","std::option::Option"],"<Sym as std::fmt::Debug>::fmt":["Sym","std::fmt::Formatter","std::marker::Sized","std::num::NonZeroU32","std::result::Result"],"<Sym as std::hash::Hash>::hash":["Sym","std::hash::Hasher","std::marker::Sized","std::num::NonZeroU32"],"<Values<'a, S> as std::iter::Iterator>::next":["InternalStrRef","Sym","Symbol","Values","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::slice::Iter"],"<Values<'a, S> as std::iter::Iterator>::size_hint":["InternalStrRef","Sym","Symbol","Values","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::slice::Iter"],"<serde_impl::StringInternerVisitor<Sym, H> as serde::de::Visitor<'de>>::expecting":["InternalStrRef","Sym","Symbol","serde_impl::StringInternerVisitor","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Formatter","std::hash::BuildHasher","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::result::Result"],"<serde_impl::StringInternerVisitor<Sym, H> as serde::de::Visitor<'de>>::visit_seq":["InternalStrRef","Sym","Symbol","serde::de::SeqAccess","serde_impl::StringInternerVisitor","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::hash::BuildHasher","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::result::Result"],"<serde_impl::StringInternerVisitor<Sym, H> as std::default::Default>::default":["InternalStrRef","Sym","Symbol","serde_impl::StringInternerVisitor","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::hash::BuildHasher","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32"],"<usize as Symbol>::from_usize":[],"<usize as Symbol>::to_usize":[],"InternalStrRef":["InternalStrRef"],"InternalStrRef::as_str":["InternalStrRef"],"InternalStrRef::from_str":["InternalStrRef"],"IntoIter":["InternalStrRef","IntoIter","Sym","Symbol","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::iter::Enumerate","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32"],"Iter":["Iter","std::iter::Enumerate","std::marker::PhantomData","std::marker::Sized"],"Iter::<'a, S>::new":["InternalStrRef","Iter","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::iter::Enumerate","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S, H>::get":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::convert::AsRef","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::vec::Vec"],"StringInterner::<S, H>::get_or_intern":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::convert::AsRef","std::convert::Into","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S, H>::intern":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::convert::AsRef","std::convert::Into","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S, H>::is_empty":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S, H>::iter":["InternalStrRef","Iter","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::iter::Enumerate","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S, H>::iter_values":["InternalStrRef","StringInterner","Sym","Symbol","Values","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::slice::Iter","std::vec::Vec"],"StringInterner::<S, H>::len":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S, H>::make_symbol":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S, H>::resolve":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::option::Option","std::vec::Vec"],"StringInterner::<S, H>::resolve_unchecked":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S, H>::shrink_to_fit":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S, H>::with_capacity_and_hasher":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S, H>::with_hasher":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S>::capacity":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S>::new":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S>::reserve":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"StringInterner::<S>::with_capacity":["InternalStrRef","StringInterner","Sym","Symbol","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::vec::Vec"],"Sym":["Sym","std::num::NonZeroU32"],"Symbol::from_usize":[],"Symbol::to_usize":[],"Values":["InternalStrRef","Sym","Symbol","Values","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::slice::Iter"],"Values::<'a, S>::new":["InternalStrRef","StringInterner","Sym","Symbol","Values","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32","std::slice::Iter","std::vec::Vec"],"serde_impl::<impl serde::Deserialize<'de> for StringInterner<Sym, H>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"serde_impl::<impl serde::Serialize for StringInterner<Sym, H>>::serialize":["InternalStrRef","StringInterner","Sym","Symbol","serde::Serializer","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::collections::HashMap","std::hash::BuildHasher","std::marker::Copy","std::marker::Sized","std::num::NonZeroU32","std::result::Result","std::vec::Vec"],"serde_impl::StringInternerVisitor":["InternalStrRef","Sym","Symbol","serde_impl::StringInternerVisitor","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::hash::BuildHasher","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::num::NonZeroU32"]},"glob_path_import":{},"self_to_fn":{"InternalStrRef":["Clone","Copy","Debug","Eq","impl Hash for InternalStrRef {\n\tfn hash<H: Hasher>(&self, state: &mut H) {\n\t\tself.as_str().hash(state)\n\t}\n}","impl InternalStrRef {\n\t/// Creates an InternalStrRef from a str.\n\t///\n\t/// This just wraps the str internally.\n\tfn from_str(val: &str) -> Self {\n\t\tInternalStrRef(val as *const str)\n\t}\n\n\t/// Reinterprets this InternalStrRef as a str.\n\t///\n\t/// This is \"safe\" as long as this InternalStrRef only\n\t/// refers to strs that outlive this instance or\n\t/// the instance that owns this InternalStrRef.\n\t/// This should hold true for `StringInterner`.\n\t///\n\t/// Does not allocate memory!\n\tfn as_str(&self) -> &str {\n\t\tunsafe { &*self.0 }\n\t}\n}","impl PartialEq for InternalStrRef {\n\tfn eq(&self, other: &InternalStrRef) -> bool {\n\t\tself.as_str() == other.as_str()\n\t}\n}","impl<T> From<T> for InternalStrRef\nwhere\n\tT: AsRef<str>,\n{\n\tfn from(val: T) -> Self {\n\t\tInternalStrRef::from_str(val.as_ref())\n\t}\n}"],"IntoIter":["impl<S> Iterator for IntoIter<S>\nwhere\n\tS: Symbol,\n{\n\ttype Item = (S, String);\n\n\tfn next(&mut self) -> Option<Self::Item> {\n\t\tself.iter\n\t\t\t.next()\n\t\t\t.map(|(num, boxed_str)| (S::from_usize(num), boxed_str.into_string()))\n\t}\n\n\t#[inline]\n\tfn size_hint(&self) -> (usize, Option<usize>) {\n\t\tself.iter.size_hint()\n\t}\n}"],"Iter":["impl<'a, S> Iter<'a, S>\nwhere\n\tS: Symbol + 'a,\n{\n\t/// Creates a new iterator for the given StringIterator over pairs of\n\t/// symbols and their associated interned string.\n\t#[inline]\n\tfn new<H>(interner: &'a StringInterner<S, H>) -> Self\n\twhere\n\t\tH: BuildHasher,\n\t{\n\t\tIter {\n\t\t\titer: interner.values.iter().enumerate(),\n\t\t\tmark: marker::PhantomData,\n\t\t}\n\t}\n}","impl<'a, S> Iterator for Iter<'a, S>\nwhere\n\tS: Symbol + 'a,\n{\n\ttype Item = (S, &'a str);\n\n\t#[inline]\n\tfn next(&mut self) -> Option<Self::Item> {\n\t\tself.iter\n\t\t\t.next()\n\t\t\t.map(|(num, boxed_str)| (S::from_usize(num), boxed_str.as_ref()))\n\t}\n\n\t#[inline]\n\tfn size_hint(&self) -> (usize, Option<usize>) {\n\t\tself.iter.size_hint()\n\t}\n}"],"StringInterner":["Clone","Debug","Eq","impl Default for StringInterner<Sym, RandomState> {\n\t#[inline]\n\tfn default() -> Self {\n\t\tStringInterner::new()\n\t}\n}","impl<'de, Sym, H> Deserialize<'de> for StringInterner<Sym, H>\n\twhere Sym: Symbol,\n\t      H  : BuildHasher + Default\n{\n\tfn deserialize<D>(deserializer: D) -> Result<StringInterner<Sym, H>, D::Error>\n\t\twhere D: Deserializer<'de>\n\t{\n\t\tdeserializer.deserialize_seq(StringInternerVisitor::default())\n\t}\n}","impl<S, H> PartialEq for StringInterner<S, H>\nwhere\n\tS: Symbol,\n\tH: BuildHasher,\n{\n\tfn eq(&self, rhs: &Self) -> bool {\n\t\tself.len() == rhs.len() && self.values == rhs.values\n\t}\n}","impl<S, H> StringInterner<S, H>\nwhere\n\tS: Symbol,\n\tH: BuildHasher,\n{\n\t/// Creates a new empty `StringInterner` with the given hasher.\n\t#[inline]\n\tpub fn with_hasher(hash_builder: H) -> StringInterner<S, H> {\n\t\tStringInterner {\n\t\t\tmap: HashMap::with_hasher(hash_builder),\n\t\t\tvalues: Vec::new(),\n\t\t}\n\t}\n\n\t/// Creates a new empty `StringInterner` with the given initial capacity and the given hasher.\n\t#[inline]\n\tpub fn with_capacity_and_hasher(cap: usize, hash_builder: H) -> StringInterner<S, H> {\n\t\tStringInterner {\n\t\t\tmap: HashMap::with_hasher(hash_builder),\n\t\t\tvalues: Vec::with_capacity(cap),\n\t\t}\n\t}\n\n\t/// Interns the given value.\n\t///\n\t/// Returns a symbol to access it within this interner.\n\t///\n\t/// This either copies the contents of the string (e.g. for str)\n\t/// or moves them into this interner (e.g. for String).\n\t#[inline]\n\tpub fn get_or_intern<T>(&mut self, val: T) -> S\n\twhere\n\t\tT: Into<String> + AsRef<str>,\n\t{\n\t\tmatch self.map.get(&val.as_ref().into()) {\n\t\t\tSome(&sym) => sym,\n\t\t\tNone => self.intern(val),\n\t\t}\n\t}\n\n\t/// Interns the given value and ignores collissions.\n\t///\n\t/// Returns a symbol to access it within this interner.\n\tfn intern<T>(&mut self, new_val: T) -> S\n\twhere\n\t\tT: Into<String> + AsRef<str>,\n\t{\n\t\tlet new_id: S = self.make_symbol();\n\t\tlet new_boxed_val = new_val.into().into_boxed_str();\n\t\tlet new_ref: InternalStrRef = new_boxed_val.as_ref().into();\n\t\tself.values.push(new_boxed_val);\n\t\tself.map.insert(new_ref, new_id);\n\t\tnew_id\n\t}\n\n\t/// Creates a new symbol for the current state of the interner.\n\tfn make_symbol(&self) -> S {\n\t\tS::from_usize(self.len())\n\t}\n\n\t/// Returns the string slice associated with the given symbol if available,\n\t/// otherwise returns `None`.\n\t#[inline]\n\tpub fn resolve(&self, symbol: S) -> Option<&str> {\n\t\tself.values\n\t\t\t.get(symbol.to_usize())\n\t\t\t.map(|boxed_str| boxed_str.as_ref())\n\t}\n\n\t/// Returns the string associated with the given symbol.\n\t///\n\t/// # Note\n\t///\n\t/// This does not check whether the given symbol has an associated string\n\t/// for the given string interner instance.\n\t///\n\t/// # Safety\n\t///\n\t/// This will result in undefined behaviour if the given symbol\n\t/// had no associated string for this interner instance.\n\t#[inline]\n\tpub unsafe fn resolve_unchecked(&self, symbol: S) -> &str {\n\t\tself.values.get_unchecked(symbol.to_usize()).as_ref()\n\t}\n\n\t/// Returns the symbol associated with the given string for this interner\n\t/// if existent, otherwise returns `None`.\n\t#[inline]\n\tpub fn get<T>(&self, val: T) -> Option<S>\n\twhere\n\t\tT: AsRef<str>,\n\t{\n\t\tself.map.get(&val.as_ref().into()).cloned()\n\t}\n\n\t/// Returns the number of uniquely interned strings within this interner.\n\t#[inline]\n\tpub fn len(&self) -> usize {\n\t\tself.values.len()\n\t}\n\n\t/// Returns true if the string interner holds no elements.\n\t#[inline]\n\tpub fn is_empty(&self) -> bool {\n\t\tself.len() == 0\n\t}\n\n\t/// Returns an iterator over the interned strings.\n\t#[inline]\n\tpub fn iter(&self) -> Iter<S> {\n\t\tIter::new(self)\n\t}\n\n\t/// Returns an iterator over all intern indices and their associated strings.\n\t#[inline]\n\tpub fn iter_values(&self) -> Values<S> {\n\t\tValues::new(self)\n\t}\n\n\t/// Shrinks the capacity of the interner as much as possible.\n\tpub fn shrink_to_fit(&mut self) {\n\t\tself.map.shrink_to_fit();\n\t\tself.values.shrink_to_fit();\n\t}\n}","impl<S, H> iter::IntoIterator for StringInterner<S, H>\nwhere\n\tS: Symbol,\n\tH: BuildHasher,\n{\n\ttype Item = (S, String);\n\ttype IntoIter = IntoIter<S>;\n\n\tfn into_iter(self) -> Self::IntoIter {\n\t\tIntoIter {\n\t\t\titer: self.values.into_iter().enumerate(),\n\t\t\tmark: marker::PhantomData,\n\t\t}\n\t}\n}","impl<S> StringInterner<S>\nwhere\n\tS: Symbol,\n{\n\t/// Creates a new empty `StringInterner`.\n\t#[inline]\n\tpub fn new() -> StringInterner<S, RandomState> {\n\t\tStringInterner {\n\t\t\tmap: HashMap::new(),\n\t\t\tvalues: Vec::new(),\n\t\t}\n\t}\n\n\t/// Creates a new `StringInterner` with the given initial capacity.\n\t#[inline]\n\tpub fn with_capacity(cap: usize) -> Self {\n\t\tStringInterner {\n\t\t\tmap: HashMap::with_capacity(cap),\n\t\t\tvalues: Vec::with_capacity(cap),\n\t\t}\n\t}\n\n\t/// Returns the number of elements the `StringInterner` can hold without reallocating.\n\t#[inline]\n\tpub fn capacity(&self) -> usize {\n\t\tstd::cmp::min(self.map.capacity(), self.values.capacity())\n\t}\n\n\t/// Reserves capacity for at least `additional` more elements to be interned into `self`.\n\t///\n\t/// The collection may reserve more space to avoid frequent allocations.\n\t/// After calling `reserve`, capacity will be greater than or equal to `self.len() + additional`.\n\t/// Does nothing if capacity is already sufficient.\n\t#[inline]\n\tpub fn reserve(&mut self, additional: usize) {\n\t\tself.map.reserve(additional);\n\t\tself.values.reserve(additional);\n\t}\n}","impl<Sym, H> Serialize for StringInterner<Sym, H>\n\twhere Sym: Symbol,\n\t      H  : BuildHasher\n{\n\tfn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n\t\twhere S: Serializer\n\t{\n\t\tlet mut seq = serializer.serialize_seq(Some(self.len()))?;\n\t\tfor s in self.iter_values() {\n\t\t\tseq.serialize_element(s)?\n\t\t}\n\t\tseq.end()\n\t}\n}","impl<T, S> FromIterator<T> for StringInterner<S>\nwhere\n\tS: Symbol,\n\tT: Into<String> + AsRef<str>,\n{\n\tfn from_iter<I>(iter: I) -> Self\n\twhere\n\t\tI: IntoIterator<Item = T>,\n\t{\n\t\tlet mut interner = StringInterner::new();\n\t\tfor s in iter.into_iter() {\n\t\t\tinterner.get_or_intern(s);\n\t\t}\n\t\tinterner\n\t}\n}","unsafe impl<S, H> Send for StringInterner<S, H>\nwhere\n\tS: Symbol + Send,\n\tH: BuildHasher,\n{\n}","unsafe impl<S, H> Sync for StringInterner<S, H>\nwhere\n\tS: Symbol + Sync,\n\tH: BuildHasher,\n{\n}"],"Sym":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Symbol for Sym {\n\t/// Creates a `Sym` from the given `usize`.\n\t///\n\t/// # Panics\n\t///\n\t/// If the given `usize` is greater than `u32::MAX - 1`.\n\tfn from_usize(val: usize) -> Self {\n\t\tassert!(val < u32::MAX as usize);\n\t\tSym(unsafe { NonZeroU32::new_unchecked((val + 1) as u32) })\n\t}\n\n\tfn to_usize(self) -> usize {\n\t\t(self.0.get() as usize) - 1\n\t}\n}"],"Values":["impl<'a, S> Iterator for Values<'a, S>\nwhere\n\tS: Symbol + 'a,\n{\n\ttype Item = &'a str;\n\n\t#[inline]\n\tfn next(&mut self) -> Option<Self::Item> {\n\t\tself.iter.next().map(|boxed_str| boxed_str.as_ref())\n\t}\n\n\t#[inline]\n\tfn size_hint(&self) -> (usize, Option<usize>) {\n\t\tself.iter.size_hint()\n\t}\n}","impl<'a, S> Values<'a, S>\nwhere\n\tS: Symbol + 'a,\n{\n\t/// Creates a new iterator for the given StringIterator over its interned strings.\n\t#[inline]\n\tfn new<H>(interner: &'a StringInterner<S, H>) -> Self\n\twhere\n\t\tH: BuildHasher,\n\t{\n\t\tValues {\n\t\t\titer: interner.values.iter(),\n\t\t\tmark: marker::PhantomData,\n\t\t}\n\t}\n}"],"serde_impl::StringInternerVisitor":["impl<'de, Sym, H> Visitor<'de> for StringInternerVisitor<Sym, H>\n\twhere Sym: Symbol,\n\t      H  : BuildHasher + Default\n\t{\n\ttype Value = StringInterner<Sym, H>;\n\n\tfn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n\t\tformatter.write_str(\"Expected a contiguous sequence of strings.\")\n\t}\n\n\tfn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n\t\twhere A: SeqAccess<'de>\n\t{\n\t\tlet mut interner: StringInterner<Sym, H> = StringInterner::with_capacity_and_hasher(\n\t\t\tseq.size_hint().unwrap_or(0), H::default());\n\t\twhile let Some(s) = seq.next_element::<Box<str>>()? {\n\t\t\tinterner.get_or_intern(s);\n\t\t}\n\t\tOk(interner)\n\t}\n}","impl<Sym, H> Default for StringInternerVisitor<Sym, H>\n\twhere Sym: Symbol,\n\t      H  : BuildHasher\n{\n\tfn default() -> Self {\n\t\tStringInternerVisitor{ mark: marker::PhantomData }\n\t}\n}"]},"single_path_import":{},"srcs":{"<InternalStrRef as std::cmp::PartialEq>::eq":["fn eq(&self, other: &InternalStrRef) -> bool{\n\t\tself.as_str() == other.as_str()\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<InternalStrRef as std::convert::From<T>>::from":["fn from(val: T) -> Self{\n\t\tInternalStrRef::from_str(val.as_ref())\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<InternalStrRef as std::hash::Hash>::hash":["fn hash<H: Hasher>(&self, state: &mut H){\n\t\tself.as_str().hash(state)\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<S> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n\t\tself.iter\n\t\t\t.next()\n\t\t\t.map(|(num, boxed_str)| (S::from_usize(num), boxed_str.into_string()))\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<S> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n\t\tself.iter.size_hint()\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<Iter<'a, S> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n\t\tself.iter\n\t\t\t.next()\n\t\t\t.map(|(num, boxed_str)| (S::from_usize(num), boxed_str.as_ref()))\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<Iter<'a, S> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n\t\tself.iter.size_hint()\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<StringInterner<S, H> as std::cmp::PartialEq>::eq":["fn eq(&self, rhs: &Self) -> bool{\n\t\tself.len() == rhs.len() && self.values == rhs.values\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<StringInterner<S, H> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n\t\tIntoIter {\n\t\t\titer: self.values.into_iter().enumerate(),\n\t\t\tmark: marker::PhantomData,\n\t\t}\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<StringInterner<S> as std::iter::FromIterator<T>>::from_iter":["fn from_iter<I>(iter: I) -> Self\n\twhere\n\t\tI: IntoIterator<Item = T>,{\n\t\tlet mut interner = StringInterner::new();\n\t\tfor s in iter.into_iter() {\n\t\t\tinterner.get_or_intern(s);\n\t\t}\n\t\tinterner\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<StringInterner<Sym> as std::default::Default>::default":["#[inline]\nfn default() -> Self{\n\t\tStringInterner::new()\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<Sym as Symbol>::from_usize":["/// Creates a `Sym` from the given `usize`.\n///\n/// # Panics\n///\n/// If the given `usize` is greater than `u32::MAX - 1`.\nfn from_usize(val: usize) -> Self{\n\t\tassert!(val < u32::MAX as usize);\n\t\tSym(unsafe { NonZeroU32::new_unchecked((val + 1) as u32) })\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<Sym as Symbol>::to_usize":["fn to_usize(self) -> usize{\n\t\t(self.0.get() as usize) - 1\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<Values<'a, S> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n\t\tself.iter.next().map(|boxed_str| boxed_str.as_ref())\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<Values<'a, S> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n\t\tself.iter.size_hint()\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<serde_impl::StringInternerVisitor<Sym, H> as serde::de::Visitor<'de>>::expecting":["fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n\t\tformatter.write_str(\"Expected a contiguous sequence of strings.\")\n\t}","Real(LocalPath(\"src/serde_impl.rs\"))"],"<serde_impl::StringInternerVisitor<Sym, H> as serde::de::Visitor<'de>>::visit_seq":["fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n\t\twhere A: SeqAccess<'de>{\n\t\tlet mut interner: StringInterner<Sym, H> = StringInterner::with_capacity_and_hasher(\n\t\t\tseq.size_hint().unwrap_or(0), H::default());\n\t\twhile let Some(s) = seq.next_element::<Box<str>>()? {\n\t\t\tinterner.get_or_intern(s);\n\t\t}\n\t\tOk(interner)\n\t}","Real(LocalPath(\"src/serde_impl.rs\"))"],"<serde_impl::StringInternerVisitor<Sym, H> as std::default::Default>::default":["fn default() -> Self{\n\t\tStringInternerVisitor{ mark: marker::PhantomData }\n\t}","Real(LocalPath(\"src/serde_impl.rs\"))"],"<usize as Symbol>::from_usize":["fn from_usize(val: usize) -> Self{\n\t\tval\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"<usize as Symbol>::to_usize":["fn to_usize(self) -> usize{\n\t\tself\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"InternalStrRef":["/// Internal reference to `str` used only within the `StringInterner` itself\n/// to encapsulate the unsafe behaviour of interior references.\nstruct InternalStrRef(*const str);","Real(LocalPath(\"src/lib.rs\"))"],"InternalStrRef::as_str":["/// Reinterprets this InternalStrRef as a str.\n///\n/// This is \"safe\" as long as this InternalStrRef only\n/// refers to strs that outlive this instance or\n/// the instance that owns this InternalStrRef.\n/// This should hold true for `StringInterner`.\n///\n/// Does not allocate memory!\nfn as_str(&self) -> &str{\n\t\tunsafe { &*self.0 }\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"InternalStrRef::from_str":["/// Creates an InternalStrRef from a str.\n///\n/// This just wraps the str internally.\nfn from_str(val: &str) -> Self{\n\t\tInternalStrRef(val as *const str)\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"IntoIter":["/// Iterator over the pairs of associated symbol and strings.\n///\n/// Consumes the `StringInterner` upon usage.\npub struct IntoIter<S>\nwhere\n\tS: Symbol,\n{\n\titer: iter::Enumerate<vec::IntoIter<Box<str>>>,\n\tmark: marker::PhantomData<S>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Iter":["/// Iterator over the pairs of associated symbols and interned strings for a `StringInterner`.\npub struct Iter<'a, S> {\n\titer: iter::Enumerate<slice::Iter<'a, Box<str>>>,\n\tmark: marker::PhantomData<S>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Iter::<'a, S>::new":["/// Creates a new iterator for the given StringIterator over pairs of\n/// symbols and their associated interned string.\n#[inline]\nfn new<H>(interner: &'a StringInterner<S, H>) -> Self\n\twhere\n\t\tH: BuildHasher,{\n\t\tIter {\n\t\t\titer: interner.values.iter().enumerate(),\n\t\t\tmark: marker::PhantomData,\n\t\t}\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner":["/// Caches strings efficiently, with minimal memory footprint and associates them with unique symbols.\n/// These symbols allow constant time comparisons and look-ups to the underlying interned strings.\npub struct StringInterner<S, H = RandomState>\nwhere\n\tS: Symbol,\n\tH: BuildHasher,\n{\n\tmap: HashMap<InternalStrRef, S, H>,\n\tvalues: Vec<Box<str>>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S, H>::get":["/// Returns the symbol associated with the given string for this interner\n/// if existent, otherwise returns `None`.\n#[inline]\npub fn get<T>(&self, val: T) -> Option<S>\n\twhere\n\t\tT: AsRef<str>,{\n\t\tself.map.get(&val.as_ref().into()).cloned()\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S, H>::get_or_intern":["/// Interns the given value.\n///\n/// Returns a symbol to access it within this interner.\n///\n/// This either copies the contents of the string (e.g. for str)\n/// or moves them into this interner (e.g. for String).\n#[inline]\npub fn get_or_intern<T>(&mut self, val: T) -> S\n\twhere\n\t\tT: Into<String> + AsRef<str>,{\n\t\tmatch self.map.get(&val.as_ref().into()) {\n\t\t\tSome(&sym) => sym,\n\t\t\tNone => self.intern(val),\n\t\t}\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S, H>::intern":["/// Interns the given value and ignores collissions.\n///\n/// Returns a symbol to access it within this interner.\nfn intern<T>(&mut self, new_val: T) -> S\n\twhere\n\t\tT: Into<String> + AsRef<str>,{\n\t\tlet new_id: S = self.make_symbol();\n\t\tlet new_boxed_val = new_val.into().into_boxed_str();\n\t\tlet new_ref: InternalStrRef = new_boxed_val.as_ref().into();\n\t\tself.values.push(new_boxed_val);\n\t\tself.map.insert(new_ref, new_id);\n\t\tnew_id\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S, H>::is_empty":["/// Returns true if the string interner holds no elements.\n#[inline]\npub fn is_empty(&self) -> bool{\n\t\tself.len() == 0\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S, H>::iter":["/// Returns an iterator over the interned strings.\n#[inline]\npub fn iter(&self) -> Iter<S>{\n\t\tIter::new(self)\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S, H>::iter_values":["/// Returns an iterator over all intern indices and their associated strings.\n#[inline]\npub fn iter_values(&self) -> Values<S>{\n\t\tValues::new(self)\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S, H>::len":["/// Returns the number of uniquely interned strings within this interner.\n#[inline]\npub fn len(&self) -> usize{\n\t\tself.values.len()\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S, H>::make_symbol":["/// Creates a new symbol for the current state of the interner.\nfn make_symbol(&self) -> S{\n\t\tS::from_usize(self.len())\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S, H>::resolve":["/// Returns the string slice associated with the given symbol if available,\n/// otherwise returns `None`.\n#[inline]\npub fn resolve(&self, symbol: S) -> Option<&str>{\n\t\tself.values\n\t\t\t.get(symbol.to_usize())\n\t\t\t.map(|boxed_str| boxed_str.as_ref())\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S, H>::resolve_unchecked":["/// Returns the string associated with the given symbol.\n///\n/// # Note\n///\n/// This does not check whether the given symbol has an associated string\n/// for the given string interner instance.\n///\n/// # Safety\n///\n/// This will result in undefined behaviour if the given symbol\n/// had no associated string for this interner instance.\n#[inline]\npub unsafe fn resolve_unchecked(&self, symbol: S) -> &str{\n\t\tself.values.get_unchecked(symbol.to_usize()).as_ref()\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S, H>::shrink_to_fit":["/// Shrinks the capacity of the interner as much as possible.\npub fn shrink_to_fit(&mut self){\n\t\tself.map.shrink_to_fit();\n\t\tself.values.shrink_to_fit();\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S, H>::with_capacity_and_hasher":["/// Creates a new empty `StringInterner` with the given initial capacity and the given hasher.\n#[inline]\npub fn with_capacity_and_hasher(cap: usize, hash_builder: H) -> StringInterner<S, H>{\n\t\tStringInterner {\n\t\t\tmap: HashMap::with_hasher(hash_builder),\n\t\t\tvalues: Vec::with_capacity(cap),\n\t\t}\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S, H>::with_hasher":["/// Creates a new empty `StringInterner` with the given hasher.\n#[inline]\npub fn with_hasher(hash_builder: H) -> StringInterner<S, H>{\n\t\tStringInterner {\n\t\t\tmap: HashMap::with_hasher(hash_builder),\n\t\t\tvalues: Vec::new(),\n\t\t}\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S>::capacity":["/// Returns the number of elements the `StringInterner` can hold without reallocating.\n#[inline]\npub fn capacity(&self) -> usize{\n\t\tstd::cmp::min(self.map.capacity(), self.values.capacity())\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S>::new":["/// Creates a new empty `StringInterner`.\n#[inline]\npub fn new() -> StringInterner<S, RandomState>{\n\t\tStringInterner {\n\t\t\tmap: HashMap::new(),\n\t\t\tvalues: Vec::new(),\n\t\t}\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S>::reserve":["/// Reserves capacity for at least `additional` more elements to be interned into `self`.\n///\n/// The collection may reserve more space to avoid frequent allocations.\n/// After calling `reserve`, capacity will be greater than or equal to `self.len() + additional`.\n/// Does nothing if capacity is already sufficient.\n#[inline]\npub fn reserve(&mut self, additional: usize){\n\t\tself.map.reserve(additional);\n\t\tself.values.reserve(additional);\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"StringInterner::<S>::with_capacity":["/// Creates a new `StringInterner` with the given initial capacity.\n#[inline]\npub fn with_capacity(cap: usize) -> Self{\n\t\tStringInterner {\n\t\t\tmap: HashMap::with_capacity(cap),\n\t\t\tvalues: Vec::with_capacity(cap),\n\t\t}\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"Sym":["/// Symbol type used by the `DefaultStringInterner`.\n///\n/// # Note\n///\n/// This special symbol type has a memory footprint of 32 bits\n/// and allows for certain space optimizations such as using it within an option: `Option<Sym>`\npub struct Sym(NonZeroU32);","Real(LocalPath(\"src/lib.rs\"))"],"Symbol":["/// Types implementing this trait are able to act as symbols for string interners.\n///\n/// Symbols are returned by `StringInterner::get_or_intern` and allow look-ups of the\n/// original string contents with `StringInterner::resolve`.\n///\n/// # Note\n///\n/// Optimal symbols allow for efficient comparisons and have a small memory footprint.\npub trait Symbol: Copy + Ord + Eq {\n\t/// Creates a symbol from a `usize`.\n\t///\n\t/// # Note\n\t///\n\t/// Implementations panic if the operation cannot succeed.\n\tfn from_usize(val: usize) -> Self;\n\n\t/// Returns the `usize` representation of `self`.\n\tfn to_usize(self) -> usize;\n}","Real(LocalPath(\"src/lib.rs\"))"],"Values":["/// Iterator over the interned strings of a `StringInterner`.\npub struct Values<'a, S>\nwhere\n\tS: Symbol + 'a,\n{\n\titer: slice::Iter<'a, Box<str>>,\n\tmark: marker::PhantomData<S>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Values::<'a, S>::new":["/// Creates a new iterator for the given StringIterator over its interned strings.\n#[inline]\nfn new<H>(interner: &'a StringInterner<S, H>) -> Self\n\twhere\n\t\tH: BuildHasher,{\n\t\tValues {\n\t\t\titer: interner.values.iter(),\n\t\t\tmark: marker::PhantomData,\n\t\t}\n\t}","Real(LocalPath(\"src/lib.rs\"))"],"serde_impl::<impl serde::Deserialize<'de> for StringInterner<Sym, H>>::deserialize":["fn deserialize<D>(deserializer: D) -> Result<StringInterner<Sym, H>, D::Error>\n\t\twhere D: Deserializer<'de>{\n\t\tdeserializer.deserialize_seq(StringInternerVisitor::default())\n\t}","Real(LocalPath(\"src/serde_impl.rs\"))"],"serde_impl::<impl serde::Serialize for StringInterner<Sym, H>>::serialize":["fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n\t\twhere S: Serializer{\n\t\tlet mut seq = serializer.serialize_seq(Some(self.len()))?;\n\t\tfor s in self.iter_values() {\n\t\t\tseq.serialize_element(s)?\n\t\t}\n\t\tseq.end()\n\t}","Real(LocalPath(\"src/serde_impl.rs\"))"],"serde_impl::StringInternerVisitor":["struct StringInternerVisitor<Sym, H>\n\twhere Sym: Symbol, H: BuildHasher\n{\n\tmark: marker::PhantomData<(Sym, H)>\n}","Real(LocalPath(\"src/serde_impl.rs\"))"]},"struct_constructor":{"&str":["as_str","resolve","resolve_unchecked"],"(usize, std::option::Option<usize>)":["size_hint"],"<IntoIter<S> as std::iter::Iterator>::Item":["next"],"<Iter<'a, S> as std::iter::Iterator>::Item":["next"],"<S as serde::Serializer>::Ok":["serialize"],"<StringInterner<S, H> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<Values<'a, S> as std::iter::Iterator>::Item":["next"],"<serde_impl::StringInternerVisitor<Sym, H> as serde::de::Visitor<'de>>::Value":["visit_seq"],"InternalStrRef":["clone","from","from_str"],"Iter":["iter","new"],"StringInterner":["clone","default","deserialize","from_iter","new","with_capacity","with_capacity_and_hasher","with_hasher"],"Sym":["clone","from_usize"],"Values":["iter_values","new"],"bool":["eq","is_empty"],"serde_impl::StringInternerVisitor":["default"],"std::cmp::Ordering":["cmp","partial_cmp"],"usize":["capacity","len","to_usize"]},"struct_to_trait":{"InternalStrRef":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq"],"IntoIter":["std::iter::Iterator"],"Iter":["std::iter::Iterator"],"StringInterner":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::iter::FromIterator","std::iter::IntoIterator","std::marker::Send","std::marker::StructuralEq","std::marker::Sync"],"Sym":["Symbol","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"Values":["std::iter::Iterator"],"serde_impl::StringInternerVisitor":["serde::de::Visitor","std::default::Default"]},"targets":{"<InternalStrRef as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<InternalStrRef as std::convert::From<T>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","std::convert::From"],"<InternalStrRef as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/lib.rs\"))","std::hash::Hash"],"<IntoIter<S> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<IntoIter<S> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<Iter<'a, S> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<Iter<'a, S> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<StringInterner<S, H> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<StringInterner<S, H> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<StringInterner<S> as std::iter::FromIterator<T>>::from_iter":["from_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::FromIterator"],"<StringInterner<Sym> as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<Sym as Symbol>::from_usize":["from_usize","Real(LocalPath(\"src/lib.rs\"))","Symbol"],"<Sym as Symbol>::to_usize":["to_usize","Real(LocalPath(\"src/lib.rs\"))","Symbol"],"<Values<'a, S> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<Values<'a, S> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<serde_impl::StringInternerVisitor<Sym, H> as serde::de::Visitor<'de>>::expecting":["expecting","Real(LocalPath(\"src/serde_impl.rs\"))","serde::de::Visitor"],"<serde_impl::StringInternerVisitor<Sym, H> as serde::de::Visitor<'de>>::visit_seq":["visit_seq","Real(LocalPath(\"src/serde_impl.rs\"))","serde::de::Visitor"],"<serde_impl::StringInternerVisitor<Sym, H> as std::default::Default>::default":["default","Real(LocalPath(\"src/serde_impl.rs\"))","std::default::Default"],"<usize as Symbol>::from_usize":["from_usize","Real(LocalPath(\"src/lib.rs\"))","Symbol"],"<usize as Symbol>::to_usize":["to_usize","Real(LocalPath(\"src/lib.rs\"))","Symbol"],"InternalStrRef::as_str":["as_str","Real(LocalPath(\"src/lib.rs\"))",""],"InternalStrRef::from_str":["from_str","Real(LocalPath(\"src/lib.rs\"))",""],"Iter::<'a, S>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S, H>::get":["get","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S, H>::get_or_intern":["get_or_intern","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S, H>::intern":["intern","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S, H>::is_empty":["is_empty","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S, H>::iter":["iter","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S, H>::iter_values":["iter_values","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S, H>::len":["len","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S, H>::make_symbol":["make_symbol","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S, H>::resolve":["resolve","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S, H>::resolve_unchecked":["resolve_unchecked","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S, H>::shrink_to_fit":["shrink_to_fit","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S, H>::with_capacity_and_hasher":["with_capacity_and_hasher","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S, H>::with_hasher":["with_hasher","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S>::capacity":["capacity","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S>::reserve":["reserve","Real(LocalPath(\"src/lib.rs\"))",""],"StringInterner::<S>::with_capacity":["with_capacity","Real(LocalPath(\"src/lib.rs\"))",""],"Values::<'a, S>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"serde_impl::<impl serde::Deserialize<'de> for StringInterner<Sym, H>>::deserialize":["deserialize","Real(LocalPath(\"src/serde_impl.rs\"))","serde::Deserialize"],"serde_impl::<impl serde::Serialize for StringInterner<Sym, H>>::serialize":["serialize","Real(LocalPath(\"src/serde_impl.rs\"))","serde::Serialize"]},"trait_to_struct":{"Symbol":["Sym"],"serde::Deserialize":["StringInterner"],"serde::Serialize":["StringInterner"],"serde::de::Visitor":["serde_impl::StringInternerVisitor"],"std::clone::Clone":["InternalStrRef","StringInterner","Sym"],"std::cmp::Eq":["InternalStrRef","StringInterner","Sym"],"std::cmp::Ord":["Sym"],"std::cmp::PartialEq":["InternalStrRef","StringInterner","Sym"],"std::cmp::PartialOrd":["Sym"],"std::convert::From":["InternalStrRef"],"std::default::Default":["StringInterner","serde_impl::StringInternerVisitor"],"std::fmt::Debug":["InternalStrRef","StringInterner","Sym"],"std::hash::Hash":["InternalStrRef","Sym"],"std::iter::FromIterator":["StringInterner"],"std::iter::IntoIterator":["StringInterner"],"std::iter::Iterator":["IntoIter","Iter","Values"],"std::marker::Copy":["InternalStrRef","Sym"],"std::marker::Send":["StringInterner"],"std::marker::StructuralEq":["InternalStrRef","StringInterner","Sym"],"std::marker::StructuralPartialEq":["Sym"],"std::marker::Sync":["StringInterner"]},"type_to_def_path":{"InternalStrRef":"InternalStrRef","IntoIter<S>":"IntoIter","Iter<'a, S>":"Iter","StringInterner<S, H>":"StringInterner","Sym":"Sym","Values<'a, S>":"Values","serde_impl::StringInternerVisitor<Sym, H>":"serde_impl::StringInternerVisitor"}}