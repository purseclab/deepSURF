{"dependencies":{"<&'a SmallVec<A> as core::iter::IntoIterator>::into_iter":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<&'a mut SmallVec<A> as core::iter::IntoIterator>::into_iter":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<CollectionAllocErr as core::convert::From<core::alloc::LayoutError>>::from":["CollectionAllocErr","core::alloc::Layout","core::alloc::LayoutError"],"<CollectionAllocErr as core::fmt::Debug>::fmt":["CollectionAllocErr","core::alloc::Layout","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<CollectionAllocErr as core::fmt::Display>::fmt":["CollectionAllocErr","core::alloc::Layout","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Drain<'a, T> as core::fmt::Debug>::fmt":["Array","Drain","core::fmt::Formatter","core::marker::Sized","core::ptr::NonNull","core::result::Result","core::slice::Iter"],"<Drain<'a, T> as core::iter::DoubleEndedIterator>::next_back":["Array","Drain","core::marker::Sized","core::option::Option","core::ptr::NonNull","core::slice::Iter"],"<Drain<'a, T> as core::iter::ExactSizeIterator>::len":["Array","Drain","core::marker::Sized","core::ptr::NonNull","core::slice::Iter"],"<Drain<'a, T> as core::iter::Iterator>::next":["Array","Drain","core::marker::Sized","core::option::Option","core::ptr::NonNull","core::slice::Iter"],"<Drain<'a, T> as core::iter::Iterator>::size_hint":["Array","Drain","core::marker::Sized","core::option::Option","core::ptr::NonNull","core::slice::Iter"],"<Drain<'a, T> as core::ops::Drop>::drop":["Array","Drain","core::marker::Sized","core::ptr::NonNull","core::slice::Iter"],"<IntoIter<A> as core::clone::Clone>::clone":["Array","IntoIter","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<IntoIter<A> as core::fmt::Debug>::fmt":["Array","IntoIter","SmallVec","SmallVecData","core::fmt::Formatter","core::marker::Sized","core::mem::MaybeUninit","core::result::Result"],"<IntoIter<A> as core::iter::DoubleEndedIterator>::next_back":["Array","IntoIter","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit","core::option::Option"],"<IntoIter<A> as core::iter::Iterator>::next":["Array","IntoIter","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit","core::option::Option"],"<IntoIter<A> as core::iter::Iterator>::size_hint":["Array","IntoIter","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit","core::option::Option"],"<IntoIter<A> as core::ops::Drop>::drop":["Array","IntoIter","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SetLenOnDrop<'a> as core::ops::Drop>::drop":["SetLenOnDrop"],"<SmallVec<A> as ExtendFromSlice<<A as Array>::Item>>::extend_from_slice":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::borrow::Borrow<[<A as Array>::Item]>>::borrow":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::borrow::BorrowMut<[<A as Array>::Item]>>::borrow_mut":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::clone::Clone>::clone":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::cmp::Ord>::cmp":["Array","SmallVec","SmallVecData","core::cmp::Ordering","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::cmp::PartialEq<SmallVec<B>>>::eq":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::cmp::PartialOrd>::partial_cmp":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit","core::option::Option"],"<SmallVec<A> as core::convert::AsMut<[<A as Array>::Item]>>::as_mut":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::convert::AsRef<[<A as Array>::Item]>>::as_ref":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::convert::From<&'a [<A as Array>::Item]>>::from":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::convert::From<A>>::from":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::convert::From<alloc::vec::Vec<<A as Array>::Item>>>::from":["Array","SmallVec","SmallVecData","alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::default::Default>::default":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::fmt::Debug>::fmt":["Array","SmallVec","SmallVecData","core::fmt::Formatter","core::marker::Sized","core::mem::MaybeUninit","core::result::Result"],"<SmallVec<A> as core::hash::Hash>::hash":["Array","SmallVec","SmallVecData","core::hash::Hasher","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::iter::Extend<<A as Array>::Item>>::extend":["Array","SmallVec","SmallVecData","core::iter::IntoIterator","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::iter::FromIterator<<A as Array>::Item>>::from_iter":["Array","SmallVec","SmallVecData","core::iter::IntoIterator","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::iter::IntoIterator>::into_iter":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::ops::Deref>::deref":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::ops::DerefMut>::deref_mut":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::ops::Drop>::drop":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::ops::Index<I>>::index":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A> as core::ops::IndexMut<I>>::index_mut":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<SmallVec<A>::insert_many::DropOnPanic<T> as core::ops::Drop>::drop":["SmallVec<A>::insert_many::DropOnPanic","core::marker::Sized","core::ops::Range"],"<[<A as Array>::Item] as ToSmallVec<A>>::to_smallvec":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"<[T; 0] as Array>::size":[],"<[T; 1024] as Array>::size":[],"<[T; 1048576] as Array>::size":[],"<[T; 10] as Array>::size":[],"<[T; 11] as Array>::size":[],"<[T; 128] as Array>::size":[],"<[T; 12] as Array>::size":[],"<[T; 131072] as Array>::size":[],"<[T; 13] as Array>::size":[],"<[T; 14] as Array>::size":[],"<[T; 1536] as Array>::size":[],"<[T; 15] as Array>::size":[],"<[T; 16384] as Array>::size":[],"<[T; 16] as Array>::size":[],"<[T; 17] as Array>::size":[],"<[T; 18] as Array>::size":[],"<[T; 19] as Array>::size":[],"<[T; 1] as Array>::size":[],"<[T; 2048] as Array>::size":[],"<[T; 20] as Array>::size":[],"<[T; 21] as Array>::size":[],"<[T; 22] as Array>::size":[],"<[T; 23] as Array>::size":[],"<[T; 24576] as Array>::size":[],"<[T; 24] as Array>::size":[],"<[T; 256] as Array>::size":[],"<[T; 25] as Array>::size":[],"<[T; 262144] as Array>::size":[],"<[T; 26] as Array>::size":[],"<[T; 27] as Array>::size":[],"<[T; 28] as Array>::size":[],"<[T; 29] as Array>::size":[],"<[T; 2] as Array>::size":[],"<[T; 30] as Array>::size":[],"<[T; 31] as Array>::size":[],"<[T; 32768] as Array>::size":[],"<[T; 32] as Array>::size":[],"<[T; 36] as Array>::size":[],"<[T; 393216] as Array>::size":[],"<[T; 3] as Array>::size":[],"<[T; 4096] as Array>::size":[],"<[T; 4] as Array>::size":[],"<[T; 512] as Array>::size":[],"<[T; 524288] as Array>::size":[],"<[T; 5] as Array>::size":[],"<[T; 64] as Array>::size":[],"<[T; 65536] as Array>::size":[],"<[T; 6] as Array>::size":[],"<[T; 7] as Array>::size":[],"<[T; 8192] as Array>::size":[],"<[T; 8] as Array>::size":[],"<[T; 96] as Array>::size":[],"<[T; 9] as Array>::size":[],"<alloc::vec::Vec<T> as ExtendFromSlice<T>>::extend_from_slice":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized"],"Array::size":[],"CollectionAllocErr":["CollectionAllocErr","core::alloc::Layout"],"Drain":["Array","Drain","core::marker::Sized","core::ptr::NonNull","core::slice::Iter"],"ExtendFromSlice::extend_from_slice":[],"IntoIter":["Array","IntoIter","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"IntoIter::<A>::as_mut_slice":["Array","IntoIter","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"IntoIter::<A>::as_slice":["Array","IntoIter","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SetLenOnDrop":["SetLenOnDrop"],"SetLenOnDrop::<'a>::get":["SetLenOnDrop"],"SetLenOnDrop::<'a>::increment_len":["SetLenOnDrop"],"SetLenOnDrop::<'a>::new":["SetLenOnDrop"],"SmallVec":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::append":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::as_mut_ptr":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::as_mut_slice":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::as_ptr":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::as_slice":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::capacity":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::clear":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::dedup":["Array","SmallVec","SmallVecData","core::cmp::PartialEq","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::dedup_by":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit","core::ops::FnMut"],"SmallVec::<A>::dedup_by_key":["Array","SmallVec","SmallVecData","core::cmp::PartialEq","core::marker::Sized","core::mem::MaybeUninit","core::ops::FnMut"],"SmallVec::<A>::drain":["Array","Drain","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit","core::ops::RangeBounds","core::ptr::NonNull","core::slice::Iter"],"SmallVec::<A>::extend_from_slice":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::from_buf":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::from_buf_and_len":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::from_buf_and_len_unchecked":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::from_elem":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::from_raw_parts":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::from_slice":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::from_vec":["Array","SmallVec","SmallVecData","alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::grow":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::inline_capacity":[],"SmallVec::<A>::inline_size":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::insert":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::insert_from_slice":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::insert_many":["Array","SmallVec","SmallVecData","core::iter::IntoIterator","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::into_boxed_slice":["Array","SmallVec","SmallVecData","alloc::boxed::Box","core::alloc::Allocator","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::into_inner":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit","core::result::Result"],"SmallVec::<A>::into_vec":["Array","SmallVec","SmallVecData","alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::is_empty":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::len":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::new":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::pop":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit","core::option::Option"],"SmallVec::<A>::push":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::remove":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::reserve":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::reserve_exact":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::resize":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::resize_with":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit","core::ops::FnMut"],"SmallVec::<A>::retain":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit","core::ops::FnMut"],"SmallVec::<A>::set_len":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::shrink_to_fit":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::spilled":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::swap_remove":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::triple":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::triple_mut":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::truncate":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec::<A>::try_grow":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit","core::result::Result"],"SmallVec::<A>::try_reserve":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit","core::result::Result"],"SmallVec::<A>::try_reserve_exact":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit","core::result::Result"],"SmallVec::<A>::with_capacity":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVec<A>::insert_many::DropOnPanic":["SmallVec<A>::insert_many::DropOnPanic","core::marker::Sized","core::ops::Range"],"SmallVecData":["Array","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVecData::<A>::from_heap":["Array","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVecData::<A>::from_inline":["Array","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVecData::<A>::heap":["Array","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVecData::<A>::heap_mut":["Array","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVecData::<A>::inline":["Array","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVecData::<A>::inline_mut":["Array","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"SmallVecData::<A>::into_inline":["Array","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"ToSmallVec::to_smallvec":["Array","SmallVec","SmallVecData","core::marker::Sized","core::mem::MaybeUninit"],"deallocate":["core::marker::Sized"],"infallible":["core::marker::Sized","core::result::Result"],"layout_array":["core::marker::Sized","core::result::Result"]},"glob_path_import":{},"self_to_fn":{"CollectionAllocErr":["Debug","impl From<LayoutErr> for CollectionAllocErr {\n    fn from(_: LayoutErr) -> Self {\n        CollectionAllocErr::CapacityOverflow\n    }\n}","impl fmt::Display for CollectionAllocErr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"Allocation error: {:?}\", self)\n    }\n}"],"Drain":["impl<'a, T: 'a + Array> DoubleEndedIterator for Drain<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T::Item> {\n        self.iter\n            .next_back()\n            .map(|reference| unsafe { ptr::read(reference) })\n    }\n}","impl<'a, T: 'a + Array> Drop for Drain<'a, T> {\n    fn drop(&mut self) {\n        self.for_each(drop);\n\n        if self.tail_len > 0 {\n            unsafe {\n                let source_vec = self.vec.as_mut();\n\n                // memmove back untouched tail, update to new length\n                let start = source_vec.len();\n                let tail = self.tail_start;\n                if tail != start {\n                    let src = source_vec.as_ptr().add(tail);\n                    let dst = source_vec.as_mut_ptr().add(start);\n                    ptr::copy(src, dst, self.tail_len);\n                }\n                source_vec.set_len(start + self.tail_len);\n            }\n        }\n    }\n}","impl<'a, T: 'a + Array> Iterator for Drain<'a, T> {\n    type Item = T::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<T::Item> {\n        self.iter\n            .next()\n            .map(|reference| unsafe { ptr::read(reference) })\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}","impl<'a, T: 'a + Array> fmt::Debug for Drain<'a, T>\nwhere\n    T::Item: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n    }\n}","impl<'a, T: Array> ExactSizeIterator for Drain<'a, T> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}","impl<'a, T: Array> FusedIterator for Drain<'a, T> {}","unsafe impl<'a, T: Send + Array> Send for Drain<'a, T> {}","unsafe impl<'a, T: Sync + Array> Sync for Drain<'a, T> {}"],"IntoIter":["impl<A: Array + Clone> Clone for IntoIter<A>\nwhere\n    A::Item: Clone,\n{\n    fn clone(&self) -> IntoIter<A> {\n        SmallVec::from(self.as_slice()).into_iter()\n    }\n}","impl<A: Array> DoubleEndedIterator for IntoIter<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A::Item> {\n        if self.current == self.end {\n            None\n        } else {\n            unsafe {\n                self.end -= 1;\n                Some(ptr::read(self.data.as_ptr().add(self.end)))\n            }\n        }\n    }\n}","impl<A: Array> Drop for IntoIter<A> {\n    fn drop(&mut self) {\n        for _ in self {}\n    }\n}","impl<A: Array> ExactSizeIterator for IntoIter<A> {}","impl<A: Array> FusedIterator for IntoIter<A> {}","impl<A: Array> IntoIter<A> {\n    /// Returns the remaining items of this iterator as a slice.\n    pub fn as_slice(&self) -> &[A::Item] {\n        let len = self.end - self.current;\n        unsafe { core::slice::from_raw_parts(self.data.as_ptr().add(self.current), len) }\n    }\n\n    /// Returns the remaining items of this iterator as a mutable slice.\n    pub fn as_mut_slice(&mut self) -> &mut [A::Item] {\n        let len = self.end - self.current;\n        unsafe { core::slice::from_raw_parts_mut(self.data.as_mut_ptr().add(self.current), len) }\n    }\n}","impl<A: Array> Iterator for IntoIter<A> {\n    type Item = A::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<A::Item> {\n        if self.current == self.end {\n            None\n        } else {\n            unsafe {\n                let current = self.current;\n                self.current += 1;\n                Some(ptr::read(self.data.as_ptr().add(current)))\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let size = self.end - self.current;\n        (size, Some(size))\n    }\n}","impl<A: Array> fmt::Debug for IntoIter<A>\nwhere\n    A::Item: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n    }\n}"],"SetLenOnDrop":["impl<'a> Drop for SetLenOnDrop<'a> {\n    #[inline]\n    fn drop(&mut self) {\n        *self.len = self.local_len;\n    }\n}","impl<'a> SetLenOnDrop<'a> {\n    #[inline]\n    fn new(len: &'a mut usize) -> Self {\n        SetLenOnDrop {\n            local_len: *len,\n            len,\n        }\n    }\n\n    #[inline]\n    fn get(&self) -> usize {\n        self.local_len\n    }\n\n    #[inline]\n    fn increment_len(&mut self, increment: usize) {\n        self.local_len += increment;\n    }\n}"],"SmallVec":["impl<'a, A: Array> From<&'a [A::Item]> for SmallVec<A>\nwhere\n    A::Item: Clone,\n{\n    #[cfg(not(feature = \"specialization\"))]\n    #[inline]\n    fn from(slice: &'a [A::Item]) -> SmallVec<A> {\n        slice.iter().cloned().collect()\n    }\n\n    #[cfg(feature = \"specialization\")]\n    #[inline]\n    fn from(slice: &'a [A::Item]) -> SmallVec<A> {\n        SmallVec::spec_from(slice)\n    }\n}","impl<A: Array, B: Array> PartialEq<SmallVec<B>> for SmallVec<A>\nwhere\n    A::Item: PartialEq<B::Item>,\n{\n    #[inline]\n    fn eq(&self, other: &SmallVec<B>) -> bool {\n        self[..] == other[..]\n    }\n}","impl<A: Array, I: SliceIndex<[A::Item]>> ops::Index<I> for SmallVec<A> {\n    type Output = I::Output;\n\n    fn index(&self, index: I) -> &I::Output {\n        &(**self)[index]\n    }\n}","impl<A: Array, I: SliceIndex<[A::Item]>> ops::IndexMut<I> for SmallVec<A> {\n    fn index_mut(&mut self, index: I) -> &mut I::Output {\n        &mut (&mut **self)[index]\n    }\n}","impl<A: Array> AsMut<[A::Item]> for SmallVec<A> {\n    #[inline]\n    fn as_mut(&mut self) -> &mut [A::Item] {\n        self\n    }\n}","impl<A: Array> AsRef<[A::Item]> for SmallVec<A> {\n    #[inline]\n    fn as_ref(&self) -> &[A::Item] {\n        self\n    }\n}","impl<A: Array> Borrow<[A::Item]> for SmallVec<A> {\n    #[inline]\n    fn borrow(&self) -> &[A::Item] {\n        self\n    }\n}","impl<A: Array> BorrowMut<[A::Item]> for SmallVec<A> {\n    #[inline]\n    fn borrow_mut(&mut self) -> &mut [A::Item] {\n        self\n    }\n}","impl<A: Array> Clone for SmallVec<A>\nwhere\n    A::Item: Clone,\n{\n    #[inline]\n    fn clone(&self) -> SmallVec<A> {\n        SmallVec::from(self.as_slice())\n    }\n}","impl<A: Array> Default for SmallVec<A> {\n    #[inline]\n    fn default() -> SmallVec<A> {\n        SmallVec::new()\n    }\n}","impl<A: Array> Drop for SmallVec<A> {\n    fn drop(&mut self) {\n        unsafe {\n            if self.spilled() {\n                let (ptr, len) = self.data.heap();\n                Vec::from_raw_parts(ptr, len, self.capacity);\n            } else {\n                ptr::drop_in_place(&mut self[..]);\n            }\n        }\n    }\n}","impl<A: Array> Eq for SmallVec<A> where A::Item: Eq {}","impl<A: Array> Extend<A::Item> for SmallVec<A> {\n    fn extend<I: IntoIterator<Item = A::Item>>(&mut self, iterable: I) {\n        let mut iter = iterable.into_iter();\n        let (lower_size_bound, _) = iter.size_hint();\n        self.reserve(lower_size_bound);\n\n        unsafe {\n            let (ptr, len_ptr, cap) = self.triple_mut();\n            let mut len = SetLenOnDrop::new(len_ptr);\n            while len.get() < cap {\n                if let Some(out) = iter.next() {\n                    ptr::write(ptr.add(len.get()), out);\n                    len.increment_len(1);\n                } else {\n                    return;\n                }\n            }\n        }\n\n        for elem in iter {\n            self.push(elem);\n        }\n    }\n}","impl<A: Array> ExtendFromSlice<A::Item> for SmallVec<A>\nwhere\n    A::Item: Copy,\n{\n    fn extend_from_slice(&mut self, other: &[A::Item]) {\n        SmallVec::extend_from_slice(self, other)\n    }\n}","impl<A: Array> From<A> for SmallVec<A> {\n    #[inline]\n    fn from(array: A) -> SmallVec<A> {\n        SmallVec::from_buf(array)\n    }\n}","impl<A: Array> From<Vec<A::Item>> for SmallVec<A> {\n    #[inline]\n    fn from(vec: Vec<A::Item>) -> SmallVec<A> {\n        SmallVec::from_vec(vec)\n    }\n}","impl<A: Array> FromIterator<A::Item> for SmallVec<A> {\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = A::Item>>(iterable: I) -> SmallVec<A> {\n        let mut v = SmallVec::new();\n        v.extend(iterable);\n        v\n    }\n}","impl<A: Array> Hash for SmallVec<A>\nwhere\n    A::Item: Hash,\n{\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        (**self).hash(state)\n    }\n}","impl<A: Array> IntoIterator for SmallVec<A> {\n    type IntoIter = IntoIter<A>;\n    type Item = A::Item;\n    fn into_iter(mut self) -> Self::IntoIter {\n        unsafe {\n            // Set SmallVec len to zero as `IntoIter` drop handles dropping of the elements\n            let len = self.len();\n            self.set_len(0);\n            IntoIter {\n                data: self,\n                current: 0,\n                end: len,\n            }\n        }\n    }\n}","impl<A: Array> Ord for SmallVec<A>\nwhere\n    A::Item: Ord,\n{\n    #[inline]\n    fn cmp(&self, other: &SmallVec<A>) -> cmp::Ordering {\n        Ord::cmp(&**self, &**other)\n    }\n}","impl<A: Array> PartialOrd for SmallVec<A>\nwhere\n    A::Item: PartialOrd,\n{\n    #[inline]\n    fn partial_cmp(&self, other: &SmallVec<A>) -> Option<cmp::Ordering> {\n        PartialOrd::partial_cmp(&**self, &**other)\n    }\n}","impl<A: Array> SmallVec<A>\nwhere\n    A::Item: Clone,\n{\n    /// Resizes the vector so that its length is equal to `len`.\n    ///\n    /// If `len` is less than the current length, the vector simply truncated.\n    ///\n    /// If `len` is greater than the current length, `value` is appended to the\n    /// vector until its length equals `len`.\n    pub fn resize(&mut self, len: usize, value: A::Item) {\n        let old_len = self.len();\n\n        if len > old_len {\n            self.extend(repeat(value).take(len - old_len));\n        } else {\n            self.truncate(len);\n        }\n    }\n\n    /// Creates a `SmallVec` with `n` copies of `elem`.\n    /// ```\n    /// use smallvec::SmallVec;\n    ///\n    /// let v = SmallVec::<[char; 128]>::from_elem('d', 2);\n    /// assert_eq!(v, SmallVec::from_buf(['d', 'd']));\n    /// ```\n    pub fn from_elem(elem: A::Item, n: usize) -> Self {\n        if n > Self::inline_capacity() {\n            vec![elem; n].into()\n        } else {\n            let mut v = SmallVec::<A>::new();\n            unsafe {\n                let (ptr, len_ptr, _) = v.triple_mut();\n                let mut local_len = SetLenOnDrop::new(len_ptr);\n\n                for i in 0..n {\n                    ::core::ptr::write(ptr.add(i), elem.clone());\n                    local_len.increment_len(1);\n                }\n            }\n            v\n        }\n    }\n}","impl<A: Array> SmallVec<A>\nwhere\n    A::Item: Copy,\n{\n    /// Copy the elements from a slice into a new `SmallVec`.\n    ///\n    /// For slices of `Copy` types, this is more efficient than `SmallVec::from(slice)`.\n    pub fn from_slice(slice: &[A::Item]) -> Self {\n        let len = slice.len();\n        if len <= Self::inline_capacity() {\n            SmallVec {\n                capacity: len,\n                data: SmallVecData::from_inline(unsafe {\n                    let mut data: MaybeUninit<A> = MaybeUninit::uninit();\n                    ptr::copy_nonoverlapping(\n                        slice.as_ptr(),\n                        data.as_mut_ptr() as *mut A::Item,\n                        len,\n                    );\n                    data\n                }),\n            }\n        } else {\n            let mut b = slice.to_vec();\n            let (ptr, cap) = (b.as_mut_ptr(), b.capacity());\n            mem::forget(b);\n            SmallVec {\n                capacity: cap,\n                data: SmallVecData::from_heap(ptr, len),\n            }\n        }\n    }\n\n    /// Copy elements from a slice into the vector at position `index`, shifting any following\n    /// elements toward the back.\n    ///\n    /// For slices of `Copy` types, this is more efficient than `insert`.\n    pub fn insert_from_slice(&mut self, index: usize, slice: &[A::Item]) {\n        self.reserve(slice.len());\n\n        let len = self.len();\n        assert!(index <= len);\n\n        unsafe {\n            let slice_ptr = slice.as_ptr();\n            let ptr = self.as_mut_ptr().add(index);\n            ptr::copy(ptr, ptr.add(slice.len()), len - index);\n            ptr::copy_nonoverlapping(slice_ptr, ptr, slice.len());\n            self.set_len(len + slice.len());\n        }\n    }\n\n    /// Copy elements from a slice and append them to the vector.\n    ///\n    /// For slices of `Copy` types, this is more efficient than `extend`.\n    #[inline]\n    pub fn extend_from_slice(&mut self, slice: &[A::Item]) {\n        let len = self.len();\n        self.insert_from_slice(len, slice);\n    }\n}","impl<A: Array> SmallVec<A> {\n    /// Construct an empty vector\n    #[inline]\n    pub fn new() -> SmallVec<A> {\n        // Try to detect invalid custom implementations of `Array`. Hopefuly,\n        // this check should be optimized away entirely for valid ones.\n        assert!(\n            mem::size_of::<A>() == A::size() * mem::size_of::<A::Item>()\n                && mem::align_of::<A>() >= mem::align_of::<A::Item>()\n        );\n        SmallVec {\n            capacity: 0,\n            data: SmallVecData::from_inline(MaybeUninit::uninit()),\n        }\n    }\n\n    /// Construct an empty vector with enough capacity pre-allocated to store at least `n`\n    /// elements.\n    ///\n    /// Will create a heap allocation only if `n` is larger than the inline capacity.\n    ///\n    /// ```\n    /// # use smallvec::SmallVec;\n    ///\n    /// let v: SmallVec<[u8; 3]> = SmallVec::with_capacity(100);\n    ///\n    /// assert!(v.is_empty());\n    /// assert!(v.capacity() >= 100);\n    /// ```\n    #[inline]\n    pub fn with_capacity(n: usize) -> Self {\n        let mut v = SmallVec::new();\n        v.reserve_exact(n);\n        v\n    }\n\n    /// Construct a new `SmallVec` from a `Vec<A::Item>`.\n    ///\n    /// Elements will be copied to the inline buffer if vec.capacity() <= Self::inline_capacity().\n    ///\n    /// ```rust\n    /// use smallvec::SmallVec;\n    ///\n    /// let vec = vec![1, 2, 3, 4, 5];\n    /// let small_vec: SmallVec<[_; 3]> = SmallVec::from_vec(vec);\n    ///\n    /// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n    /// ```\n    #[inline]\n    pub fn from_vec(mut vec: Vec<A::Item>) -> SmallVec<A> {\n        if vec.capacity() <= Self::inline_capacity() {\n            unsafe {\n                let mut data = SmallVecData::<A>::from_inline(MaybeUninit::uninit());\n                let len = vec.len();\n                vec.set_len(0);\n                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut(), len);\n\n                SmallVec {\n                    capacity: len,\n                    data,\n                }\n            }\n        } else {\n            let (ptr, cap, len) = (vec.as_mut_ptr(), vec.capacity(), vec.len());\n            mem::forget(vec);\n\n            SmallVec {\n                capacity: cap,\n                data: SmallVecData::from_heap(ptr, len),\n            }\n        }\n    }\n\n    /// Constructs a new `SmallVec` on the stack from an `A` without\n    /// copying elements.\n    ///\n    /// ```rust\n    /// use smallvec::SmallVec;\n    ///\n    /// let buf = [1, 2, 3, 4, 5];\n    /// let small_vec: SmallVec<_> = SmallVec::from_buf(buf);\n    ///\n    /// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n    /// ```\n    #[inline]\n    pub fn from_buf(buf: A) -> SmallVec<A> {\n        SmallVec {\n            capacity: A::size(),\n            data: SmallVecData::from_inline(MaybeUninit::new(buf)),\n        }\n    }\n\n    /// Constructs a new `SmallVec` on the stack from an `A` without\n    /// copying elements. Also sets the length, which must be less or\n    /// equal to the size of `buf`.\n    ///\n    /// ```rust\n    /// use smallvec::SmallVec;\n    ///\n    /// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n    /// let small_vec: SmallVec<_> = SmallVec::from_buf_and_len(buf, 5);\n    ///\n    /// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n    /// ```\n    #[inline]\n    pub fn from_buf_and_len(buf: A, len: usize) -> SmallVec<A> {\n        assert!(len <= A::size());\n        unsafe { SmallVec::from_buf_and_len_unchecked(MaybeUninit::new(buf), len) }\n    }\n\n    /// Constructs a new `SmallVec` on the stack from an `A` without\n    /// copying elements. Also sets the length. The user is responsible\n    /// for ensuring that `len <= A::size()`.\n    ///\n    /// ```rust\n    /// use smallvec::SmallVec;\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n    /// let small_vec: SmallVec<_> = unsafe {\n    ///     SmallVec::from_buf_and_len_unchecked(MaybeUninit::new(buf), 5)\n    /// };\n    ///\n    /// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n    /// ```\n    #[inline]\n    pub unsafe fn from_buf_and_len_unchecked(buf: MaybeUninit<A>, len: usize) -> SmallVec<A> {\n        SmallVec {\n            capacity: len,\n            data: SmallVecData::from_inline(buf),\n        }\n    }\n\n    /// Sets the length of a vector.\n    ///\n    /// This will explicitly set the size of the vector, without actually\n    /// modifying its buffers, so it is up to the caller to ensure that the\n    /// vector is actually the specified size.\n    pub unsafe fn set_len(&mut self, new_len: usize) {\n        let (_, len_ptr, _) = self.triple_mut();\n        *len_ptr = new_len;\n    }\n\n    /// The maximum number of elements this vector can hold inline\n    #[inline]\n    fn inline_capacity() -> usize {\n        if mem::size_of::<A::Item>() > 0 {\n            A::size()\n        } else {\n            // For zero-size items code like `ptr.add(offset)` always returns the same pointer.\n            // Therefore all items are at the same address,\n            // and any array size has capacity for infinitely many items.\n            // The capacity is limited by the bit width of the length field.\n            //\n            // `Vec` also does this:\n            // https://github.com/rust-lang/rust/blob/1.44.0/src/liballoc/raw_vec.rs#L186\n            //\n            // In our case, this also ensures that a smallvec of zero-size items never spills,\n            // and we never try to allocate zero bytes which `std::alloc::alloc` disallows.\n            core::usize::MAX\n        }\n    }\n\n    /// The maximum number of elements this vector can hold inline\n    #[inline]\n    pub fn inline_size(&self) -> usize {\n        Self::inline_capacity()\n    }\n\n    /// The number of elements stored in the vector\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.triple().1\n    }\n\n    /// Returns `true` if the vector is empty\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// The number of items the vector can hold without reallocating\n    #[inline]\n    pub fn capacity(&self) -> usize {\n        self.triple().2\n    }\n\n    /// Returns a tuple with (data ptr, len, capacity)\n    /// Useful to get all SmallVec properties with a single check of the current storage variant.\n    #[inline]\n    fn triple(&self) -> (*const A::Item, usize, usize) {\n        unsafe {\n            if self.spilled() {\n                let (ptr, len) = self.data.heap();\n                (ptr, len, self.capacity)\n            } else {\n                (self.data.inline(), self.capacity, Self::inline_capacity())\n            }\n        }\n    }\n\n    /// Returns a tuple with (data ptr, len ptr, capacity)\n    #[inline]\n    fn triple_mut(&mut self) -> (*mut A::Item, &mut usize, usize) {\n        unsafe {\n            if self.spilled() {\n                let &mut (ptr, ref mut len_ptr) = self.data.heap_mut();\n                (ptr, len_ptr, self.capacity)\n            } else {\n                (\n                    self.data.inline_mut(),\n                    &mut self.capacity,\n                    Self::inline_capacity(),\n                )\n            }\n        }\n    }\n\n    /// Returns `true` if the data has spilled into a separate heap-allocated buffer.\n    #[inline]\n    pub fn spilled(&self) -> bool {\n        self.capacity > Self::inline_capacity()\n    }\n\n    /// Creates a draining iterator that removes the specified range in the vector\n    /// and yields the removed items.\n    ///\n    /// Note 1: The element range is removed even if the iterator is only\n    /// partially consumed or not consumed at all.\n    ///\n    /// Note 2: It is unspecified how many elements are removed from the vector\n    /// if the `Drain` value is leaked.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the vector.\n    pub fn drain<R>(&mut self, range: R) -> Drain<'_, A>\n    where\n        R: RangeBounds<usize>,\n    {\n        use core::ops::Bound::*;\n\n        let len = self.len();\n        let start = match range.start_bound() {\n            Included(&n) => n,\n            Excluded(&n) => n + 1,\n            Unbounded => 0,\n        };\n        let end = match range.end_bound() {\n            Included(&n) => n + 1,\n            Excluded(&n) => n,\n            Unbounded => len,\n        };\n\n        assert!(start <= end);\n        assert!(end <= len);\n\n        unsafe {\n            self.set_len(start);\n\n            let range_slice = slice::from_raw_parts_mut(self.as_mut_ptr().add(start), end - start);\n\n            Drain {\n                tail_start: end,\n                tail_len: len - end,\n                iter: range_slice.iter(),\n                vec: NonNull::from(self),\n            }\n        }\n    }\n\n    /// Append an item to the vector.\n    #[inline]\n    pub fn push(&mut self, value: A::Item) {\n        unsafe {\n            let (mut ptr, mut len, cap) = self.triple_mut();\n            if *len == cap {\n                self.reserve(1);\n                let &mut (heap_ptr, ref mut heap_len) = self.data.heap_mut();\n                ptr = heap_ptr;\n                len = heap_len;\n            }\n            ptr::write(ptr.add(*len), value);\n            *len += 1;\n        }\n    }\n\n    /// Remove an item from the end of the vector and return it, or None if empty.\n    #[inline]\n    pub fn pop(&mut self) -> Option<A::Item> {\n        unsafe {\n            let (ptr, len_ptr, _) = self.triple_mut();\n            if *len_ptr == 0 {\n                return None;\n            }\n            let last_index = *len_ptr - 1;\n            *len_ptr = last_index;\n            Some(ptr::read(ptr.add(last_index)))\n        }\n    }\n\n    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use smallvec::{SmallVec, smallvec};\n    /// let mut v0: SmallVec<[u8; 16]> = smallvec![1, 2, 3];\n    /// let mut v1: SmallVec<[u8; 32]> = smallvec![4, 5, 6];\n    /// v0.append(&mut v1);\n    /// assert_eq!(*v0, [1, 2, 3, 4, 5, 6]);\n    /// assert_eq!(*v1, []);\n    /// ```\n    pub fn append<B>(&mut self, other: &mut SmallVec<B>)\n    where\n        B: Array<Item = A::Item>,\n    {\n        self.extend(other.drain(..))\n    }\n\n    /// Re-allocate to set the capacity to `max(new_cap, inline_size())`.\n    ///\n    /// Panics if `new_cap` is less than the vector's length\n    /// or if the capacity computation overflows `usize`.\n    pub fn grow(&mut self, new_cap: usize) {\n        infallible(self.try_grow(new_cap))\n    }\n\n    /// Re-allocate to set the capacity to `max(new_cap, inline_size())`.\n    ///\n    /// Panics if `new_cap` is less than the vector's length\n    pub fn try_grow(&mut self, new_cap: usize) -> Result<(), CollectionAllocErr> {\n        unsafe {\n            let (ptr, &mut len, cap) = self.triple_mut();\n            let unspilled = !self.spilled();\n            assert!(new_cap >= len);\n            if new_cap <= self.inline_size() {\n                if unspilled {\n                    return Ok(());\n                }\n                self.data = SmallVecData::from_inline(MaybeUninit::uninit());\n                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);\n                self.capacity = len;\n                deallocate(ptr, cap);\n            } else if new_cap != cap {\n                let layout = layout_array::<A::Item>(new_cap)?;\n                debug_assert!(layout.size() > 0);\n                let new_alloc;\n                if unspilled {\n                    new_alloc = NonNull::new(alloc::alloc::alloc(layout))\n                        .ok_or(CollectionAllocErr::AllocErr { layout })?\n                        .cast()\n                        .as_ptr();\n                    ptr::copy_nonoverlapping(ptr, new_alloc, len);\n                } else {\n                    // This should never fail since the same succeeded\n                    // when previously allocating `ptr`.\n                    let old_layout = layout_array::<A::Item>(cap)?;\n\n                    let new_ptr = alloc::alloc::realloc(ptr as *mut u8, old_layout, layout.size());\n                    new_alloc = NonNull::new(new_ptr)\n                        .ok_or(CollectionAllocErr::AllocErr { layout })?\n                        .cast()\n                        .as_ptr();\n                }\n                self.data = SmallVecData::from_heap(new_alloc, len);\n                self.capacity = new_cap;\n            }\n            Ok(())\n        }\n    }\n\n    /// Reserve capacity for `additional` more elements to be inserted.\n    ///\n    /// May reserve more space to avoid frequent reallocations.\n    ///\n    /// Panics if the capacity computation overflows `usize`.\n    #[inline]\n    pub fn reserve(&mut self, additional: usize) {\n        infallible(self.try_reserve(additional))\n    }\n\n    /// Reserve capacity for `additional` more elements to be inserted.\n    ///\n    /// May reserve more space to avoid frequent reallocations.\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n        // prefer triple_mut() even if triple() would work\n        // so that the optimizer removes duplicated calls to it\n        // from callers like insert()\n        let (_, &mut len, cap) = self.triple_mut();\n        if cap - len >= additional {\n            return Ok(());\n        }\n        let new_cap = len\n            .checked_add(additional)\n            .and_then(usize::checked_next_power_of_two)\n            .ok_or(CollectionAllocErr::CapacityOverflow)?;\n        self.try_grow(new_cap)\n    }\n\n    /// Reserve the minimum capacity for `additional` more elements to be inserted.\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    pub fn reserve_exact(&mut self, additional: usize) {\n        infallible(self.try_reserve_exact(additional))\n    }\n\n    /// Reserve the minimum capacity for `additional` more elements to be inserted.\n    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n        let (_, &mut len, cap) = self.triple_mut();\n        if cap - len >= additional {\n            return Ok(());\n        }\n        let new_cap = len\n            .checked_add(additional)\n            .ok_or(CollectionAllocErr::CapacityOverflow)?;\n        self.try_grow(new_cap)\n    }\n\n    /// Shrink the capacity of the vector as much as possible.\n    ///\n    /// When possible, this will move data from an external heap buffer to the vector's inline\n    /// storage.\n    pub fn shrink_to_fit(&mut self) {\n        if !self.spilled() {\n            return;\n        }\n        let len = self.len();\n        if self.inline_size() >= len {\n            unsafe {\n                let (ptr, len) = self.data.heap();\n                self.data = SmallVecData::from_inline(MaybeUninit::uninit());\n                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);\n                deallocate(ptr, self.capacity);\n                self.capacity = len;\n            }\n        } else if self.capacity() > len {\n            self.grow(len);\n        }\n    }\n\n    /// Shorten the vector, keeping the first `len` elements and dropping the rest.\n    ///\n    /// If `len` is greater than or equal to the vector's current length, this has no\n    /// effect.\n    ///\n    /// This does not re-allocate.  If you want the vector's capacity to shrink, call\n    /// `shrink_to_fit` after truncating.\n    pub fn truncate(&mut self, len: usize) {\n        unsafe {\n            let (ptr, len_ptr, _) = self.triple_mut();\n            while len < *len_ptr {\n                let last_index = *len_ptr - 1;\n                *len_ptr = last_index;\n                ptr::drop_in_place(ptr.add(last_index));\n            }\n        }\n    }\n\n    /// Extracts a slice containing the entire vector.\n    ///\n    /// Equivalent to `&s[..]`.\n    pub fn as_slice(&self) -> &[A::Item] {\n        self\n    }\n\n    /// Extracts a mutable slice of the entire vector.\n    ///\n    /// Equivalent to `&mut s[..]`.\n    pub fn as_mut_slice(&mut self) -> &mut [A::Item] {\n        self\n    }\n\n    /// Remove the element at position `index`, replacing it with the last element.\n    ///\n    /// This does not preserve ordering, but is O(1).\n    ///\n    /// Panics if `index` is out of bounds.\n    #[inline]\n    pub fn swap_remove(&mut self, index: usize) -> A::Item {\n        let len = self.len();\n        self.swap(len - 1, index);\n        self.pop()\n            .unwrap_or_else(|| unsafe { unreachable_unchecked() })\n    }\n\n    /// Remove all elements from the vector.\n    #[inline]\n    pub fn clear(&mut self) {\n        self.truncate(0);\n    }\n\n    /// Remove and return the element at position `index`, shifting all elements after it to the\n    /// left.\n    ///\n    /// Panics if `index` is out of bounds.\n    pub fn remove(&mut self, index: usize) -> A::Item {\n        unsafe {\n            let (mut ptr, len_ptr, _) = self.triple_mut();\n            let len = *len_ptr;\n            assert!(index < len);\n            *len_ptr = len - 1;\n            ptr = ptr.add(index);\n            let item = ptr::read(ptr);\n            ptr::copy(ptr.add(1), ptr, len - index - 1);\n            item\n        }\n    }\n\n    /// Insert an element at position `index`, shifting all elements after it to the right.\n    ///\n    /// Panics if `index` is out of bounds.\n    pub fn insert(&mut self, index: usize, element: A::Item) {\n        self.reserve(1);\n\n        unsafe {\n            let (mut ptr, len_ptr, _) = self.triple_mut();\n            let len = *len_ptr;\n            assert!(index <= len);\n            *len_ptr = len + 1;\n            ptr = ptr.add(index);\n            ptr::copy(ptr, ptr.add(1), len - index);\n            ptr::write(ptr, element);\n        }\n    }\n\n    /// Insert multiple elements at position `index`, shifting all following elements toward the\n    /// back.\n    pub fn insert_many<I: IntoIterator<Item = A::Item>>(&mut self, index: usize, iterable: I) {\n        let iter = iterable.into_iter();\n        if index == self.len() {\n            return self.extend(iter);\n        }\n\n        let (lower_size_bound, _) = iter.size_hint();\n        assert!(lower_size_bound <= core::isize::MAX as usize); // Ensure offset is indexable\n        assert!(index + lower_size_bound >= index); // Protect against overflow\n        self.reserve(lower_size_bound);\n\n        unsafe {\n            let old_len = self.len();\n            assert!(index <= old_len);\n            let start = self.as_mut_ptr();\n            let mut ptr = start.add(index);\n\n            // Move the trailing elements.\n            ptr::copy(ptr, ptr.add(lower_size_bound), old_len - index);\n\n            // In case the iterator panics, don't double-drop the items we just copied above.\n            self.set_len(0);\n            let mut guard = DropOnPanic {\n                start,\n                skip: index..(index + lower_size_bound),\n                len: old_len + lower_size_bound,\n            };\n\n            let mut num_added = 0;\n            for element in iter {\n                let mut cur = ptr.add(num_added);\n                if num_added >= lower_size_bound {\n                    // Iterator provided more elements than the hint.  Move trailing items again.\n                    self.reserve(1);\n                    let start = self.as_mut_ptr();\n                    ptr = start.add(index);\n                    cur = ptr.add(num_added);\n                    ptr::copy(cur, cur.add(1), old_len - index);\n\n                    guard.start = start;\n                    guard.len += 1;\n                    guard.skip.end += 1;\n                }\n                ptr::write(cur, element);\n                guard.skip.start += 1;\n                num_added += 1;\n            }\n            mem::forget(guard);\n\n            if num_added < lower_size_bound {\n                // Iterator provided fewer elements than the hint\n                ptr::copy(\n                    ptr.add(lower_size_bound),\n                    ptr.add(num_added),\n                    old_len - index,\n                );\n            }\n\n            self.set_len(old_len + num_added);\n        }\n\n        struct DropOnPanic<T> {\n            start: *mut T,\n            skip: Range<usize>,\n            len: usize,\n        }\n\n        impl<T> Drop for DropOnPanic<T> {\n            fn drop(&mut self) {\n                for i in 0..self.len {\n                    if !self.skip.contains(&i) {\n                        unsafe {\n                            ptr::drop_in_place(self.start.add(i));\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /// Convert a SmallVec to a Vec, without reallocating if the SmallVec has already spilled onto\n    /// the heap.\n    pub fn into_vec(self) -> Vec<A::Item> {\n        if self.spilled() {\n            unsafe {\n                let (ptr, len) = self.data.heap();\n                let v = Vec::from_raw_parts(ptr, len, self.capacity);\n                mem::forget(self);\n                v\n            }\n        } else {\n            self.into_iter().collect()\n        }\n    }\n\n    /// Converts a `SmallVec` into a `Box<[T]>` without reallocating if the `SmallVec` has already spilled\n    /// onto the heap.\n    ///\n    /// Note that this will drop any excess capacity.\n    pub fn into_boxed_slice(self) -> Box<[A::Item]> {\n        self.into_vec().into_boxed_slice()\n    }\n\n    /// Convert the SmallVec into an `A` if possible. Otherwise return `Err(Self)`.\n    ///\n    /// This method returns `Err(Self)` if the SmallVec is too short (and the `A` contains uninitialized elements),\n    /// or if the SmallVec is too long (and all the elements were spilled to the heap).\n    pub fn into_inner(self) -> Result<A, Self> {\n        if self.spilled() || self.len() != A::size() {\n            // Note: A::size, not Self::inline_capacity\n            Err(self)\n        } else {\n            unsafe {\n                let data = ptr::read(&self.data);\n                mem::forget(self);\n                Ok(data.into_inline().assume_init())\n            }\n        }\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n    /// This method operates in place and preserves the order of the retained\n    /// elements.\n    pub fn retain<F: FnMut(&mut A::Item) -> bool>(&mut self, mut f: F) {\n        let mut del = 0;\n        let len = self.len();\n        for i in 0..len {\n            if !f(&mut self[i]) {\n                del += 1;\n            } else if del > 0 {\n                self.swap(i - del, i);\n            }\n        }\n        self.truncate(len - del);\n    }\n\n    /// Removes consecutive duplicate elements.\n    pub fn dedup(&mut self)\n    where\n        A::Item: PartialEq<A::Item>,\n    {\n        self.dedup_by(|a, b| a == b);\n    }\n\n    /// Removes consecutive duplicate elements using the given equality relation.\n    pub fn dedup_by<F>(&mut self, mut same_bucket: F)\n    where\n        F: FnMut(&mut A::Item, &mut A::Item) -> bool,\n    {\n        // See the implementation of Vec::dedup_by in the\n        // standard library for an explanation of this algorithm.\n        let len = self.len();\n        if len <= 1 {\n            return;\n        }\n\n        let ptr = self.as_mut_ptr();\n        let mut w: usize = 1;\n\n        unsafe {\n            for r in 1..len {\n                let p_r = ptr.add(r);\n                let p_wm1 = ptr.add(w - 1);\n                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n                    if r != w {\n                        let p_w = p_wm1.add(1);\n                        mem::swap(&mut *p_r, &mut *p_w);\n                    }\n                    w += 1;\n                }\n            }\n        }\n\n        self.truncate(w);\n    }\n\n    /// Removes consecutive elements that map to the same key.\n    pub fn dedup_by_key<F, K>(&mut self, mut key: F)\n    where\n        F: FnMut(&mut A::Item) -> K,\n        K: PartialEq<K>,\n    {\n        self.dedup_by(|a, b| key(a) == key(b));\n    }\n\n    /// Resizes the `SmallVec` in-place so that `len` is equal to `new_len`.\n    ///\n    /// If `new_len` is greater than `len`, the `SmallVec` is extended by the difference, with each\n    /// additional slot filled with the result of calling the closure `f`. The return values from `f`\n    //// will end up in the `SmallVec` in the order they have been generated.\n    ///\n    /// If `new_len` is less than `len`, the `SmallVec` is simply truncated.\n    ///\n    /// This method uses a closure to create new values on every push. If you'd rather `Clone` a given\n    /// value, use `resize`. If you want to use the `Default` trait to generate values, you can pass\n    /// `Default::default()` as the second argument.\n    ///\n    /// Added for std::vec::Vec compatibility (added in Rust 1.33.0)\n    ///\n    /// ```\n    /// # use smallvec::{smallvec, SmallVec};\n    /// let mut vec : SmallVec<[_; 4]> = smallvec![1, 2, 3];\n    /// vec.resize_with(5, Default::default);\n    /// assert_eq!(&*vec, &[1, 2, 3, 0, 0]);\n    ///\n    /// let mut vec : SmallVec<[_; 4]> = smallvec![];\n    /// let mut p = 1;\n    /// vec.resize_with(4, || { p *= 2; p });\n    /// assert_eq!(&*vec, &[2, 4, 8, 16]);\n    /// ```\n    pub fn resize_with<F>(&mut self, new_len: usize, f: F)\n    where\n        F: FnMut() -> A::Item,\n    {\n        let old_len = self.len();\n        if old_len < new_len {\n            let mut f = f;\n            let additional = new_len - old_len;\n            self.reserve(additional);\n            for _ in 0..additional {\n                self.push(f());\n            }\n        } else if old_len > new_len {\n            self.truncate(new_len);\n        }\n    }\n\n    /// Creates a `SmallVec` directly from the raw components of another\n    /// `SmallVec`.\n    ///\n    /// # Safety\n    ///\n    /// This is highly unsafe, due to the number of invariants that aren't\n    /// checked:\n    ///\n    /// * `ptr` needs to have been previously allocated via `SmallVec` for its\n    ///   spilled storage (at least, it's highly likely to be incorrect if it\n    ///   wasn't).\n    /// * `ptr`'s `A::Item` type needs to be the same size and alignment that\n    ///   it was allocated with\n    /// * `length` needs to be less than or equal to `capacity`.\n    /// * `capacity` needs to be the capacity that the pointer was allocated\n    ///   with.\n    ///\n    /// Violating these may cause problems like corrupting the allocator's\n    /// internal data structures.\n    ///\n    /// Additionally, `capacity` must be greater than the amount of inline\n    /// storage `A` has; that is, the new `SmallVec` must need to spill over\n    /// into heap allocated storage. This condition is asserted against.\n    ///\n    /// The ownership of `ptr` is effectively transferred to the\n    /// `SmallVec` which may then deallocate, reallocate or change the\n    /// contents of memory pointed to by the pointer at will. Ensure\n    /// that nothing else uses the pointer after calling this\n    /// function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate smallvec;\n    /// # use smallvec::SmallVec;\n    /// use std::mem;\n    /// use std::ptr;\n    ///\n    /// fn main() {\n    ///     let mut v: SmallVec<[_; 1]> = smallvec![1, 2, 3];\n    ///\n    ///     // Pull out the important parts of `v`.\n    ///     let p = v.as_mut_ptr();\n    ///     let len = v.len();\n    ///     let cap = v.capacity();\n    ///     let spilled = v.spilled();\n    ///\n    ///     unsafe {\n    ///         // Forget all about `v`. The heap allocation that stored the\n    ///         // three values won't be deallocated.\n    ///         mem::forget(v);\n    ///\n    ///         // Overwrite memory with [4, 5, 6].\n    ///         //\n    ///         // This is only safe if `spilled` is true! Otherwise, we are\n    ///         // writing into the old `SmallVec`'s inline storage on the\n    ///         // stack.\n    ///         assert!(spilled);\n    ///         for i in 0..len {\n    ///             ptr::write(p.add(i), 4 + i);\n    ///         }\n    ///\n    ///         // Put everything back together into a SmallVec with a different\n    ///         // amount of inline storage, but which is still less than `cap`.\n    ///         let rebuilt = SmallVec::<[_; 2]>::from_raw_parts(p, len, cap);\n    ///         assert_eq!(&*rebuilt, &[4, 5, 6]);\n    ///     }\n    /// }\n    #[inline]\n    pub unsafe fn from_raw_parts(ptr: *mut A::Item, length: usize, capacity: usize) -> SmallVec<A> {\n        assert!(capacity > Self::inline_capacity());\n        SmallVec {\n            capacity,\n            data: SmallVecData::from_heap(ptr, length),\n        }\n    }\n\n    /// Returns a raw pointer to the vector's buffer.\n    pub fn as_ptr(&self) -> *const A::Item {\n        // We shadow the slice method of the same name to avoid going through\n        // `deref`, which creates an intermediate reference that may place\n        // additional safety constraints on the contents of the slice.\n        self.triple().0\n    }\n\n    /// Returns a raw mutable pointer to the vector's buffer.\n    pub fn as_mut_ptr(&mut self) -> *mut A::Item {\n        // We shadow the slice method of the same name to avoid going through\n        // `deref_mut`, which creates an intermediate reference that may place\n        // additional safety constraints on the contents of the slice.\n        self.triple_mut().0\n    }\n}","impl<A: Array> fmt::Debug for SmallVec<A>\nwhere\n    A::Item: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}","impl<A: Array> ops::Deref for SmallVec<A> {\n    type Target = [A::Item];\n    #[inline]\n    fn deref(&self) -> &[A::Item] {\n        unsafe {\n            let (ptr, len, _) = self.triple();\n            slice::from_raw_parts(ptr, len)\n        }\n    }\n}","impl<A: Array> ops::DerefMut for SmallVec<A> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut [A::Item] {\n        unsafe {\n            let (ptr, &mut len, _) = self.triple_mut();\n            slice::from_raw_parts_mut(ptr, len)\n        }\n    }\n}","unsafe impl<A: Array> Send for SmallVec<A> where A::Item: Send {}"],"SmallVec<A>::insert_many::DropOnPanic":["impl<T> Drop for DropOnPanic<T> {\n            fn drop(&mut self) {\n                for i in 0..self.len {\n                    if !self.skip.contains(&i) {\n                        unsafe {\n                            ptr::drop_in_place(self.start.add(i));\n                        }\n                    }\n                }\n            }\n        }"],"SmallVecData":["impl<A: Array> SmallVecData<A> {\n    #[inline]\n    unsafe fn inline(&self) -> *const A::Item {\n        match self {\n            SmallVecData::Inline(a) => a.as_ptr() as *const A::Item,\n            _ => debug_unreachable!(),\n        }\n    }\n    #[inline]\n    unsafe fn inline_mut(&mut self) -> *mut A::Item {\n        match self {\n            SmallVecData::Inline(a) => a.as_mut_ptr() as *mut A::Item,\n            _ => debug_unreachable!(),\n        }\n    }\n    #[inline]\n    fn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {\n        SmallVecData::Inline(inline)\n    }\n    #[inline]\n    unsafe fn into_inline(self) -> MaybeUninit<A> {\n        match self {\n            SmallVecData::Inline(a) => a,\n            _ => debug_unreachable!(),\n        }\n    }\n    #[inline]\n    unsafe fn heap(&self) -> (*mut A::Item, usize) {\n        match self {\n            SmallVecData::Heap(data) => *data,\n            _ => debug_unreachable!(),\n        }\n    }\n    #[inline]\n    unsafe fn heap_mut(&mut self) -> &mut (*mut A::Item, usize) {\n        match self {\n            SmallVecData::Heap(data) => data,\n            _ => debug_unreachable!(),\n        }\n    }\n    #[inline]\n    fn from_heap(ptr: *mut A::Item, len: usize) -> SmallVecData<A> {\n        SmallVecData::Heap((ptr, len))\n    }\n}","unsafe impl<A: Array + Send> Send for SmallVecData<A> {}","unsafe impl<A: Array + Sync> Sync for SmallVecData<A> {}"],"alloc::vec::Vec":["impl<T: Clone> ExtendFromSlice<T> for Vec<T> {\n    fn extend_from_slice(&mut self, other: &[T]) {\n        Vec::extend_from_slice(self, other)\n    }\n}"]},"single_path_import":{},"srcs":{"<&'a SmallVec<A> as core::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a mut SmallVec<A> as core::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter_mut()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CollectionAllocErr as core::convert::From<core::alloc::LayoutError>>::from":["fn from(_: LayoutErr) -> Self{\n        CollectionAllocErr::CapacityOverflow\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<CollectionAllocErr as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"Allocation error: {:?}\", self)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as core::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<T::Item>{\n        self.iter\n            .next_back()\n            .map(|reference| unsafe { ptr::read(reference) })\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as core::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n        self.iter.len()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as core::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<T::Item>{\n        self.iter\n            .next()\n            .map(|reference| unsafe { ptr::read(reference) })\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as core::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as core::ops::Drop>::drop":["fn drop(&mut self){\n        self.for_each(drop);\n\n        if self.tail_len > 0 {\n            unsafe {\n                let source_vec = self.vec.as_mut();\n\n                // memmove back untouched tail, update to new length\n                let start = source_vec.len();\n                let tail = self.tail_start;\n                if tail != start {\n                    let src = source_vec.as_ptr().add(tail);\n                    let dst = source_vec.as_mut_ptr().add(start);\n                    ptr::copy(src, dst, self.tail_len);\n                }\n                source_vec.set_len(start + self.tail_len);\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<A> as core::clone::Clone>::clone":["fn clone(&self) -> IntoIter<A>{\n        SmallVec::from(self.as_slice()).into_iter()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<A> as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<A> as core::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<A::Item>{\n        if self.current == self.end {\n            None\n        } else {\n            unsafe {\n                self.end -= 1;\n                Some(ptr::read(self.data.as_ptr().add(self.end)))\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<A> as core::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<A::Item>{\n        if self.current == self.end {\n            None\n        } else {\n            unsafe {\n                let current = self.current;\n                self.current += 1;\n                Some(ptr::read(self.data.as_ptr().add(current)))\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<A> as core::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        let size = self.end - self.current;\n        (size, Some(size))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IntoIter<A> as core::ops::Drop>::drop":["fn drop(&mut self){\n        for _ in self {}\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SetLenOnDrop<'a> as core::ops::Drop>::drop":["#[inline]\nfn drop(&mut self){\n        *self.len = self.local_len;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as ExtendFromSlice<<A as Array>::Item>>::extend_from_slice":["fn extend_from_slice(&mut self, other: &[A::Item]){\n        SmallVec::extend_from_slice(self, other)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::borrow::Borrow<[<A as Array>::Item]>>::borrow":["#[inline]\nfn borrow(&self) -> &[A::Item]{\n        self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::borrow::BorrowMut<[<A as Array>::Item]>>::borrow_mut":["#[inline]\nfn borrow_mut(&mut self) -> &mut [A::Item]{\n        self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::clone::Clone>::clone":["#[inline]\nfn clone(&self) -> SmallVec<A>{\n        SmallVec::from(self.as_slice())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::cmp::Ord>::cmp":["#[inline]\nfn cmp(&self, other: &SmallVec<A>) -> cmp::Ordering{\n        Ord::cmp(&**self, &**other)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::cmp::PartialEq<SmallVec<B>>>::eq":["#[inline]\nfn eq(&self, other: &SmallVec<B>) -> bool{\n        self[..] == other[..]\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::cmp::PartialOrd>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &SmallVec<A>) -> Option<cmp::Ordering>{\n        PartialOrd::partial_cmp(&**self, &**other)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::convert::AsMut<[<A as Array>::Item]>>::as_mut":["#[inline]\nfn as_mut(&mut self) -> &mut [A::Item]{\n        self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::convert::AsRef<[<A as Array>::Item]>>::as_ref":["#[inline]\nfn as_ref(&self) -> &[A::Item]{\n        self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::convert::From<&'a [<A as Array>::Item]>>::from":["#[cfg(not(feature = \"specialization\"))]\n#[inline]\nfn from(slice: &'a [A::Item]) -> SmallVec<A>{\n        slice.iter().cloned().collect()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::convert::From<A>>::from":["#[inline]\nfn from(array: A) -> SmallVec<A>{\n        SmallVec::from_buf(array)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::convert::From<alloc::vec::Vec<<A as Array>::Item>>>::from":["#[inline]\nfn from(vec: Vec<A::Item>) -> SmallVec<A>{\n        SmallVec::from_vec(vec)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::default::Default>::default":["#[inline]\nfn default() -> SmallVec<A>{\n        SmallVec::new()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.iter()).finish()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::hash::Hash>::hash":["fn hash<H: Hasher>(&self, state: &mut H){\n        (**self).hash(state)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::iter::Extend<<A as Array>::Item>>::extend":["fn extend<I: IntoIterator<Item = A::Item>>(&mut self, iterable: I){\n        let mut iter = iterable.into_iter();\n        let (lower_size_bound, _) = iter.size_hint();\n        self.reserve(lower_size_bound);\n\n        unsafe {\n            let (ptr, len_ptr, cap) = self.triple_mut();\n            let mut len = SetLenOnDrop::new(len_ptr);\n            while len.get() < cap {\n                if let Some(out) = iter.next() {\n                    ptr::write(ptr.add(len.get()), out);\n                    len.increment_len(1);\n                } else {\n                    return;\n                }\n            }\n        }\n\n        for elem in iter {\n            self.push(elem);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::iter::FromIterator<<A as Array>::Item>>::from_iter":["#[inline]\nfn from_iter<I: IntoIterator<Item = A::Item>>(iterable: I) -> SmallVec<A>{\n        let mut v = SmallVec::new();\n        v.extend(iterable);\n        v\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::iter::IntoIterator>::into_iter":["fn into_iter(mut self) -> Self::IntoIter{\n        unsafe {\n            // Set SmallVec len to zero as `IntoIter` drop handles dropping of the elements\n            let len = self.len();\n            self.set_len(0);\n            IntoIter {\n                data: self,\n                current: 0,\n                end: len,\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::ops::Deref>::deref":["#[inline]\nfn deref(&self) -> &[A::Item]{\n        unsafe {\n            let (ptr, len, _) = self.triple();\n            slice::from_raw_parts(ptr, len)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::ops::DerefMut>::deref_mut":["#[inline]\nfn deref_mut(&mut self) -> &mut [A::Item]{\n        unsafe {\n            let (ptr, &mut len, _) = self.triple_mut();\n            slice::from_raw_parts_mut(ptr, len)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::ops::Drop>::drop":["fn drop(&mut self){\n        unsafe {\n            if self.spilled() {\n                let (ptr, len) = self.data.heap();\n                Vec::from_raw_parts(ptr, len, self.capacity);\n            } else {\n                ptr::drop_in_place(&mut self[..]);\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::ops::Index<I>>::index":["fn index(&self, index: I) -> &I::Output{\n        &(**self)[index]\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A> as core::ops::IndexMut<I>>::index_mut":["fn index_mut(&mut self, index: I) -> &mut I::Output{\n        &mut (&mut **self)[index]\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SmallVec<A>::insert_many::DropOnPanic<T> as core::ops::Drop>::drop":["fn drop(&mut self){\n                for i in 0..self.len {\n                    if !self.skip.contains(&i) {\n                        unsafe {\n                            ptr::drop_in_place(self.start.add(i));\n                        }\n                    }\n                }\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<[<A as Array>::Item] as ToSmallVec<A>>::to_smallvec":["#[inline]\nfn to_smallvec(&self) -> SmallVec<A>{\n        SmallVec::from_slice(self)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 0] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 1024] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 1048576] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 10] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 11] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 128] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 12] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 131072] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 13] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 14] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 1536] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 15] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 16384] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 16] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 17] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 18] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 19] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 1] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 2048] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 20] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 21] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 22] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 23] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 24576] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 24] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 256] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 25] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 262144] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 26] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 27] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 28] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 29] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 2] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 30] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 31] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 32768] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 32] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 36] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 393216] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 3] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 4096] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 4] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 512] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 524288] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 5] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 64] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 65536] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 6] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 7] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 8192] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 8] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 96] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<[T; 9] as Array>::size":["fn size() -> usize{ $size }","Real(LocalPath(\"src/lib.rs\"))"],"<alloc::vec::Vec<T> as ExtendFromSlice<T>>::extend_from_slice":["fn extend_from_slice(&mut self, other: &[T]){\n        Vec::extend_from_slice(self, other)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Array":["/// Types that can be used as the backing store for a SmallVec\npub unsafe trait Array {\n    /// The type of the array's elements.\n    type Item;\n    /// Returns the number of items the array can hold.\n    fn size() -> usize;\n}","Real(LocalPath(\"src/lib.rs\"))"],"CollectionAllocErr":["/// Error type for APIs with fallible heap allocation\npub enum CollectionAllocErr {\n    /// Overflow `usize::MAX` or other error during size computation\n    CapacityOverflow,\n    /// The allocator return an error\n    AllocErr {\n        /// The layout that was passed to the allocator\n        layout: Layout,\n    },\n}","Real(LocalPath(\"src/lib.rs\"))"],"Drain":["/// An iterator that removes the items from a `SmallVec` and yields them by value.\n///\n/// Returned from [`SmallVec::drain`][1].\n///\n/// [1]: struct.SmallVec.html#method.drain\npub struct Drain<'a, T: 'a + Array> {\n    tail_start: usize,\n    tail_len: usize,\n    iter: slice::Iter<'a, T::Item>,\n    vec: NonNull<SmallVec<T>>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"ExtendFromSlice":["/// Trait to be implemented by a collection that can be extended from a slice\n///\n/// ## Example\n///\n/// ```rust\n/// use smallvec::{ExtendFromSlice, SmallVec};\n///\n/// fn initialize<V: ExtendFromSlice<u8>>(v: &mut V) {\n///     v.extend_from_slice(b\"Test!\");\n/// }\n///\n/// let mut vec = Vec::new();\n/// initialize(&mut vec);\n/// assert_eq!(&vec, b\"Test!\");\n///\n/// let mut small_vec = SmallVec::<[u8; 8]>::new();\n/// initialize(&mut small_vec);\n/// assert_eq!(&small_vec as &[_], b\"Test!\");\n/// ```\n#[doc(hidden)]\n#[deprecated]\npub trait ExtendFromSlice<T> {\n    /// Extends a collection from a slice of its element type\n    fn extend_from_slice(&mut self, other: &[T]);\n}","Real(LocalPath(\"src/lib.rs\"))"],"IntoIter":["/// An iterator that consumes a `SmallVec` and yields its items by value.\n///\n/// Returned from [`SmallVec::into_iter`][1].\n///\n/// [1]: struct.SmallVec.html#method.into_iter\npub struct IntoIter<A: Array> {\n    data: SmallVec<A>,\n    current: usize,\n    end: usize,\n}","Real(LocalPath(\"src/lib.rs\"))"],"IntoIter::<A>::as_mut_slice":["/// Returns the remaining items of this iterator as a mutable slice.\npub fn as_mut_slice(&mut self) -> &mut [A::Item]{\n        let len = self.end - self.current;\n        unsafe { core::slice::from_raw_parts_mut(self.data.as_mut_ptr().add(self.current), len) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"IntoIter::<A>::as_slice":["/// Returns the remaining items of this iterator as a slice.\npub fn as_slice(&self) -> &[A::Item]{\n        let len = self.end - self.current;\n        unsafe { core::slice::from_raw_parts(self.data.as_ptr().add(self.current), len) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SetLenOnDrop":["/// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n///\n/// Copied from https://github.com/rust-lang/rust/pull/36355\nstruct SetLenOnDrop<'a> {\n    len: &'a mut usize,\n    local_len: usize,\n}","Real(LocalPath(\"src/lib.rs\"))"],"SetLenOnDrop::<'a>::get":["#[inline]\nfn get(&self) -> usize{\n        self.local_len\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SetLenOnDrop::<'a>::increment_len":["#[inline]\nfn increment_len(&mut self, increment: usize){\n        self.local_len += increment;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SetLenOnDrop::<'a>::new":["#[inline]\nfn new(len: &'a mut usize) -> Self{\n        SetLenOnDrop {\n            local_len: *len,\n            len,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec":["/// A `Vec`-like container that can store a small number of elements inline.\n///\n/// `SmallVec` acts like a vector, but can store a limited amount of data inline within the\n/// `SmallVec` struct rather than in a separate allocation.  If the data exceeds this limit, the\n/// `SmallVec` will \"spill\" its data onto the heap, allocating a new buffer to hold it.\n///\n/// The amount of data that a `SmallVec` can store inline depends on its backing store. The backing\n/// store can be any type that implements the `Array` trait; usually it is a small fixed-sized\n/// array.  For example a `SmallVec<[u64; 8]>` can hold up to eight 64-bit integers inline.\n///\n/// ## Example\n///\n/// ```rust\n/// use smallvec::SmallVec;\n/// let mut v = SmallVec::<[u8; 4]>::new(); // initialize an empty vector\n///\n/// // The vector can hold up to 4 items without spilling onto the heap.\n/// v.extend(0..4);\n/// assert_eq!(v.len(), 4);\n/// assert!(!v.spilled());\n///\n/// // Pushing another element will force the buffer to spill:\n/// v.push(4);\n/// assert_eq!(v.len(), 5);\n/// assert!(v.spilled());\n/// ```\npub struct SmallVec<A: Array> {\n    // The capacity field is used to determine which of the storage variants is active:\n    // If capacity <= Self::inline_capacity() then the inline variant is used and capacity holds the current length of the vector (number of elements actually in use).\n    // If capacity > Self::inline_capacity() then the heap variant is used and capacity holds the size of the memory allocation.\n    capacity: usize,\n    data: SmallVecData<A>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::append":["/// Moves all the elements of `other` into `self`, leaving `other` empty.\n///\n/// # Example\n///\n/// ```\n/// # use smallvec::{SmallVec, smallvec};\n/// let mut v0: SmallVec<[u8; 16]> = smallvec![1, 2, 3];\n/// let mut v1: SmallVec<[u8; 32]> = smallvec![4, 5, 6];\n/// v0.append(&mut v1);\n/// assert_eq!(*v0, [1, 2, 3, 4, 5, 6]);\n/// assert_eq!(*v1, []);\n/// ```\npub fn append<B>(&mut self, other: &mut SmallVec<B>)\n    where\n        B: Array<Item = A::Item>,{\n        self.extend(other.drain(..))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::as_mut_ptr":["/// Returns a raw mutable pointer to the vector's buffer.\npub fn as_mut_ptr(&mut self) -> *mut A::Item{\n        // We shadow the slice method of the same name to avoid going through\n        // `deref_mut`, which creates an intermediate reference that may place\n        // additional safety constraints on the contents of the slice.\n        self.triple_mut().0\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::as_mut_slice":["/// Extracts a mutable slice of the entire vector.\n///\n/// Equivalent to `&mut s[..]`.\npub fn as_mut_slice(&mut self) -> &mut [A::Item]{\n        self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::as_ptr":["/// Returns a raw pointer to the vector's buffer.\npub fn as_ptr(&self) -> *const A::Item{\n        // We shadow the slice method of the same name to avoid going through\n        // `deref`, which creates an intermediate reference that may place\n        // additional safety constraints on the contents of the slice.\n        self.triple().0\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::as_slice":["/// Extracts a slice containing the entire vector.\n///\n/// Equivalent to `&s[..]`.\npub fn as_slice(&self) -> &[A::Item]{\n        self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::capacity":["/// The number of items the vector can hold without reallocating\n#[inline]\npub fn capacity(&self) -> usize{\n        self.triple().2\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::clear":["/// Remove all elements from the vector.\n#[inline]\npub fn clear(&mut self){\n        self.truncate(0);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::dedup":["/// Removes consecutive duplicate elements.\npub fn dedup(&mut self)\n    where\n        A::Item: PartialEq<A::Item>,{\n        self.dedup_by(|a, b| a == b);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::dedup_by":["/// Removes consecutive duplicate elements using the given equality relation.\npub fn dedup_by<F>(&mut self, mut same_bucket: F)\n    where\n        F: FnMut(&mut A::Item, &mut A::Item) -> bool,{\n        // See the implementation of Vec::dedup_by in the\n        // standard library for an explanation of this algorithm.\n        let len = self.len();\n        if len <= 1 {\n            return;\n        }\n\n        let ptr = self.as_mut_ptr();\n        let mut w: usize = 1;\n\n        unsafe {\n            for r in 1..len {\n                let p_r = ptr.add(r);\n                let p_wm1 = ptr.add(w - 1);\n                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n                    if r != w {\n                        let p_w = p_wm1.add(1);\n                        mem::swap(&mut *p_r, &mut *p_w);\n                    }\n                    w += 1;\n                }\n            }\n        }\n\n        self.truncate(w);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::dedup_by_key":["/// Removes consecutive elements that map to the same key.\npub fn dedup_by_key<F, K>(&mut self, mut key: F)\n    where\n        F: FnMut(&mut A::Item) -> K,\n        K: PartialEq<K>,{\n        self.dedup_by(|a, b| key(a) == key(b));\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::drain":["/// Creates a draining iterator that removes the specified range in the vector\n/// and yields the removed items.\n///\n/// Note 1: The element range is removed even if the iterator is only\n/// partially consumed or not consumed at all.\n///\n/// Note 2: It is unspecified how many elements are removed from the vector\n/// if the `Drain` value is leaked.\n///\n/// # Panics\n///\n/// Panics if the starting point is greater than the end point or if\n/// the end point is greater than the length of the vector.\npub fn drain<R>(&mut self, range: R) -> Drain<'_, A>\n    where\n        R: RangeBounds<usize>,{\n        use core::ops::Bound::*;\n\n        let len = self.len();\n        let start = match range.start_bound() {\n            Included(&n) => n,\n            Excluded(&n) => n + 1,\n            Unbounded => 0,\n        };\n        let end = match range.end_bound() {\n            Included(&n) => n + 1,\n            Excluded(&n) => n,\n            Unbounded => len,\n        };\n\n        assert!(start <= end);\n        assert!(end <= len);\n\n        unsafe {\n            self.set_len(start);\n\n            let range_slice = slice::from_raw_parts_mut(self.as_mut_ptr().add(start), end - start);\n\n            Drain {\n                tail_start: end,\n                tail_len: len - end,\n                iter: range_slice.iter(),\n                vec: NonNull::from(self),\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::extend_from_slice":["/// Copy elements from a slice and append them to the vector.\n///\n/// For slices of `Copy` types, this is more efficient than `extend`.\n#[inline]\npub fn extend_from_slice(&mut self, slice: &[A::Item]){\n        let len = self.len();\n        self.insert_from_slice(len, slice);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::from_buf":["/// Constructs a new `SmallVec` on the stack from an `A` without\n/// copying elements.\n///\n/// ```rust\n/// use smallvec::SmallVec;\n///\n/// let buf = [1, 2, 3, 4, 5];\n/// let small_vec: SmallVec<_> = SmallVec::from_buf(buf);\n///\n/// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n/// ```\n#[inline]\npub fn from_buf(buf: A) -> SmallVec<A>{\n        SmallVec {\n            capacity: A::size(),\n            data: SmallVecData::from_inline(MaybeUninit::new(buf)),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::from_buf_and_len":["/// Constructs a new `SmallVec` on the stack from an `A` without\n/// copying elements. Also sets the length, which must be less or\n/// equal to the size of `buf`.\n///\n/// ```rust\n/// use smallvec::SmallVec;\n///\n/// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n/// let small_vec: SmallVec<_> = SmallVec::from_buf_and_len(buf, 5);\n///\n/// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n/// ```\n#[inline]\npub fn from_buf_and_len(buf: A, len: usize) -> SmallVec<A>{\n        assert!(len <= A::size());\n        unsafe { SmallVec::from_buf_and_len_unchecked(MaybeUninit::new(buf), len) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::from_buf_and_len_unchecked":["/// Constructs a new `SmallVec` on the stack from an `A` without\n/// copying elements. Also sets the length. The user is responsible\n/// for ensuring that `len <= A::size()`.\n///\n/// ```rust\n/// use smallvec::SmallVec;\n/// use std::mem::MaybeUninit;\n///\n/// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n/// let small_vec: SmallVec<_> = unsafe {\n///     SmallVec::from_buf_and_len_unchecked(MaybeUninit::new(buf), 5)\n/// };\n///\n/// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n/// ```\n#[inline]\npub unsafe fn from_buf_and_len_unchecked(buf: MaybeUninit<A>, len: usize) -> SmallVec<A>{\n        SmallVec {\n            capacity: len,\n            data: SmallVecData::from_inline(buf),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::from_elem":["/// Creates a `SmallVec` with `n` copies of `elem`.\n/// ```\n/// use smallvec::SmallVec;\n///\n/// let v = SmallVec::<[char; 128]>::from_elem('d', 2);\n/// assert_eq!(v, SmallVec::from_buf(['d', 'd']));\n/// ```\npub fn from_elem(elem: A::Item, n: usize) -> Self{\n        if n > Self::inline_capacity() {\n            vec![elem; n].into()\n        } else {\n            let mut v = SmallVec::<A>::new();\n            unsafe {\n                let (ptr, len_ptr, _) = v.triple_mut();\n                let mut local_len = SetLenOnDrop::new(len_ptr);\n\n                for i in 0..n {\n                    ::core::ptr::write(ptr.add(i), elem.clone());\n                    local_len.increment_len(1);\n                }\n            }\n            v\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::from_raw_parts":["/// Creates a `SmallVec` directly from the raw components of another\n/// `SmallVec`.\n///\n/// # Safety\n///\n/// This is highly unsafe, due to the number of invariants that aren't\n/// checked:\n///\n/// * `ptr` needs to have been previously allocated via `SmallVec` for its\n///   spilled storage (at least, it's highly likely to be incorrect if it\n///   wasn't).\n/// * `ptr`'s `A::Item` type needs to be the same size and alignment that\n///   it was allocated with\n/// * `length` needs to be less than or equal to `capacity`.\n/// * `capacity` needs to be the capacity that the pointer was allocated\n///   with.\n///\n/// Violating these may cause problems like corrupting the allocator's\n/// internal data structures.\n///\n/// Additionally, `capacity` must be greater than the amount of inline\n/// storage `A` has; that is, the new `SmallVec` must need to spill over\n/// into heap allocated storage. This condition is asserted against.\n///\n/// The ownership of `ptr` is effectively transferred to the\n/// `SmallVec` which may then deallocate, reallocate or change the\n/// contents of memory pointed to by the pointer at will. Ensure\n/// that nothing else uses the pointer after calling this\n/// function.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate smallvec;\n/// # use smallvec::SmallVec;\n/// use std::mem;\n/// use std::ptr;\n///\n/// fn main() {\n///     let mut v: SmallVec<[_; 1]> = smallvec![1, 2, 3];\n///\n///     // Pull out the important parts of `v`.\n///     let p = v.as_mut_ptr();\n///     let len = v.len();\n///     let cap = v.capacity();\n///     let spilled = v.spilled();\n///\n///     unsafe {\n///         // Forget all about `v`. The heap allocation that stored the\n///         // three values won't be deallocated.\n///         mem::forget(v);\n///\n///         // Overwrite memory with [4, 5, 6].\n///         //\n///         // This is only safe if `spilled` is true! Otherwise, we are\n///         // writing into the old `SmallVec`'s inline storage on the\n///         // stack.\n///         assert!(spilled);\n///         for i in 0..len {\n///             ptr::write(p.add(i), 4 + i);\n///         }\n///\n///         // Put everything back together into a SmallVec with a different\n///         // amount of inline storage, but which is still less than `cap`.\n///         let rebuilt = SmallVec::<[_; 2]>::from_raw_parts(p, len, cap);\n///         assert_eq!(&*rebuilt, &[4, 5, 6]);\n///     }\n/// }\n#[inline]\npub unsafe fn from_raw_parts(ptr: *mut A::Item, length: usize, capacity: usize) -> SmallVec<A>{\n        assert!(capacity > Self::inline_capacity());\n        SmallVec {\n            capacity,\n            data: SmallVecData::from_heap(ptr, length),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::from_slice":["/// Copy the elements from a slice into a new `SmallVec`.\n///\n/// For slices of `Copy` types, this is more efficient than `SmallVec::from(slice)`.\npub fn from_slice(slice: &[A::Item]) -> Self{\n        let len = slice.len();\n        if len <= Self::inline_capacity() {\n            SmallVec {\n                capacity: len,\n                data: SmallVecData::from_inline(unsafe {\n                    let mut data: MaybeUninit<A> = MaybeUninit::uninit();\n                    ptr::copy_nonoverlapping(\n                        slice.as_ptr(),\n                        data.as_mut_ptr() as *mut A::Item,\n                        len,\n                    );\n                    data\n                }),\n            }\n        } else {\n            let mut b = slice.to_vec();\n            let (ptr, cap) = (b.as_mut_ptr(), b.capacity());\n            mem::forget(b);\n            SmallVec {\n                capacity: cap,\n                data: SmallVecData::from_heap(ptr, len),\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::from_vec":["/// Construct a new `SmallVec` from a `Vec<A::Item>`.\n///\n/// Elements will be copied to the inline buffer if vec.capacity() <= Self::inline_capacity().\n///\n/// ```rust\n/// use smallvec::SmallVec;\n///\n/// let vec = vec![1, 2, 3, 4, 5];\n/// let small_vec: SmallVec<[_; 3]> = SmallVec::from_vec(vec);\n///\n/// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n/// ```\n#[inline]\npub fn from_vec(mut vec: Vec<A::Item>) -> SmallVec<A>{\n        if vec.capacity() <= Self::inline_capacity() {\n            unsafe {\n                let mut data = SmallVecData::<A>::from_inline(MaybeUninit::uninit());\n                let len = vec.len();\n                vec.set_len(0);\n                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut(), len);\n\n                SmallVec {\n                    capacity: len,\n                    data,\n                }\n            }\n        } else {\n            let (ptr, cap, len) = (vec.as_mut_ptr(), vec.capacity(), vec.len());\n            mem::forget(vec);\n\n            SmallVec {\n                capacity: cap,\n                data: SmallVecData::from_heap(ptr, len),\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::grow":["/// Re-allocate to set the capacity to `max(new_cap, inline_size())`.\n///\n/// Panics if `new_cap` is less than the vector's length\n/// or if the capacity computation overflows `usize`.\npub fn grow(&mut self, new_cap: usize){\n        infallible(self.try_grow(new_cap))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::inline_capacity":["/// The maximum number of elements this vector can hold inline\n#[inline]\nfn inline_capacity() -> usize{\n        if mem::size_of::<A::Item>() > 0 {\n            A::size()\n        } else {\n            // For zero-size items code like `ptr.add(offset)` always returns the same pointer.\n            // Therefore all items are at the same address,\n            // and any array size has capacity for infinitely many items.\n            // The capacity is limited by the bit width of the length field.\n            //\n            // `Vec` also does this:\n            // https://github.com/rust-lang/rust/blob/1.44.0/src/liballoc/raw_vec.rs#L186\n            //\n            // In our case, this also ensures that a smallvec of zero-size items never spills,\n            // and we never try to allocate zero bytes which `std::alloc::alloc` disallows.\n            core::usize::MAX\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::inline_size":["/// The maximum number of elements this vector can hold inline\n#[inline]\npub fn inline_size(&self) -> usize{\n        Self::inline_capacity()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::insert":["/// Insert an element at position `index`, shifting all elements after it to the right.\n///\n/// Panics if `index` is out of bounds.\npub fn insert(&mut self, index: usize, element: A::Item){\n        self.reserve(1);\n\n        unsafe {\n            let (mut ptr, len_ptr, _) = self.triple_mut();\n            let len = *len_ptr;\n            assert!(index <= len);\n            *len_ptr = len + 1;\n            ptr = ptr.add(index);\n            ptr::copy(ptr, ptr.add(1), len - index);\n            ptr::write(ptr, element);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::insert_from_slice":["/// Copy elements from a slice into the vector at position `index`, shifting any following\n/// elements toward the back.\n///\n/// For slices of `Copy` types, this is more efficient than `insert`.\npub fn insert_from_slice(&mut self, index: usize, slice: &[A::Item]){\n        self.reserve(slice.len());\n\n        let len = self.len();\n        assert!(index <= len);\n\n        unsafe {\n            let slice_ptr = slice.as_ptr();\n            let ptr = self.as_mut_ptr().add(index);\n            ptr::copy(ptr, ptr.add(slice.len()), len - index);\n            ptr::copy_nonoverlapping(slice_ptr, ptr, slice.len());\n            self.set_len(len + slice.len());\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::insert_many":["/// Insert multiple elements at position `index`, shifting all following elements toward the\n/// back.\npub fn insert_many<I: IntoIterator<Item = A::Item>>(&mut self, index: usize, iterable: I){\n        let iter = iterable.into_iter();\n        if index == self.len() {\n            return self.extend(iter);\n        }\n\n        let (lower_size_bound, _) = iter.size_hint();\n        assert!(lower_size_bound <= core::isize::MAX as usize); // Ensure offset is indexable\n        assert!(index + lower_size_bound >= index); // Protect against overflow\n        self.reserve(lower_size_bound);\n\n        unsafe {\n            let old_len = self.len();\n            assert!(index <= old_len);\n            let start = self.as_mut_ptr();\n            let mut ptr = start.add(index);\n\n            // Move the trailing elements.\n            ptr::copy(ptr, ptr.add(lower_size_bound), old_len - index);\n\n            // In case the iterator panics, don't double-drop the items we just copied above.\n            self.set_len(0);\n            let mut guard = DropOnPanic {\n                start,\n                skip: index..(index + lower_size_bound),\n                len: old_len + lower_size_bound,\n            };\n\n            let mut num_added = 0;\n            for element in iter {\n                let mut cur = ptr.add(num_added);\n                if num_added >= lower_size_bound {\n                    // Iterator provided more elements than the hint.  Move trailing items again.\n                    self.reserve(1);\n                    let start = self.as_mut_ptr();\n                    ptr = start.add(index);\n                    cur = ptr.add(num_added);\n                    ptr::copy(cur, cur.add(1), old_len - index);\n\n                    guard.start = start;\n                    guard.len += 1;\n                    guard.skip.end += 1;\n                }\n                ptr::write(cur, element);\n                guard.skip.start += 1;\n                num_added += 1;\n            }\n            mem::forget(guard);\n\n            if num_added < lower_size_bound {\n                // Iterator provided fewer elements than the hint\n                ptr::copy(\n                    ptr.add(lower_size_bound),\n                    ptr.add(num_added),\n                    old_len - index,\n                );\n            }\n\n            self.set_len(old_len + num_added);\n        }\n\n        struct DropOnPanic<T> {\n            start: *mut T,\n            skip: Range<usize>,\n            len: usize,\n        }\n\n        impl<T> Drop for DropOnPanic<T> {\n            fn drop(&mut self) {\n                for i in 0..self.len {\n                    if !self.skip.contains(&i) {\n                        unsafe {\n                            ptr::drop_in_place(self.start.add(i));\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::into_boxed_slice":["/// Converts a `SmallVec` into a `Box<[T]>` without reallocating if the `SmallVec` has already spilled\n/// onto the heap.\n///\n/// Note that this will drop any excess capacity.\npub fn into_boxed_slice(self) -> Box<[A::Item]>{\n        self.into_vec().into_boxed_slice()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::into_inner":["/// Convert the SmallVec into an `A` if possible. Otherwise return `Err(Self)`.\n///\n/// This method returns `Err(Self)` if the SmallVec is too short (and the `A` contains uninitialized elements),\n/// or if the SmallVec is too long (and all the elements were spilled to the heap).\npub fn into_inner(self) -> Result<A, Self>{\n        if self.spilled() || self.len() != A::size() {\n            // Note: A::size, not Self::inline_capacity\n            Err(self)\n        } else {\n            unsafe {\n                let data = ptr::read(&self.data);\n                mem::forget(self);\n                Ok(data.into_inline().assume_init())\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::into_vec":["/// Convert a SmallVec to a Vec, without reallocating if the SmallVec has already spilled onto\n/// the heap.\npub fn into_vec(self) -> Vec<A::Item>{\n        if self.spilled() {\n            unsafe {\n                let (ptr, len) = self.data.heap();\n                let v = Vec::from_raw_parts(ptr, len, self.capacity);\n                mem::forget(self);\n                v\n            }\n        } else {\n            self.into_iter().collect()\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::is_empty":["/// Returns `true` if the vector is empty\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::len":["/// The number of elements stored in the vector\n#[inline]\npub fn len(&self) -> usize{\n        self.triple().1\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::new":["/// Construct an empty vector\n#[inline]\npub fn new() -> SmallVec<A>{\n        // Try to detect invalid custom implementations of `Array`. Hopefuly,\n        // this check should be optimized away entirely for valid ones.\n        assert!(\n            mem::size_of::<A>() == A::size() * mem::size_of::<A::Item>()\n                && mem::align_of::<A>() >= mem::align_of::<A::Item>()\n        );\n        SmallVec {\n            capacity: 0,\n            data: SmallVecData::from_inline(MaybeUninit::uninit()),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::pop":["/// Remove an item from the end of the vector and return it, or None if empty.\n#[inline]\npub fn pop(&mut self) -> Option<A::Item>{\n        unsafe {\n            let (ptr, len_ptr, _) = self.triple_mut();\n            if *len_ptr == 0 {\n                return None;\n            }\n            let last_index = *len_ptr - 1;\n            *len_ptr = last_index;\n            Some(ptr::read(ptr.add(last_index)))\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::push":["/// Append an item to the vector.\n#[inline]\npub fn push(&mut self, value: A::Item){\n        unsafe {\n            let (mut ptr, mut len, cap) = self.triple_mut();\n            if *len == cap {\n                self.reserve(1);\n                let &mut (heap_ptr, ref mut heap_len) = self.data.heap_mut();\n                ptr = heap_ptr;\n                len = heap_len;\n            }\n            ptr::write(ptr.add(*len), value);\n            *len += 1;\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::remove":["/// Remove and return the element at position `index`, shifting all elements after it to the\n/// left.\n///\n/// Panics if `index` is out of bounds.\npub fn remove(&mut self, index: usize) -> A::Item{\n        unsafe {\n            let (mut ptr, len_ptr, _) = self.triple_mut();\n            let len = *len_ptr;\n            assert!(index < len);\n            *len_ptr = len - 1;\n            ptr = ptr.add(index);\n            let item = ptr::read(ptr);\n            ptr::copy(ptr.add(1), ptr, len - index - 1);\n            item\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::reserve":["/// Reserve capacity for `additional` more elements to be inserted.\n///\n/// May reserve more space to avoid frequent reallocations.\n///\n/// Panics if the capacity computation overflows `usize`.\n#[inline]\npub fn reserve(&mut self, additional: usize){\n        infallible(self.try_reserve(additional))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::reserve_exact":["/// Reserve the minimum capacity for `additional` more elements to be inserted.\n///\n/// Panics if the new capacity overflows `usize`.\npub fn reserve_exact(&mut self, additional: usize){\n        infallible(self.try_reserve_exact(additional))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::resize":["/// Resizes the vector so that its length is equal to `len`.\n///\n/// If `len` is less than the current length, the vector simply truncated.\n///\n/// If `len` is greater than the current length, `value` is appended to the\n/// vector until its length equals `len`.\npub fn resize(&mut self, len: usize, value: A::Item){\n        let old_len = self.len();\n\n        if len > old_len {\n            self.extend(repeat(value).take(len - old_len));\n        } else {\n            self.truncate(len);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::resize_with":["/// Resizes the `SmallVec` in-place so that `len` is equal to `new_len`.\n///\n/// If `new_len` is greater than `len`, the `SmallVec` is extended by the difference, with each\n/// additional slot filled with the result of calling the closure `f`. The return values from `f`\n///\n/// If `new_len` is less than `len`, the `SmallVec` is simply truncated.\n///\n/// This method uses a closure to create new values on every push. If you'd rather `Clone` a given\n/// value, use `resize`. If you want to use the `Default` trait to generate values, you can pass\n/// `Default::default()` as the second argument.\n///\n/// Added for std::vec::Vec compatibility (added in Rust 1.33.0)\n///\n/// ```\n/// # use smallvec::{smallvec, SmallVec};\n/// let mut vec : SmallVec<[_; 4]> = smallvec![1, 2, 3];\n/// vec.resize_with(5, Default::default);\n/// assert_eq!(&*vec, &[1, 2, 3, 0, 0]);\n///\n/// let mut vec : SmallVec<[_; 4]> = smallvec![];\n/// let mut p = 1;\n/// vec.resize_with(4, || { p *= 2; p });\n/// assert_eq!(&*vec, &[2, 4, 8, 16]);\n/// ```\npub fn resize_with<F>(&mut self, new_len: usize, f: F)\n    where\n        F: FnMut() -> A::Item,{\n        let old_len = self.len();\n        if old_len < new_len {\n            let mut f = f;\n            let additional = new_len - old_len;\n            self.reserve(additional);\n            for _ in 0..additional {\n                self.push(f());\n            }\n        } else if old_len > new_len {\n            self.truncate(new_len);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::retain":["/// Retains only the elements specified by the predicate.\n///\n/// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n/// This method operates in place and preserves the order of the retained\n/// elements.\npub fn retain<F: FnMut(&mut A::Item) -> bool>(&mut self, mut f: F){\n        let mut del = 0;\n        let len = self.len();\n        for i in 0..len {\n            if !f(&mut self[i]) {\n                del += 1;\n            } else if del > 0 {\n                self.swap(i - del, i);\n            }\n        }\n        self.truncate(len - del);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::set_len":["/// Sets the length of a vector.\n///\n/// This will explicitly set the size of the vector, without actually\n/// modifying its buffers, so it is up to the caller to ensure that the\n/// vector is actually the specified size.\npub unsafe fn set_len(&mut self, new_len: usize){\n        let (_, len_ptr, _) = self.triple_mut();\n        *len_ptr = new_len;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::shrink_to_fit":["/// Shrink the capacity of the vector as much as possible.\n///\n/// When possible, this will move data from an external heap buffer to the vector's inline\n/// storage.\npub fn shrink_to_fit(&mut self){\n        if !self.spilled() {\n            return;\n        }\n        let len = self.len();\n        if self.inline_size() >= len {\n            unsafe {\n                let (ptr, len) = self.data.heap();\n                self.data = SmallVecData::from_inline(MaybeUninit::uninit());\n                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);\n                deallocate(ptr, self.capacity);\n                self.capacity = len;\n            }\n        } else if self.capacity() > len {\n            self.grow(len);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::spilled":["/// Returns `true` if the data has spilled into a separate heap-allocated buffer.\n#[inline]\npub fn spilled(&self) -> bool{\n        self.capacity > Self::inline_capacity()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::swap_remove":["/// Remove the element at position `index`, replacing it with the last element.\n///\n/// This does not preserve ordering, but is O(1).\n///\n/// Panics if `index` is out of bounds.\n#[inline]\npub fn swap_remove(&mut self, index: usize) -> A::Item{\n        let len = self.len();\n        self.swap(len - 1, index);\n        self.pop()\n            .unwrap_or_else(|| unsafe { unreachable_unchecked() })\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::triple":["/// Returns a tuple with (data ptr, len, capacity)\n/// Useful to get all SmallVec properties with a single check of the current storage variant.\n#[inline]\nfn triple(&self) -> (*const A::Item, usize, usize){\n        unsafe {\n            if self.spilled() {\n                let (ptr, len) = self.data.heap();\n                (ptr, len, self.capacity)\n            } else {\n                (self.data.inline(), self.capacity, Self::inline_capacity())\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::triple_mut":["/// Returns a tuple with (data ptr, len ptr, capacity)\n#[inline]\nfn triple_mut(&mut self) -> (*mut A::Item, &mut usize, usize){\n        unsafe {\n            if self.spilled() {\n                let &mut (ptr, ref mut len_ptr) = self.data.heap_mut();\n                (ptr, len_ptr, self.capacity)\n            } else {\n                (\n                    self.data.inline_mut(),\n                    &mut self.capacity,\n                    Self::inline_capacity(),\n                )\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::truncate":["/// Shorten the vector, keeping the first `len` elements and dropping the rest.\n///\n/// If `len` is greater than or equal to the vector's current length, this has no\n/// effect.\n///\n/// This does not re-allocate.  If you want the vector's capacity to shrink, call\n/// `shrink_to_fit` after truncating.\npub fn truncate(&mut self, len: usize){\n        unsafe {\n            let (ptr, len_ptr, _) = self.triple_mut();\n            while len < *len_ptr {\n                let last_index = *len_ptr - 1;\n                *len_ptr = last_index;\n                ptr::drop_in_place(ptr.add(last_index));\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::try_grow":["/// Re-allocate to set the capacity to `max(new_cap, inline_size())`.\n///\n/// Panics if `new_cap` is less than the vector's length\npub fn try_grow(&mut self, new_cap: usize) -> Result<(), CollectionAllocErr>{\n        unsafe {\n            let (ptr, &mut len, cap) = self.triple_mut();\n            let unspilled = !self.spilled();\n            assert!(new_cap >= len);\n            if new_cap <= self.inline_size() {\n                if unspilled {\n                    return Ok(());\n                }\n                self.data = SmallVecData::from_inline(MaybeUninit::uninit());\n                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);\n                self.capacity = len;\n                deallocate(ptr, cap);\n            } else if new_cap != cap {\n                let layout = layout_array::<A::Item>(new_cap)?;\n                debug_assert!(layout.size() > 0);\n                let new_alloc;\n                if unspilled {\n                    new_alloc = NonNull::new(alloc::alloc::alloc(layout))\n                        .ok_or(CollectionAllocErr::AllocErr { layout })?\n                        .cast()\n                        .as_ptr();\n                    ptr::copy_nonoverlapping(ptr, new_alloc, len);\n                } else {\n                    // This should never fail since the same succeeded\n                    // when previously allocating `ptr`.\n                    let old_layout = layout_array::<A::Item>(cap)?;\n\n                    let new_ptr = alloc::alloc::realloc(ptr as *mut u8, old_layout, layout.size());\n                    new_alloc = NonNull::new(new_ptr)\n                        .ok_or(CollectionAllocErr::AllocErr { layout })?\n                        .cast()\n                        .as_ptr();\n                }\n                self.data = SmallVecData::from_heap(new_alloc, len);\n                self.capacity = new_cap;\n            }\n            Ok(())\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::try_reserve":["/// Reserve capacity for `additional` more elements to be inserted.\n///\n/// May reserve more space to avoid frequent reallocations.\npub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr>{\n        // prefer triple_mut() even if triple() would work\n        // so that the optimizer removes duplicated calls to it\n        // from callers like insert()\n        let (_, &mut len, cap) = self.triple_mut();\n        if cap - len >= additional {\n            return Ok(());\n        }\n        let new_cap = len\n            .checked_add(additional)\n            .and_then(usize::checked_next_power_of_two)\n            .ok_or(CollectionAllocErr::CapacityOverflow)?;\n        self.try_grow(new_cap)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::try_reserve_exact":["/// Reserve the minimum capacity for `additional` more elements to be inserted.\npub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>{\n        let (_, &mut len, cap) = self.triple_mut();\n        if cap - len >= additional {\n            return Ok(());\n        }\n        let new_cap = len\n            .checked_add(additional)\n            .ok_or(CollectionAllocErr::CapacityOverflow)?;\n        self.try_grow(new_cap)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec::<A>::with_capacity":["/// Construct an empty vector with enough capacity pre-allocated to store at least `n`\n/// elements.\n///\n/// Will create a heap allocation only if `n` is larger than the inline capacity.\n///\n/// ```\n/// # use smallvec::SmallVec;\n///\n/// let v: SmallVec<[u8; 3]> = SmallVec::with_capacity(100);\n///\n/// assert!(v.is_empty());\n/// assert!(v.capacity() >= 100);\n/// ```\n#[inline]\npub fn with_capacity(n: usize) -> Self{\n        let mut v = SmallVec::new();\n        v.reserve_exact(n);\n        v\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVec<A>::insert_many::DropOnPanic":["struct DropOnPanic<T> {\n            start: *mut T,\n            skip: Range<usize>,\n            len: usize,\n        }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVecData":["#[cfg(not(feature = \"union\"))]\nenum SmallVecData<A: Array> {\n    Inline(MaybeUninit<A>),\n    Heap((*mut A::Item, usize)),\n}","Real(LocalPath(\"src/lib.rs\"))"],"SmallVecData::<A>::from_heap":["#[inline]\nfn from_heap(ptr: *mut A::Item, len: usize) -> SmallVecData<A>{\n        SmallVecData::Heap((ptr, len))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVecData::<A>::from_inline":["#[inline]\nfn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A>{\n        SmallVecData::Inline(inline)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVecData::<A>::heap":["#[inline]\nunsafe fn heap(&self) -> (*mut A::Item, usize){\n        match self {\n            SmallVecData::Heap(data) => *data,\n            _ => debug_unreachable!(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVecData::<A>::heap_mut":["#[inline]\nunsafe fn heap_mut(&mut self) -> &mut (*mut A::Item, usize){\n        match self {\n            SmallVecData::Heap(data) => data,\n            _ => debug_unreachable!(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVecData::<A>::inline":["#[inline]\nunsafe fn inline(&self) -> *const A::Item{\n        match self {\n            SmallVecData::Inline(a) => a.as_ptr() as *const A::Item,\n            _ => debug_unreachable!(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVecData::<A>::inline_mut":["#[inline]\nunsafe fn inline_mut(&mut self) -> *mut A::Item{\n        match self {\n            SmallVecData::Inline(a) => a.as_mut_ptr() as *mut A::Item,\n            _ => debug_unreachable!(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"SmallVecData::<A>::into_inline":["#[inline]\nunsafe fn into_inline(self) -> MaybeUninit<A>{\n        match self {\n            SmallVecData::Inline(a) => a,\n            _ => debug_unreachable!(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"ToSmallVec":["/// Convenience trait for constructing a `SmallVec`\npub trait ToSmallVec<A: Array> {\n    /// Construct a new `SmallVec` from a slice.\n    fn to_smallvec(&self) -> SmallVec<A>;\n}","Real(LocalPath(\"src/lib.rs\"))"],"deallocate":["unsafe fn deallocate<T>(ptr: *mut T, capacity: usize){\n    // This unwrap should succeed since the same did when allocating.\n    let layout = layout_array::<T>(capacity).unwrap();\n    alloc::alloc::dealloc(ptr as *mut u8, layout)\n}","Real(LocalPath(\"src/lib.rs\"))"],"infallible":["fn infallible<T>(result: Result<T, CollectionAllocErr>) -> T{\n    match result {\n        Ok(x) => x,\n        Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n        Err(CollectionAllocErr::AllocErr { layout }) => alloc::alloc::handle_alloc_error(layout),\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"layout_array":["/// FIXME: use `Layout::array` when we require a Rust version where it’s stable\n/// https://github.com/rust-lang/rust/issues/55724\nfn layout_array<T>(n: usize) -> Result<Layout, CollectionAllocErr>{\n    let size = mem::size_of::<T>()\n        .checked_mul(n)\n        .ok_or(CollectionAllocErr::CapacityOverflow)?;\n    let align = mem::align_of::<T>();\n    Layout::from_size_align(size, align).map_err(|_| CollectionAllocErr::CapacityOverflow)\n}","Real(LocalPath(\"src/lib.rs\"))"]},"struct_constructor":{"&<I as core::slice::SliceIndex<[<A as Array>::Item]>>::Output":["index"],"&[<A as Array>::Item]":["as_ref","as_slice","borrow","deref"],"&mut (*mut <A as Array>::Item, usize)":["heap_mut"],"&mut <I as core::slice::SliceIndex<[<A as Array>::Item]>>::Output":["index_mut"],"&mut [<A as Array>::Item]":["as_mut","as_mut_slice","borrow_mut","deref_mut"],"(*const <A as Array>::Item, usize, usize)":["triple"],"(*mut <A as Array>::Item, &mut usize, usize)":["triple_mut"],"(*mut <A as Array>::Item, usize)":["heap"],"(usize, core::option::Option<usize>)":["size_hint"],"*const <A as Array>::Item":["as_ptr","inline"],"*mut <A as Array>::Item":["as_mut_ptr","inline_mut"],"<&'a SmallVec<A> as core::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a mut SmallVec<A> as core::iter::IntoIterator>::IntoIter":["into_iter"],"<A as Array>::Item":["remove","swap_remove"],"<SmallVec<A> as core::iter::IntoIterator>::IntoIter":["into_iter"],"CollectionAllocErr":["from"],"Drain":["drain"],"IntoIter":["clone"],"SetLenOnDrop":["new"],"SmallVec":["clone","default","from","from_buf","from_buf_and_len","from_buf_and_len_unchecked","from_elem","from_iter","from_raw_parts","from_slice","from_vec","new","to_smallvec","with_capacity"],"SmallVecData":["from_heap","from_inline"],"alloc::boxed::Box":["into_boxed_slice"],"alloc::vec::Vec":["into_vec"],"bool":["eq","is_empty","spilled"],"core::cmp::Ordering":["cmp"],"core::mem::MaybeUninit":["into_inline"],"core::option::Option":["next","next_back","partial_cmp","pop"],"core::result::Result":["fmt","into_inner","layout_array","try_grow","try_reserve","try_reserve_exact"],"usize":["capacity","get","inline_capacity","inline_size","len","size"]},"struct_to_trait":{"CollectionAllocErr":["core::convert::From","core::fmt::Debug","core::fmt::Display"],"Drain":["core::fmt::Debug","core::iter::DoubleEndedIterator","core::iter::ExactSizeIterator","core::iter::FusedIterator","core::iter::Iterator","core::marker::Send","core::marker::Sync","core::ops::Drop"],"IntoIter":["core::clone::Clone","core::fmt::Debug","core::iter::DoubleEndedIterator","core::iter::ExactSizeIterator","core::iter::FusedIterator","core::iter::Iterator","core::ops::Drop"],"SetLenOnDrop":["core::ops::Drop"],"SmallVec":["ExtendFromSlice","core::borrow::Borrow","core::borrow::BorrowMut","core::clone::Clone","core::cmp::Eq","core::cmp::Ord","core::cmp::PartialEq","core::cmp::PartialOrd","core::convert::AsMut","core::convert::AsRef","core::convert::From","core::default::Default","core::fmt::Debug","core::hash::Hash","core::iter::Extend","core::iter::FromIterator","core::iter::IntoIterator","core::marker::Send","core::ops::Deref","core::ops::DerefMut","core::ops::Drop","core::ops::Index","core::ops::IndexMut"],"SmallVec<A>::insert_many::DropOnPanic":["core::ops::Drop"],"SmallVecData":["core::marker::Send","core::marker::Sync"],"alloc::vec::Vec":["ExtendFromSlice"]},"targets":{"<&'a SmallVec<A> as core::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","core::iter::IntoIterator"],"<&'a mut SmallVec<A> as core::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","core::iter::IntoIterator"],"<CollectionAllocErr as core::convert::From<core::alloc::LayoutError>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","core::convert::From"],"<CollectionAllocErr as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Display"],"<Drain<'a, T> as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Debug"],"<Drain<'a, T> as core::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/lib.rs\"))","core::iter::DoubleEndedIterator"],"<Drain<'a, T> as core::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/lib.rs\"))","core::iter::ExactSizeIterator"],"<Drain<'a, T> as core::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","core::iter::Iterator"],"<Drain<'a, T> as core::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/lib.rs\"))","core::iter::Iterator"],"<Drain<'a, T> as core::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","core::ops::Drop"],"<IntoIter<A> as core::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","core::clone::Clone"],"<IntoIter<A> as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Debug"],"<IntoIter<A> as core::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/lib.rs\"))","core::iter::DoubleEndedIterator"],"<IntoIter<A> as core::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","core::iter::Iterator"],"<IntoIter<A> as core::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/lib.rs\"))","core::iter::Iterator"],"<IntoIter<A> as core::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","core::ops::Drop"],"<SetLenOnDrop<'a> as core::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","core::ops::Drop"],"<SmallVec<A> as ExtendFromSlice<<A as Array>::Item>>::extend_from_slice":["extend_from_slice","Real(LocalPath(\"src/lib.rs\"))","ExtendFromSlice"],"<SmallVec<A> as core::borrow::Borrow<[<A as Array>::Item]>>::borrow":["borrow","Real(LocalPath(\"src/lib.rs\"))","core::borrow::Borrow"],"<SmallVec<A> as core::borrow::BorrowMut<[<A as Array>::Item]>>::borrow_mut":["borrow_mut","Real(LocalPath(\"src/lib.rs\"))","core::borrow::BorrowMut"],"<SmallVec<A> as core::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","core::clone::Clone"],"<SmallVec<A> as core::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/lib.rs\"))","core::cmp::Ord"],"<SmallVec<A> as core::cmp::PartialEq<SmallVec<B>>>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","core::cmp::PartialEq"],"<SmallVec<A> as core::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/lib.rs\"))","core::cmp::PartialOrd"],"<SmallVec<A> as core::convert::AsMut<[<A as Array>::Item]>>::as_mut":["as_mut","Real(LocalPath(\"src/lib.rs\"))","core::convert::AsMut"],"<SmallVec<A> as core::convert::AsRef<[<A as Array>::Item]>>::as_ref":["as_ref","Real(LocalPath(\"src/lib.rs\"))","core::convert::AsRef"],"<SmallVec<A> as core::convert::From<&'a [<A as Array>::Item]>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","core::convert::From"],"<SmallVec<A> as core::convert::From<A>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","core::convert::From"],"<SmallVec<A> as core::convert::From<alloc::vec::Vec<<A as Array>::Item>>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","core::convert::From"],"<SmallVec<A> as core::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","core::default::Default"],"<SmallVec<A> as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Debug"],"<SmallVec<A> as core::hash::Hash>::hash":["hash","Real(LocalPath(\"src/lib.rs\"))","core::hash::Hash"],"<SmallVec<A> as core::iter::Extend<<A as Array>::Item>>::extend":["extend","Real(LocalPath(\"src/lib.rs\"))","core::iter::Extend"],"<SmallVec<A> as core::iter::FromIterator<<A as Array>::Item>>::from_iter":["from_iter","Real(LocalPath(\"src/lib.rs\"))","core::iter::FromIterator"],"<SmallVec<A> as core::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","core::iter::IntoIterator"],"<SmallVec<A> as core::ops::Deref>::deref":["deref","Real(LocalPath(\"src/lib.rs\"))","core::ops::Deref"],"<SmallVec<A> as core::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/lib.rs\"))","core::ops::DerefMut"],"<SmallVec<A> as core::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","core::ops::Drop"],"<SmallVec<A> as core::ops::Index<I>>::index":["index","Real(LocalPath(\"src/lib.rs\"))","core::ops::Index"],"<SmallVec<A> as core::ops::IndexMut<I>>::index_mut":["index_mut","Real(LocalPath(\"src/lib.rs\"))","core::ops::IndexMut"],"<SmallVec<A>::insert_many::DropOnPanic<T> as core::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","core::ops::Drop"],"<[<A as Array>::Item] as ToSmallVec<A>>::to_smallvec":["to_smallvec","Real(LocalPath(\"src/lib.rs\"))","ToSmallVec"],"<[T; 0] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 1024] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 1048576] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 10] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 11] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 128] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 12] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 131072] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 13] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 14] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 1536] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 15] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 16384] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 16] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 17] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 18] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 19] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 1] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 2048] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 20] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 21] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 22] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 23] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 24576] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 24] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 256] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 25] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 262144] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 26] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 27] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 28] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 29] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 2] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 30] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 31] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 32768] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 32] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 36] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 393216] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 3] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 4096] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 4] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 512] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 524288] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 5] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 64] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 65536] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 6] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 7] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 8192] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 8] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 96] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<[T; 9] as Array>::size":["size","Real(LocalPath(\"src/lib.rs\"))","Array"],"<alloc::vec::Vec<T> as ExtendFromSlice<T>>::extend_from_slice":["extend_from_slice","Real(LocalPath(\"src/lib.rs\"))","ExtendFromSlice"],"IntoIter::<A>::as_mut_slice":["as_mut_slice","Real(LocalPath(\"src/lib.rs\"))",""],"IntoIter::<A>::as_slice":["as_slice","Real(LocalPath(\"src/lib.rs\"))",""],"SetLenOnDrop::<'a>::get":["get","Real(LocalPath(\"src/lib.rs\"))",""],"SetLenOnDrop::<'a>::increment_len":["increment_len","Real(LocalPath(\"src/lib.rs\"))",""],"SetLenOnDrop::<'a>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::append":["append","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::as_mut_ptr":["as_mut_ptr","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::as_mut_slice":["as_mut_slice","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::as_ptr":["as_ptr","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::as_slice":["as_slice","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::capacity":["capacity","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::clear":["clear","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::dedup":["dedup","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::dedup_by":["dedup_by","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::dedup_by_key":["dedup_by_key","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::drain":["drain","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::extend_from_slice":["extend_from_slice","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::from_buf":["from_buf","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::from_buf_and_len":["from_buf_and_len","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::from_buf_and_len_unchecked":["from_buf_and_len_unchecked","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::from_elem":["from_elem","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::from_raw_parts":["from_raw_parts","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::from_slice":["from_slice","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::from_vec":["from_vec","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::grow":["grow","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::inline_capacity":["inline_capacity","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::inline_size":["inline_size","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::insert":["insert","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::insert_from_slice":["insert_from_slice","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::insert_many":["insert_many","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::into_boxed_slice":["into_boxed_slice","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::into_inner":["into_inner","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::into_vec":["into_vec","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::is_empty":["is_empty","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::len":["len","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::pop":["pop","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::push":["push","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::remove":["remove","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::reserve":["reserve","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::reserve_exact":["reserve_exact","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::resize":["resize","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::resize_with":["resize_with","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::retain":["retain","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::set_len":["set_len","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::shrink_to_fit":["shrink_to_fit","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::spilled":["spilled","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::swap_remove":["swap_remove","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::triple":["triple","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::triple_mut":["triple_mut","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::truncate":["truncate","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::try_grow":["try_grow","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::try_reserve":["try_reserve","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::try_reserve_exact":["try_reserve_exact","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVec::<A>::with_capacity":["with_capacity","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVecData::<A>::from_heap":["from_heap","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVecData::<A>::from_inline":["from_inline","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVecData::<A>::heap":["heap","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVecData::<A>::heap_mut":["heap_mut","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVecData::<A>::inline":["inline","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVecData::<A>::inline_mut":["inline_mut","Real(LocalPath(\"src/lib.rs\"))",""],"SmallVecData::<A>::into_inline":["into_inline","Real(LocalPath(\"src/lib.rs\"))",""],"deallocate":["deallocate","Real(LocalPath(\"src/lib.rs\"))",""],"infallible":["infallible","Real(LocalPath(\"src/lib.rs\"))",""],"layout_array":["layout_array","Real(LocalPath(\"src/lib.rs\"))",""]},"trait_to_struct":{"ExtendFromSlice":["SmallVec","alloc::vec::Vec"],"core::borrow::Borrow":["SmallVec"],"core::borrow::BorrowMut":["SmallVec"],"core::clone::Clone":["IntoIter","SmallVec"],"core::cmp::Eq":["SmallVec"],"core::cmp::Ord":["SmallVec"],"core::cmp::PartialEq":["SmallVec"],"core::cmp::PartialOrd":["SmallVec"],"core::convert::AsMut":["SmallVec"],"core::convert::AsRef":["SmallVec"],"core::convert::From":["CollectionAllocErr","SmallVec"],"core::default::Default":["SmallVec"],"core::fmt::Debug":["CollectionAllocErr","Drain","IntoIter","SmallVec"],"core::fmt::Display":["CollectionAllocErr"],"core::hash::Hash":["SmallVec"],"core::iter::DoubleEndedIterator":["Drain","IntoIter"],"core::iter::ExactSizeIterator":["Drain","IntoIter"],"core::iter::Extend":["SmallVec"],"core::iter::FromIterator":["SmallVec"],"core::iter::FusedIterator":["Drain","IntoIter"],"core::iter::IntoIterator":["SmallVec"],"core::iter::Iterator":["Drain","IntoIter"],"core::marker::Send":["Drain","SmallVec","SmallVecData"],"core::marker::Sync":["Drain","SmallVecData"],"core::ops::Deref":["SmallVec"],"core::ops::DerefMut":["SmallVec"],"core::ops::Drop":["Drain","IntoIter","SetLenOnDrop","SmallVec","SmallVec<A>::insert_many::DropOnPanic"],"core::ops::Index":["SmallVec"],"core::ops::IndexMut":["SmallVec"]},"type_to_def_path":{"CollectionAllocErr":"CollectionAllocErr","Drain<'a, T>":"Drain","IntoIter<A>":"IntoIter","SetLenOnDrop<'a>":"SetLenOnDrop","SmallVec<A>":"SmallVec","SmallVec<A>::insert_many::DropOnPanic<T>":"SmallVec<A>::insert_many::DropOnPanic","SmallVecData<A>":"SmallVecData"}}